/* Copyright (c) 2012-2018, Hisilicon Tech. Co., Ltd. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include "hisi_hiace_single_mode.h"
#include "hisi_display_effect.h"
#include "hisi_fb.h"
#include <linux/fb.h>
#include "global_ddr_map.h"
#include <linux/hisi/hw_cmdline_parse.h>
#ifdef CONFIG_HW_DSS_BOOST
#include <linux/sysctl.h>
#endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeclaration-after-statement"
// lint -e747, -e838, -e774

#define COUNT_LIMIT_TO_PRINT_DELAY (200)

typedef struct time_interval {
	long start; // microsecond
	long stop;
} time_interval_t;

typedef struct delay_record {
	const char *name;
	long max;
	long min;
	long sum;
	int count;
} delay_record_t;

#define DEBUG_EFFECT_LOG HISI_FB_ERR

#define EFFECT_GRADUAL_REFRESH_FRAMES (30)

static bool g_is_effect_init;
static bool g_is_ce_service_init;
static struct mutex g_ce_service_lock;
static ce_service_t g_hiace_service;

static bool g_is_effect_lock_init;
static spinlock_t g_gmp_effect_lock;
static spinlock_t g_igm_effect_lock;
static spinlock_t g_xcc_effect_lock;
static spinlock_t g_gama_effect_lock;
static spinlock_t g_post_xcc_effect_lock;
static spinlock_t g_hiace_table_lock;
static spinlock_t g_roi_lock;
static spinlock_t g_dpproi_effect_lock;

struct mutex g_dpp_buf_lock_arr[DISP_PANEL_NUM][DPP_BUF_MAX_COUNT - 1];
struct mutex g_dpp_ch0_lock;
struct mutex g_dpp_ch1_lock;

extern struct mutex g_rgbw_lock;
static uint32_t g_table_update;
static uint32_t g_sel_gamma_ab_shadow_hdr_lut;
uint8_t g_dpp_cmdlist_state = 0;

static time_interval_t g_interval_wait_hist = {0};
static time_interval_t g_interval_algorithm = {0};
static delay_record_t g_delay_wait_hist = {
	"event hist waiting", 0, 0xFFFFFFFF, 0, 0
};
static delay_record_t g_delay_algorithm = {
	"algorithm processing", 0, 0xFFFFFFFF, 0, 0
};

uint32_t g_post_xcc_table_temp[12] = {
	0x0, 0x8000, 0x0, 0x0, 0x0, 0x0,
	0x8000, 0x0, 0x0, 0x0, 0x0, 0x8000
};

static uint32_t g_post_xcc_enable_state;

uint32_t g_enable_effect = ENABLE_EFFECT_HIACE | ENABLE_EFFECT_BL;
uint32_t g_debug_effect;
static bool g_hiace_enable_status;
/*
* dpp chanel default select register
* 0: none roi region use CH0
* 1: none roi region use CH1
*/
uint32_t g_dyn_sw_default;

#define SCREEN_OFF_BLC_DELTA (-10000)

/* HIACE HDR LUT */
#define DETAIL_WEIGHT_TABLE_UPDATED (1 << 0)
#define LOGLUM_EOTF_TABLE_UPDATED (1 << 1)
#define LUMA_GAMA_TABLE_UPDATED (1 << 2)

static u32 g_hiace_hdr_detail_weight[DISP_PANEL_NUM][HIACE_DETAIL_WEIGHT_TABLE_LEN] = {
	{
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80
	},
#ifdef CONFIG_HISI_FB_V600
	{
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x80
	}
#endif
};
static int g_hiace_hdr_loglum_eotf[DISP_PANEL_NUM][HIACE_LOGLUM_EOTF_TABLE_LEN] = {
	{
		-4096, -4096, -4096, -4096, -4096, -3942, -3719, -3518,
		-3347, -3201, -3074, -2963, -2863, -2546, -2309, -2118,
		-1958, -1819, -1695, -1585, -1484, -1391, -1078, -826,
		-613,  -426,  -259,  32,    288,   512,   718,   910,
		1089,  1259,  1421,  1576,  1726,  1872,  2014,  2153,
		2289,  2424,  2556,  2687,  2817,  2947,  3075,  3204,
		3332,  3461,  3590,  3720,  3851,  3983,  4050,  4083,
		4087,  4091,  4095,  4095,  4095,  4095,  4095
	},
#ifdef CONFIG_HISI_FB_V600
	{
		-4096, -4096, -4096, -4096, -4096, -3942, -3719, -3518,
		-3347, -3201, -3074, -2963, -2863, -2546, -2309, -2118,
		-1958, -1819, -1695, -1585, -1484, -1391, -1078, -826,
		-613,  -426,  -259,  32, 288,   512,   718, 910,
		1089,  1259,  1421,  1576, 1726,  1872,  2014,  2153,
		2289,  2424,  2556,  2687, 2817,  2947,  3075,  3204,
		3332,  3461,  3590,  3720, 3851,  3983,  4050,  4083,
		4087,  4091,  4095,  4095, 4095,  4095,  4095
	}
#endif
};

static int g_hiace_hdr_luma_gamma[DISP_PANEL_NUM][HIACE_LUMA_GAMA_TABLE_LEN] = {
	{
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 45, 65, 83, 99, 116, 133,
		151,  169,  188,  208,  229,  252,  275,  300,
		326,  354,  384,  415,  448,  483,  520,  560,
		602,  646,  693,  743,  796,  853,  913,  976,
		1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
		1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
		1023, 1023, 1023, 1023, 1023, 1023, 1023
	},
#ifdef CONFIG_HISI_FB_V600
	{
		0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 45, 65, 83, 99, 116, 133,
		151,  169,  188,  208,  229,  252,  275,  300,
		326,  354,  384,  415,  448,  483,  520,  560,
		602,  646,  693,  743,  796,  853,  913,  976,
		1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
		1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
		1023, 1023, 1023, 1023, 1023, 1023, 1023
	},
#endif
};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
/* GMP LUT */
u32 g_gmp_lut_table_low32bit_init[4913] = {
	0x00000000, 0x02001105, 0x06004207, 0x08005309, 0x0900640a, 0x0800450d, 0x06000610, 0x08000712, 0x0b000814, 0x0e000916, 0x12000a19, 0x16000b1b, 0x1b000c1e, 0x20000d20, 0x26000e22, 0x2c000f24, 0x33000fff,
	0x0c101005, 0x0e101101, 0x10102205, 0x10100307, 0x110ff40a, 0x0f0fc50b, 0x0e0f860f, 0x100f5712, 0x120f1814, 0x150ec916, 0x190e7a18, 0x1d0e0b1b, 0x220d9c1d, 0x270d0d20, 0x2d0c7e22, 0x340bcf24, 0x3a0b0fff,
	0x2120300c, 0x202030fd, 0x1e201202, 0x1d200306, 0x1c200408, 0x1c1fe50b, 0x1c1fc60e, 0x1e1fb710, 0x201f8813, 0x231f6916, 0x261f3a18, 0x2b1efb1a, 0x2f1ecc1d, 0x341e8d1f, 0x3a1e3e21, 0x411ddf24, 0x481d8fff,
	0x33302009, 0x333020f0, 0x323021fb, 0x33301301, 0x33301405, 0x33300509, 0x322fe60c, 0x342fd70f, 0x362fb812, 0x392fa914, 0x3c2f8a17, 0x402f6b19, 0x452f4c1c, 0x4a2f1d1e, 0x502ede21, 0x562eaf23, 0x5d2e6fff,
	0x49401000, 0x494010d9, 0x4b4011ef, 0x4f4012fb, 0x53401401, 0x53401505, 0x54400609, 0x543fe70d, 0x563fd80f, 0x583fc913, 0x5c3fba15, 0x5f3f9b18, 0x643f8c1b, 0x693f6d1d, 0x6f3f3e1f, 0x753f1f22, 0x7c3eefff,
	0x72502000, 0x745010bf, 0x765011e3, 0x7a5012f3, 0x7f5023fc, 0x7e502502, 0x7e500605, 0x7d4ff709, 0x7e4fe80d, 0x824fe910, 0x844fca13, 0x884fbb16, 0x8d4fac19, 0x944f8d1b, 0x9b4f7e1d, 0xa24f6f1f, 0xab4f4ffc,
	0xa7602000, 0xaa602099, 0xac6021d4, 0xb16022e9, 0xb86023f5, 0xb56024fc, 0xb2600600, 0xb2600705, 0xb25ff80a, 0xb45ff90d, 0xb85fea11, 0xbc5fdb14, 0xc05fcc17, 0xc95fbd19, 0xd05fae1a, 0xd95f9f1b, 0xe15f7ffa,
	0xe1702002, 0xe2702067, 0xe37021bc, 0xe77022dc, 0xeb7023eb, 0xec7014f5, 0xef7015fc, 0xee700700, 0xec700806, 0xed70090a, 0xef6ffa0e, 0xf26feb11, 0xf56fdc15, 0xfd6fcd17, 0x056fbe19, 0x0d6fbf1a, 0x146faffa,
	0x1c802004, 0x1b80202d, 0x1980219e, 0x1b8022c9, 0x1d8023de, 0x238024ec, 0x2b8025f6, 0x288016fc, 0x26801801, 0x26800906, 0x26800a0a, 0x297ffb0e, 0x2c7fec12, 0x337fdd14, 0x397fce17, 0x427fcf18, 0x497fbffa,
	0x54903002, 0x53903001, 0x5290317b, 0x549022b5, 0x569023d0, 0x5b9024e2, 0x609025ee, 0x609016f5, 0x5e9017fc, 0x5f901901, 0x5f900a06, 0x618ffb0a, 0x628ffc0e, 0x678fed12, 0x6d8fde15, 0x738fdf17, 0x7a8fcffc,
	0x8ba03000, 0x8ba03000, 0x8ba0314e, 0x8ea0329c, 0x90a033c0, 0x93a024d5, 0x96a025e3, 0x96a026ed, 0x97a017f5, 0x98a018fb, 0x99a01a01, 0x99a00b06, 0x98a00c0a, 0x9c9ffd0f, 0x9f9ffe12, 0xa59fef15, 0xaa9fdffd,
	0xc4b03000, 0xc4b03000, 0xc4b03114, 0xc5b03280, 0xc8b033ad, 0xcbb034c7, 0xceb035d8, 0xcdb026e5, 0xcfb027ee, 0xd6b028f5, 0xdfb019fc, 0xddb01b01, 0xdcb00c05, 0xd8b00d0a, 0xd5affe0f, 0xd9afef13, 0xddafeffe,
	0xfdc03000, 0xfdc03000, 0xfdc030c5, 0xfec0325e, 0xffc03396, 0x01c034b7, 0x04c035cc, 0x05c036db, 0x06c037e5, 0x16c018f0, 0x26c019f8, 0x24c00afc, 0x20c00c01, 0x17c00d05, 0x0cc00e0b, 0x0ebfff0f, 0x11bfefff,
	0x36d04000, 0x36d04000, 0x36d04056, 0x36d04235, 0x38d0337d, 0x39d034a4, 0x3bd035bc, 0x3cd036ce, 0x3dd037db, 0x48d018e8, 0x54d019f0, 0x5cd00af7, 0x63cffbfc, 0x5ad00d00, 0x51cffe05, 0x4dd00f0a, 0x4acfffff,
	0x6fe04000, 0x6fe04000, 0x6fe04000, 0x6fe04204, 0x70e0435f, 0x70e0448e, 0x70e045ac, 0x71e036c0, 0x73e037d0, 0x7ae038dd, 0x82e019e8, 0x94e00af1, 0xa7dffbf8, 0xa0dffcfc, 0x99dffe00, 0x8edfff05, 0x83e00fff,
	0xa8f04000, 0xa8f04000, 0xa8f04000, 0xa8f041ca, 0xa9f0433e, 0xa9f04477, 0xa9f0459a, 0xaaf046b2, 0xabf047c4, 0xb0f038d3, 0xb4f029de, 0xc0f02ae9, 0xcdf00bf1, 0xcdf00cf6, 0xcff00dfb, 0xc7f00f00, 0xc0f00ffe,
	0xe0fff000, 0xe1fff000, 0xe1fff000, 0xe1fff181, 0xe1fff319, 0xe2fff45d, 0xe2fff586, 0xe3fff6a2, 0xe4fff7b7, 0xe4fff8c6, 0xe5fff9d3, 0xeafffadf, 0xf0ffebe8, 0xfaffdcef, 0x05ffddf6, 0x01ffdefb, 0xfdffeffe,
	0xfb005002, 0xfc006105, 0xfd007207, 0xfd007309, 0xfe00640a, 0xfe00350c, 0xff000610, 0x00000712, 0x02000814, 0x05000916, 0x07000a19, 0x0a000b1b, 0x0d000c1e, 0x11000d20, 0x15000e22, 0x1a000f24, 0x1e000fff,
	0x03103009, 0x00100100, 0x02102205, 0x03100307, 0x040ff40a, 0x040fc50b, 0x040f860f, 0x060f4712, 0x080f1814, 0x0a0ec916, 0x0d0e7a18, 0x0f0e0b1b, 0x130d9c1d, 0x160d0d20, 0x1b0c7e22, 0x1f0bcf24, 0x240affff,
	0x12205016, 0x11204100, 0x0f202203, 0x0f201306, 0x0d200408, 0x0d1fe50b, 0x0d1fc60e, 0x0f1fa710, 0x111f8813, 0x131f6916, 0x161f3a18, 0x191efb1a, 0x1c1ecc1d, 0x1f1e7d1f, 0x231e3e21, 0x281ddf24, 0x2c1d8fff,
	0x23304015, 0x223030f5, 0x213031fd, 0x1f302302, 0x1e301406, 0x1f300509, 0x202ff60c, 0x202fe70e, 0x212fb812, 0x232fa914, 0x242f8a17, 0x272f6b19, 0x2a2f3c1c, 0x2e2f1d1e, 0x312ede21, 0x362eaf23, 0x3a2e6fff,
	0x3440200c, 0x354020e2, 0x384031f5, 0x364022fd, 0x36401402, 0x37401506, 0x38400609, 0x373ff70b, 0x363fd80e, 0x373fc913, 0x383fba15, 0x3b3f9b18, 0x3e3f8c1b, 0x413f6d1d, 0x453f3e1f, 0x483f1f22, 0x4d3eefff,
	0x4c503008, 0x4e5020c5, 0x505021e8, 0x515022f5, 0x525023fd, 0x51502502, 0x51501605, 0x50500709, 0x504fe80d, 0x504fe910, 0x514fca13, 0x544fbb16, 0x584fac19, 0x5c4f8d1b, 0x5f4f7e1d, 0x644f6f1f, 0x694f4ffc,
	0x66602001, 0x6960209a, 0x6b6021d5, 0x6f6022ea, 0x736023f6, 0x716024fc, 0x6e600601, 0x6d600705, 0x6d5ff80a, 0x6d5fe90d, 0x6f5fea11, 0x735fdb14, 0x755fcc17, 0x7b5fad19, 0x805fae1a, 0x865f9f1b, 0x8b5f7ffa,
	0x8a702003, 0x8b702069, 0x8c7021bd, 0x8f7022dd, 0x937023ec, 0x937014f6, 0x957025fd, 0x92700701, 0x91700806, 0x9170090a, 0x916ffa0e, 0x946feb11, 0x976fdc15, 0x9c6fcd17, 0xa26fce18, 0xa76fbf1a, 0xad6faffa,
	0xb1802005, 0xb080202d, 0xb080219f, 0xb18022ca, 0xb48023df, 0xba8024ed, 0xc18025f7, 0xbd8016fc, 0xb8801801, 0xb8800906, 0xb8800a0a, 0xba7ffb0e, 0xbc7fec12, 0xc27fdd14, 0xc87fce16, 0xce7fcf18, 0xd37fbffa,
	0xd9903003, 0xd8903002, 0xd990317b, 0xda9022b5, 0xdd9023d1, 0xe29024e3, 0xe89025ef, 0xe59016f6, 0xe29017fc, 0xe1901901, 0xe2900a06, 0xe38ffb0a, 0xe48ffc0e, 0xe88fed11, 0xed8fde15, 0xf28fdf17, 0xf78fcffc,
	0x03a03000, 0x03a03000, 0x03a0314e, 0x06a0329d, 0x09a033c1, 0x0ba024d6, 0x0fa025e4, 0x0ea026ee, 0x0da017f5, 0x0da018fb, 0x0fa01a01, 0x0da00b06, 0x0da00c0a, 0x109ffd0f, 0x139fee12, 0x189fef15, 0x1d9fdffd,
	0x30b03000, 0x30b03000, 0x31b03114, 0x33b03280, 0x34b033ad, 0x38b034c8, 0x3ab035d9, 0x3ab026e5, 0x3ab027ee, 0x41b028f5, 0x48b019fc, 0x46b01b01, 0x45b00c05, 0x42b00d0a, 0x3faffe0f, 0x42afef13, 0x46afeffe,
	0x5fc03000, 0x5fc03000, 0x5fc030c5, 0x61c0325e, 0x61c03396, 0x64c034b7, 0x66c035cc, 0x67c036db, 0x68c037e5, 0x76c018f0, 0x85c019f8, 0x83c00afc, 0x80c00c01, 0x76c00d05, 0x6cc00e0b, 0x6ebfff0f, 0x70bfefff,
	0x90d04000, 0x90d04000, 0x90d04055, 0x90d04235, 0x91d0337d, 0x93d034a4, 0x95d035bc, 0x95d036ce, 0x96d037db, 0xa1d018e8, 0xacd019f0, 0xb3d00af7, 0xbacffbfc, 0xb1d00d00, 0xa8cffe05, 0xa6d00f0a, 0xa2cfffff,
	0xc1e04000, 0xc1e04000, 0xc2e04000, 0xc2e04204, 0xc2e0435f, 0xc2e0448e, 0xc3e045ab, 0xc4e036c0, 0xc5e037d0, 0xcbe038dd, 0xd2e019e8, 0xe5e00af2, 0xf7dffbf8, 0xf0dffcfc, 0xe8dffe00, 0xdedfff05, 0xd4e00fff,
	0xf4f04000, 0xf4f04000, 0xf4f04000, 0xf4f041ca, 0xf4f0433e, 0xf5f04477, 0xf5f0459a, 0xf6f046b2, 0xf7f047c4, 0xfbf038d3, 0xfff029de, 0x0bf01ae9, 0x17f00bf1, 0x18f00cf6, 0x19f00dfb, 0x11f00f00, 0x09f00ffe,
	0x27fff000, 0x27fff000, 0x27fff000, 0x27fff181, 0x28fff319, 0x28fff45d, 0x28fff586, 0x29fff6a2, 0x2afff7b7, 0x2afff8c6, 0x2bfff9d3, 0x30fffadf, 0x35ffebe8, 0x40ffdcef, 0x49ffddf6, 0x45ffdefb, 0x40ffeffe,
	0xf800e007, 0xf800e106, 0xf900d207, 0xf900a309, 0xfa00740b, 0xf900450c, 0xfa000610, 0xfb000712, 0xfc000814, 0xfd000916, 0xff000a19, 0x00000b1b, 0x02000c1d, 0x04000d20, 0x06000e22, 0x09000f24, 0x0c000fff,
	0xfd107010, 0xfd106104, 0xfd104206, 0xfc102307, 0xfc0ff40a, 0xfd0fb50c, 0xfd0f860f, 0xfe0f4711, 0xff0f0814, 0x000ec916, 0x020e6a18, 0x030e0b1b, 0x050d8c1d, 0x070d0d20, 0x090c6e22, 0x0c0bcf24, 0x0f0affff,
	0x07208021, 0x05206102, 0x00200200, 0x03202306, 0x02200408, 0x031fe50b, 0x021fc60e, 0x031fa710, 0x041f8813, 0x051f6916, 0x071f3a18, 0x081efb1a, 0x0b1ebc1d, 0x0d1e7d1f, 0x0f1e2e21, 0x111ddf24, 0x141d8fff,
	0x11306021, 0x103050fa, 0x0f305200, 0x0e303303, 0x0c301406, 0x0d301509, 0x0d2ff60b, 0x0e2fe70e, 0x0e2fb811, 0x0e2fa914, 0x0f2f8a17, 0x112f6b19, 0x132f3c1c, 0x152f1d1e, 0x172ede21, 0x1a2eaf23, 0x1c2e6fff,
	0x1c404018, 0x1f4040ea, 0x214051fb, 0x1e404300, 0x1d402402, 0x1d402506, 0x1e401609, 0x1d40070b, 0x1b3fe80e, 0x1b3fc912, 0x1b3faa15, 0x1d3f9b18, 0x1f3f7c1b, 0x213f6d1d, 0x233f3e1f, 0x263f1f22, 0x283eefff,
	0x2a502010, 0x2c5030cc, 0x2f5031ed, 0x2e5032f7, 0x2f5033fe, 0x2e502503, 0x2e501605, 0x2c500709, 0x2a4fe80d, 0x2b4fe910, 0x2b4fca13, 0x2d4fbb16, 0x2f4fac18, 0x314f8d1b, 0x344f7e1c, 0x374f6f1f, 0x3a4f4ffc,
	0x39602003, 0x3b60209b, 0x3c6031d5, 0x406022ec, 0x446023f7, 0x416024fc, 0x3e601601, 0x3d600705, 0x3d5ff80a, 0x3d5fe90d, 0x3e5fea11, 0x415fdb14, 0x435fcc16, 0x465fbd18, 0x4a5fae1a, 0x4e5f9f1a, 0x515f7ffa,
	0x51702004, 0x5270206a, 0x527021be, 0x557022de, 0x587033ed, 0x597024f6, 0x5a7025fd, 0x58700701, 0x55700806, 0x5570090a, 0x556ffa0e, 0x576feb11, 0x5a6fdc14, 0x5e6fcd16, 0x626fce18, 0x666fbf19, 0x6a6f9ffa,
	0x6c802006, 0x6b80202e, 0x6b8021a0, 0x6d8022ca, 0x6e8023e0, 0x748024ee, 0x7b8035f8, 0x768016fd, 0x71801801, 0x70800906, 0x70800a0a, 0x717ffb0e, 0x737fec12, 0x797fdd13, 0x7e7fde16, 0x827fcf17, 0x857fbffa,
	0x89903003, 0x88903002, 0x8890217b, 0x8a9022b6, 0x8c9023d2, 0x929024e4, 0x989025f0, 0x939016f6, 0x8f9017fc, 0x8f901901, 0x8e900a06, 0x8f8ffb0a, 0x908ffc0e, 0x948fed11, 0x978fde14, 0x9c8fdf16, 0xa08fcffb,
	0xa7a03000, 0xa7a03000, 0xa7a0314e, 0xaaa0329d, 0xada033c2, 0xb0a024d8, 0xb5a025e6, 0xb2a026ee, 0xb0a017f5, 0xb0a018fb, 0xb0a01a01, 0xb0a00b06, 0xafa00c0a, 0xb19ffd0f, 0xb39fee12, 0xb79fef15, 0xbb9fdffd,
	0xcab03000, 0xcab03000, 0xcab03114, 0xccb03280, 0xceb033ae, 0xd1b034c9, 0xd4b035da, 0xd3b026e5, 0xd2b027ee, 0xd8b028f6, 0xdfb019fc, 0xddb01b01, 0xdbb00c05, 0xd8b00d0a, 0xd5affe0f, 0xd8afef13, 0xdbafeffe,
	0xefc03000, 0xefc03000, 0xefc030c4, 0xf0c0325e, 0xf0c03396, 0xf3c034b7, 0xf6c035cc, 0xf6c036db, 0xf7c037e5, 0x04c018f0, 0x11c009f9, 0x0ec00afc, 0x0bc00c01, 0x03c00d05, 0xf9c00e0b, 0xfbbfff0f, 0xfdbfefff,
	0x16d04000, 0x16d04000, 0x16d04055, 0x16d04234, 0x18d0337d, 0x19d034a4, 0x1bd035bc, 0x1bd036ce, 0x1cd037db, 0x26d018e8, 0x30d019f1, 0x36d00af7, 0x3ccffbfc, 0x34d00d00, 0x2ccffe05, 0x28d00f0a, 0x25cfffff,
	0x3fe04000, 0x3fe04000, 0x3fe04000, 0x40e04204, 0x40e0435f, 0x40e0448e, 0x41e045ab, 0x41e036c0, 0x43e037d0, 0x49e028dd, 0x4ee019e8, 0x60e00af2, 0x70dffbf8, 0x69dffcfc, 0x62dffe00, 0x59dfff05, 0x4fe00fff,
	0x6af04000, 0x6af04000, 0x6af04000, 0x6af041ca, 0x6af0433e, 0x6bf04477, 0x6bf0459a, 0x6cf046b2, 0x6cf047c3, 0x70f038d3, 0x74f029df, 0x80f01ae9, 0x8beffbf1, 0x8bf00cf6, 0x8bf00dfb, 0x84f00f00, 0x7df00ffe,
	0x96fff000, 0x96fff000, 0x96fff000, 0x96fff181, 0x96fff318, 0x97fff45d, 0x97fff586, 0x97fff6a2, 0x98fff7b7, 0x99fff8c6, 0x9afff9d3, 0x9ffffadf, 0xa3ffebe8, 0xadffdcef, 0xb6ffddf6, 0xb1ffdefb, 0xadffeffe,
	0xf602c016, 0xf501c107, 0xf500d207, 0xf5009308, 0xf500540b, 0xf500350d, 0xf6001610, 0xf6001712, 0xf7000814, 0xf8000916, 0xf9000a19, 0xfa000b1b, 0xfb000c1d, 0xfd000d20, 0xff000e22, 0x00000f24, 0x02000fff,
	0xfa11b02c, 0xfa11910c, 0xf911620a, 0xf910a308, 0xf70ff40a, 0xf70fc50c, 0xf80f760f, 0xf80f4711, 0xf90f0814, 0xfa0eb916, 0xfb0e6a18, 0xfc0dfb1b, 0xfd0d8c1d, 0xff0d0d20, 0x000c6e22, 0x020bbf24, 0x040affff,
	0x0421a05b, 0x0521b11d, 0x0621d214, 0x0120f30a, 0xfb201408, 0xfc1ff50b, 0xfb1fc60e, 0xfc1fa710, 0xfd1f8813, 0xfe1f5915, 0xff1f2a18, 0x001efb1a, 0x011ebc1d, 0x021e7d1f, 0x041e2e21, 0x061ddf24, 0x071d7fff,
	0x0c30f04d, 0x0e310116, 0x0f311212, 0x00300300, 0x04303407, 0x05303508, 0x0530360a, 0x0530070d, 0x042fc811, 0x042fb913, 0x042f8a17, 0x062f6b19, 0x072f3c1c, 0x082f0d1e, 0x0a2ede21, 0x0b2eaf23, 0x0d2e6fff,
	0x10405024, 0x124070f6, 0x15408204, 0x13407305, 0x12406405, 0x14407507, 0x16407608, 0x12403709, 0x0e3ff80d, 0x0e3fd911, 0x0d3faa15, 0x0e3f9b18, 0x0f3f7c1b, 0x103f5d1d, 0x123f3e1f, 0x133f1f22, 0x153eeffe,
	0x1a50301b, 0x1e5050d9, 0x215061f9, 0x23506301, 0x24507405, 0x21505505, 0x1f504606, 0x1c502708, 0x194ff80c, 0x184fe90f, 0x174fca13, 0x194fbb15, 0x1b4fac18, 0x1c4f9d1a, 0x1e4f8e1c, 0x204f6f1e, 0x234f4ffb,
	0x2460300d, 0x296040ac, 0x2d6041e5, 0x356052fb, 0x3c606405, 0x31604501, 0x26601601, 0x26601705, 0x2660080a, 0x265fe90d, 0x265fea11, 0x275fdb13, 0x295fdc15, 0x2c5fbd17, 0x2f5fae19, 0x315f9f19, 0x345f8ff9,
	0x3470200b, 0x38703076, 0x3b7031ca, 0x417042e9, 0x477043f9, 0x447034fd, 0x427035ff, 0x3c701702, 0x37700806, 0x366ff90a, 0x366ffa0e, 0x386feb10, 0x3a6fdc14, 0x3d6fdd15, 0x416fce16, 0x436fbf18, 0x466faff8,
	0x46802009, 0x46802031, 0x468021a3, 0x4b8022cf, 0x508033e6, 0x5b8034f7, 0x67803600, 0x588026ff, 0x4a801801, 0x4a800906, 0x48800a0a, 0x4a7ffb0d, 0x4d7fec11, 0x517fed12, 0x557fde14, 0x597fcf14, 0x5b7fbff8,
	0x5b903005, 0x5b903005, 0x5b90217d, 0x5f9022ba, 0x639023d7, 0x6b9024ea, 0x749025f7, 0x6b9016f9, 0x609017fc, 0x60901901, 0x5f900a06, 0x608ffb0a, 0x628ffc0d, 0x658fed11, 0x698fde13, 0x6b8fdf15, 0x6f8fcffa,
	0x71a03000, 0x71a03000, 0x71a0314d, 0x74a0329f, 0x77a033c3, 0x7ca024da, 0x80a025e8, 0x7ca026f0, 0x79a017f5, 0x79a018fc, 0x79a01a01, 0x79a00b06, 0x78a00c0a, 0x7a9ffd0d, 0x7c9fee11, 0x7f9fdf14, 0x829fdffd,
	0x8bb03000, 0x8bb03000, 0x8bb03113, 0x8eb03281, 0x90b033af, 0x93b034ca, 0x98b035dc, 0x96b026e7, 0x95b027ee, 0x99b028f6, 0x9fb009fc, 0x9db01b01, 0x9bb00c05, 0x98b00d0a, 0x96affe0f, 0x98afef12, 0x9aafeffe,
	0xa8c03000, 0xa8c03000, 0xa9c030c4, 0xaac0325d, 0xaac03396, 0xadc034b8, 0xafc035ce, 0xb1c036db, 0xb2c037e6, 0xbec018f1, 0xcac009f9, 0xc6c00afd, 0xc2c00c01, 0xb9bffd05, 0xb0c00e0b, 0xb2bfff0f, 0xb3bfefff,
	0xc7d04000, 0xc7d04000, 0xc7d04054, 0xc8d04235, 0xc9d0337d, 0xcad034a4, 0xccd035bd, 0xcdd036cf, 0xcdd037dc, 0xd7d018e9, 0xe1d009f1, 0xe6d00af8, 0xebcffbfc, 0xe3d00d00, 0xdacffe05, 0xd6d00f0a, 0xd2cfffff,
	0xe8e04000, 0xe8e04000, 0xe8e04000, 0xe8e04204, 0xe9e0435f, 0xe9e0448e, 0xeae045ab, 0xebe036c0, 0xebe037cf, 0xf1e028dd, 0xf7e019e9, 0x07e00af2, 0x18dfebf8, 0x10dffcfc, 0x09dffe00, 0xffdfff04, 0xf5e00fff,
	0x0bf04000, 0x0bf04000, 0x0bf04000, 0x0cf041c9, 0x0cf0433e, 0x0cf04477, 0x0cf0459a, 0x0df046b2, 0x0df047c3, 0x11f038d2, 0x14f029df, 0x1ff01ae9, 0x2aeffbf1, 0x2aeffcf7, 0x2beffdfb, 0x23efff00, 0x1cf00ffe,
	0x30fff000, 0x30fff000, 0x30fff000, 0x30fff181, 0x30fff318, 0x30fff45d, 0x31fff586, 0x31fff6a2, 0x32fff7b6, 0x33fff8c6, 0x33fff9d3, 0x38ffeadf, 0x3dffebe8, 0x45ffdcf0, 0x4effcdf6, 0x4affdefb, 0x45ffeffe,
	0xf105702c, 0xf103010a, 0xf1009207, 0xf1005308, 0xf200140b, 0xf200150d, 0xf2001610, 0xf3001712, 0xf3001814, 0xf4001916, 0xf5000a19, 0xf6000b1b, 0xf6000c1d, 0xf8000d20, 0xf9000e22, 0xfa000f24, 0xfb000fff,
	0xf3140053, 0xf313b118, 0xf3137210, 0xf311c30a, 0xf30ff40a, 0xf30fb50c, 0xf40f860f, 0xf40f5711, 0xf50f1814, 0xf60eb916, 0xf60e5a18, 0xf70dfb1b, 0xf80d7c1d, 0xf90cfd1f, 0xfa0c5e22, 0xfb0baf24, 0xfc0aefff,
	0xfc23b09d, 0xfd241140, 0xff247228, 0xfb22530f, 0xf7202408, 0xf620050b, 0xf61fc60e, 0xf71fb710, 0xf81f8813, 0xf81f5915, 0xf91f2a18, 0xfa1efb1a, 0xfa1ebc1c, 0xfc1e7d1f, 0xfc1e2e21, 0xfe1ddf24, 0xff1d7fff,
	0x0531c07d, 0x07320136, 0x08324226, 0x03316310, 0xfd307408, 0xfe308508, 0xff307609, 0xfe30370c, 0xfd2fd810, 0xfd2fa913, 0xfd2f8a17, 0xfe2f5b19, 0xff2f3c1c, 0x002f0d1e, 0x012ede21, 0x022eaf23, 0x032e6ffe,
	0x06408030, 0x0940b101, 0x0b40d20d, 0x0a40d30a, 0x00400400, 0x0c40c509, 0x0f40e608, 0x0a408708, 0x0540180c, 0x043fe910, 0x033faa15, 0x043f9b18, 0x053f7c1b, 0x053f5d1d, 0x073f3e1f, 0x083f1f21, 0x093eeffe,
	0x0f505027, 0x135070e8, 0x1750a205, 0x1950b30b, 0x1b50c40c, 0x18509508, 0x15507607, 0x11504708, 0x0e50080b, 0x0c4fe90f, 0x0c4fca13, 0x0d4fbb15, 0x0d4fbc18, 0x0f4f9d1a, 0x104f8e1b, 0x124f6f1d, 0x134f5ffb,
	0x16604018, 0x1c6050bd, 0x226061f5, 0x2b60930b, 0x3360c413, 0x25607506, 0x17601601, 0x17601705, 0x17600808, 0x175ff90c, 0x165fea10, 0x175feb13, 0x195fdc15, 0x1c5fbd16, 0x1e5fbe17, 0x1f5f9f18, 0x215f8ff7,
	0x23703013, 0x27704083, 0x2b7041d5, 0x327062f6, 0x3a707405, 0x36705504, 0x31705602, 0x2b702703, 0x24701805, 0x2370090a, 0x226ffa0e, 0x246ffb10, 0x266fec13, 0x286fdd14, 0x2c6fde15, 0x2e6fbf16, 0x2f6faff6,
	0x2f80200c, 0x30802036, 0x308021a6, 0x368032d6, 0x3c8033ed, 0x498054ff, 0x57805608, 0x44803702, 0x32800801, 0x31800906, 0x31800a0a, 0x337ffb0d, 0x357ffc10, 0x397fed11, 0x3d7fde12, 0x3f7fdf13, 0x417fcff6,
	0x3e902007, 0x3e902007, 0x3f90217f, 0x439022be, 0x499023dc, 0x539034f1, 0x5d9025fd, 0x509026fb, 0x439017fc, 0x43901901, 0x41900a06, 0x438ffb09, 0x458ffc0d, 0x488fed10, 0x4a8fee12, 0x4c8fef14, 0x4f8fcff9,
	0x4fa03000, 0x4fa03000, 0x4fa0314d, 0x52a032a0, 0x55a033c5, 0x5aa024dc, 0x5fa025ea, 0x5aa026f1, 0x57a017f6, 0x56a018fc, 0x55a01a01, 0x55a00b06, 0x559ffc0a, 0x589ffd0d, 0x599fee10, 0x5c9fdf14, 0x5e9fdffc,
	0x63b03000, 0x63b03000, 0x64b03113, 0x66b03281, 0x69b033b0, 0x6cb034cc, 0x70b035de, 0x6eb026e7, 0x6cb027ef, 0x71b018f7, 0x76b019fd, 0x73b01b01, 0x71b00c05, 0x6fb00d0a, 0x6caffe0e, 0x6eafef12, 0x6fafeffe,
	0x7ac03000, 0x7ac03000, 0x7ac030c3, 0x7bc0325d, 0x7dc03397, 0x80c034b9, 0x82c025cf, 0x83c026dc, 0x84c017e7, 0x90c018f2, 0x9ac009fa, 0x96c00afd, 0x92c00c01, 0x89c00d05, 0x80c00e0b, 0x82bfff0f, 0x83bfefff,
	0x93d04000, 0x93d04000, 0x93d04054, 0x93d03235, 0x94d0337d, 0x97d034a5, 0x98d035be, 0x99d036d0, 0x9ad037dc, 0xa2d018e9, 0xabd009f2, 0xafd00af8, 0xb3cffbfc, 0xabd00d00, 0xa3cffe05, 0xa0d00f0a, 0x9ccfffff,
	0xade04000, 0xaee04000, 0xaee04000, 0xaee04204, 0xaee0435f, 0xaee0448e, 0xafe045ab, 0xb0e036c0, 0xb0e037d0, 0xb6e028dd, 0xbbe019e8, 0xcadffaf3, 0xd9dfebf9, 0xd2dffcfc, 0xcbdffe00, 0xc2dfff04, 0xb9e00fff,
	0xcaf04000, 0xcaf04000, 0xcaf04000, 0xcaf041c9, 0xcaf0433e, 0xcbf04477, 0xcbf0459a, 0xcbf046b1, 0xcdf047c3, 0xcff038d2, 0xd3f029df, 0xddf01aea, 0xe7effbf2, 0xe7effcf7, 0xe7effdfb, 0xe0efff00, 0xd8f00ffe,
	0xe8fff000, 0xe8fff000, 0xe8fff000, 0xe8fff181, 0xe9fff318, 0xe9fff45d, 0xe9fff586, 0xeafff6a2, 0xeafff7b6, 0xeafff8c6, 0xebfff9d3, 0xf0ffeade, 0xf4ffebe9, 0xfcffdcf0, 0x05ffcdf6, 0x00ffdefb, 0xfbffeffe,
	0xeb042022, 0xed027108, 0xee00b207, 0xee008308, 0xee00440b, 0xef00350d, 0xef00360f, 0xef002712, 0xf0001814, 0xf1001916, 0xf1001a19, 0xf1000b1b, 0xf2000c1d, 0xf3000d20, 0xf4000e22, 0xf5000f24, 0xf6000fff,
	0xeb13b043, 0xeb139115, 0xeb13720e, 0xee11e30a, 0xef10540a, 0xf010150b, 0xf00fd60e, 0xf10f7710, 0xf10f0814, 0xf10eb916, 0xf20e5a18, 0xf30deb1b, 0xf30d7c1d, 0xf40ced1f, 0xf50c5e22, 0xf60baf24, 0xf70adfff,
	0xef23807a, 0xee23f133, 0xee246221, 0xf022830e, 0xf2209409, 0xf220650a, 0xf220360c, 0xf31fd70e, 0xf31f8813, 0xf31f6915, 0xf41f2a18, 0xf51eeb1a, 0xf51ebc1c, 0xf61e6d1f, 0xf71e2e21, 0xf81dcf24, 0xf91d7fff,
	0xf832708e, 0xf932f146, 0xfa337233, 0xf932b31a, 0xf832040e, 0xf931c509, 0xf9319606, 0xf830e708, 0xf730280e, 0xf82fd911, 0xf72f7a17, 0xf82f5b19, 0xf92f3c1c, 0xfa2f0d1e, 0xfa2ede21, 0xfb2e9f22, 0xfc2e7ffe,
	0x0441e09e, 0x0842615b, 0x0b42f24c, 0x0b42e331, 0x0c42e420, 0x0b42b512, 0x0a428608, 0x05418703, 0xff407809, 0xfd40190d, 0xfc3fba14, 0xfc3f9b18, 0xfd3f7c1a, 0xfe3f5d1d, 0xff3f3e1f, 0x003f1f21, 0x013efffd,
	0x0c50f072, 0x12516137, 0x1951d242, 0x1d521338, 0x2052642d, 0x00500500, 0x1151260a, 0x0d50d707, 0x08506808, 0x0650290b, 0x044fea11, 0x054fdb13, 0x044fcc16, 0x064fad17, 0x074f8e19, 0x084f7f1b, 0x094f6ff9,
	0x0e60602d, 0x1760a0eb, 0x2060f223, 0x2c616338, 0x3961e43b, 0x24610514, 0x0e604603, 0x11605706, 0x14606807, 0x11603909, 0x0e601a0e, 0x0e5ffb10, 0x0f5fec12, 0x115fdd13, 0x125fce14, 0x135fbf15, 0x145faff5,
	0x17704024, 0x1d7060a4, 0x257081f7, 0x3070c319, 0x3c70f426, 0x3270c514, 0x29709609, 0x23706705, 0x1d704805, 0x1b702908, 0x19700a0b, 0x1a700b0d, 0x1b6ffc0f, 0x1d6ffd10, 0x1f6fee10, 0x206fcf12, 0x216fcff3,
	0x21803017, 0x22803042, 0x238031b0, 0x2a8042e2, 0x318053f9, 0x4080850f, 0x5180a617, 0x3b806707, 0x26801802, 0x26801906, 0x25800a08, 0x27801b0b, 0x2a800c0c, 0x2b7ffd0d, 0x2e7ffe0d, 0x2f7fef0d, 0x307fdff2,
	0x2c90200d, 0x2d902010, 0x2d902185, 0x349032c8, 0x3a9033e6, 0x479044fe, 0x5590460b, 0x49903703, 0x3c902800, 0x37902902, 0x33901a06, 0x34900b08, 0x35900c0b, 0x368ffd0d, 0x398fee0f, 0x3a8fdf11, 0x3b8fcff6,
	0x37a03002, 0x37a03002, 0x38a0314d, 0x3da032a5, 0x42a023cc, 0x4aa024e6, 0x51a025f5, 0x55a026fb, 0x58a01800, 0x4ba018ff, 0x40a01a01, 0x41a00b06, 0x409ffc09, 0x429ffd0c, 0x439fee0f, 0x459fdf12, 0x469fdffb,
	0x48b03001, 0x48b03001, 0x48b03113, 0x4bb03285, 0x50b033b5, 0x56b024d3, 0x5cb015e6, 0x5fb016ef, 0x61b017f7, 0x5fb008fa, 0x5db019fe, 0x5ab01b01, 0x57b00c05, 0x55b00d08, 0x51affe0e, 0x52afef11, 0x53afeffd,
	0x5bc03000, 0x5bc03000, 0x5bc030c2, 0x5cc0325e, 0x5dc03398, 0x61c034bb, 0x64c025d1, 0x66c026e0, 0x69c017eb, 0x73c008f5, 0x7fc009fb, 0x78bffafd, 0x71c00c01, 0x69bffd05, 0x60c00e0b, 0x60bfff0f, 0x63bfefff,
	0x6fd04000, 0x6fd04000, 0x6fd04053, 0x70d03234, 0x70d0337d, 0x72d034a6, 0x74d025c0, 0x76d026d2, 0x78d017de, 0x80d018ea, 0x89d009f4, 0x8dd00af9, 0x90cfebfd, 0x87cffd00, 0x7ecffe05, 0x7ad00f0a, 0x76cfffff,
	0x84e04000, 0x84e04000, 0x84e04000, 0x84e04204, 0x85e0435f, 0x85e0448d, 0x85e035ab, 0x87e036c1, 0x87e037d0, 0x8ce028de, 0x91e019e8, 0xa2dffaf4, 0xb3dfdbfa, 0xa8dfecfc, 0x9fdffe00, 0x96dfff04, 0x8de00fff,
	0x9cf04000, 0x9cf04000, 0x9cf04000, 0x9cf041c9, 0x9cf0433e, 0x9df04477, 0x9df04599, 0x9df046b1, 0x9ef037c4, 0xa1f038d3, 0xa4f029df, 0xb0f01aeb, 0xbbefebf3, 0xb9effcf7, 0xb8effdfb, 0xafefff00, 0xa8f00ffe,
	0xb5fff000, 0xb5fff000, 0xb5fff000, 0xb5fff180, 0xb5fff318, 0xb6fff45d, 0xb6fff586, 0xb6fff6a2, 0xb6fff7b6, 0xb7fff8c6, 0xb8fff9d3, 0xbcffeade, 0xc0ffebe8, 0xc9ffdcf0, 0xd1ffcdf6, 0xcbffdefb, 0xc6ffeffe,
	0xe901d00f, 0xea016106, 0xea00e206, 0xeb00b308, 0xec00740a, 0xec00650d, 0xec00560f, 0xec003712, 0xec002814, 0xed002916, 0xed001a18, 0xee001b1b, 0xee000c1d, 0xef000d20, 0xf0000e22, 0xf0000f24, 0xf1000fff,
	0xe7128029, 0xe712b10e, 0xe712d20c, 0xe811d309, 0xea10c409, 0xea10950b, 0xeb10560c, 0xec0fb70f, 0xee0f0814, 0xee0ea916, 0xee0e4a18, 0xef0ddb1b, 0xef0d5c1d, 0xf00cdd1f, 0xf00c3e22, 0xf10b8f24, 0xf20acfff,
	0xe822c051, 0xe7232120, 0xe6238218, 0xe922530c, 0xeb21240a, 0xec210509, 0xec20d60b, 0xee20370d, 0xef1f7812, 0xef1f5914, 0xf01f2a18, 0xf01eeb1a, 0xf11eac1c, 0xf21e6d1f, 0xf21e1e21, 0xf31dcf24, 0xf41d6fff,
	0xeb3360a3, 0xea344159, 0xe9351242, 0xea34b327, 0xeb344417, 0xec33d50c, 0xed335605, 0xef31f703, 0xf130780b, 0xf230090f, 0xf32f8a16, 0xf32f5b19, 0xf32f2c1c, 0xf42efd1e, 0xf52ede20, 0xf62eaf22, 0xf72e7ffe,
	0xf743d112, 0xf844f1bc, 0xfa461290, 0xfa46135d, 0xfb46243c, 0xfb45751d, 0xfb44d608, 0xfa42f6ff, 0xf7410805, 0xf740690a, 0xf63fba14, 0xf73f9b17, 0xf73f7c1a, 0xf83f5d1d, 0xf93f4e1e, 0xf93f1f20, 0xfa3eeffd,
	0x0351e0c1, 0x0852c18a, 0x0d539284, 0x10541369, 0x1454a451, 0x0d537525, 0x0752360f, 0x04519706, 0x0050f806, 0xff508908, 0xfd500a0f, 0xfd4feb12, 0xfd4fdc15, 0xfe4fbd15, 0x004fae17, 0x004f8f19, 0x014f6ff7,
	0x05608043, 0x0e612119, 0x1661c252, 0x23629367, 0x2f638466, 0x1b61f524, 0x00600600, 0x0960a707, 0x0c60d806, 0x0a608906, 0x06603a0b, 0x07601b0d, 0x06600c0f, 0x075ffd10, 0x095fee10, 0x0a5fcf11, 0x0a5fbff2,
	0x0e706035, 0x1570a0c6, 0x1c70e219, 0x2871533d, 0x3471b448, 0x29715525, 0x1f70e610, 0x1a70b709, 0x15707806, 0x13705907, 0x10702a09, 0x10702b0a, 0x11702c0c, 0x13700d0c, 0x15700e0c, 0x146fef0d, 0x156fdff0,
	0x15804021, 0x1680404e, 0x188041ba, 0x1f8062ee, 0x26808407, 0x3580d51e, 0x45811626, 0x3080b70d, 0x1b803803, 0x1b803905, 0x1b802a07, 0x1d802b08, 0x1f802c09, 0x21801d08, 0x23801e07, 0x22800f08, 0x227fffee,
	0x1f903014, 0x1f903019, 0x2090318b, 0x279042d1, 0x2e9043f2, 0x3c90750d, 0x4a90861a, 0x3f90670b, 0x34905805, 0x2d903903, 0x26901a05, 0x27901b07, 0x28901c09, 0x29900d0b, 0x2b8ffe0c, 0x2b8fef0d, 0x2b8fdff4,
	0x28a03003, 0x28a03003, 0x28a0314d, 0x2da032a9, 0x32a023d2, 0x3ca034f0, 0x46a03600, 0x4da04707, 0x54a0380a, 0x42a02902, 0x30a01a02, 0x30a00b04, 0x309ffc08, 0x31a00d0b, 0x329ffe0e, 0x339fef10, 0x349feff9,
	0x34b03002, 0x34b03002, 0x34b03112, 0x38b03288, 0x3cb033b9, 0x44b034d9, 0x4cb015ee, 0x51b016f8, 0x58b017ff, 0x50b018fe, 0x49b019ff, 0x47b01b01, 0x43b00c04, 0x40b00d08, 0x3eaffe0d, 0x3eafef10, 0x3fafeffc,
	0x43c03000, 0x43c03000, 0x44c030c1, 0x45c0325e, 0x46c03397, 0x4ac034bc, 0x4ec025d4, 0x51c026e3, 0x54c017ee, 0x5ec008f8, 0x68c009fd, 0x61bffafe, 0x59c00c01, 0x51c00d05, 0x48c00e0b, 0x4abfff0f, 0x4abfeffe,
	0x54d04000, 0x54d04000, 0x54d03051, 0x55d03234, 0x55d0337d, 0x58d034a7, 0x5bd025c2, 0x5dd026d3, 0x5fd017e1, 0x67d008ec, 0x6fd009f5, 0x72cffafa, 0x75cfebfd, 0x6ccffd00, 0x61cffe04, 0x5ed00f0a, 0x5ccffffe,
	0x66e04000, 0x66e04000, 0x66e04000, 0x66e04203, 0x66e0435e, 0x66e0448d, 0x67e035ab, 0x68e036c1, 0x69e037d0, 0x6ee028de, 0x72e019e9, 0x83dffaf5, 0x95dfdbfb, 0x8adfdcfc, 0x7edffdff, 0x76dfff04, 0x6ee00fff,
	0x7af04000, 0x7af04000, 0x7af04000, 0x7af041c8, 0x7af0433d, 0x7af04476, 0x7af04599, 0x7cf046b1, 0x7cf037c4, 0x7ef028d3, 0x82f029e0, 0x8deffaeb, 0x9aefebf4, 0x96efecf7, 0x94effdfb, 0x8defff00, 0x85effffe,
	0x8ffff000, 0x8ffff000, 0x8ffff000, 0x8ffff17f, 0x8ffff318, 0x8ffff45c, 0x8ffff586, 0x90fff6a1, 0x90fff7b6, 0x91fff8c6, 0x92fff9d3, 0x95ffeadf, 0x9affebe8, 0xa2ffccf0, 0xaaffbdf6, 0xa4ffcefb, 0x9effdffe,
	0xe4029015, 0xe4028108, 0xe4028208, 0xe502030a, 0xe601940a, 0xe701250d, 0xe800b60e, 0xe8008711, 0xe9005813, 0xe9003915, 0xea002a18, 0xea001b1b, 0xeb000c1d, 0xeb000d20, 0xec000e22, 0xed000f24, 0xed000fff,
	0xe212d02b, 0xe1131110, 0xe113420d, 0xe312630a, 0xe511740a, 0xe611150b, 0xe610960c, 0xe80fd70f, 0xea0f1812, 0xea0eb915, 0xeb0e3a18, 0xeb0dcb1a, 0xeb0d4c1d, 0xec0ccd1f, 0xed0c2e22, 0xed0b7f24, 0xee0aafff,
	0xe022f04b, 0xdf23411c, 0xde239216, 0xe122930d, 0xe521a40a, 0xe621550a, 0xe721160a, 0xe920670d, 0xea1fa811, 0xeb1f6914, 0xec1f2a18, 0xec1eeb1a, 0xed1e9c1c, 0xee1e5d1f, 0xee1e0e21, 0xef1dbf24, 0xef1d5fff,
	0xdd3490b8, 0xdb35315f, 0xd935c241, 0xdb356328, 0xdd350419, 0xdf34450d, 0xe233a606, 0xe6324705, 0xeb30f809, 0xec30490e, 0xee2f9a14, 0xef2f6b17, 0xef2f3c1b, 0xf02f0d1d, 0xf02ede1f, 0xf12eaf21, 0xf22e7ffd,
	0xe345714e, 0xe14641cf, 0xdf471290, 0xdf46f35c, 0xe046f43a, 0xe345f51e, 0xe645060b, 0xea436701, 0xed41a803, 0xf040d908, 0xf13ffa11, 0xf23fbb15, 0xf23f7c19, 0xf33f5d1b, 0xf33f4e1d, 0xf43f2f1f, 0xf53f0ffb,
	0xf5533117, 0xf553f1bb, 0xf554d29a, 0xf5553373, 0xf655a456, 0xf654b52d, 0xf653c614, 0xf7532706, 0xf75277ff, 0xf7519900, 0xf650aa08, 0xf7505b0b, 0xf7500c10, 0xf84fed11, 0xf84fde13, 0xf94faf15, 0xfa4f8ff5,
	0x006190bd, 0x0462517e, 0x08631293, 0x0c63e387, 0x1064a476, 0x0c63c53e, 0x0862d61d, 0x0962d70f, 0x0a62e801, 0x0661f8fb, 0x02610a00, 0x0160bb02, 0xff606c07, 0x00604d09, 0x01603e0a, 0x01600f0c, 0x015fdfee,
	0x0870c075, 0x0c711101, 0x10716240, 0x1871e359, 0x1f72745c, 0x20727543, 0x2072762e, 0x00700700, 0x14718808, 0x11713903, 0x0e70da01, 0x0c70cb00, 0x0c709c01, 0x0c707d00, 0x0c705e02, 0x0c703f05, 0x0b700feb,
	0x09803015, 0x0a804044, 0x0b8041b7, 0x1580a301, 0x1f80f423, 0x2f81753e, 0x3f820645, 0x2b81571a, 0x17809806, 0x1980a905, 0x1c80aa03, 0x1c80aaff, 0x1d809bfb, 0x1d808cfb, 0x1c807dfb, 0x1a804efe, 0x18802fe8,
	0x1290200c, 0x13903014, 0x1390318a, 0x1d9052e0, 0x26908408, 0x3590b528, 0x45910635, 0x3b90d71c, 0x3190a80c, 0x2d908907, 0x29907a04, 0x29906b02, 0x28906c00, 0x26904d01, 0x23902e03, 0x22901f06, 0x1f8ffff0,
	0x1aa03002, 0x1ba03003, 0x1ba0314e, 0x21a032b1, 0x28a033de, 0x33a05501, 0x3fa06614, 0x49a06719, 0x54a07819, 0x45a0690b, 0x37a04a04, 0x34a03b02, 0x30a02c03, 0x2da01d05, 0x29a00e09, 0x289fff0c, 0x279feff7,
	0x25b03001, 0x25b03002, 0x26b03113, 0x2ab0328d, 0x2fb033c1, 0x38b034e6, 0x42b025fc, 0x4bb02707, 0x53b0280d, 0x4fb02908, 0x4db02a04, 0x49b02b02, 0x47b01c01, 0x3db00d03, 0x34affe09, 0x32afef0d, 0x31afdffa,
	0x32c03000, 0x32c03000, 0x32c030c1, 0x34c03260, 0x35c0339c, 0x3ac024c2, 0x3ec025da, 0x43c026ea, 0x49c017f5, 0x57c00900, 0x65bffa05, 0x63bffb02, 0x60bfebff, 0x50bffd01, 0x3ec00e08, 0x3dbfff0c, 0x3abfeffd,
	0x40d03000, 0x40d03000, 0x40d03050, 0x41d03236, 0x42d03380, 0x45d024aa, 0x48d025c5, 0x4cd026d8, 0x50d007e6, 0x5bcff8f3, 0x65cfe9fc, 0x6ccfeaff, 0x72cfdbff, 0x62cfecff, 0x52cffe03, 0x4dcfff08, 0x49cffffe,
	0x4fe04000, 0x4fe04000, 0x4fe04000, 0x4fe04202, 0x4fe0435e, 0x4fe0348d, 0x50e035ac, 0x52e036c1, 0x54e027d2, 0x5be028e1, 0x61e009ed, 0x72dfdaf8, 0x84dfbbfe, 0x75dfdcfc, 0x67dffdff, 0x5edfff04, 0x56e00ffe,
	0x60f04000, 0x60f04000, 0x60f04000, 0x60f041c7, 0x60f0433d, 0x60f04476, 0x61f04599, 0x62f046b2, 0x63f037c5, 0x67f028d5, 0x6af019e1, 0x77effaee, 0x83efdbf6, 0x7fefecf8, 0x7aefedfb, 0x72effeff, 0x6beffffe,
	0x72fff000, 0x72fff000, 0x72fff000, 0x72fff17e, 0x72fff317, 0x72fff45c, 0x72fff585, 0x73fff6a1, 0x73fff7b6, 0x73fff8c6, 0x74fff9d3, 0x79ffeadf, 0x7dffdbe9, 0x86ffccf1, 0x8fffadf7, 0x88ffcefa, 0x80ffdffe,
	0xdf03601b, 0xde03f10d, 0xdd04820c, 0xde03b30b, 0xe002f40b, 0xe102150c, 0xe401460e, 0xe500e710, 0xe5007813, 0xe6005915, 0xe7003a17, 0xe7002b1b, 0xe7000c1d, 0xe8000d1f, 0xe8000e22, 0xe9000f24, 0xe9000fff,
	0xdd13102c, 0xdc137111, 0xdb13b20f, 0xdd13030c, 0xdf12340b, 0xe011950b, 0xe210e60c, 0xe410170f, 0xe60f2812, 0xe60eb915, 0xe70e3a17, 0xe80dbb1a, 0xe80d2c1d, 0xe90cad1f, 0xe90c0e22, 0xe90b5f24, 0xea0a9fff,
	0xdb22f043, 0xda232118, 0xda236212, 0xdc22d30d, 0xde22340b, 0xdf21d50a, 0xe121660b, 0xe420970d, 0xe71fb810, 0xe71f7914, 0xe91f2a17, 0xe91eeb1a, 0xe91e9c1c, 0xe91e4d1f, 0xea1e0e21, 0xeb1daf24, 0xeb1d4fff,
	0xce3600d1, 0xcd363165, 0xcc367240, 0xce360328, 0xd035b41a, 0xd434b50e, 0xd933b608, 0xdd32a706, 0xe2319808, 0xe630b90c, 0xe92fda12, 0xea2f8b16, 0xeb2f3c1b, 0xeb2f1d1c, 0xec2eee1e, 0xec2eaf21, 0xed2e7ffc,
	0xc947b18f, 0xc847e1e4, 0xc8481290, 0xc947d35b, 0xcb47a43b, 0xd146651d, 0xd745160c, 0xdd43d703, 0xe2429801, 0xe7417905, 0xeb403a0f, 0xec3feb12, 0xed3f9c18, 0xee3f7d1a, 0xef3f5e1b, 0xef3f3f1d, 0xf03f1ffa,
	0xde54f172, 0xdd55a1f1, 0xdb5642b3, 0xda56837f, 0xd956d45a, 0xdc565536, 0xde55d61b, 0xe1552708, 0xe35487f9, 0xe85308f7, 0xec517a01, 0xee50eb04, 0xf0506c0b, 0xf1503d0c, 0xf1501e0f, 0xf14fef12, 0xf34fbff2,
	0xf163013b, 0xf063f1e9, 0xf064e2d8, 0xef6583ab, 0xf0661486, 0xf066155c, 0xf1662639, 0xf265f719, 0xf465b7fe, 0xf563f8f2, 0xf66229f7, 0xf6618af9, 0xf760ec00, 0xf760ad01, 0xf7607e04, 0xf8604f06, 0xf9600feb,
	0xfe7140b6, 0xff71b13e, 0x0172226a, 0x0472c376, 0x07736472, 0x0a741564, 0x0e74a64f, 0x0a73d725, 0x0872f80c, 0x057258ff, 0x0371b9fa, 0x03717af7, 0x02713bf5, 0x0270fcf6, 0x0270cdf9, 0x01708efd, 0x01704fe6,
	0xff803008, 0x00804039, 0x018051b2, 0x0980f314, 0x1281843f, 0x1f82755f, 0x2b836665, 0x1c824729, 0x00800800, 0x10813906, 0x138159fe, 0x14815af7, 0x15815bee, 0x13812ced, 0x1180edef, 0x0f80aef4, 0x0c805fe2,
	0x06902004, 0x0790300e, 0x08903188, 0x129082ef, 0x1b90d41f, 0x29913545, 0x3791b653, 0x2f91772e, 0x27912816, 0x2591090b, 0x2390fa02, 0x2390eafc, 0x2190dbf7, 0x1d90acf8, 0x1a907dfb, 0x17904eff, 0x15901feb,
	0x0fa02000, 0x0fa02004, 0x10a0214e, 0x16a042ba, 0x1ca053ec, 0x28a08513, 0x33a0a628, 0x3ea0c72c, 0x49a0f82a, 0x3fa0c914, 0x35a09a06, 0x30a08b00, 0x2ca06bfe, 0x26a04cff, 0x20a02e04, 0x1ea00f08, 0x1c9ffff4,
	0x19b03000, 0x19b03002, 0x1ab03113, 0x1fb03293, 0x24b033cb, 0x2db034f4, 0x36b0460b, 0x40b05717, 0x4ab0581b, 0x49b04912, 0x49b05a0a, 0x46b05b03, 0x43b04bfd, 0x36b02cfe, 0x2ab01e05, 0x28afff08, 0x25afeff8,
	0x24c03000, 0x24c03001, 0x24c030bf, 0x26c03263, 0x28c033a0, 0x2dc034c7, 0x31c025e0, 0x37c016f2, 0x3ec017fc, 0x4dc01909, 0x5cc00a0d, 0x5ec00b06, 0x5fbffbff, 0x4ac00cfe, 0x35c00e05, 0x31bfff09, 0x2ebfeffb,
	0x30d03000, 0x30d03000, 0x30d0304f, 0x31d03237, 0x33d03382, 0x35d024ae, 0x38d025c8, 0x3ed016dd, 0x42d007eb, 0x4fcff8fb, 0x5bcfea03, 0x63cfdb04, 0x6bcfcc02, 0x57cfecfe, 0x43cffe02, 0x3fcfff07, 0x39cffffd,
	0x3de04000, 0x3de04000, 0x3de04000, 0x3de04202, 0x3de0435e, 0x3de0348e, 0x3ee035ab, 0x41e036c3, 0x43e027d4, 0x4ae008e5, 0x52dff9f0, 0x63dfdafb, 0x75dfbc01, 0x64dfccfd, 0x52dffdff, 0x4bdfff03, 0x43e00ffe,
	0x4bf04000, 0x4bf04000, 0x4cf04000, 0x4cf041c7, 0x4cf0433c, 0x4cf04476, 0x4cf0459a, 0x4ef046b3, 0x4ff027c6, 0x53f028d7, 0x59f019e3, 0x64efeaf1, 0x71efcbf8, 0x6befdcf9, 0x65efddfb, 0x5deffeff, 0x54effffe,
	0x5bfff000, 0x5bfff000, 0x5bfff000, 0x5bfff17d, 0x5bfff317, 0x5bfff45c, 0x5bfff585, 0x5cfff6a1, 0x5cfff7b6, 0x5cfff8c6, 0x5dfff9d3, 0x62ffeae0, 0x66ffdbe9, 0x6fffbcf2, 0x79ffadf7, 0x71ffcefa, 0x68ffdffe,
	0xd9044022, 0xd7056112, 0xd4069210, 0xd406d30e, 0xd307140d, 0xd805250c, 0xdc03260c, 0xdf02170f, 0xe1010812, 0xe200a915, 0xe3004a17, 0xe4003b1a, 0xe4001c1d, 0xe4001d1f, 0xe5000e22, 0xe5002f23, 0xe6003ffe,
	0xd7138031, 0xd4146116, 0xd2153213, 0xd1156310, 0xd015a40e, 0xd513f50b, 0xda12260c, 0xdd10f70d, 0xe10fa811, 0xe20f0914, 0xe30e4a17, 0xe40dbb19, 0xe40d2c1d, 0xe50c9d1f, 0xe50bfe20, 0xe60b5f23, 0xe60a9ffe,
	0xd5235045, 0xd323f11d, 0xd0248218, 0xcf24c313, 0xce24f410, 0xd423a50c, 0xd922460b, 0xdd21470c, 0xe020380f, 0xe31fc912, 0xe41f3a16, 0xe41eeb19, 0xe61e9c1c, 0xe61e5d1e, 0xe61e1e20, 0xe71dbf22, 0xe71d7ffd,
	0xc33660c4, 0xc236b162, 0xc0371241, 0xbd37b330, 0xba384422, 0xc4368512, 0xcd34a609, 0xd4337706, 0xd9323807, 0xde31390a, 0xe2302a10, 0xe52fcb14, 0xe62f6c19, 0xe72f3d1b, 0xe72f0e1c, 0xe82edf1f, 0xe82e9ffb,
	0xb948016a, 0xb84831cd, 0xb7486284, 0xb3494361, 0xae4a1447, 0xba480523, 0xc645f60e, 0xce44a704, 0xd5435801, 0xdd420903, 0xe440ba0c, 0xe5403b0f, 0xe73fdc15, 0xe83fad17, 0xe83f7e19, 0xe93f6f1b, 0xea3f4ff8,
	0xc7564194, 0xc456d202, 0xc15772ba, 0xbe57f389, 0xbc589465, 0xc157b53b, 0xc656e61e, 0xcb56470a, 0xcf5587fb, 0xd753e8f6, 0xe15239fc, 0xe4519aff, 0xe750fc05, 0xe850ad07, 0xe9506e0a, 0xeb501f0e, 0xec4fdfef,
	0xd86501bd, 0xd465c23e, 0xd16692ff, 0xd066f3bd, 0xcf67448d, 0xd0675561, 0xd067663d, 0xd267171c, 0xd566c801, 0xdd6508f2, 0xe46339f2, 0xe8627af1, 0xea61bbf7, 0xec614cf8, 0xee60fdfd, 0xef60af01, 0xf0604fe8,
	0xef72511d, 0xee72c193, 0xed73329b, 0xec73d394, 0xeb748485, 0xea75256f, 0xea75c655, 0xec75272d, 0xee748810, 0xf073d8fd, 0xf17349f1, 0xf272fae8, 0xf472abe1, 0xf5720ce4, 0xf6717dec, 0xf6710ef3, 0xf7707fe2,
	0xf980904d, 0xfa80b08b, 0xfa80e1f1, 0xfd81a344, 0x00827466, 0x03837574, 0x0784666f, 0x0583973a, 0x0382c819, 0x0482f908, 0x068329f5, 0x07831ae4, 0x08831bd3, 0x06826cd4, 0x0481addd, 0x03812ee7, 0x01809fdd,
	0x0190502a, 0x0290603d, 0x029071ab, 0x0790d30d, 0x0c913437, 0x1491c558, 0x1c927661, 0x1c926743, 0x1c92582a, 0x1c924915, 0x1d924a01, 0x1c922af1, 0x1c920be3, 0x15918ce3, 0x1090fdec, 0x0d90aef4, 0x0a904fe7,
	0x06a02000, 0x06a02002, 0x06a0214b, 0x0aa042ba, 0x10a063ee, 0x1aa0b522, 0x25a1063c, 0x30a16746, 0x3ba1c841, 0x38a1a925, 0x36a18a0e, 0x31a16afb, 0x2da13bf0, 0x24a0dcef, 0x1aa07df8, 0x16a04efe, 0x11a00ff0,
	0x0fb03000, 0x0fb03001, 0x0fb0310f, 0x13b04294, 0x17b033cc, 0x20b054fe, 0x2ab0761b, 0x35b0972c, 0x41b0a831, 0x47b0c927, 0x4db0da19, 0x49b0cb06, 0x46b0bbf7, 0x37b08cf3, 0x26b03dfa, 0x22b02eff, 0x1caffff2,
	0x18c03000, 0x18c03000, 0x18c030bd, 0x1ac03264, 0x1cc033a2, 0x20c034ce, 0x26c035e7, 0x2fc026ff, 0x37c0280c, 0x4ec0391f, 0x65c03a22, 0x64c03b10, 0x62c03c00, 0x4bc02cf8, 0x35c00dfc, 0x2ec00f00, 0x27bffff5,
	0x23d03000, 0x23d03000, 0x23d0304c, 0x24d03237, 0x25d03383, 0x28d024b0, 0x2cd025cd, 0x32d016e6, 0x38d007f6, 0x4bcff90a, 0x5ccfda14, 0x66cfcb0f, 0x70cfbc07, 0x59cfdcfc, 0x43cfedfd, 0x3acfff01, 0x30cffff9,
	0x2ee04000, 0x2ee04000, 0x2ee04000, 0x2fe04201, 0x2fe0335d, 0x2fe0348e, 0x30e035ac, 0x32e036c4, 0x34e027d6, 0x3ce008e8, 0x44dff9f5, 0x5fdfbb05, 0x79df7c09, 0x66dfacff, 0x52dfddfd, 0x45dfef00, 0x39dffffc,
	0x3bf04000, 0x3bf04000, 0x3bf04000, 0x3bf041c6, 0x3bf0433c, 0x3bf04476, 0x3bf04599, 0x3df036b4, 0x3ff027c7, 0x44f018d9, 0x49f009e6, 0x5befcaf8, 0x6eef9c00, 0x65efacfc, 0x5defbdfb, 0x52efdefe, 0x47effffd,
	0x48fff000, 0x48fff000, 0x48fff000, 0x48fff17c, 0x49fff316, 0x49fff45b, 0x49fff585, 0x49fff6a1, 0x49fff7b6, 0x4bfff8c7, 0x4bfff9d3, 0x51ffdae1, 0x57ffcbec, 0x60ffbcf4, 0x68ff9df8, 0x5fffbefa, 0x54ffdffe,
	0xd305202a, 0xce071118, 0xca08f216, 0xc60a8314, 0xc30c0411, 0xcb08b50d, 0xd305560c, 0xd703870e, 0xdc01b811, 0xde011914, 0xdf006a17, 0xe0004b19, 0xe1001c1d, 0xe1001d1f, 0xe1001e22, 0xe2004f23, 0xe1007ffd,
	0xd0141036, 0xcb15711c, 0xc716f219, 0xc2186316, 0xbd19e413, 0xc716d50d, 0xd113b60c, 0xd612070c, 0xda10480f, 0xde0f4912, 0xe00e5a16, 0xe00dbb19, 0xe10d1c1b, 0xe10c8d1e, 0xe10bfe20, 0xe10b6f22, 0xe20abffc,
	0xce23a046, 0xc924c123, 0xc425d21e, 0xbf27331b, 0xb928a417, 0xc426150d, 0xd023660a, 0xd522370b, 0xda20e80e, 0xdd202911, 0xdf1f6a15, 0xe11f0b18, 0xe21e8c1b, 0xe11e5d1d, 0xe21e1e1f, 0xe21ddf20, 0xe31d8ffc,
	0xbc3690b4, 0xb937115c, 0xb6379240, 0xaa399338, 0x9f3b942e, 0xb038a516, 0xc135b60a, 0xc8347706, 0xcf331806, 0xd631d909, 0xdc30aa0e, 0xde302b12, 0xe22f8c17, 0xe22f5d18, 0xe22f2e1a, 0xe32eff1d, 0xe32ecff9,
	0xae482142, 0xac4851b3, 0xab488276, 0x9c4ad368, 0x8e4d1455, 0xa24a0529, 0xb746f611, 0xc0459706, 0xc8444801, 0xd242d902, 0xdb414a09, 0xde40bb0c, 0xe2401c12, 0xe23fed14, 0xe33fce16, 0xe33f9f18, 0xe43f6ff6,
	0xae57e1b9, 0xac585215, 0xa958b2c1, 0xa2599394, 0x9d5a9471, 0xa6595542, 0xaf582622, 0xb457670c, 0xbb56a7fc, 0xc654f8f6, 0xd25349f8, 0xd7528af9, 0xdc51abff, 0xde514d01, 0xe150de05, 0xe3507f0a, 0xe5501fed,
	0xb5678247, 0xb2681299, 0xaf68a32b, 0xaf68a3d1, 0xaf68a494, 0xb068a567, 0xb068b642, 0xb3686721, 0xb7680804, 0xc36648f2, 0xcf6469ed, 0xd5639aea, 0xdb62abee, 0xdf621cf0, 0xe2618df6, 0xe5610efb, 0xe8609fe5,
	0xd873c189, 0xd67421eb, 0xd47482cf, 0xd17533b4, 0xcd75e499, 0xca76757b, 0xc777065c, 0xca76c735, 0xcd767815, 0xd175e8fb, 0xd57549e9, 0xd874ead9, 0xdb747bce, 0xe1737cd2, 0xe6725ddf, 0xea719eea, 0xed70cfde,
	0xef812094, 0xef8160de, 0xee81b232, 0xea82b376, 0xe683c48e, 0xe484a58a, 0xe185a67b, 0xe385674e, 0xe685282a, 0xe585590c, 0xe78599ee, 0xe8858ad3, 0xea857bb9, 0xed841cbb, 0xf182bdcc, 0xf481dedb, 0xf580efd9,
	0xf9908052, 0xf990a06d, 0xf990b1d1, 0xfa91332b, 0xfb91c451, 0xfc92856c, 0xfe934671, 0x0093a75a, 0x01940840, 0x02941921, 0x03943a02, 0x04940ae7, 0x0493cbd0, 0x0392ccd0, 0x0191bdde, 0x00912ee8, 0xff908fe3,
	0xffa02000, 0xffa02000, 0xffa02147, 0x01a052ba, 0x03a083ef, 0x0aa11531, 0x10a1a653, 0x18a24761, 0x20a2e85c, 0x21a2e937, 0x22a2fa16, 0x20a2aaf9, 0x1da26be4, 0x16a1ace1, 0x0ea0fded, 0x0ba09ef5, 0x07a03fec,
	0x06b03000, 0x06b03000, 0x06b0310b, 0x09b03294, 0x0bb043cf, 0x12b0850a, 0x1bb0b62c, 0x24b0f743, 0x2eb13848, 0x37b1893d, 0x40b1ba29, 0x3cb1ab0b, 0x39b18bf2, 0x2bb11cea, 0x1db09df1, 0x18b06ef6, 0x13b02fed,
	0x0fc03000, 0x0fc03000, 0x0fc030ba, 0x10c03264, 0x12c033a4, 0x16c044d3, 0x1ac035f0, 0x23c0470d, 0x2cc0581d, 0x43c08936, 0x5cc0ba39, 0x59c0bb1a, 0x56c0bc01, 0x42c08cf2, 0x2dc04df4, 0x26c03ef8, 0x1fc00fef,
	0x18d03000, 0x18d03000, 0x18d03049, 0x19d03236, 0x1ad03383, 0x1dd034b4, 0x20d015d3, 0x27d016ef, 0x2dd01800, 0x41d0091b, 0x54cffa25, 0x5ecffb1c, 0x68cfec0d, 0x52cffcfb, 0x3cd00df8, 0x32cffefb, 0x27cffff5,
	0x22e04000, 0x22e04000, 0x22e03000, 0x22e03200, 0x22e0335c, 0x22e0348d, 0x23e035ac, 0x26e036c5, 0x28e027d6, 0x2fe008ec, 0x37dff9f9, 0x55dfbb0e, 0x73df7c13, 0x60df9d01, 0x4bdfbdfa, 0x3edfdefc, 0x2fdffff9,
	0x2df04000, 0x2df04000, 0x2df04000, 0x2df041c4, 0x2df0433b, 0x2df04476, 0x2df03599, 0x30f036b5, 0x31f027c7, 0x36f018db, 0x3beff9e9, 0x50efbaff, 0x65ef7c08, 0x5def9d00, 0x53efadfc, 0x47efdefd, 0x39efeffc,
	0x39fff000, 0x39fff000, 0x39fff000, 0x39fff17b, 0x39fff316, 0x39fff45b, 0x39fff584, 0x3afff6a1, 0x3afff7b5, 0x3bfff8c6, 0x3cfff9d4, 0x42ffdae3, 0x49ffcbee, 0x51ffacf5, 0x58ff8df9, 0x4effbefa, 0x43ffdffd,
	0xcf04f028, 0xca06f117, 0xc508f217, 0xba0d0318, 0xb0111416, 0xbb0d050e, 0xc608e60c, 0xce05e70c, 0xd602e80f, 0xd801f913, 0xdb00fa16, 0xdb00ab18, 0xdd005c1c, 0xdd006d1e, 0xdd007e20, 0xde009f21, 0xdd00cffc,
	0xce13a031, 0xc9151119, 0xc3167218, 0xb71a131a, 0xaa1da418, 0xb61a150f, 0xc316760b, 0xcb13e70b, 0xd311380e, 0xd70ff911, 0xda0eaa15, 0xdc0dfb18, 0xdd0d2c1a, 0xdd0cbd1d, 0xdd0c3e1e, 0xdd0b8f20, 0xdd0acffb,
	0xcc23403c, 0xc724511b, 0xc225521a, 0xb3286320, 0xa52b741d, 0xb2289511, 0xc125a60b, 0xca23b70a, 0xd221b80d, 0xd620b90f, 0xda1fba14, 0xdc1f3b17, 0xdd1ecc1a, 0xdd1e8d1b, 0xdd1e4e1d, 0xde1e0f1f, 0xde1daffb,
	0xba35d094, 0xb7366148, 0xb336f235, 0xa139f338, 0x8f3d0432, 0xa03a551a, 0xb037a60d, 0xbb35c707, 0xc633e806, 0xce327908, 0xd630fa0e, 0xd9306b10, 0xdc2fcc15, 0xdc2fad16, 0xdd2f6e19, 0xdd2f2f1a, 0xde2edff8,
	0xab474101, 0xa9477188, 0xa747b25e, 0x934aa35e, 0x7e4da453, 0x904b152c, 0xa3489614, 0xb046c708, 0xbd44f802, 0xc8435902, 0xd341aa08, 0xd7410b0b, 0xdb406c10, 0xdc403d13, 0xdd3ffe14, 0xde3fcf16, 0xdf3f7ff5,
	0xa257e184, 0x9f5861ef, 0x9b58d2ae, 0x905a438e, 0x845bb473, 0x8d5ab547, 0x9659b626, 0xa158670f, 0xac571800, 0xba5548f9, 0xc75379fb, 0xcd52cafb, 0xd3520bfe, 0xd6518d01, 0xda511e05, 0xdc50af0a, 0xdf503fed,
	0xa0681223, 0x9b68b27c, 0x9669531d, 0x9369c3d2, 0x906a249c, 0x906a356d, 0x916a3647, 0x9a694723, 0xa3685807, 0xb26678f7, 0xc16499f3, 0xc863daef, 0xcf630bef, 0xd3626cf2, 0xd961bdf7, 0xdc613efd, 0xe060afe6,
	0xc174d1b8, 0xbd754215, 0xb975c2eb, 0xb276a3cd, 0xab7784ae, 0xa977d585, 0xa6784661, 0xab77e739, 0xaf777818, 0xb87668ff, 0xc17569ef, 0xc4750ae2, 0xc874bbd7, 0xd073acd9, 0xd8727de4, 0xdf71beee, 0xe470efe1,
	0xdb82712b, 0xd982c171, 0xd6831291, 0xce8443b6, 0xc68574ba, 0xc386059c, 0xbe86967e, 0xc0868754, 0xc2868830, 0xc586190f, 0xc985b9f4, 0xcb85badd, 0xcd859bc6, 0xd5844cc7, 0xde82edd4, 0xe481fee1, 0xe980ffdc,
	0xee9100a4, 0xed9120c1, 0xed914209, 0xe991f354, 0xe6929471, 0xe293657e, 0xde94367a, 0xdd94a763, 0xdb952848, 0xde94d923, 0xe0948a05, 0xe2945aec, 0xe5941bd7, 0xe9931cd6, 0xee920de0, 0xf1915eea, 0xf390afe4,
	0xf8a02000, 0xf8a02000, 0xf8a02145, 0xf8a072c3, 0xf8a0c3fd, 0xf8a18544, 0xf7a25668, 0xf8a3176f, 0xf9a3e865, 0xfaa3a939, 0xfba37a17, 0xfba31afb, 0xfca2dbe7, 0xfca21ce2, 0xfca14dea, 0xfda0def3, 0xfca05fec,
	0xffb02000, 0xffb02000, 0xffb02109, 0x00b04296, 0x01b063d3, 0x05b0b517, 0x09b1163d, 0x0db17753, 0x12b1e858, 0x15b22945, 0x18b27a2d, 0x17b24b0c, 0x16b21bf3, 0x12b19ce8, 0x0db0fdeb, 0x09b0aef1, 0x07b04fea,
	0x06c03000, 0x06c03000, 0x06c030b7, 0x06c0325e, 0x07c0339b, 0x0ac044d5, 0x0ec055f8, 0x17c08721, 0x1ec0b837, 0x2cc1094a, 0x3bc16a47, 0x39c15b21, 0x37c15c02, 0x2bc0fcef, 0x1fc0aded, 0x1ac06ef0, 0x13c03fea,
	0x0ed03000, 0x0ed03000, 0x0ed03047, 0x0ed03232, 0x0fd0337e, 0x11d034b4, 0x14d025d7, 0x1cd026fc, 0x23d02811, 0x31d0392a, 0x3fd04a32, 0x49d04b26, 0x52d05c13, 0x43d04cfb, 0x33d03df3, 0x29d02ef2, 0x1fd00fee,
	0x17e03000, 0x17e03000, 0x17e03000, 0x17e031ff, 0x17e0335c, 0x17e0348c, 0x17e035ab, 0x1ae036c5, 0x1ce017d9, 0x24e008f2, 0x2ddffa01, 0x4ddfbb1e, 0x6ddf7c21, 0x5bdfad06, 0x48dfbdf8, 0x3adfdef5, 0x2cdffff1,
	0x21f04000, 0x21f04000, 0x21f04000, 0x21f041c3, 0x21f0433b, 0x21f04474, 0x22f03599, 0x23f036b4, 0x25f027c8, 0x2af018df, 0x30eff9ef, 0x48efab09, 0x5fef5c13, 0x56ef7d06, 0x4def9dfc, 0x40efbefa, 0x33efdff8,
	0x2cfff000, 0x2cfff000, 0x2cfff000, 0x2cfff17a, 0x2cfff315, 0x2cfff45a, 0x2cfff584, 0x2cfff6a1, 0x2cfff7b5, 0x2efff8c7, 0x2fffe9d5, 0x35ffdae5, 0x3bffbbf0, 0x44ff9cf8, 0x4cff7dfb, 0x41ffaefa, 0x37ffdffd,
	0xcc04a026, 0xc606c116, 0xc008d216, 0xad0fd31e, 0x9916d41d, 0xa711e512, 0xb50cf60c, 0xc208970b, 0xce04380f, 0xd202f911, 0xd601aa15, 0xd7011b17, 0xd8009c1a, 0xd900cd1c, 0xd900fe1d, 0xd9010f20, 0xd9010ffb,
	0xcc13002a, 0xc6147114, 0xc115d216, 0xaa1be320, 0x9421f420, 0xa31de513, 0xb219c60c, 0xbf16170a, 0xcb12580d, 0xd010b910, 0xd50f0a14, 0xd60e3b17, 0xd90d4c19, 0xd80ced1c, 0xd80c6e1d, 0xd90baf1f, 0xd90aeffa,
	0xcb22a031, 0xc6239112, 0xc2248215, 0xa8299324, 0x8e2ec425, 0x9e2b9515, 0xae28660d, 0xbb25970a, 0xc922c80c, 0xcf21690e, 0xd5200a13, 0xd61f8b15, 0xd81efc19, 0xd91ecd1a, 0xd91e8e1c, 0xd91e3f1d, 0xd91ddffa,
	0xbc34a06e, 0xb835312f, 0xb535b227, 0x9a3a0336, 0x7f3e6435, 0x8e3c251e, 0x9c39d610, 0xac375708, 0xbc34c806, 0xc6330908, 0xd0315a0c, 0xd230cb0f, 0xd5302c13, 0xd72fed15, 0xd72f9e17, 0xd82f5f19, 0xd92f1ff7,
	0xb045c0ba, 0xae460156, 0xab465242, 0x904a0352, 0x744dc450, 0x814c252f, 0x8d4a8618, 0x9f48270a, 0xb145c803, 0xbe43e903, 0xcc420a08, 0xd0416b0a, 0xd440cc0f, 0xd5408d10, 0xd6404e12, 0xd83fff14, 0xd93fbff4,
	0x9c57814c, 0x975811c5, 0x9258b297, 0x815ab387, 0x705cc474, 0x755c254b, 0x7c5b862c, 0x8e597713, 0x9f577803, 0xb05598fc, 0xbf53b9fd, 0xc4530afd, 0xca525bff, 0xce51dd01, 0xd2514e05, 0xd550cf09, 0xd8504fee,
	0x8f6891fd, 0x8869525e, 0x806a130f, 0x796ae3d3, 0x716bc4a5, 0x726bd574, 0x726be64d, 0x836a2725, 0x9468680b, 0xa56688fb, 0xb764b9f7, 0xbd641af3, 0xc3635bf1, 0xc962acf3, 0xcf61fdf9, 0xd5615eff, 0xd960bfe8,
	0xa67621e9, 0xa276a241, 0x9c77330a, 0x917853e9, 0x867974c6, 0x87798591, 0x86799666, 0x8d79073c, 0x9478681b, 0xa376e902, 0xb27569f4, 0xb5751ae9, 0xb974cbdf, 0xc373bce0, 0xcd72bde8, 0xd471def2, 0xdb70ffe4,
	0xbe8441c8, 0xba84a209, 0xb68502f4, 0xaa8643f9, 0x9e8774e8, 0x9d8795af, 0x9d87b682, 0x9c87d75b, 0x9b881837, 0xa886e912, 0xb485b9fa, 0xb685aae6, 0xb7859bd3, 0xc3845cd2, 0xce831ddb, 0xd8821ee7, 0xe0810fe0,
	0xdd91c0fa, 0xdc91e116, 0xda920242, 0xd392d380, 0xcb93a493, 0xc5946591, 0xbe953685, 0xb995d76e, 0xb4968851, 0xbd959925, 0xc694ba07, 0xc8948af1, 0xcb945bdf, 0xd4935cdb, 0xdc925de1, 0xe2918eec, 0xe990bfe6,
	0xf2a02000, 0xf2a02000, 0xf2a02143, 0xeea082cc, 0xeba1040d, 0xe3a22558, 0xdba3467e, 0xd5a4277e, 0xd0a5086f, 0xd5a4793b, 0xdaa3ca17, 0xdda38aff, 0xe0a33beb, 0xe5a28ce4, 0xeaa1bde8, 0xeea12ef1, 0xf2a07feb,
	0xf8b02000, 0xf8b02000, 0xf8b02107, 0xf7b05299, 0xf7b073d8, 0xf5b10523, 0xf4b1864d, 0xf2b22765, 0xf1b2d86a, 0xf2b3094f, 0xf2b33a32, 0xf3b30b0f, 0xf5b2cbf4, 0xf7b23ce6, 0xf8b18de5, 0xf9b10eeb, 0xfbb07fe7,
	0xffc03000, 0xffc03000, 0xffc030b4, 0xffc03257, 0xffc02392, 0x00c054d7, 0x02c07601, 0x05c0e737, 0x09c14852, 0x0ec1d960, 0x13c25a56, 0x13c23b29, 0x12c22c05, 0x0fc1acec, 0x0bc12de6, 0x09c0cee8, 0x06c06fe5,
	0x06d03000, 0x06d03000, 0x06d03044, 0x06d0322e, 0x06d02378, 0x08d024b5, 0x0ad035db, 0x0fd04708, 0x15d06823, 0x1cd0893b, 0x25d0aa3f, 0x2cd0db32, 0x33d0fc1b, 0x2ad0ccfb, 0x21d09ded, 0x1bd06eeb, 0x14d02fe7,
	0x0ee03000, 0x0ee03000, 0x0ee03000, 0x0ee031fd, 0x0ee0335b, 0x0ee0348b, 0x0ee035a9, 0x10e026c6, 0x12e027db, 0x19e018f9, 0x20e01a0a, 0x3bdffb2f, 0x57dfdc31, 0x49dfed0b, 0x39dffdf5, 0x2edffeee, 0x23dfffea,
	0x17f04000, 0x17f04000, 0x17f04000, 0x17f041c2, 0x17f0433a, 0x17f03474, 0x17f03597, 0x18f036b5, 0x19f027ca, 0x20f018e3, 0x25eff9f4, 0x3aefab15, 0x4fef5c20, 0x48ef7d0c, 0x41ef9dfe, 0x35efbef7, 0x29efdff5,
	0x20fff000, 0x20fff000, 0x20fff000, 0x20fff178, 0x21fff314, 0x21fff45a, 0x21fff584, 0x21fff6a0, 0x21fff7b5, 0x22fff8c7, 0x23ffe9d6, 0x29ffdae6, 0x2effbbf2, 0x36ff9cfa, 0x3eff7dfc, 0x35ffaefa, 0x2bffdffc,
	0xca03f020, 0xc505a10f, 0xc0076213, 0xab0e731d, 0x9515941e, 0xa0121513, 0xab0e960d, 0xb909e70c, 0xc805280d, 0xcd038910, 0xd201da15, 0xd3016b17, 0xd400ec1a, 0xd4010d1c, 0xd5013e1d, 0xd5013f1f, 0xd5013ffa,
	0xc9125024, 0xc413810d, 0xc014a212, 0xa91a931d, 0x92209420, 0x9d1db514, 0xa81ad60d, 0xb716d70a, 0xc512b80d, 0xcb10e910, 0xd10f0a13, 0xd20e3b16, 0xd40d6c19, 0xd40ced1a, 0xd40c5e1c, 0xd40b9f1e, 0xd50acffa,
	0xc9224029, 0xc5230109, 0xc123c20f, 0xa828a320, 0x8f2d9424, 0x992b6516, 0xa529360e, 0xb426270a, 0xc322e80c, 0xca21890e, 0xd1200a12, 0xd31f8b15, 0xd41f0c18, 0xd41ecd1a, 0xd51e8e1b, 0xd51e3f1d, 0xd51dcffa,
	0xbe33b053, 0xbb34311a, 0xb834a21c, 0xa038532b, 0x883c042d, 0x8f3ae51d, 0x9739c611, 0xa737270a, 0xb8348809, 0xc232e90a, 0xcc313a0e, 0xcf30bb10, 0xd1302c14, 0xd32ffd15, 0xd32fbe17, 0xd42f5f19, 0xd52f0ff7,
	0xb5447086, 0xb344c130, 0xb045122b, 0x9a47e33b, 0x834ac43c, 0x884a5528, 0x8b49d619, 0x9d47970c, 0xae455807, 0xbb43a906, 0xc841ea0a, 0xcb415b0c, 0xd040cc0f, 0xd1408d11, 0xd2404e13, 0xd33fff15, 0xd63faff5,
	0xa555d0ea, 0x9d56b17e, 0x95579271, 0x8359836b, 0x725b745f, 0x775af540, 0x7b5a8628, 0x8d58a713, 0x9e56c806, 0xad550901, 0xbd534a03, 0xc152bb02, 0xc5523c03, 0xca51bd05, 0xcd512e08, 0xd150bf0d, 0xd5503ff1,
	0x9966a160, 0x8d67d1e9, 0x806902d2, 0x736a53b1, 0x666b9493, 0x6b6b2564, 0x706ab642, 0x81693722, 0x9167a80d, 0xa265e901, 0xb46419fd, 0xb9639afa, 0xbe631bf9, 0xc4627cfb, 0xca61ddff, 0xd0612f05, 0xd5608fed,
	0xa7751167, 0x9e75d1d2, 0x9676a2cc, 0x827863cc, 0x6f7a14bd, 0x7379c586, 0x7879865c, 0x7f78e737, 0x8678481b, 0x9976a906, 0xab74f9fb, 0xb0749af2, 0xb5742bec, 0xbe734cee, 0xc7725df4, 0xd0719efc, 0xd770bfea,
	0xb683e168, 0xb18451a9, 0xac84c2b9, 0x9486b3e8, 0x7d88b4f0, 0x7f8895b0, 0x8288667e, 0x83887757, 0x83887835, 0x9686e913, 0xa88559ff, 0xac851af0, 0xb084cbe4, 0xbc83bce3, 0xc882adeb, 0xd181bef4, 0xda80dfe8,
	0xd491b0d3, 0xd09200fb, 0xcd924238, 0xbc93a397, 0xab9514bd, 0xa395c5ab, 0x9b967693, 0x9896c771, 0x9697084f, 0xa1962925, 0xae953a09, 0xb6948af7, 0xbe93ebeb, 0xc892fce9, 0xd3920def, 0xda915ef7, 0xe1909fec,
	0xeba0401f, 0xe9a06039, 0xe7a08180, 0xdca1831e, 0xd1a27467, 0xc3a3a596, 0xb5a4d6a8, 0xb1a5478c, 0xaca5c86d, 0xb3a5393f, 0xbaa4ba1b, 0xc4a3eb01, 0xcda31bf3, 0xd5a25cee, 0xdda18df2, 0xe4a0fef9, 0xe9a05ff0,
	0xf1b03011, 0xf1b0401f, 0xf0b05129, 0xecb0b2cb, 0xe8b10412, 0xe1b1b554, 0xd9b27676, 0xd3b3177c, 0xceb3b875, 0xccb3e955, 0xcbb41a35, 0xd1b3bb11, 0xd6b33bf7, 0xdeb26ceb, 0xe6b18ded, 0xebb10ef3, 0xefb07fec,
	0xf8c03000, 0xf8c03000, 0xf8c020b1, 0xf8c0225c, 0xf8c0339c, 0xf5c094f3, 0xf2c0e627, 0xeec1875b, 0xebc22873, 0xe8c2a96d, 0xe6c32a59, 0xe8c2fb2c, 0xeac2dc08, 0xefc21cef, 0xf3c15dec, 0xf6c0eeee, 0xf8c07fe9,
	0xffd03000, 0xffd03000, 0xffd02040, 0xffd02231, 0xffd0237e, 0xffd044c5, 0x00d055f1, 0x01d08722, 0x02d0c83d, 0x03d1094c, 0x05d13a4b, 0x07d17b39, 0x09d1ac1d, 0x08d15cfc, 0x07d10dec, 0x05d0cee7, 0x05d07fe2,
	0x06e03000, 0x06e03000, 0x06e03000, 0x06e031fc, 0x06e0335a, 0x06e0348b, 0x06e035a9, 0x08e026d0, 0x0ae027eb, 0x0fe03912, 0x15e03a27, 0x20e05b3c, 0x2be06c37, 0x27e06d0e, 0x22e06df3, 0x1de04ee6, 0x17e03fdf,
	0x0ef04000, 0x0ef04000, 0x0ef04000, 0x0ef031c0, 0x0ef03339, 0x0ef03473, 0x0ef03597, 0x10f036ba, 0x11f027d3, 0x16f008f2, 0x1ceffa06, 0x27efcb1e, 0x32efac23, 0x30efad0f, 0x2fefbe00, 0x29efcef5, 0x21efdfee,
	0x17fff000, 0x17fff000, 0x17fff000, 0x17fff176, 0x17fff313, 0x17fff459, 0x17fff583, 0x17fff6a0, 0x17fff7b5, 0x18fff8c7, 0x18fff9d5, 0x1cffdae6, 0x20ffcbf1, 0x28ffacfc, 0x2fff8dfe, 0x2bff9efa, 0x26ffbff9,
	0xc9032019, 0xc5045107, 0xc105920d, 0xaa0cb31b, 0x9413e41e, 0x9a120515, 0xa010360f, 0xb00b370d, 0xc006380d, 0xc7042910, 0xce021a14, 0xcf01ab17, 0xd0014c19, 0xd0015d1b, 0xd1017e1c, 0xd1016f1e, 0xd1016ffa,
	0xc811901c, 0xc5126104, 0xc113220c, 0xaa18e31b, 0x931e941e, 0x981d4516, 0x9d1bf60f, 0xae17870c, 0xc013180d, 0xc611190f, 0xcd0efa13, 0xce0e3b16, 0xd10d6c19, 0xd00ced1a, 0xd00c5e1c, 0xd00b9f1d, 0xd10abffa,
	0xc821a020, 0xc52230ff, 0xc222c209, 0xab27331b, 0x932ba420, 0x972ae517, 0x9b2a2610, 0xad26970c, 0xbf23180d, 0xc721890f, 0xce200a12, 0xcf1f9b15, 0xd01f1c18, 0xd01eed19, 0xd01e9e1a, 0xd11e3f1d, 0xd11ddff9,
	0xc3325034, 0xc032c101, 0xbd33320d, 0xab35f31d, 0x9938b421, 0x9739051a, 0x94396613, 0xa536c70b, 0xb634280a, 0xbf32a90b, 0xc8311a0f, 0xcb30ab11, 0xcd303c14, 0xce2ffd15, 0xce2fbe17, 0xd02f5f1a, 0xd12efff8,
	0xbf42a04d, 0xbc430103, 0xb9435212, 0xac44f31e, 0x9f469422, 0x9747a51d, 0x8e48a617, 0x9e46a70d, 0xaf44a809, 0xba432909, 0xc641ba0c, 0xc8413b0e, 0xcb40cc10, 0xcc409d12, 0xcd404e14, 0xd03fff16, 0xd13f9ff7,
	0xb6537080, 0xab54a12f, 0x9f55e246, 0x8f57934c, 0x7e595447, 0x81592533, 0x8358f622, 0x92576713, 0xa055c809, 0xaf543906, 0xbe52aa07, 0xc0524b07, 0xc351ec08, 0xc6518d0a, 0xca510e0c, 0xcd508f10, 0xd1500ff4,
	0xaf63e0bc, 0x9c65b16b, 0x8867728f, 0x7669338b, 0x636af47e, 0x6f69f552, 0x7a68f634, 0x8767a71c, 0x9566680e, 0xa664d905, 0xb7633a03, 0xba62eb02, 0xbd62ac00, 0xc2620d02, 0xc7618e05, 0xcc60ff0b, 0xd2604ff2,
	0xb27390df, 0xa574a15c, 0x9975b289, 0x7b7823ae, 0x5e7a94b3, 0x6679e57a, 0x70792651, 0x78788732, 0x8077e81b, 0x96760908, 0xac742a01, 0xb173bafb, 0xb7734bf8, 0xbf728cfa, 0xc671ddff, 0xcd711f06, 0xd4707ff0,
	0xb7833105, 0xb083b145, 0xa984327a, 0x838723d8, 0x5d8a04f8, 0x648975b0, 0x6c89067a, 0x6e88d754, 0x7288a834, 0x8b86b913, 0xa584aa02, 0xab842af9, 0xb3839bf3, 0xbd82ccf4, 0xc781edf9, 0xd0813f00, 0xd7808fef,
	0xcd91a0ab, 0xc79210e0, 0xc192722d, 0xa394a3b1, 0x8596d4e8, 0x7d9765c5, 0x7697f6a3, 0x7a97c773, 0x7d97884c, 0x8c968926, 0x9a958a0b, 0xaa945afb, 0xbb932bf6, 0xc5926cf6, 0xcf919dfb, 0xd690ff02, 0xdd906ff2,
	0xe2a0803f, 0xdda0d074, 0xd8a131c0, 0xc0a2c373, 0xa9a454c5, 0x97a595d7, 0x85a6d6d4, 0x89a6979a, 0x8da6686a, 0x93a61941, 0x97a5ca1f, 0xafa43b03, 0xc4a2abf9, 0xcea1fcf8, 0xd7a13dfd, 0xdda0bf02, 0xe4a03ff4,
	0xeab05022, 0xe8b0703e, 0xe5b0914d, 0xdcb132ff, 0xd2b1d44d, 0xc4b2c586, 0xb7b3b6a1, 0xb0b43795, 0xa8b4c880, 0xa7b4e95c, 0xa7b50a39, 0xb1b45b13, 0xbdb39bfa, 0xccb28cf0, 0xdab17df5, 0xe0b0fefa, 0xe7b06ff0,
	0xf2c02000, 0xf2c02000, 0xf2c020ad, 0xf1c03263, 0xf0c043a7, 0xe6c0e511, 0xddc1964e, 0xd0c26781, 0xc3c35895, 0xc0c3a97b, 0xbcc3fa5b, 0xc0c3db2f, 0xc3c3ac0b, 0xd3c29cf2, 0xe1c16df1, 0xe8c0fef3, 0xedc07fed,
	0xf8d02000, 0xf8d02000, 0xf8d0203c, 0xf8d02234, 0xf7d03384, 0xf5d064d6, 0xf2d09608, 0xedd0f73c, 0xe9d15858, 0xe5d1a95f, 0xe2d1fa58, 0xe0d23b40, 0xdfd27c21, 0xe4d20cff, 0xead18deb, 0xefd13ee4, 0xf3d0cfdd,
	0xfee03000, 0xfee03000, 0xfee03000, 0xffe031fa, 0xffe03359, 0xffe0348a, 0xffe025a8, 0xffe036d9, 0xfee047fa, 0xfee0792c, 0xfde0aa45, 0xfee0eb4b, 0xfee13c3c, 0xffe11d13, 0x00e11df3, 0x01e0eedf, 0x01e09fd5,
	0x06f03000, 0x06f03000, 0x06f03000, 0x06f031be, 0x06f03338, 0x06f03472, 0x06f03596, 0x07f036bf, 0x08f027dc, 0x0af01902, 0x0df00a18, 0x11f00b27, 0x15effc27, 0x16effd14, 0x17effe01, 0x15f00ef3, 0x12efffe8,
	0x0dfff000, 0x0dfff000, 0x0efff000, 0x0efff174, 0x0efff312, 0x0efff459, 0x0efff583, 0x0efff69f, 0x0efff7b4, 0x0efff8c5, 0x0efff9d4, 0x11ffeae5, 0x14ffdbf1, 0x19ffbcfd, 0x1eff9e00, 0x1effaefb, 0x1cffbff6,
	0xc7029015, 0xc5036100, 0xc2043208, 0xb0099315, 0x9e0ef419, 0xa00e6514, 0xa20de610, 0xaf09c70d, 0xbd05b80f, 0xc403c910, 0xcb01ca14, 0xcd016b18, 0xce00fc1a, 0xcd012d1b, 0xcd016e1d, 0xce016f1e, 0xce017ffa,
	0xc710d017, 0xc41160fc, 0xc211f206, 0xb0164314, 0x9d1a7419, 0x9f1a2514, 0xa019c610, 0xae16370c, 0xbd12780f, 0xc4108910, 0xcb0e7a14, 0xcc0dbb16, 0xce0cdc1a, 0xce0c7d1b, 0xcd0c0e1c, 0xcd0b5f1e, 0xcd0a7ffa,
	0xc7213019, 0xc52180f7, 0xc321e203, 0xb1254314, 0x9f289419, 0x9f288515, 0x9f286610, 0xae25870c, 0xbd22b80d, 0xc321390f, 0xca1fba13, 0xcd1f3b16, 0xce1ebc18, 0xce1e9d19, 0xcd1e7e1b, 0xcd1e1f1e, 0xce1dcffa,
	0xc431a026, 0xc231f0f3, 0xc0324203, 0xb2344312, 0xa4366418, 0xa036f515, 0x9c379611, 0xaa35770d, 0xb833480c, 0xc031f90d, 0xc8309a11, 0xc9304b12, 0xcb2fec15, 0xcc2fbd17, 0xcc2f9e18, 0xcc2f4f1b, 0xce2eeff9,
	0xc141e035, 0xbf4210ec, 0xbe425202, 0xb3439311, 0xa944c416, 0xa145c517, 0x9946c614, 0xa645270d, 0xb343880b, 0xbc42490b, 0xc6410a0e, 0xc840cb10, 0xc9408c12, 0xca406d14, 0xcb401e16, 0xcc3fdf18, 0xcd3f7ff8,
	0xbc525052, 0xb25350ff, 0xa9545223, 0x9d55832d, 0x9256b42d, 0x8f56f525, 0x8d57461c, 0x9955f711, 0xa554a80b, 0xb2535908, 0xbe520a0a, 0xc051db0b, 0xc1518c0b, 0xc4513d0e, 0xc850ce0f, 0xcb506f14, 0xce4fdff6,
	0xb8629073, 0xa8641118, 0x9765a251, 0x8a66c354, 0x7f67e44f, 0x8167a539, 0x84676628, 0x90665718, 0x9b65580d, 0xa9640907, 0xb762aa07, 0xb9626b06, 0xbb623c05, 0xc061bd07, 0xc5614e0a, 0xca60af10, 0xcf602ff5,
	0xb972808f, 0xac738108, 0x9f74924f, 0x8276e37d, 0x6679348a, 0x6978f564, 0x6c78b647, 0x7678072d, 0x7f774819, 0x9375990a, 0xa873ea04, 0xae736b00, 0xb572dbff, 0xbc722d01, 0xc4718e05, 0xca70ef0b, 0xd2703ff4,
	0xba8260ae, 0xb08310f2, 0xa783c24b, 0x7d86e3b2, 0x5289f4da, 0x5689a5a0, 0x5b896673, 0x6288e74e, 0x6988682f, 0x83868913, 0x9c84aa05, 0xa683fafd, 0xb0832bfa, 0xba827cfc, 0xc481ae00, 0xcc810f07, 0xd3805ff4,
	0xcb916081, 0xc291f0bf, 0xb892921c, 0x939503a7, 0x6e9774e2, 0x649835c3, 0x5a98e6a3, 0x61987771, 0x6898084a, 0x79970926, 0x8895fa0d, 0x9c949afe, 0xb0933bfa, 0xbd925cfa, 0xc9917dff, 0xd090ef06, 0xd9903ff5,
	0xd9a0a04b, 0xd1a1208e, 0xc9a1a1dc, 0xa9a39391, 0x89a574e3, 0x74a6d5ea, 0x5ea826df, 0x66a7c7a0, 0x6ca7686e, 0x74a70943, 0x7ca68a21, 0x98a4db05, 0xb4a31bfb, 0xc1a22cf9, 0xcea15dfe, 0xd6a0cf05, 0xdfa02ff7,
	0xe3b0502b, 0xdfb0804f, 0xdbb0b15f, 0xcbb1a31d, 0xbab29472, 0xa6b3c5a7, 0x92b4e6be, 0x89b577a6, 0x81b5f88b, 0x84b5d960, 0x87b5ba39, 0x96b4eb15, 0xa4b42bfd, 0xbab2dcf3, 0xcfb19df7, 0xd8b0fefc, 0xe0b06ff3,
	0xecc02005, 0xecc02006, 0xebc020b0, 0xe6c07283, 0xe1c0b3d5, 0xcfc1a544, 0xbdc28684, 0xabc387a4, 0x98c488ac, 0x98c49981, 0x98c4ba59, 0x9cc49b30, 0xa0c46c0d, 0xb9c30cf5, 0xd2c19df4, 0xdbc10ef7, 0xe4c07ff0,
	0xf1d03011, 0xf1d03010, 0xf1d03047, 0xf0d0424a, 0xeed0539e, 0xe7d0a4f5, 0xe0d0f62a, 0xd5d17758, 0xcbd1f870, 0xc4d2596d, 0xbdd2ca60, 0xbbd2fb42, 0xb8d32c23, 0xc3d2ad01, 0xced21dec, 0xd8d19ee6, 0xe2d10fe0,
	0xf7e0401f, 0xf7e0401c, 0xf7e03019, 0xf8e03204, 0xf8e0235b, 0xf8e0248e, 0xf7e025af, 0xf3e056ec, 0xefe08813, 0xe6e0e945, 0xdee14a5d, 0xd9e19b53, 0xd4e1ec3c, 0xd5e1dd16, 0xd8e1cdf4, 0xe1e17ee0, 0xe9e10fd6,
	0xfef03015, 0xfef03013, 0xfef03012, 0xfef031c4, 0xfff03339, 0xfff03475, 0xfff0359a, 0xfef026c9, 0xfdf037ea, 0xfcf03910, 0xfaf04a26, 0xf9f04b2a, 0xf9f05c26, 0xf9f05d16, 0xf9f06e04, 0xfbf05ef2, 0xfcf04fe4,
	0x06fff00b, 0x06fff00a, 0x06fff009, 0x06fff175, 0x06fff311, 0x06fff458, 0x06fff582, 0x06fff69f, 0x06fff7b4, 0x06fff8c5, 0x06fff9d2, 0x06fffae3, 0x07ffebef, 0x0affdcff, 0x0cffbe02, 0x0dffbefb, 0x0effbfef,
	0xc501e00f, 0xc40240f6, 0xc302a202, 0xb705f30d, 0xab094412, 0xa80a2511, 0xa50b1610, 0xb008170f, 0xba052810, 0xc2034911, 0xc8016a15, 0xca010b17, 0xcb009c1b, 0xca00fd1c, 0xc9015e1d, 0xc8016f1f, 0xc9017ffa,
	0xc5100010, 0xc41040f3, 0xc31081ff, 0xb713030b, 0xac158411, 0xa9164510, 0xa5170610, 0xb014670e, 0xbb11b80f, 0xc10fd911, 0xc80dea14, 0xc90d1b17, 0xcb0c3c1b, 0xca0c0d1c, 0xc80bae1c, 0xc90b0f1e, 0xc90a4ffa,
	0xc6209012, 0xc520b0ec, 0xc420d1fc, 0xb922c309, 0xae24a40f, 0xaa256510, 0xa6262610, 0xb024270d, 0xba22280e, 0xc120c910, 0xc71f5a13, 0xc91edb16, 0xcb1e4c1a, 0xca1e4d1a, 0xc91e4e1c, 0xc91def1d, 0xc91daffa,
	0xc430c016, 0xc330e0e2, 0xc23111f8, 0xba323306, 0xb233540d, 0xac34450f, 0xa635260f, 0xb033a70d, 0xba32280d, 0xc131190f, 0xc72ffa13, 0xc82fcb14, 0xc82f8c17, 0xc92f7d19, 0xc82f5e19, 0xc92f1f1c, 0xc92edff9,
	0xc440e01b, 0xc440e0d2, 0xc34101f1, 0xbe41b301, 0xb8427409, 0xb043550e, 0xa944360f, 0xb243270c, 0xba42080c, 0xc141290e, 0xc8403a11, 0xc7403b12, 0xc6404c14, 0xc6401d15, 0xc83ffe17, 0xc93faf1a, 0xca3f6ff9,
	0xc650d020, 0xbe5190c9, 0xb75241fc, 0xb352c30a, 0xae53440f, 0xa6541513, 0x9e54f613, 0xa654070e, 0xaf53080b, 0xb752290b, 0xc0513a0d, 0xc1512b0e, 0xc1511c0e, 0xc350cd10, 0xc5508e13, 0xc8501f17, 0xcb4faff9,
	0xc760d026, 0xba6200be, 0xad63220c, 0xaa637317, 0xa663b419, 0x9e64851b, 0x9565461b, 0x9d648712, 0xa663b80c, 0xb062d909, 0xb961ea0a, 0xba61cb0a, 0xbc619c0a, 0xc0613d0c, 0xc360de0e, 0xc8606f13, 0xcd5fdff8,
	0xc571203b, 0xb87220ad, 0xab732212, 0x91752347, 0x7777345c, 0x7277954b, 0x6e77f63c, 0x79771726, 0x84764816, 0x9574e90b, 0xa6737a06, 0xae72eb04, 0xb6724c05, 0xbc71bd07, 0xc2711e0a, 0xc9708f11, 0xcf6ffff8,
	0xc4814053, 0xb782309a, 0xaa831218, 0x7c86438a, 0x4e8984b9, 0x4e89958f, 0x4e89966c, 0x5b88b746, 0x6787e82a, 0x7f863913, 0x96849a07, 0xa3839b01, 0xb1829c01, 0xba81ed03, 0xc3813e07, 0xca80bf0d, 0xd2800ff8,
	0xca910056, 0xbd91d09e, 0xb092a20c, 0x8595539c, 0x599824db, 0x4c98f5c0, 0x3f99d6a3, 0x4b99276f, 0x56986847, 0x68975926, 0x78965a0e, 0x9194bb00, 0xa9933bfd, 0xb6924cfe, 0xc4915e03, 0xcc90bf0a, 0xd5900ff9,
	0xcfa0e058, 0xc3a190a9, 0xb7a241f9, 0x8ea493b0, 0x65a6d502, 0x4fa825fe, 0x37a996ec, 0x41a907a7, 0x4ca87871, 0x57a7d946, 0x62a74a24, 0x83a56b07, 0xa3a36bfc, 0xb4a26cfa, 0xc7a14e00, 0xd0a0af07, 0xd9a00ffa,
	0xdab07034, 0xd5b0b060, 0xcfb10170, 0xb7b2433d, 0x9eb38497, 0x83b4f5c9, 0x68b656dc, 0x60b6c7ba, 0x58b74897, 0x62b6c964, 0x6bb66a3a, 0x7bb59b17, 0x8bb4bbff, 0xa7b32cf5, 0xc4b19dfa, 0xcfb0feff, 0xdab05ff6,
	0xe5c03009, 0xe5c0300c, 0xe4c030b2, 0xd9c0b2a2, 0xcdc13404, 0xb1c28579, 0x94c3e6ba, 0x7dc4f7c9, 0x68c5f8c4, 0x70c5b987, 0x78c55a57, 0x7bc53b31, 0x7fc52c10, 0xa2c37cf7, 0xc5c1adf7, 0xd0c11efa, 0xddc07ff3,
	0xe8d04022, 0xe8d04021, 0xe8d04052, 0xe4d06260, 0xe0d093bb, 0xd4d11516, 0xc8d1964c, 0xb8d23776, 0xa7d2d889, 0x9fd3497c, 0x97d3aa68, 0x95d3cb46, 0x94d3dc24, 0xa3d34d03, 0xb1d2bdee, 0xc1d1fee7, 0xd2d13fe1,
	0xede0403e, 0xeee04038, 0xeee03033, 0xefe0320c, 0xf0e0235d, 0xf0e03493, 0xefe035b4, 0xe4e096fe, 0xd9e0e82c, 0xc7e19961, 0xb4e23a77, 0xb1e25b5b, 0xaee28c3c, 0xade29d18, 0xade2bdf5, 0xbee20ee0, 0xd0e16fd7,
	0xf5f0302b, 0xf5f03027, 0xf6f03023, 0xf6f031ca, 0xf7f03339, 0xf7f03477, 0xf6f0259d, 0xf3f036d4, 0xeff057f8, 0xe8f07920, 0xe2f09a35, 0xe1f0ab2e, 0xe0f0ac23, 0xdcf0cd18, 0xd9f0ee06, 0xddf0def2, 0xe0f0bfdf,
	0xfdfff016, 0xfdfff014, 0xfdfff012, 0xfdfff176, 0xfdfff310, 0xfdfff457, 0xfdfff581, 0xfdfff69f, 0xfefff7b3, 0xfefff8c4, 0xfefff9d1, 0xfdfffae1, 0xfdfffbec, 0xf9fffd00, 0xf7fffe05, 0xf5fffefc, 0xf4ffffea,
};

u32 g_gmp_lut_table_high4bit_init[4913] = {
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x2,
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x2, 0x2, 0x2,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x5, 0x5, 0x5, 0x5, 0x5, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x6, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
	0x7, 0x7, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x7, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
	0x8, 0x8, 0x8, 0x8, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
	0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0x9,
	0x9, 0x9, 0x9, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
	0xa, 0xa, 0xa, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
	0xb, 0xb, 0xb, 0xb, 0xb, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
	0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
	0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
	0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
};
#pragma GCC diagnostic pop

static inline long get_timestamp_in_us(void)
{
	struct timespec ts;
	ktime_get_ts(&ts);
	return ts.tv_sec * USEC_PER_SEC + ts.tv_nsec / NSEC_PER_USEC;
}

static void count_delay(delay_record_t *cord, long delay)
{
	cord->count++;
	cord->sum += delay;
	if (delay > cord->max)
		cord->max = delay;

	if (delay < cord->min)
		cord->min = delay;

	if (!(cord->count % COUNT_LIMIT_TO_PRINT_DELAY)) {
		DEBUG_EFFECT_LOG("[effect] Delay(us/%4d) | average:%5ld"
			" | min:%5ld | max:%8ld | %s\n",
			cord->count, cord->sum / cord->count,
			cord->min, cord->max, cord->name);
		cord->count = 0;
		cord->sum = 0;
		cord->max = 0;
		cord->min = 0xFFFFFFFF;
	}
}

static int hisi_effect_copy_to_user(uint32_t *table_dst,
	uint32_t *table_src, uint32_t table_length)
{
	unsigned long table_size;

	if (table_dst == NULL) {
		HISI_FB_ERR("[effect]table_dst is NULL!\n");
		return -EINVAL;
	}

	if (table_src == NULL) {
		HISI_FB_ERR("[effect]table_src is NULL!\n");
		return -EINVAL;
	}

	if (table_length == 0) {
		HISI_FB_ERR("[effect]table_length is 0!\n");
		return -EINVAL;
	}

	table_size = (unsigned long)table_length * BYTES_PER_TABLE_ELEMENT;

	if (copy_to_user(table_dst, table_src, table_size)) {
		HISI_FB_ERR("[effect]failed to copy table to user.\n");
		return -EINVAL;
	}

	return 0;
}

static int hisi_effect_alloc_and_copy(uint32_t **table_dst,
	uint32_t *table_src, uint32_t lut_table_length, bool copy_user)
{
	uint32_t *table_new = NULL;
	unsigned long table_size;

	if (table_dst == NULL) {
		HISI_FB_ERR("[effect]table_dst is NULL");
		return -EINVAL;
	}

	if (table_src == NULL) {
		HISI_FB_ERR("[effect]table_src is NULL");
		return -EINVAL;
	}

	if (lut_table_length == 0) {
		HISI_FB_ERR("[effect]lut_table_length is 0");
		return -EINVAL;
	}

	table_size = (unsigned long)lut_table_length * BYTES_PER_TABLE_ELEMENT;

	if (*table_dst == NULL) {
		table_new = kmalloc(table_size, GFP_ATOMIC);
		if (table_new != NULL) {
			memset(table_new, 0, table_size);
			*table_dst = table_new;
		} else {
			HISI_FB_ERR("[effect]failed to kmalloc lut_table!\n");
			return -EINVAL;
		}
	}

	if (copy_user) {
		if (copy_from_user(*table_dst, table_src, table_size)) {
			HISI_FB_ERR("[effect]failed to copy table from user\n");
			if (table_new != NULL)
				kfree(table_new);
			*table_dst = NULL;
			return -EINVAL;
		}
	} else {
		memcpy(*table_dst, table_src, table_size);
	}

	return 0;
}

static int hisifb_ce_do_contrast(struct hisi_fb_data_type *hisifd)
{
	ce_service_t *service = &g_hiace_service;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (g_is_ce_service_init) {
		service->new_hist = true;
		HISI_FB_DEBUG("[effect] service->new_hist is true\n");
		if (g_debug_effect & DEBUG_EFFECT_DELAY)
			g_interval_wait_hist.start = get_timestamp_in_us();
		wake_up_interruptible(&service->wq_hist);
	}

	return 0;
}

static void hisifb_ce_service_init(void)
{
	mutex_lock(&g_ce_service_lock);
	if (!g_is_ce_service_init) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] step in\n");

		g_hiace_service.is_ready = true;
		g_hiace_service.stop = false;
		g_hiace_service.hist_stop = false;

		g_is_ce_service_init = true;
	}
	mutex_unlock(&g_ce_service_lock);
}

static void hisifb_ce_service_deinit(void)
{
	mutex_lock(&g_ce_service_lock);
	if (g_is_ce_service_init) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] step in\n");

		g_is_ce_service_init = false;

		g_hiace_service.is_ready = false;
		g_hiace_service.stop = true;
		g_hiace_service.hist_stop = true;

		wake_up_interruptible(&g_hiace_service.wq_hist);
	}
	mutex_unlock(&g_ce_service_lock);
}

static int handle_err_hist(struct fb_info *info, int wait_ret)
{
	struct hisi_fb_data_type *hisifd = NULL;
	int ret = 0;

	if (info == NULL) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->panel_power_on) {
		if (wait_ret > 0)
			ret = 3; // panel on hist not return hist stop is true
		else if (wait_ret == -ERESTARTSYS)
			ret = 4; // system err and return -ERESTARTSYS
		else
			ret = 2; // hist not return time out
	} else {
		ret = 1; // panel off hist not return hist stop is true
	}

	if ((g_debug_effect & DEBUG_EFFECT_ENTRY) && wait_ret != 0)
		DEBUG_EFFECT_LOG("[effect] wait_event_interruptible_timeout()"
			" return %d, -ERESTARTSYS:%d\n",
			wait_ret, -ERESTARTSYS);

	return ret;
}

static void adjust_dst_rect(dss_overlay_t *pov_req, struct hisi_panel_info *pinfo, dss_rect_t *pdst_rect)
{
	pdst_rect->x = 0;
	pdst_rect->y = 0;

	if (pov_req->dirty_rect.w == 0 || pov_req->dirty_rect.h == 0) {
		pdst_rect->w = pinfo->xres;
		pdst_rect->h = pinfo->yres;
	} else {
		pdst_rect->w = pov_req->dirty_rect.w;
		pdst_rect->h = pov_req->dirty_rect.h;

		// rog scale, just consider (x,y) is (0,0) now
		if (pinfo->cascadeic_support &&
			(pov_req->rog_width > 0 && pov_req->rog_height > 0)) {
			pdst_rect->w = pdst_rect->w * pinfo->xres / pov_req->rog_width;
			pdst_rect->h = pdst_rect->h * pinfo->yres / pov_req->rog_height;

			if ((uint32_t)pdst_rect->w > pinfo->xres)
				pdst_rect->w = pinfo->xres;
			if ((uint32_t)pdst_rect->h > pinfo->yres)
				pdst_rect->h = pinfo->yres;
		}
	}
}

static void adjust_src_rect(dss_overlay_t *pov_req,
	struct hisi_panel_info *pinfo, dss_rect_t *psrc_rect, dss_rect_t *pdst_rect)
{
	if (((pov_req->dirty_rect.w > 0) && (pov_req->dirty_rect.h > 0)) ||
		((pov_req->res_updt_rect.w == 0) || (pov_req->res_updt_rect.h == 0))) {
		if ((!pinfo->cascadeic_support) ||
			(pov_req->rog_width == pinfo->xres && pov_req->rog_height == pinfo->yres) ||
			(pov_req->rog_width == 0 && pov_req->rog_height == 0)) {  // no rog scale
			*psrc_rect = *pdst_rect;
		} else {
			*psrc_rect = pov_req->res_updt_rect;
		}
	} else {
		*psrc_rect = pov_req->res_updt_rect;
	}
}

void hisi_effect_init(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	hiace_alg_parameter_t *param = NULL;
	int i;
	int j;

	if (!g_is_effect_lock_init) {
		spin_lock_init(&g_gmp_effect_lock);
		spin_lock_init(&g_igm_effect_lock);
		spin_lock_init(&g_xcc_effect_lock);
		spin_lock_init(&g_gama_effect_lock);
		spin_lock_init(&g_post_xcc_effect_lock);
		spin_lock_init(&g_hiace_table_lock);
		spin_lock_init(&g_dpproi_effect_lock);
		spin_lock_init(&g_roi_lock);

		for (i = 0; i < DISP_PANEL_NUM; ++i) {
			for (j = 0; j < DPP_BUF_MAX_COUNT - 1; ++j)
				mutex_init(&g_dpp_buf_lock_arr[i][j]);
		}

		mutex_init(&g_dpp_ch0_lock);
		mutex_init(&g_dpp_ch1_lock);
		mutex_init(&g_rgbw_lock);
		g_is_effect_lock_init = true;
	}

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");

		return;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	for (i = 0; (!g_is_effect_init) && (i < DISP_PANEL_NUM); ++i) {
		memset(&hisifd->hiace_info[i], 0, sizeof(dss_ce_info_t));
		hisifd->hiace_info[i].algorithm_result = 1;
		mutex_init(&(hisifd->hiace_info[i].hist_lock));
		mutex_init(&(hisifd->hiace_info[i].lut_lock));
	}

	param = &pinfo->hiace_param;

	if (!g_is_effect_init) {
		mutex_init(&g_ce_service_lock);
		mutex_init(&(hisifd->al_ctrl.ctrl_lock));
		mutex_init(&(hisifd->ce_ctrl.ctrl_lock));
		mutex_init(&(hisifd->bl_ctrl.ctrl_lock));
		mutex_init(&(hisifd->bl_enable_ctrl.ctrl_lock));
		mutex_init(&(hisifd->metadata_ctrl.ctrl_lock));
		hisifd->bl_enable_ctrl.ctrl_bl_enable = 1;

		param->iWidth = (int)pinfo->xres;
		param->iHeight = (int)pinfo->yres;
		param->iMode = 0;
		param->bitWidth = 10;
		param->iMinBackLight = (int)hisifd->panel_info.bl_min;
		param->iMaxBackLight = (int)hisifd->panel_info.bl_max;
		param->iAmbientLight = -1;

		memset(&g_hiace_service, 0, sizeof(g_hiace_service));
		init_waitqueue_head(&g_hiace_service.wq_hist);

		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] width:%d, height:%d, minbl:%d, maxbl:%d\n",
				param->iWidth, param->iHeight,
				param->iMinBackLight, param->iMaxBackLight);

		g_is_effect_init = true;
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] bypass\n");
	}

#ifdef HIACE_SINGLE_MODE_SUPPORT
	// init hiace single mode info
	hisifb_hiace_single_mode_init();
#endif
}

void hisi_effect_deinit(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	int i;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");
		return;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	if (g_is_effect_lock_init) {
		g_is_effect_lock_init = false;
		mutex_destroy(&g_rgbw_lock);
	}
	/* avoid  using  mutex_lock() but hist_lock was destoried
	 * by mutex_destory in  hisi_effect_deinit
	 */
	down(&hisifd->hiace_hist_lock_sem);
	if (g_is_effect_init) {
		g_is_effect_init = false;

		for (i = 0; i < DISP_PANEL_NUM; ++i) {
			mutex_destroy(&(hisifd->hiace_info[i].hist_lock));
			mutex_destroy(&(hisifd->hiace_info[i].lut_lock));
		}

		mutex_destroy(&(hisifd->al_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->ce_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->bl_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->bl_enable_ctrl.ctrl_lock));
		mutex_destroy(&(hisifd->metadata_ctrl.ctrl_lock));

		mutex_destroy(&g_ce_service_lock);
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] bypass\n");
	}
	up(&hisifd->hiace_hist_lock_sem);
}

static void enable_hiace(struct hisi_fb_data_type *hisifd, bool enable)
{
	if (enable)
		hisifb_ce_service_init();
	else
		hisifb_ce_service_deinit();

	down(&hisifd->blank_sem);
	effect_debug_log(DEBUG_EFFECT_FRAME, "fb%d panel_power_on=%d enable=%d hiace_enable=%d\n", hisifd->index,
		hisifd->panel_power_on, (int)enable, hisifd->hiace_info[hisifd->panel_info.disp_panel_id].hiace_enable);
	if (hisifd->panel_power_on && (hisifd->hiace_info[hisifd->panel_info.disp_panel_id].hiace_enable != enable))
		hisifd->hiace_info[hisifd->panel_info.disp_panel_id].hiace_enable = enable;
	up(&hisifd->blank_sem);
}

static bool hisifb_hiace_is_normal_mode(struct hisi_fb_data_type *hisifd)
{
	if (!(g_enable_effect & ENABLE_EFFECT_HIACE))
		return false;

	if ((hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_IMAGE) ||
		(hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_VIDEO))
		return true;

	return false;
}

int hisifb_ce_service_blank(int blank_mode, struct fb_info *info)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;

	if (info == NULL) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		if (pinfo->hiace_support) {
			if (blank_mode == FB_BLANK_UNBLANK) {
				effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] UNBLANK\n");
				hisifb_ce_service_init();
				if (hisifb_hiace_is_normal_mode(hisifd))
					enable_hiace(hisifd, true);
			} else {
				if (hisifb_hiace_is_normal_mode(hisifd))
					g_hiace_service.use_last_value = true;
				hisifd->hiace_info[pinfo->disp_panel_id].gradual_frames = 0;
				hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable = false;
				hisifd->hiace_info[pinfo->disp_panel_id].to_stop_hdr = false;
				hisifd->hiace_info[pinfo->disp_panel_id].to_stop_sre = false;
				g_hiace_service.blc_used = false;
				g_hiace_enable_status = false;

				// Since java has no destruct function and Gallery will
				// refresh metadata when power on,
				// always close HDR for Gallery when power off.
				if (hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_IMAGE)
					hisifd->ce_ctrl.ctrl_ce_mode = CE_MODE_DISABLE;
				effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] BLANK\n");
				hisifb_ce_service_deinit();

#ifdef HIACE_SINGLE_MODE_SUPPORT
				// terminate single mode, wait next trigger
				hisifb_hiace_single_mode_terminate(hisifd, true);
#endif

				// set hiace off timestamp when sleep
				hisifb_panel_set_hiace_timestamp(hisifd, false, hisifd->ce_ctrl.ctrl_ce_mode);
			}
		}
	}
	return 0;
}

int hisifb_ce_service_get_support(struct fb_info *info,
	void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	unsigned int support = 0;
	int ret;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support)
		support = 1;

	if (g_debug_effect & DEBUG_EFFECT_ENTRY)
		DEBUG_EFFECT_LOG("[effect] support:%d\n", support);

	ret = (int)copy_to_user(argp, &support, sizeof(support));
	if (ret) {
		HISI_FB_ERR("[effect] copy_to_user failed! ret=%d\n", ret);
		return ret;
	}

	return ret;
}

int hisifb_ce_service_get_limit(struct fb_info *info, void __user *argp)
{
	int limit = 0;
	int ret;

	if (argp == NULL) {
		HISI_FB_ERR("argp is NULL\n");
		return -EINVAL;
	}

	ret = (int)copy_to_user(argp, &limit, sizeof(limit));
	if (ret) {
		HISI_FB_ERR("copy_to_user failed! ret=%d.\n", ret);
		return ret;
	}

	return ret;
}

#if defined(CONFIG_HISI_FB_V510) || defined(CONFIG_HISI_FB_V600)
int hisifb_get_hiace_roi(struct fb_info *info, void __user *argp)
{
	int ret;
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] hisifd index error: fd = %d\n", hisifd->index);
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");
		return -EINVAL;
	}

	spin_lock(&g_roi_lock);
	ret = copy_to_user(argp, &(hisifd->hist_hiace_roi_info), sizeof(struct hiace_roi_info));
	if (ret) {
		spin_unlock(&g_roi_lock);
		HISI_FB_ERR("failed to copy result of ioctl to user space\n");
		return -EINVAL;
	}
	spin_unlock(&g_roi_lock);
	return 0;
}
#endif

int hisifb_ce_service_get_hiace_param(struct fb_info *info,
	void __user *argp)
{
	int ret;
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	struct dss_effect_info effect_info;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] hisifd index error: fd = %d\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");

		return -EINVAL;
	}

	ret = copy_from_user(&effect_info, argp, sizeof(struct dss_effect_info));
	if (ret) {
		HISI_FB_ERR("failed to copy dss_effect_info from user space\n");
		return -EINVAL;
	}

	if (effect_info.modules & DSS_EFFECT_MODULE_HIACE) {
		ret = hisi_effect_hiace_info_get(hisifd, &(effect_info.hiace));
		if (ret) {
			HISI_FB_ERR("failed to get hiace info\n");
			return -EINVAL;
		}
	}

	ret = copy_to_user(argp, &effect_info, sizeof(struct dss_effect_info));
	if (ret) {
		HISI_FB_ERR("failed to copy result of ioctl to user space\n");
		return -EINVAL;
	}

	return 0;
}

/*lint -e571*/
int hisifb_ce_service_get_param(struct fb_info *info, void __user *argp)
{
	int ret;
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_display_effect_al_t *al_ctrl = NULL;
	dss_display_effect_metadata_t *metadata_ctrl = NULL;
	int mode;
	struct timespec ts;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");

		return -EINVAL;
	}

	ce_ctrl = &(hisifd->ce_ctrl);
	al_ctrl = &(hisifd->al_ctrl);
	metadata_ctrl = &(hisifd->metadata_ctrl);
	mode = ce_ctrl->ctrl_ce_mode;
	if (mode != 0) {
		pinfo->hiace_param.iDoLCE = 1;
		pinfo->hiace_param.iDoAPLC = 1;
	}
	pinfo->hiace_param.iLevel = MAX(mode - 1, 0);
	pinfo->hiace_param.iAmbientLight = al_ctrl->ctrl_al_value;
	pinfo->hiace_param.iBackLight = (int)hisifd->bl_level;
	ktime_get_ts(&ts);
	pinfo->hiace_param.lTimestamp = ts.tv_sec * MSEC_PER_SEC +
		ts.tv_nsec / NSEC_PER_MSEC;
	if (metadata_ctrl->count <= META_DATA_SIZE) {
		memcpy(pinfo->hiace_param.Classifieresult,
			metadata_ctrl->metadata, (size_t)metadata_ctrl->count);
		pinfo->hiace_param.iResultLen = metadata_ctrl->count;
	}

	ret = (int)copy_to_user(argp, &pinfo->hiace_param, sizeof(pinfo->hiace_param));
	if (ret) {
		HISI_FB_ERR("[effect] copy_to_user(hiace_param) failed! ret=%d\n", ret);
		return ret;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME)
		DEBUG_EFFECT_LOG("[effect] iLevel:%d, iAmbientLight:%d, "
			"iBackLight:%d, lTimestamp:%ld(ms)\n",
			pinfo->hiace_param.iLevel, pinfo->hiace_param.iAmbientLight,
			pinfo->hiace_param.iBackLight, pinfo->hiace_param.lTimestamp);

	if (g_debug_effect & DEBUG_EFFECT_DELAY)
		g_interval_algorithm.start = get_timestamp_in_us();

	return ret;
}

static int check_param_for_get_hist(struct hisi_fb_data_type *hisifd)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL\n");
		return -EINVAL;
	}
	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("fb%d is not supported!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->panel_power_on) {
		HISI_FB_INFO("[effect] panel is power off!\n");
		return 1; /* panel off, do not get hist, return 1. */
	}
	return 0;
}

/*lint +e571*/
int hisifb_ce_service_get_hist(struct fb_info *info, void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	ce_service_t *service = &g_hiace_service;
	int ret = 0;
	long wait_ret = 0;
	int times = 0;
	long timeout = msecs_to_jiffies(100000);

	if (runmode_is_factory())
		return ret;

	if (info == NULL) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	ret = check_param_for_get_hist(hisifd);
	if (ret != 0)
		return ret;

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME)
		DEBUG_EFFECT_LOG("[effect] wait hist\n");

	if (g_is_effect_init) {
		unlock_fb_info(info);
		while (1) {
			wait_ret = wait_event_interruptible_timeout(service->wq_hist,
				service->new_hist || service->hist_stop, timeout);
			if ((wait_ret == -ERESTARTSYS) && (times++ < 100)) {
				mdelay(10);
			} else {
				if (times != 0)
					HISI_FB_INFO("[effect] wait_ret is -ERESTARTSYS, max times=%d\n", times);
				break;
			}
		}
		(void)lock_fb_info(info);
		service->hist_stop = false;
	}
	if (!g_is_effect_init) {
		HISI_FB_ERR("[effect] wq_hist uninit\n");
		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		g_interval_wait_hist.stop = get_timestamp_in_us();
		count_delay(&g_delay_wait_hist,
			g_interval_wait_hist.stop - g_interval_wait_hist.start);
	}
	/* avoid  using  mutex_lock() but hist_lock was destoried
	 * by mutex_destory in  hisi_effect_deinit
	 */
	down(&hisifd->hiace_hist_lock_sem);
	if (service->new_hist) {
		time_interval_t interval_copy_hist = {0};
		static delay_record_t delay_copy_hist = {
			"hist copy", 0, 0xFFFFFFFF, 0, 0
		};

		service->new_hist = false;

		if (!g_is_effect_init) {
			HISI_FB_ERR("[effect] wq_hist uninit here\n");
			up(&hisifd->hiace_hist_lock_sem);
			return -EINVAL;
		}
		/* use index 0 cause hist only valid in one panel, if use disp_panel_id to index hiace_info may cause
		 * histogram wrong when fold or unfold panel
		 */
		mutex_lock(&hisifd->hiace_info[0].hist_lock);
		if (g_debug_effect & DEBUG_EFFECT_DELAY)
			interval_copy_hist.start = get_timestamp_in_us();

		ret = (int)copy_to_user(argp, hisifd->hiace_info[0].histogram,
			sizeof(hisifd->hiace_info[0].histogram));
		if (ret) {
			HISI_FB_ERR("[effect] copy_to_user failed(param)! ret=%d.\n", ret);
			ret = -1;
		}
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_copy_hist.stop = get_timestamp_in_us();
			count_delay(&delay_copy_hist,
				interval_copy_hist.stop - interval_copy_hist.start);
		}
		mutex_unlock(&hisifd->hiace_info[0].hist_lock);
	} else {
		ret = handle_err_hist(info, wait_ret);
	}
	up(&hisifd->hiace_hist_lock_sem);

	return ret;
}

int hisifb_ce_service_set_lut(struct fb_info *info, const void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	hiace_interface_set_t hiace_set_interface;
	int ret = 0;
	time_interval_t interval_copy_lut = {0};
	static delay_record_t delay_copy_lut = { "lut copy", 0, 0xFFFFFFFF, 0, 0 };

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		g_interval_algorithm.stop = get_timestamp_in_us();
		count_delay(&g_delay_algorithm,
			g_interval_algorithm.stop - g_interval_algorithm.start);
	}

	if (runmode_is_factory())
		return ret;

	if (info == NULL) {
		HISI_FB_ERR("info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] Don't support HIACE\n");

		return -EINVAL;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME)
		DEBUG_EFFECT_LOG("[effect] step in\n");

	ret = (int)copy_from_user(&hiace_set_interface, argp, sizeof(hiace_interface_set_t));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d\n", ret);
		return -2;
	}

	if (hiace_set_interface.disp_panel_id >= DISP_PANEL_NUM || hiace_set_interface.disp_panel_id < 0) {
		HISI_FB_ERR("[effect] disp_panel_id %d overflow\n", hiace_set_interface.disp_panel_id);
		return -EINVAL;
	}

	mutex_lock(&hisifd->hiace_info[hiace_set_interface.disp_panel_id].lut_lock);
	if (g_debug_effect & DEBUG_EFFECT_DELAY)
		interval_copy_lut.start = get_timestamp_in_us();

	ret = (int)hisi_effect_alloc_and_copy(&hisifd->hiace_info[hiace_set_interface.disp_panel_id].lut_table,
		hiace_set_interface.lut, CE_SIZE_LUT, true);
	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] g_debug_effect=0x%x disp_panel_id=%d\n",
		g_debug_effect, hiace_set_interface.disp_panel_id);

	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(lut_table) failed! ret=%d\n", ret);
		ret = -2;
	}

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_copy_lut.stop = get_timestamp_in_us();
		count_delay(&delay_copy_lut,
			interval_copy_lut.stop - interval_copy_lut.start);
	}
	mutex_unlock(&hisifd->hiace_info[hiace_set_interface.disp_panel_id].lut_lock);
	hisifd->hiace_info[hiace_set_interface.disp_panel_id].algorithm_result = 0;
	hisifd->effect_init_update[hiace_set_interface.disp_panel_id].hiace_lut_update = 1;

	return ret;
}

ssize_t hisifb_display_effect_al_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_al_t *al_ctrl = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	if (buf == NULL)
		HISI_FB_ERR("[effect] buf is NULL\n");

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	al_ctrl = &(hisifd->al_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", al_ctrl->ctrl_al_value);
}

ssize_t hisifb_display_effect_al_ctrl_store(struct fb_info *info,
	const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_ce_ctrl_show(struct fb_info *info,
	char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	if (buf == NULL)
		HISI_FB_ERR("[effect] buf is NULL\n");

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	ce_ctrl = &(hisifd->ce_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", ce_ctrl->ctrl_ce_mode);
}

ssize_t hisifb_display_effect_ce_ctrl_store(struct fb_info *info,
	const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_bl_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_bl_t *bl_ctrl = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	if (buf == NULL)
		HISI_FB_ERR("[effect] buf is NULL\n");

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	bl_ctrl = &(hisifd->bl_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", bl_ctrl->ctrl_bl_delta);
}

ssize_t hisifb_display_effect_bl_enable_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_bl_enable_t *bl_enable_ctrl = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect] info is NULL\n");
		return -1;
	}

	if (buf == NULL)
		HISI_FB_ERR("[effect] buf is NULL\n");

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	bl_enable_ctrl = &(hisifd->bl_enable_ctrl);

	return snprintf(buf, PAGE_SIZE, "%d\n", bl_enable_ctrl->ctrl_bl_enable);
}

ssize_t hisifb_display_effect_bl_enable_ctrl_store(struct fb_info *info,
	const char *buf, size_t count)
{
	(void)info, (void)buf;

	return (ssize_t)count;
}

ssize_t hisifb_display_effect_sre_ctrl_show(struct fb_info *info, char *buf)
{
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_sre_t *sre_ctrl = NULL;

	if (info == NULL) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	if (buf == NULL)
		HISI_FB_ERR("[effect] buf is NULL\n");

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("NULL Pointer\n");
		return -1;
	}

	sre_ctrl = &(hisifd->sre_ctrl);

	return snprintf(buf, PAGE_SIZE, "sre_enable:%d, sre_al:%d\n",
		sre_ctrl->ctrl_sre_enable, sre_ctrl->ctrl_sre_al);
}

ssize_t hisifb_display_effect_sre_ctrl_store(struct fb_info *info,
	const char *buf, size_t count)
{
	(void)info, (void)buf;
	return (ssize_t)count;
}

ssize_t hisifb_display_effect_metadata_ctrl_show(struct fb_info *info, char *buf)
{
	(void)info, (void)buf;
	return 0;
}

/*lint -e550 -e715*/
ssize_t hisifb_display_effect_metadata_ctrl_store(struct fb_info *info,
	const char *buf, size_t count)
{
	(void)info, (void)buf;
	return (ssize_t)count;
}

void hisifb_display_effect_func_switch(struct hisi_fb_data_type *hisifd,
	const char *command)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}
	if (command == NULL) {
		HISI_FB_ERR("[effect] command is NULL\n");
		return;
	}

	if (!strncmp("hiace:", command, strlen("hiace:"))) {
		if (command[strlen("hiace:")] == '0') {
			hisifd->panel_info.hiace_support = 0;
			HISI_FB_INFO("[effect] hiace disable\n");
		} else {
			hisifd->panel_info.hiace_support = 1;
			HISI_FB_INFO("[effect] hiace enable\n");
		}
	}
	if (!strncmp("effect_enable:", command, strlen("effect_enable:"))) {
		g_enable_effect = (int)simple_strtoul(&command[strlen("effect_enable:")], NULL, 0);
		HISI_FB_INFO("[effect] effect_enable changed to %d\n", g_enable_effect);
	}
	if (!strncmp("effect_debug:", command, strlen("effect_debug:"))) {
		g_debug_effect = (int)simple_strtoul(&command[strlen("effect_debug:")], NULL, 0);
		HISI_FB_INFO("[effect] effect_debug changed to %d\n", g_debug_effect);
	}
}

bool hisifb_display_effect_is_need_ace(struct hisi_fb_data_type *hisifd)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return false;
	}

	return (g_enable_effect & ENABLE_EFFECT_HIACE) && (hisifd->ce_ctrl.ctrl_ce_mode > 0);
}

bool hisifb_display_effect_is_need_blc(struct hisi_fb_data_type *hisifd)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return false;
	}
	return hisifd->de_info.blc_enable;
}

bool hisifb_display_effect_check_bl_value(int curr, int last)
{
	if (abs(curr - last) > 200)
		return true;

	return false;
}

bool hisifb_display_effect_check_bl_delta(int curr, int last)
{
	if (abs(curr - last) > 20)
		return true;

	return false;
}

static void display_engine_bl_debug_print(int bl_in,
	int bl_out, int delta)
{
	static int last_delta;
	static int last_bl;
	static int last_bl_out;
	static int count;

	if (hisifb_display_effect_check_bl_value(bl_in, last_bl) ||
		hisifb_display_effect_check_bl_value(bl_out, last_bl_out) ||
		hisifb_display_effect_check_bl_delta(delta, last_delta)) {
		if (count == 0)
			HISI_FB_INFO("[effect] last delta:%d bl:%d->%d\n", last_delta, last_bl, last_bl_out);

		count = DISPLAYENGINE_BL_DEBUG_FRAMES;
	}
	if (count > 0) {
		HISI_FB_INFO("[effect] delta:%d bl:%d->%d\n", delta, bl_in, bl_out);
		count--;
	}
	last_delta = delta;
	last_bl = bl_in;
	last_bl_out = bl_out;
}

static void hisifb_dbv_curve_mapped(struct hisi_fb_data_type *hisifd,
	int backlight_in, int *backlight_out)
{
	if (hisifd == NULL || backlight_out == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}
	if (hisifd->panel_info.dbv_curve_mapped_support &&
		hisifd->panel_info.is_dbv_need_mapped &&
		((uint32_t)backlight_in < hisifd->panel_info.dbv_map_points_num) &&
		(backlight_in >= 0)) {
		int bl = (int)(*(hisifd->panel_info.dbv_map_curve_pointer +
			hisifd->panel_info.dbv_map_index *
			(hisifd->panel_info.dbv_map_points_num))) + backlight_in;
		*backlight_out = bl;
		HISI_FB_DEBUG("[effect] delta:%d bl:%d(bl_in:%d)->%d\n",
			hisifd->de_info.blc_delta, hisifd->bl_level,
			backlight_in, *backlight_out);
	}
}

bool hisifb_display_effect_is_low_precision_mapping(int manufacture_brightness_mode)
{
	return (runmode_is_factory() && (manufacture_brightness_mode == 0));
}

static void hisifb_display_effect_dbv_map(
	struct hisi_fb_data_type *hisifd, int *backlight_out)
{
	if (*backlight_out >= MAP_LUMLUT_LENGTH) {
		if (hisifd->panel_info.dbv_max)
			*backlight_out = hisifd->panel_info.dbv_max;
		else
			*backlight_out = hisifd->panel_info.bl_max;
		HISI_FB_INFO("backlight_out is outline!\n");
		return;
	}

	if (*backlight_out <= 0) {
		HISI_FB_INFO("backlight_out is set 0!\n");
		*backlight_out = 0;
		return;
	}

	if (hisifd->de_info.dbv_map[*backlight_out] == 0)
		HISI_FB_INFO("dbv map is 0\n");
	else
		*backlight_out = hisifd->de_info.dbv_map[*backlight_out];

	if (hisifd->panel_info.dbv_max > 0 &&
		(uint32_t)(*backlight_out) > hisifd->panel_info.dbv_max)
		*backlight_out = hisifd->panel_info.dbv_max;
}

bool hisifb_display_effect_fine_tune_backlight(struct hisi_fb_data_type *hisifd,
	int backlight_in, int *backlight_out)
{
	bool changed = false;
	struct hisi_panel_info *pinfo = NULL;
	int delta = 0;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return false;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo == NULL) {
		HISI_FB_ERR("pinfo is NULL!\n");
		return false;
	}

	if (backlight_out == NULL) {
		HISI_FB_ERR("[effect] backlight_out is NULL\n");
		return false;
	}

	if (hisifd->panel_info.need_skip_delta) {
		hisifd->panel_info.need_skip_delta = 0;
		return changed;
	}

	if (hisifd->bl_level > 0) {
		if (hisifb_display_effect_is_need_blc(hisifd)) {
			int bl = MIN((int)hisifd->panel_info.bl_max,
				MAX((int)hisifd->panel_info.bl_min,
					backlight_in + hisifd->de_info.blc_delta));
			if (hisifd->de_info.amoled_param.dc_brightness_dimming_enable_real) {
				if (backlight_in <= hisifd->de_info.
					amoled_param.dc_lowac_dbv_thre &&
					backlight_in > hisifd->de_info.
					amoled_param.dc_lowac_dbv_thres_low)
					bl = hisifd->de_info.amoled_param.
						dc_lowac_fixed_dbv_thres;
			} else if (hisifd->de_info.amoled_param.amoled_diming_enable) {
				if (backlight_in >= hisifd->de_info.amoled_param.Lowac_DBV_XCCThres &&
					backlight_in <= hisifd->de_info.amoled_param.Lowac_DBVThres)
					bl = hisifd->de_info.amoled_param.Lowac_Fixed_DBVThres;
			}

			if (*backlight_out != bl) {
				HISI_FB_DEBUG("[effect] delta:%d bl:%d %d->%d\n",
					hisifd->de_info.blc_delta, backlight_in,
					hisifd->bl_level, bl);
				*backlight_out = bl;
				changed = true;
				hisifd->de_info.blc_used = true;
			}
			delta = hisifd->de_info.blc_delta;
		} else {
			if (hisifd->de_info.blc_used) {
				if (*backlight_out != backlight_in) {
					HISI_FB_DEBUG("[effect] bl:%d->%d\n",
						*backlight_out, backlight_in);
					*backlight_out = backlight_in;
					changed = true;
				}
				hisifd->de_info.blc_used = false;
			}
			delta = 0;
		}
	}

	if (hisifb_display_effect_is_low_precision_mapping(
		hisifd->de_param.manufacture_brightness.engine_mode)) {
		hisifb_dbv_curve_mapped(hisifd, *backlight_out, backlight_out);
		HISI_FB_DEBUG("[effect] runmode_is_factory bl:%d->%d\n",
			*backlight_out, backlight_in);
	}
	hisifb_display_effect_dbv_map(hisifd, backlight_out);
	display_engine_bl_debug_print(backlight_in, *backlight_out, delta);

	return changed;
}

int hisifb_display_effect_blc_cabc_update(struct hisi_fb_data_type *hisifd)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -1;
	}

	if ((hisifd->panel_info.blpwm_input_ena ||
		hisifb_display_effect_is_need_blc(hisifd)) && hisifd->cabc_update)
		hisifd->cabc_update(hisifd);

	return 0;
}

//lint -e774
static void set_somebrightness(struct hiace_info *hiace_param,
	char __iomem *nr_base)
{
	uint32_t somebrightness0, somebrightness1, somebrightness2;
	uint32_t somebrightness3, somebrightness4;

	set_reg(nr_base + DPE_BYPASS_NR, 0x1, 1, 0);
	somebrightness0 = 819 & 0x3ff;
	somebrightness1 = 640 & 0x3ff;
	somebrightness2 = 384 & 0x3ff;
	somebrightness3 = 205 & 0x3ff;
	somebrightness4 = 96 & 0x3ff;
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS01,
		somebrightness0 | (somebrightness1 << 16), 32, 0);
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS23,
		somebrightness2 | (somebrightness3 << 16), 32, 0);
	set_reg(nr_base + DPE_S3_SOME_BRIGHTNESS4, somebrightness4, 32, 0);

	hiace_param->s3_some_brightness01 = somebrightness0 | (somebrightness1 << 16);
	hiace_param->s3_some_brightness23 = somebrightness2 | (somebrightness3 << 16);
	hiace_param->s3_some_brightness4 = somebrightness4;
}

static void set_color_sigma(struct hiace_info *hiace_param,
	char __iomem *nr_base)
{
	uint32_t min_sigma, max_sigma;
	uint32_t color_sigma0, color_sigma1, color_sigma2;
	uint32_t color_sigma3, color_sigma4, color_sigma5;

	min_sigma = 0x16 & 0x1f; // -10
	max_sigma = 0x1f & 0x1f; // -1
	set_reg(nr_base + DPE_S3_MIN_MAX_SIGMA, min_sigma | (max_sigma << 16), 32, 0);
	hiace_param->s3_min_max_sigma = min_sigma | (max_sigma << 16);

	color_sigma0 = 0x1f & 0x1f; // -1
	color_sigma1 = 0x1f & 0x1f; // -1
	color_sigma2 = 0x1e & 0x1f; // -2
	color_sigma3 = 0x1e & 0x1f; // -2
	color_sigma4 = 0x1e & 0x1f; // -2
	color_sigma5 = 0x1e & 0x1f; // -2

	hiace_param->s3_green_sigma03 = color_sigma0 | (color_sigma1 << 8) |
		(color_sigma2 << 16) | (color_sigma3 << 24);
	hiace_param->s3_red_sigma03 = hiace_param->s3_green_sigma03;
	hiace_param->s3_blue_sigma03 = hiace_param->s3_green_sigma03;
	hiace_param->s3_white_sigma03 = hiace_param->s3_green_sigma03;

	hiace_param->s3_green_sigma45 = color_sigma4 | (color_sigma5 << 8);
	hiace_param->s3_red_sigma45 = hiace_param->s3_green_sigma45;
	hiace_param->s3_blue_sigma45 = hiace_param->s3_red_sigma45;
	hiace_param->s3_white_sigma45 = hiace_param->s3_red_sigma45;

	set_reg(nr_base + DPE_S3_GREEN_SIGMA03, hiace_param->s3_green_sigma03, 32, 0);
	set_reg(nr_base + DPE_S3_GREEN_SIGMA45, hiace_param->s3_green_sigma45, 32, 0);

	set_reg(nr_base + DPE_S3_RED_SIGMA03, hiace_param->s3_red_sigma03, 32, 0);
	set_reg(nr_base + DPE_S3_RED_SIGMA45, hiace_param->s3_red_sigma45, 32, 0);

	set_reg(nr_base + DPE_S3_BLUE_SIGMA03, hiace_param->s3_blue_sigma03, 32, 0);
	set_reg(nr_base + DPE_S3_BLUE_SIGMA45, hiace_param->s3_blue_sigma45, 32, 0);

	set_reg(nr_base + DPE_S3_WHITE_SIGMA03, hiace_param->s3_white_sigma03, 32, 0);
	set_reg(nr_base + DPE_S3_WHITE_SIGMA45, hiace_param->s3_white_sigma45, 32, 0);

	set_reg(nr_base + DPE_S3_FILTER_LEVEL, 20, 5, 0);
	set_reg(nr_base + DPE_S3_SIMILARITY_COEFF, 296, 10, 0);
	set_reg(nr_base + DPE_S3_V_FILTER_WEIGHT_ADJ, 0x1, 2, 0);

	hiace_param->s3_filter_level = 20;
	hiace_param->s3_similarity_coeff = 296;
	hiace_param->s3_v_filter_weight_adj = 0x1;
}

void init_noisereduction(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *nr_base = NULL;
	struct hiace_info *hiace_param = NULL;
	uint32_t slop;
	uint32_t th_max, th_min;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		nr_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] NR is not supported!\n");
		return;
	}
	hiace_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace);

	/* disable noisereduction */
	set_somebrightness(hiace_param, nr_base);
	set_color_sigma(hiace_param, nr_base);

	slop = 68 & 0xff;
	th_min = 0x0 & 0x1ff;
	th_max = 25 & 0x1ff;
	hiace_param->s3_hue = (slop << 24) | (th_max << 12) | th_min;
	set_reg(nr_base + DPE_S3_HUE, hiace_param->s3_hue, 32, 0);

	th_min = 80 & 0xff;
	th_max = 120 & 0xff;
	hiace_param->s3_saturation = (slop << 24) | (th_max << 12) | th_min;
	set_reg(nr_base + DPE_S3_SATURATION, hiace_param->s3_saturation, 32, 0);

	th_min = 120 & 0xff;
	th_max = 255 & 0xff;
	hiace_param->s3_value = (slop << 24) | (th_max << 12) | th_min;
	set_reg(nr_base + DPE_S3_VALUE, hiace_param->s3_value, 32, 0);

	set_reg(nr_base + DPE_S3_SKIN_GAIN, 0x80, 8, 0);
	hiace_param->s3_skin_gain = 0x80;

	/* disable noisereduction */
	set_reg(nr_base + DPE_BYPASS_NR, 0x1, 1, 0);
	hiace_param->bypass_nr = 0x1;

	if (pinfo->noisereduction_support == 1) {
	/* enable noisereduction */
		set_reg(nr_base + DPE_BYPASS_NR, 0x0, 1, 0);
		hiace_param->bypass_nr = 0x0;
	}
}

static int effect_hiace_set_hdr_table(struct hisi_fb_data_type *hisifd, int disp_panel_id)
{
	struct hiace_info *hiace_dst = NULL;

	hiace_dst = &(hisifd->effect_info[disp_panel_id].hiace);

	if (hiace_dst->detail_weight_table == NULL)
		hiace_dst->detail_weight_table = g_hiace_hdr_detail_weight[disp_panel_id];
	if (hiace_dst->loglum_eotf_table == NULL)
		hiace_dst->loglum_eotf_table = g_hiace_hdr_loglum_eotf[disp_panel_id];
	if (hiace_dst->luma_gamma_table == NULL)
		hiace_dst->luma_gamma_table = g_hiace_hdr_luma_gamma[disp_panel_id];

	hisi_check_and_return((hiace_dst->detail_weight_table == NULL),
		-EINVAL, ERR, "detail_weight_table is NULL\n");
	hisi_check_and_return((hiace_dst->loglum_eotf_table == NULL),
		-EINVAL, ERR, "loglum_eotf_table is NULL\n");
	hisi_check_and_return((hiace_dst->luma_gamma_table == NULL),
		-EINVAL, ERR, "luma_gamma_table is NULL\n");

	return 0;
}

static void effect_hiace_init_hdr10_lut(struct hisi_fb_data_type *hisifd)
{
	if (hisifd->panel_info.hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME)
			DEBUG_EFFECT_LOG("[effect] HIACE is not support!\n");
		return;
	}

	if (effect_hiace_set_hdr_table(hisifd, hisifd->panel_info.disp_panel_id))
		HISI_FB_INFO("[effect] failed to init hdr table!\n");
	return ;
}

static int effect_set_hiace_hdr_lut_info(struct hisi_fb_data_type *hisifd,
	const struct hiace_info *hiace_src)
{
	if (effect_hiace_set_hdr_table(hisifd, hiace_src->disp_panel_id)) {
		HISI_FB_ERR("failed to set_hdr_table!\n");
		return -EINVAL;
	}

	if (copy_from_user(g_hiace_hdr_detail_weight[hiace_src->disp_panel_id], hiace_src->detail_weight_table,
		(HIACE_DETAIL_WEIGHT_TABLE_LEN * BYTES_PER_TABLE_ELEMENT))) {
			HISI_FB_ERR("failed to copy detail_weight_table from user\n");
			return -EINVAL;
	}
	if (copy_from_user(g_hiace_hdr_loglum_eotf[hiace_src->disp_panel_id], hiace_src->loglum_eotf_table,
		(HIACE_LOGLUM_EOTF_TABLE_LEN * BYTES_PER_TABLE_ELEMENT))) {
			HISI_FB_ERR("failed to copy loglum_eotf_table from user\n");
			return -EINVAL;
	}
	if (copy_from_user(g_hiace_hdr_luma_gamma[hiace_src->disp_panel_id], hiace_src->luma_gamma_table,
		(HIACE_LUMA_GAMA_TABLE_LEN * BYTES_PER_TABLE_ELEMENT))) {
			HISI_FB_ERR("failed to copy luma_gamma_table from user\n");
			return -EINVAL;
	}

	return 0;
}

static void effect_hiace_v3_set_reg(char __iomem *hiace_v3_base, struct hiace_v3_register *param)
{
	set_reg(hiace_v3_base + HIACE_V3_HIGHLIGHT, param->highlight, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN0, param->hl_hue_gain0, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN1, param->hl_hue_gain1, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN2, param->hl_hue_gain2, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN3, param->hl_hue_gain3, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN4, param->hl_hue_gain4, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_HUE_GAIN5, param->hl_hue_gain5, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_SAT, param->hl_sat, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_YOUT_MAXTH, param->hl_yout_maxth, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_YOUT, param->hl_yout, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_HL_DIFF, param->hl_diff, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_SKIN_COUNT, param->skin_count, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_LRE_SAT, param->lre_sat, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_LOCAL_REFRESH_H, param->local_refresh_h, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_LOCAL_REFRESH_V, param->local_refresh_v, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_GLOBAL_HIST_EN, param->global_hist_en, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_GLOBAL_HIST_START, param->global_hist_start, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_GLOBAL_HIST_SIZE, param->global_hist_size, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_SCREEN_MODE, param->screen_mode, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_SEPARATOR, param->separator, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_WEIGHT_MIN_MAX, param->weight_min_max, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_FNA_EN, param->fna_en, 32, 0);
	set_reg(hiace_v3_base + HIACE_V3_DBUG_HIACE, param->dbg_hiace, 32, 0);
}

static void effect_hiace_init_v3(struct hisi_fb_data_type *hisifd)
{
	struct hiace_v3_register *param = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace.hiace_v3_regs);

	// HIGH LIGHT
	param->highlight = HIGH16(0x0) | LOW16(0x1BA);
	param->hl_hue_gain0 = HIGH16(0x100) | LOW16(0x100);
	param->hl_hue_gain1 = HIGH16(0x10A) | LOW16(0x10F);
	param->hl_hue_gain2 = HIGH16(0x106) | LOW16(0x10F);
	param->hl_hue_gain3 = HIGH16(0x12B) | LOW16(0x140);
	param->hl_hue_gain4 = HIGH16(0x140) | LOW16(0x123);
	param->hl_hue_gain5 = HIGH16(0x10F) | LOW16(0x100);
	param->hl_sat = HIGH16(0xA06) | LOW16(0x10E);
	param->hl_yout_maxth = HIGH16(0x274) | LOW16(0x258);
	param->hl_yout = HIGH16(0x8) | LOW16(0x16C);
	param->hl_diff = HIGH16(0x20) | LOW16(0x7);

	// SKIN
	param->skin_count = HIGH16(0x1) | LOW16(0x78);

	// SAT
	param->lre_sat = 0x0;

	// REFRESH
	param->local_refresh_h = 0x0;
	param->local_refresh_v = 0x0;
	param->global_hist_en = 0x0;
	param->global_hist_start = 0x0;
	param->global_hist_size = 0x0;

	// SCREEN
	param->screen_mode = 0x0;
	param->separator = 0x0;
	param->weight_min_max = HIGH16(0x0) | LOW16(0x100);

	// PROTECT
	param->fna_en = HIGH16(0x0) | LOW16(0x1);
	param->dbg_hiace = HIGH16(0x0) | LOW16(0x18);

	effect_hiace_v3_set_reg(hisifd->dss_base + DSS_DISP_CH0_OFFSET, param);
}

void init_hiace_single_panel(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *hiace_base = NULL;
	struct hiace_info *hiace_param = NULL;
	unsigned long dw_jiffies;
	uint32_t temp = 0;
	bool is_ready = false;

	uint32_t global_hist_ab_work, global_hist_ab_shadow;
	uint32_t gamma_ab_work, gamma_ab_shadow;
	uint32_t width, height;
	uint32_t half_block_w, half_block_h;
	uint32_t pipe_mode;
	uint32_t partition_mode;
	uint32_t x_partition;
	uint32_t is_left_pipe;
	uint32_t lhist_quant;
	uint32_t lhist_sft;
	uint32_t slop;
	uint32_t th_max, th_min;
	uint32_t up_thres;
	uint32_t low_thres;
	uint32_t fixbit_x, fixbit_y;
	uint32_t reciprocal_x, reciprocal_y;

	uint32_t block_pixel_num;
	uint32_t max_lhist_block_pixel_num;
	uint32_t max_lhist_bin_reg_num;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);

	if (pinfo->hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] HIACE is not supported!\n");
		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return;
	}

	hiace_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace);

	set_reg(hiace_base + DPE_BYPASS_ACE, 0x1, 1, 0);
	set_reg(hiace_base + DPE_INIT_GAMMA, 0x1, 1, 0);

	/* parameters */
	width = hisifd->panel_info.xres & 0x1fff;
	height = hisifd->panel_info.yres & 0x1fff;

#if defined(CONFIG_HISI_FB_V510) || defined(CONFIG_HISI_FB_V600)
	hiace_size_config(hisifd, width, height);
#endif

	hiace_param->image_info = (height << 16) | width;
	set_reg(hiace_base + DPE_IMAGE_INFO, hiace_param->image_info, 32, 0);

	pipe_mode = 0;
	partition_mode = 0;
	is_left_pipe = 0;
	hiace_param->db_pipe_cfg =
		(is_left_pipe << 31) | (partition_mode << 30) | pipe_mode;
	set_reg(hiace_base + DPE_DB_PIPE_CFG, hiace_param->db_pipe_cfg, 32, 0);
	x_partition = 6;

	lhist_quant = 0;
	set_reg(hiace_base + DPE_LHIST_EN, lhist_quant, 1, 10);

	hiace_param->lhist_en = lhist_quant << 10 | hiace_param->lhist_en;

	half_block_w = (width / (2 * x_partition)) & 0x1ff;
	half_block_h = ((height + 11) / 12) & 0x1ff;
	set_reg(hiace_base + DPE_HALF_BLOCK_INFO,
		(half_block_h << 16) | half_block_w, 32, 0);

	hiace_param->half_block_info = (half_block_h << 16) | half_block_w;

	block_pixel_num = (half_block_w * half_block_h) << 2;
	max_lhist_block_pixel_num = block_pixel_num << 2;
	max_lhist_bin_reg_num = (1 << 16) - 1; /* each local hist bin 20bit -> 16bit */
	if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num))
		lhist_sft = 0;
	else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 1))
		lhist_sft = 1;
	else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 2))
		lhist_sft = 2;
	else if (max_lhist_block_pixel_num < (max_lhist_bin_reg_num << 3))
		lhist_sft = 3;
	else
		lhist_sft = 4;

	set_reg(hiace_base + DPE_LHIST_SFT, lhist_sft, 3, 0);
	pinfo->hiace_param.ilhist_sft = (int)lhist_sft;
	hiace_param->lhist_sft = lhist_sft;

	slop = 68 & 0xff;
	th_min = 0 & 0x1ff;
	th_max = 30 & 0x1ff;
	hiace_param->hue = (slop << 24) | (th_max << 12) | th_min;
	set_reg(hiace_base + DPE_HUE, hiace_param->hue, 32, 0);

	th_min = 80 & 0xff;
	th_max = 140 & 0xff;
	hiace_param->saturation = (slop << 24) | (th_max << 12) | th_min;
	set_reg(hiace_base + DPE_SATURATION, hiace_param->saturation, 32, 0);

	th_min = 100 & 0xff;
	th_max = 255 & 0xff;
	hiace_param->value = (slop << 24) | (th_max << 12) | th_min;
	set_reg(hiace_base + DPE_VALUE, hiace_param->value, 32, 0);

	set_reg(hiace_base + DPE_SKIN_GAIN, 128, 8, 0);
	hiace_param->skin_gain = 128; // SDR:128;  HDR:0

	up_thres = 248 & 0xff;
	low_thres = 8 & 0xff;
	hiace_param->up_low_th = (up_thres << 8) | low_thres;
	set_reg(hiace_base + DPE_UP_LOW_TH, hiace_param->up_low_th, 32, 0);

	fixbit_x = get_fixed_point_offset(half_block_w) & 0x1f;
	fixbit_y = get_fixed_point_offset(half_block_h) & 0x1f;
	reciprocal_x = (1U << (fixbit_x + 8)) / (2 * MAX(half_block_w, 1)) & 0x3ff;
	reciprocal_y = (1U << (fixbit_y + 8)) / (2 * MAX(half_block_h, 1)) & 0x3ff;
	hiace_param->xyweight = (fixbit_y << 26) | (reciprocal_y << 16) | (fixbit_x << 10) | reciprocal_x;
	set_reg(hiace_base + DPE_XYWEIGHT, hiace_param->xyweight, 32, 0);

	if (g_debug_effect & DEBUG_EFFECT_ENTRY)
		DEBUG_EFFECT_LOG("[effect] half_block_w:%d, half_block_h:%d, fixbit_x:%d, fixbit_y:%d, reciprocal_x:%d, reciprocal_y:%d, lhist_sft:%d\n",
			half_block_w, half_block_h, fixbit_x, fixbit_y, reciprocal_x, reciprocal_y, lhist_sft);

	/* wait for gamma init finishing */
	dw_jiffies = jiffies + HZ / 2;
	do {
		temp = inp32(hiace_base + DPE_INIT_GAMMA);
		if ((temp & 0x1) != 0x1) {
			is_ready = true;
			break;
		}
	} while (time_after(dw_jiffies, jiffies)); //lint !e550

	if (!is_ready) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY) {
			DEBUG_EFFECT_LOG("[effect] fb%d, HIACE_INIT_GAMMA is not ready! HIACE_INIT_GAMMA=0x%08X.\n",
				hisifd->index, temp);
		} else {
			HISI_FB_INFO("[effect] fb%d, HIACE_INIT_GAMMA is not ready! HIACE_INIT_GAMMA=0x%08X.\n",
				hisifd->index, temp);
		}
	}

	global_hist_ab_work = inp32(hiace_base + DPE_GLOBAL_HIST_AB_WORK);
	global_hist_ab_shadow = !global_hist_ab_work;

	gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK);
	gamma_ab_shadow = !gamma_ab_work;

	set_reg(hiace_base + DPE_GLOBAL_HIST_AB_SHADOW, global_hist_ab_shadow, 1, 0);
	set_reg(hiace_base + DPE_GAMMA_AB_SHADOW, gamma_ab_shadow, 1, 0);

	/* clear hiace interrupt */
	outp32(hiace_base + DPE_INT_STAT, 0x1);

	/* unmask hiace interrupt */
	set_reg(hiace_base + DPE_INT_UNMASK, 0x1, 1, 0);

	hiace_param->roi_start_point = 0x0;
	hiace_param->roi_width_high = (0x0780 << 16) | 0x0438;
	hiace_param->roi_mode_ctrl = 0x0;
	hiace_param->roi_hist_stat_mode = 0x0;
	hiace_param->rgb_blend_weight = 0;
	set_reg(hiace_base + DPE_RGB_BLEND_WEIGHT, hiace_param->rgb_blend_weight, 32, 0);
	hiace_param->fna_statistic = (0x0f << 8) | 0x03;
	hiace_param->gamma_w = 0;
	hiace_param->gamma_r = 0x0;
	hiace_param->fna_addr = 0x0;
	hiace_param->update_fna = 0x0;
	hiace_param->db_pipe_ext_width = 0x0;
	hiace_param->db_pipe_full_img_width = 0x0438;

	init_noisereduction(hisifd);

	hiace_param->hdr10_en = 0x0;
	set_reg(hiace_base + DPE_HDR10_EN, hiace_param->hdr10_en, 32, 0);
	hiace_param->loglum_max = 0x0;
	set_reg(hiace_base + DPE_LOGLUM_MAX, hiace_param->loglum_max, 32, 0);
	hiace_param->hist_modev = 0x44AB70DA;
	set_reg(hiace_base + DPE_HIST_MODEV, hiace_param->hist_modev, 32, 0);
	hiace_param->end_point = (636 << 16) | 82;
	set_reg(hiace_base + DPE_END_POINT, hiace_param->end_point, 32, 0);

	effect_hiace_init_hdr10_lut(hisifd);

	effect_hiace_init_v3(hisifd);

	/* enable hiace */
	hiace_param->enable = 0;
}

#ifdef CONFIG_HISI_FB_V600
static void init_hiace_dual_panel(struct hisi_fb_data_type *hisifd)
{
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *hiace_base = NULL;
	struct hiace_info *hiace_param = NULL;
	unsigned long dw_jiffies;
	uint32_t temp = 0;
	bool is_ready = false;
	uint32_t width, height;

	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] +\n");

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] HIACE is not supported!\n");
		return;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] fb%d, not support!\n", hisifd->index);
		return;
	}

	hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	hiace_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace);

	set_reg(hiace_base + DPE_BYPASS_ACE, 0x1, 1, 0);
	set_reg(hiace_base + DPE_INIT_GAMMA, 0x1, 1, 0);

	/* parameters */
	width = hisifd->panel_info.xres & 0x1fff;
	height = hisifd->panel_info.yres & 0x1fff;

	hiace_size_config(hisifd, width, height);

	set_reg(hiace_base + DPE_LHIST_EN, 0, 1, 10);

	/* wait for gamma init finishing */
	dw_jiffies = jiffies + HZ / 2;
	do {
		temp = inp32(hiace_base + DPE_INIT_GAMMA);
		if ((temp & 0x1) != 0x1) {
			is_ready = true;
			break;
		}
	} while (time_after(dw_jiffies, jiffies)); //lint !e550

	if (!is_ready) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] fb%d, HIACE_INIT_GAMMA is not ready! INIT_GAMMA=0x%08X.\n", hisifd->index, temp);
		else
			HISI_FB_INFO("[effect] fb%d, HIACE_INIT_GAMMA is not ready! INIT_GAMMA=0x%08X.\n", hisifd->index, temp);
	}

	/* clear hiace interrupt */
	outp32(hiace_base + DPE_INT_STAT, 0x1);

	/* unmask hiace interrupt */
	set_reg(hiace_base + DPE_INT_UNMASK, 0x1, 1, 0);

	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] hiace_mode=%d hiace_param_update=%d hiace_lut_update=%d\n",
		hisifd->effect_init_update[pinfo->disp_panel_id].hiace_mode,
		hisifd->effect_init_update[pinfo->disp_panel_id].hiace_param_update,
		hisifd->effect_init_update[pinfo->disp_panel_id].hiace_lut_update);

	g_hiace_enable_status = false; // this var is set false in hisifb_ce_service_blank, so we don't need set false here
	hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable = hisifd->effect_init_update[pinfo->disp_panel_id].hiace_mode > 0 ? 1 : 0;
	hisifd->ce_ctrl.ctrl_ce_mode = hisifd->effect_init_update[pinfo->disp_panel_id].hiace_mode;
	hisifd->effect_updated_flag[pinfo->disp_panel_id].hiace_effect_updated = hisifd->effect_init_update[pinfo->disp_panel_id].hiace_param_update;
	if (hisifd->effect_init_update[pinfo->disp_panel_id].hiace_lut_update) {
		g_table_update = hisifd->effect_info[pinfo->disp_panel_id].hiace.table_update;
		hisifd->hiace_info[pinfo->disp_panel_id].algorithm_result = 0;
	}

	hisi_effect_hiace_config(hisifd);
	hisi_dss_dpp_hiace_set_reg(hisifd);
}
#endif

void init_hiace(struct hisi_fb_data_type *hisifd)
{
	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] product_type=0x%x skip_power_on_off=%d\n",
		hisifd->panel_info.product_type, hisifd->panel_info.skip_power_on_off);
#ifdef CONFIG_HISI_FB_V600
	if ((hisifd->panel_info.product_type & PANEL_SUPPORT_TWO_PANEL_DISPLAY_TYPE) &&
		(hisifd->panel_info.skip_power_on_off != NORMAL_POWER_ON_OFF)) {
		init_hiace_dual_panel(hisifd);
	} else
#endif
	{
		init_hiace_single_panel(hisifd);
	}
}

static int effect_hiace_get_lhist_band(const char __iomem *hiace_base)
{
	uint32_t lhist_en;
	int lhist_quant;
	int lhist_band;

	lhist_en = inp32(hiace_base + DPE_LHIST_EN);

	lhist_quant = (lhist_en>>10) & 0x1;

	if (lhist_quant == 0)
		lhist_band = 16;
	else
		lhist_band = 8;

	return lhist_band;
}

static int hisi_hiace_v3_set_reg(struct hisi_fb_data_type *hisifd, bool *is_after_hiace_reload)
{
	if ((*is_after_hiace_reload) == false) {
		set_reg(hisifd->dss_base + DSS_DISP_CH0_OFFSET + HIACE_V3_DBUG_HIACE, 0x0, 2, 3);
		return 0;
	} else {
		*is_after_hiace_reload = false;
		g_hiace_service.is_ready = true;
		return -EINVAL;
	}
}

static bool get_hiace_hist_finish_state(struct hisi_fb_data_type *hisifd)
{
	uint32_t vstate;

	vstate = inp32(hisifd->mipi_dsi0_base + MIPI_LDI_VSTATE); //lint !e529
	if (vstate & (LDI_VSTATE_VSW | LDI_VSTATE_VBP | LDI_VSTATE_VACTIVE0 | LDI_VSTATE_V_WAIT_TE0))
		return  true;
	else
		return  false;
}

void hisi_dpp_hiace_end_handle_func(struct work_struct *work)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	char __iomem *hiace_base = NULL;
	char __iomem *disp_ch0_base = NULL;
	uint32_t *global_hist_ptr = NULL;
	uint32_t *sat_global_hist_ptr = NULL;
	uint32_t *skin_count_ptr = NULL;
	uint32_t *local_hist_ptr = NULL;
	uint32_t *fna_data_ptr = NULL;
	dss_ce_info_t *ce_info = NULL;

	int i;
	int ret;
	int x_partition = 6;
	int lhist_band;
	int sum_sat;
	int global_hist_ab_shadow;
	int global_hist_ab_work;
	int skin_count_val;
	static bool is_after_hiace_reload = false;

	time_interval_t interval_total = {0};
	time_interval_t interval_hist_global = {0};
	time_interval_t interval_sat_hist_global = {0};
	time_interval_t interval_hist_local = {0};
	time_interval_t interval_fna_local = {0};
	time_interval_t interval_skin_count = {0};

	static delay_record_t delay_total = { "interrupt handling", 0, 0xFFFFFFFF, 0, 0 };
	static delay_record_t delay_hist_global = { "global hist reading", 0, 0xFFFFFFFF, 0, 0 };
	static delay_record_t delay_sat_hist_global = { "sat_global hist reading", 0, 0xFFFFFFFF, 0, 0 };
	static delay_record_t delay_hist_local = { "local hist reading", 0, 0xFFFFFFFF, 0, 0 };
	static delay_record_t delay_fna_local = { "fna_local hist reading", 0, 0xFFFFFFFF, 0, 0 };
	static delay_record_t delay_skin_count = { "skin_count hist reading", 0, 0xFFFFFFFF, 0, 0 };

	if (work == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	hisifd = container_of(work, struct hisi_fb_data_type, hiace_end_work);
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0)
		return;

	if (!g_is_effect_lock_init) {
		HISI_FB_ERR("display effect lock is not init\n");
		return;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] fb%d, not support!\n", hisifd->index);
		return;
	}

	/* use index 0 cause hist only valid in one panel, if use disp_panel_id to index hiace_info may cause
	 * histogram wrong when fold or unfold panel
	 */
	ce_info = &(hisifd->hiace_info[0]);
	hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	disp_ch0_base = hisifd->dss_base + DSS_DISP_CH0_OFFSET;

#if defined(CONFIG_HISI_FB_V510) || defined(CONFIG_HISI_FB_V600)
	spin_lock(&g_roi_lock);
	hisifd->hist_hiace_roi_info = hisifd->auto_hiace_roi_info;
	spin_unlock(&g_roi_lock);
#endif

#ifdef HIACE_SINGLE_MODE_SUPPORT
	// first try hiace singe mode routine
	if (hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_SINGLE) {
		hisi_hiace_single_mode_wq_handler(work);
		HISI_FB_INFO("[effect] hiace single mode, return at this point!\n");
		return;
	}
#endif

	down(&hisifd->blank_sem_effect_hiace);
	if (!hisifd->panel_power_on) {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] panel power off!\n");
		up(&hisifd->blank_sem_effect_hiace);
		return;

	}

	if (!(g_enable_effect & ENABLE_EFFECT_HIACE) || hisifd->ce_ctrl.ctrl_ce_mode == CE_MODE_DISABLE) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME)
			DEBUG_EFFECT_LOG("[effect] g_enable_effect is %d, ctrl_ce_mode is %d.\n",
				g_enable_effect, hisifd->ce_ctrl.ctrl_ce_mode);
		goto ERR_OUT;
	}

	if (g_hiace_service.is_ready) {
		g_hiace_service.is_ready = false;
	} else {
		if (g_debug_effect & DEBUG_EFFECT_ENTRY)
			DEBUG_EFFECT_LOG("[effect] service is not ready!\n");
		goto ERR_OUT;
	}

	if (g_debug_effect & DEBUG_EFFECT_FRAME)
		DEBUG_EFFECT_LOG("[effect] step in\n");

	hisifb_ce_service_init();

	if (g_debug_effect & DEBUG_EFFECT_DELAY)
		interval_total.start = get_timestamp_in_us();

	hisifb_activate_vsync(hisifd);

	/* if last frame has not finished reading local list, current frame skip */
	ret = hisi_hiace_v3_set_reg(hisifd, &is_after_hiace_reload);
	if (ret) {
		HISI_FB_DEBUG("hiace is not in idle");
		hisifb_deactivate_vsync(hisifd);
		goto ERR_OUT;
	}

	mutex_lock(&ce_info->hist_lock);

	sum_sat = (int)inp32(hiace_base + DPE_SUM_SATURATION);

	lhist_band = effect_hiace_get_lhist_band(hiace_base);

	/* read local hist */
	local_hist_ptr = &hisifd->hiace_info[0].histogram[HIACE_GHIST_RANK * 2];
	set_reg(hiace_base + DPE_LHIST_EN, 1, 1, 31);

	if (g_debug_effect & DEBUG_EFFECT_DELAY)
		interval_hist_local.start = get_timestamp_in_us();

	for (i = 0; i < (6 * x_partition * lhist_band); i++) /* H  L */
		local_hist_ptr[i] = inp32(hiace_base + DPE_LOCAL_HIST_VxHy_2z_2z1);

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_hist_local.stop = get_timestamp_in_us();
		count_delay(&delay_hist_local, interval_hist_local.stop - interval_hist_local.start);
	}

	set_reg(hiace_base + DPE_LHIST_EN, 0, 1, 31);

	/* read fna data */
	// cppcheck-suppress *
	fna_data_ptr = &hisifd->hiace_info[0].histogram[HIACE_GHIST_RANK * 2 + YBLOCKNUM * XBLOCKNUM * HIACE_LHIST_RANK];
	set_reg(hiace_base + DPE_FNA_EN, 1, 1, 31);

	if (g_debug_effect & DEBUG_EFFECT_DELAY)
		interval_fna_local.start = get_timestamp_in_us();

	for (i = 0; i < (6 * x_partition); i++) /* FNA */
		fna_data_ptr[i] = inp32(hiace_base + DPE_FNA_VxHy);

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_fna_local.stop = get_timestamp_in_us();
		count_delay(&delay_fna_local, interval_fna_local.stop - interval_fna_local.start);
	}

	set_reg(hiace_base + DPE_FNA_EN, 0, 1, 31);

	is_after_hiace_reload = get_hiace_hist_finish_state(hisifd);

	// protect: permit refresh local_hist and fna
	set_reg(disp_ch0_base + HIACE_V3_DBUG_HIACE, 0x3, 2, 3);

	global_hist_ab_shadow = inp32(hiace_base + DPE_GLOBAL_HIST_AB_SHADOW);
	global_hist_ab_work = inp32(hiace_base + DPE_GLOBAL_HIST_AB_WORK);
	if (global_hist_ab_shadow == global_hist_ab_work) {
		/* read global hist */
		global_hist_ptr = &hisifd->hiace_info[0].histogram[0]; /* HIACE_GHIST_RANK */

		if (g_debug_effect & DEBUG_EFFECT_DELAY)
			interval_hist_global.start = get_timestamp_in_us();

		for (i = 0; i < 32; i++)
			global_hist_ptr[i] = inp32(hiace_base + DPE_GLOBAL_HIST_LUT_ADDR + i * 4);

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_hist_global.stop = get_timestamp_in_us();
			count_delay(&delay_hist_global,
				interval_hist_global.stop - interval_hist_global.start);
		}

		/* read sat_global hist */
		sat_global_hist_ptr = &hisifd->hiace_info[0].histogram[HIACE_GHIST_RANK]; /* HIACE_GHIST_RANK */

		if (g_debug_effect & DEBUG_EFFECT_DELAY)
			interval_sat_hist_global.start = get_timestamp_in_us();

		for (i = 0; i < 32; i++)
			sat_global_hist_ptr[i] = inp32(hiace_base + DPE_SAT_GLOBAL_HIST_LUT_ADDR + i * 4);

		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_sat_hist_global.stop = get_timestamp_in_us();
			count_delay(&delay_sat_hist_global,
				interval_sat_hist_global.stop - interval_sat_hist_global.start);
		}

		/* read skin_count */
		skin_count_ptr = &hisifd->hiace_info[0].histogram[CE_SIZE_HIST - HIACE_SKIN_COUNT_RANK - 1];

		if (g_debug_effect & DEBUG_EFFECT_DELAY)
			interval_skin_count.start = get_timestamp_in_us();

		/*lint -e679*/
		for (i = 0; i < 18; i++) {
			skin_count_val = inp32(hisifd->dss_base + HIACE_SKIN_COUNT + 0x4 * i);
			skin_count_ptr[2 * i] = skin_count_val & 0xFFFF;
			skin_count_ptr[2 * i + 1] = (skin_count_val >> 16) & 0xFFFF;
		}
		/*lint +e679*/
		if (g_debug_effect & DEBUG_EFFECT_DELAY) {
			interval_skin_count.stop = get_timestamp_in_us();
			count_delay(&delay_skin_count,
				interval_skin_count.stop - interval_skin_count.start);
		}

		outp32(hiace_base +  DPE_GLOBAL_HIST_AB_SHADOW, global_hist_ab_shadow ^ 1);
	}

	hisifd->hiace_info[0].histogram[CE_SIZE_HIST - 1] = sum_sat;
	mutex_unlock(&ce_info->hist_lock);

	hisifb_deactivate_vsync(hisifd);

	/* global or local hist or fna is updated */
	hisifb_ce_do_contrast(hisifd);

	g_hiace_service.is_ready = true;

	if (g_debug_effect & DEBUG_EFFECT_DELAY) {
		interval_total.stop = get_timestamp_in_us();
		count_delay(&delay_total, interval_total.stop - interval_total.start);
	}

ERR_OUT:
	/* clear INT */
	if (hisifd->panel_power_on) {
		hisifb_activate_vsync(hisifd);
		outp32(hiace_base + DPE_INT_STAT, 0x1);
		hisifb_deactivate_vsync(hisifd);
	}

	up(&hisifd->blank_sem_effect_hiace);
} //lint !e550
//lint +e774

void init_acm_ce(struct hisi_fb_data_type *hisifd)
{
	(void *)hisifd;
}

void hisi_dss_dpp_ace_set_reg(struct hisi_fb_data_type *hisifd)
{
	(void *)hisifd;
}

void hisi_dpp_ace_end_handle_func(struct work_struct *work)
{
	(void *)work;
}

/* ***************************************************************************
 * GM IGM
 */
#define GM_LUT_LEN 257
#define GM_LUT_MHLEN 254
static uint16_t g_degm_gm_lut[GM_LUT_LEN * 6];

int hisifb_use_dynamic_gamma(struct hisi_fb_data_type *hisifd, char __iomem *dpp_base)
{
	uint32_t i;
	uint32_t index;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL)
		return -1;

	if (dpp_base == NULL)
		return -1;

	pinfo = &(hisifd->panel_info);

	if (hisifd->dynamic_gamma_info.use_dynamic_gm_init == 1) {
		uint16_t *gm_lut_r =  g_degm_gm_lut;
		uint16_t *gm_lut_g =  gm_lut_r + GM_LUT_LEN;
		uint16_t *gm_lut_b =  gm_lut_g + GM_LUT_LEN;

		for (i = 0; i < pinfo->gamma_lut_table_len / 2; i++) {
			index = i << 1;
			if (index >= GM_LUT_MHLEN)
				index = GM_LUT_MHLEN;

			outp32(dpp_base + (U_GAMA_R_COEF + i * 4), gm_lut_r[index] | gm_lut_r[index+1] << 16);
			outp32(dpp_base + (U_GAMA_G_COEF + i * 4), gm_lut_g[index] | gm_lut_g[index+1] << 16);
			outp32(dpp_base + (U_GAMA_B_COEF + i * 4), gm_lut_b[index] | gm_lut_b[index+1] << 16);
		}
		if (pinfo->gamma_lut_table_len <= GM_LUT_LEN) {
			outp32(dpp_base + U_GAMA_R_LAST_COEF, gm_lut_r[pinfo->gamma_lut_table_len - 1]);
			outp32(dpp_base + U_GAMA_G_LAST_COEF, gm_lut_g[pinfo->gamma_lut_table_len - 1]);
			outp32(dpp_base + U_GAMA_B_LAST_COEF, gm_lut_b[pinfo->gamma_lut_table_len - 1]);
		}
		return 1; // lint !e438
	}

	return 0; // lint !e438

} // lint !e550

int hisifb_use_dynamic_degamma(struct hisi_fb_data_type *hisifd, char __iomem *dpp_base)
{
	uint32_t i;
	uint32_t index;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL)
		return -1;

	if (dpp_base == NULL)
		return -1;

	pinfo = &(hisifd->panel_info);

	if (hisifd->dynamic_gamma_info.use_dynamic_gm_init == 1) {
		uint16_t *degm_lut_r = g_degm_gm_lut + GM_LUT_LEN * 3;
		uint16_t *degm_lut_g = degm_lut_r + GM_LUT_LEN;
		uint16_t *degm_lut_b = degm_lut_g + GM_LUT_LEN;

		for (i = 0; i < pinfo->igm_lut_table_len / 2; i++) {
			index = i << 1;
			if (index >= GM_LUT_MHLEN)
				index = GM_LUT_MHLEN;

			outp32(dpp_base + (U_DEGAMA_R_COEF +  i * 4),
				degm_lut_r[index] | degm_lut_r[index+1] << 16);
			outp32(dpp_base + (U_DEGAMA_G_COEF +  i * 4),
				degm_lut_g[index] | degm_lut_g[index+1] << 16);
			outp32(dpp_base + (U_DEGAMA_B_COEF +  i * 4),
				degm_lut_b[index] | degm_lut_b[index+1] << 16);
		}
		if (pinfo->igm_lut_table_len <= GM_LUT_LEN) {
			outp32(dpp_base + U_DEGAMA_R_LAST_COEF,
				degm_lut_r[pinfo->igm_lut_table_len - 1]);
			outp32(dpp_base + U_DEGAMA_G_LAST_COEF,
				degm_lut_g[pinfo->igm_lut_table_len - 1]);
			outp32(dpp_base + U_DEGAMA_B_LAST_COEF,
				degm_lut_b[pinfo->igm_lut_table_len - 1]);
		}

		return 1;
	}

	return 0;

}

/*lint -e571 -e774*/
void hisifb_update_dynamic_gamma(struct hisi_fb_data_type *hisifd,
	const char *buffer, size_t len)
{
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL || buffer == NULL)
		return;

	pinfo = &(hisifd->panel_info);
	if (pinfo == NULL)
		return;

	if (!HISI_DSS_SUPPORT_DPP_MODULE_BIT(DPP_MODULE_GAMA))
		return;

	hisifd->dynamic_gamma_info.use_dynamic_gm = 0;
	hisifd->dynamic_gamma_info.use_dynamic_gm_init = 0;

	if (pinfo->gamma_support == 1) {
		if ((len > 0) && (len <= (int)sizeof(g_degm_gm_lut))) {
			memcpy((char *)g_degm_gm_lut, buffer, (size_t)len);
			hisifd->dynamic_gamma_info.use_dynamic_gm = 1;
			hisifd->dynamic_gamma_info.use_dynamic_gm_init = 1;
		}
	}

}
/* lint +e571 +e774 */

void hisifb_update_gm_from_reserved_mem(uint32_t *gm_r,
	uint32_t *gm_g, uint32_t *gm_b, uint32_t *igm_r,
	uint32_t *igm_g, uint32_t *igm_b)
{
	int i;
	int len = 0;
	uint16_t *u16_gm_r = NULL;
	uint16_t *u16_gm_g = NULL;
	uint16_t *u16_gm_b = NULL;
	uint16_t *u16_igm_r = NULL;
	uint16_t *u16_igm_g = NULL;
	uint16_t *u16_igm_b = NULL;
	void *mem = NULL;
	unsigned long gm_addr;
	unsigned long gm_size;

	if (gm_r == NULL || gm_g == NULL || gm_b == NULL
		|| igm_r == NULL || igm_g == NULL || igm_b == NULL)
		return;

	gm_addr = HISI_SUB_RESERVED_LCD_GAMMA_MEM_PHYMEM_BASE; // 0x20AF1000;
	gm_size = HISI_SUB_RESERVED_LCD_GAMMA_MEM_PHYMEM_SIZE; // 0x1000;

	HISI_FB_INFO("gamma kernel gm_addr = 0x%lx  gm_size = 0x%lx\n",
		gm_addr, gm_size);

	mem = (void *)ioremap_wc(gm_addr, gm_size);
	if (mem == NULL) {
		HISI_FB_ERR("mem ioremap error !\n");
		return;
	}
	memcpy(&len, mem, 4UL);
	HISI_FB_INFO("gamma read len = %d\n", len);
	if (len != GM_IGM_LEN) {
		HISI_FB_INFO("gamma read len error !\n");
		iounmap(mem);
		return;
	}

	u16_gm_r = (uint16_t *)(mem + 4);
	u16_gm_g = u16_gm_r + GM_LUT_LEN;
	u16_gm_b = u16_gm_g + GM_LUT_LEN;

	u16_igm_r = u16_gm_b + GM_LUT_LEN;
	u16_igm_g = u16_igm_r + GM_LUT_LEN;
	u16_igm_b = u16_igm_g + GM_LUT_LEN;

	for (i = 0; i < GM_LUT_LEN; i++) {
		gm_r[i] = u16_gm_r[i];
		gm_g[i] = u16_gm_g[i];
		gm_b[i] = u16_gm_b[i];

		igm_r[i]  = u16_igm_r[i];
		igm_g[i] = u16_igm_g[i];
		igm_b[i] = u16_igm_b[i];
	}
	iounmap(mem);
}

/* lint -e571, -e573, -e737, -e732, -e850, -e730, -e713, -e529, -e574, -e732, -e845, -e570,
-e774 -e568 -e587 -e685 */

int hisi_effect_arsr2p_info_get(struct hisi_fb_data_type *hisifd,
	struct arsr2p_info *arsr2p)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (arsr2p == NULL) {
		HISI_FB_ERR("fb%d, arsr2p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr2p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr2p is not supported!\n", hisifd->index);
		return 0;
	}

	memcpy(&arsr2p[0],
		&(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect),
		sizeof(struct arsr2p_info));
	memcpy(&arsr2p[1],
		&(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect_scale_up),
		sizeof(struct arsr2p_info));
	memcpy(&arsr2p[2],
		&(hisifd->dss_module_default.arsr2p[DSS_RCHN_V0].arsr2p_effect_scale_down),
		sizeof(struct arsr2p_info));
	arsr2p[0].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;
	arsr2p[1].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;
	arsr2p[2].sharp_enable = hisifd->panel_info.prefix_sharpness2D_support;

	return 0;
}

static void effect_arsr_post_init_param(struct arsr1p_info *arsr_para)
{
	if (arsr_para == NULL)
		return;

	arsr_para->skin_thres_y = (600 << 20) | (332 << 10) | 300; // 0x2585312C
	arsr_para->skin_thres_u = (452 << 20) | (40 << 10) | 20; // 0x1C40A014
	arsr_para->skin_thres_v = (580 << 20) | (48 << 10) | 24; // 0x2440C018
	arsr_para->skin_cfg0 = (12 << 13) | 512; // 0x00018200
	arsr_para->skin_cfg1 = 819; // 0x00000333
	arsr_para->skin_cfg2 = 682; // 0x000002AA
	arsr_para->shoot_cfg1 = (20 << 16) | 341; // 0x00140155
	arsr_para->shoot_cfg2 = (-80 & 0x7ff) | (16 << 16); // 0x001007B0
	arsr_para->shoot_cfg3 = 20; // 0x00000014
	arsr_para->sharp_cfg3 = HIGH16(0xA0) | LOW16(0x60); // 0x00A00060
	arsr_para->sharp_cfg4 = HIGH16(0x60) | LOW16(0x20); // 0x00600020
	arsr_para->sharp_cfg5 = 0;
	arsr_para->sharp_cfg6 = HIGH16(0x4) | LOW16(0x8); // 0x00040008
	arsr_para->sharp_cfg7 = (6 << 8) | 10; // 0x0000060A
	arsr_para->sharp_cfg8 = HIGH16(0xA0) | LOW16(0x10); // 0x00A00010

	arsr_para->sharp_level = 0x0020002;
	arsr_para->sharp_gain_low = 0x3C0078;
	arsr_para->sharp_gain_mid = 0x6400C8;
	arsr_para->sharp_gain_high = 0x5000A0;
	arsr_para->sharp_gainctrl_sloph_mf = 0x280;
	arsr_para->sharp_gainctrl_slopl_mf = 0x1400;
	arsr_para->sharp_gainctrl_sloph_hf = 0x140;
	arsr_para->sharp_gainctrl_slopl_hf = 0xA00;
	arsr_para->sharp_mf_lmt = 0x40;
	arsr_para->sharp_gain_mf = 0x12C012C;
	arsr_para->sharp_mf_b = 0;
	arsr_para->sharp_hf_lmt = 0x80;
	arsr_para->sharp_gain_hf = 0x104012C;
	arsr_para->sharp_hf_b = 0x1400;
	arsr_para->sharp_lf_ctrl = 0x100010;
	arsr_para->sharp_lf_var = 0x1800080;
	arsr_para->sharp_lf_ctrl_slop = 0;
	arsr_para->sharp_hf_select = 0;
	arsr_para->sharp_cfg2_h = 0x10000C0;
	arsr_para->sharp_cfg2_l = 0x200010;
	arsr_para->texture_analysis = 0x500040;
	arsr_para->intplshootctrl = 0x8;
}

int hisi_effect_arsr1p_info_get(struct hisi_fb_data_type *hisifd,
	struct arsr1p_info *arsr1p)
{
	struct arsr1p_info *arsr1p_param = NULL;
	struct arsr1p_info *arsr1p_rog_fhd = NULL;
	struct arsr1p_info *arsr1p_rog_hd = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (arsr1p == NULL) {
		HISI_FB_ERR("fb%d, arsr1p is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr1p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr1p lcd is not supported!\n", hisifd->index);
		return 0;
	}

	/* arsr1p normal init */
	arsr1p_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p[0]);
	arsr1p_param->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_param->skin_enable = arsr1p_param->sharp_enable;
	arsr1p_param->shoot_enable = arsr1p_param->skin_enable;
	effect_arsr_post_init_param(arsr1p_param);
	memcpy(&(arsr1p[0]), arsr1p_param, sizeof(struct arsr1p_info));

	/* arsr1p rog fhd init */
	arsr1p_rog_fhd = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p[1]);
	arsr1p_rog_fhd->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_rog_fhd->skin_enable = arsr1p_rog_fhd->sharp_enable;
	arsr1p_rog_fhd->shoot_enable = arsr1p_rog_fhd->skin_enable;
	if (!(hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p_rog_initialized & ARSR1P_ROG_FHD_FLAG)) {
		effect_arsr_post_init_param(arsr1p_rog_fhd);
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
	}
	memcpy(&(arsr1p[1]), arsr1p_rog_fhd, sizeof(struct arsr1p_info));

	/* arsr1p rog hd init */
	arsr1p_rog_hd = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p[2]);
	arsr1p_rog_hd->sharp_enable = hisifd->panel_info.arsr1p_sharpness_support;
	arsr1p_rog_hd->skin_enable = arsr1p_rog_hd->sharp_enable;
	arsr1p_rog_hd->shoot_enable = arsr1p_rog_hd->skin_enable;
	if (!(hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p_rog_initialized & ARSR1P_ROG_HD_FLAG)) {
		effect_arsr_post_init_param(arsr1p_rog_hd);
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;
	}
	memcpy(&(arsr1p[2]), arsr1p_rog_hd, sizeof(struct arsr1p_info));

	return 0;
}

int hisi_effect_acm_info_get(struct hisi_fb_data_type *hisifd,
	struct acm_info *acm_dst)
{
	return 0;
}

int hisi_effect_lcp_info_get(struct hisi_fb_data_type *hisifd,
	struct lcp_info *lcp)
{
	int ret = 0;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (lcp == NULL) {
		HISI_FB_ERR("fb%d, lcp is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);

	if (hisifd->effect_ctl.lcp_gmp_support &&
		(pinfo->gmp_lut_table_len == LCP_GMP_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->gmp_table_low32,
			pinfo->gmp_lut_table_low32bit, LCP_GMP_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gmp_table_low32 to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->gmp_table_high4,
			pinfo->gmp_lut_table_high4bit, LCP_GMP_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gmp_table_high4 to user!\n",
				hisifd->index);
			goto err_ret;
		}
	}

	if (hisifd->effect_ctl.lcp_xcc_support &&
		(pinfo->xcc_table_len == LCP_XCC_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->xcc0_table,
			pinfo->xcc_table, LCP_XCC_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy xcc0_table to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->xcc1_table,
			pinfo->xcc_table, LCP_XCC_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy xcc1_table to user!\n",
				hisifd->index);
			goto err_ret;
		}
	}

	if (hisifd->effect_ctl.lcp_igm_support &&
		(pinfo->igm_lut_table_len == LCP_IGM_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->igm_r_table,
			pinfo->igm_lut_table_R, LCP_IGM_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_r_table to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->igm_g_table,
			pinfo->igm_lut_table_G, LCP_IGM_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_g_table to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(lcp->igm_b_table,
			pinfo->igm_lut_table_B, LCP_IGM_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy igm_b_table to user!\n",
				hisifd->index);
			goto err_ret;
		}
	}

	if (hisifd->effect_ctl.post_xcc_support &&
		(pinfo->post_xcc_table_len == POST_XCC_LUT_LENGTH)) {
		ret = hisi_effect_copy_to_user(lcp->post_xcc_table,
			pinfo->post_xcc_table, POST_XCC_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy post_xcc_table to user!\n",
				hisifd->index);
			goto err_ret;
		}
	}

err_ret:
	return ret;
}

int hisi_effect_gamma_info_get(struct hisi_fb_data_type *hisifd,
	struct gamma_info *gamma)
{
	struct hisi_panel_info *pinfo = NULL;
	int ret = 0;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (gamma == NULL) {
		HISI_FB_ERR("fb%d, gamma is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.gamma_support) {
		HISI_FB_INFO("fb%d, gamma is not supported!\n", hisifd->index);
		return 0;
	}

	pinfo = &(hisifd->panel_info);

	if (pinfo->gamma_lut_table_len == GAMA_LUT_LENGTH) {
		gamma->para_mode = 0;

		ret = hisi_effect_copy_to_user(gamma->gamma_r_table,
			pinfo->gamma_lut_table_R, GAMA_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_r_table to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_g_table,
			pinfo->gamma_lut_table_G, GAMA_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_g_table to user!\n",
				hisifd->index);
			goto err_ret;
		}

		ret = hisi_effect_copy_to_user(gamma->gamma_b_table,
			pinfo->gamma_lut_table_B, GAMA_LUT_LENGTH);
		if (ret) {
			HISI_FB_ERR("fb%d, failed to copy gamma_b_table to user!\n",
				hisifd->index);
			goto err_ret;
		}
	}

err_ret:
	return ret;
}

int hisi_effect_hiace_info_get(struct hisi_fb_data_type *hisifd,
	struct hiace_info *hiace)
{
	struct hisi_panel_info *pinfo = NULL;
	struct hiace_info *hiace_param = NULL;
	int ret;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (hiace == NULL) {
		HISI_FB_ERR("fb%d, hiace is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		HISI_FB_INFO("fb%d, hiace is not supported!\n", hisifd->index);
		return 0;
	}

	hiace_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace);

	hiace->image_info = hiace_param->image_info;
	hiace->half_block_info = hiace_param->half_block_info;
	hiace->xyweight = hiace_param->xyweight;
	hiace->lhist_sft = hiace_param->lhist_sft;
	hiace->roi_start_point = hiace_param->roi_start_point;
	hiace->roi_width_high = hiace_param->roi_width_high;
	hiace->roi_mode_ctrl = hiace_param->roi_mode_ctrl;
	hiace->roi_hist_stat_mode = hiace_param->roi_hist_stat_mode;
	hiace->hue = hiace_param->hue;
	hiace->saturation = hiace_param->saturation;
	hiace->value = hiace_param->value;
	hiace->skin_gain = hiace_param->skin_gain;
	hiace->up_low_th = hiace_param->up_low_th;
	hiace->rgb_blend_weight = hiace_param->rgb_blend_weight;
	hiace->fna_statistic = hiace_param->fna_statistic;
	hiace->up_cnt = hiace_param->up_cnt;
	hiace->low_cnt = hiace_param->low_cnt;
	hiace->sum_saturation = hiace_param->sum_saturation;
	hiace->lhist_en = hiace_param->lhist_en;
	hiace->gamma_w = hiace_param->gamma_w;
	hiace->gamma_r = hiace_param->gamma_r;
	hiace->fna_addr = hiace_param->fna_addr;
	hiace->fna_data = hiace_param->fna_data;
	hiace->update_fna = hiace_param->update_fna;
	hiace->fna_valid = hiace_param->fna_valid;
	hiace->db_pipe_cfg = hiace_param->db_pipe_cfg;
	hiace->db_pipe_ext_width = hiace_param->db_pipe_ext_width;
	hiace->db_pipe_full_img_width = hiace_param->db_pipe_full_img_width;
	hiace->bypass_nr = hiace_param->bypass_nr;
	hiace->bypass_nr_gain = hiace_param->bypass_nr_gain;
	hiace->s3_some_brightness01 = hiace_param->s3_some_brightness01;
	hiace->s3_some_brightness23 = hiace_param->s3_some_brightness23;
	hiace->s3_some_brightness4 = hiace_param->s3_some_brightness4;
	hiace->s3_min_max_sigma = hiace_param->s3_min_max_sigma;
	hiace->s3_green_sigma03 = hiace_param->s3_green_sigma03;
	hiace->s3_green_sigma45 = hiace_param->s3_green_sigma45;
	hiace->s3_red_sigma03 = hiace_param->s3_red_sigma03;
	hiace->s3_red_sigma45 = hiace_param->s3_red_sigma45;
	hiace->s3_blue_sigma03 = hiace_param->s3_blue_sigma03;
	hiace->s3_blue_sigma45 = hiace_param->s3_blue_sigma45;
	hiace->s3_white_sigma03 = hiace_param->s3_white_sigma03;
	hiace->s3_white_sigma45 = hiace_param->s3_white_sigma45;
	hiace->s3_filter_level = hiace_param->s3_filter_level;
	hiace->s3_similarity_coeff = hiace_param->s3_similarity_coeff;
	hiace->s3_v_filter_weight_adj = hiace_param->s3_v_filter_weight_adj;
	hiace->s3_hue = hiace_param->s3_hue;
	hiace->s3_saturation = hiace_param->s3_saturation;
	hiace->s3_value = hiace_param->s3_value;
	hiace->s3_skin_gain = hiace_param->s3_skin_gain;
	hiace->param_update = hiace_param->param_update;
	hiace->enable = hiace_param->enable;
	hiace->enable_update = hiace_param->enable_update;
	hiace->lut_update = hiace_param->lut_update;
	hiace->hdr10_en = hiace_param->hdr10_en;
	hiace->loglum_max = hiace_param->loglum_max;
	hiace->hist_modev = hiace_param->hist_modev;
	hiace->end_point = hiace_param->end_point;
	hiace->table_update = hiace_param->table_update;

	memcpy(&(hiace->hiace_v3_regs),
		&(hiace_param->hiace_v3_regs), sizeof(struct hiace_v3_register));

	ret = hisi_effect_copy_to_user(hiace->detail_weight_table,
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace.detail_weight_table,
		HIACE_DETAIL_WEIGHT_TABLE_LEN);
	if (ret)
		HISI_FB_ERR("fb%d, failed to copy detail_weight_table to user!\n",
			hisifd->index);

	ret = hisi_effect_copy_to_user(hiace->loglum_eotf_table,
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace.loglum_eotf_table,
		HIACE_LOGLUM_EOTF_TABLE_LEN);
	if (ret)
		HISI_FB_ERR("fb%d, failed to copy loglum_eotf_table to user!\n",
		hisifd->index);

	ret = hisi_effect_copy_to_user(hiace->luma_gamma_table,
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].hiace.luma_gamma_table,
		HIACE_LUMA_GAMA_TABLE_LEN);
	if (ret)
		HISI_FB_ERR("fb%d, failed to copy luma_gamma_table to user!\n",
		hisifd->index);

	return ret;
}

int hisi_effect_save_arsr2p_info(struct hisi_fb_data_type *hisifd, struct dss_effect_info *effect_info_src)
{
	uint32_t i;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (effect_info_src == NULL) {
		HISI_FB_ERR("fb%d, effect_info_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr2p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr2p lcd is not supported!\n", hisifd->index);
		return 0;
	}

	for (i = 0; i < ARSR2P_MAX_NUM; i++) {
		if (effect_info_src->arsr2p[i].update == 1)
			memcpy(&(hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i]),
				&(effect_info_src->arsr2p[i]), sizeof(struct arsr2p_info));
	}

	/* use effect_init_update_status to set arsr1p update status in dual-panel display effect */
	if (effect_info_src->arsr2p[0].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr2p_update_normal = 1;
	if (effect_info_src->arsr2p[1].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr2p_update_scale_up = 1;
	if (effect_info_src->arsr2p[2].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr2p_update_scale_down = 1;

	hisifd->effect_updated_flag[effect_info_src->disp_panel_id].arsr2p_effect_updated = true;

	// debug info
	for (i = 0; i < ARSR2P_MAX_NUM; i++)
		if (hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].update)
			HISI_FB_INFO("arsr2p mode %d: enable : %u, lcd_enable:%u, "
				"shoot_enable:%u, skin_enable:%u, update: %u\n",
				i, hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].enable,
				hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].sharp_enable,
				hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].shoot_enable,
				hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].skin_enable,
				hisifd->effect_info[effect_info_src->disp_panel_id].arsr2p[i].update);

	return 0;
}

int hisi_effect_save_arsr1p_info(struct hisi_fb_data_type *hisifd, struct dss_effect_info *effect_info_src)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return -EINVAL;
	}

	if (effect_info_src == NULL) {
		HISI_FB_ERR("fb%d, effect_info_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	if (!hisifd->effect_ctl.arsr1p_sharp_support) {
		HISI_FB_INFO("fb%d, arsr1p lcd is not supported!\n", hisifd->index);
		return 0;
	}

	effect_info_src->arsr1p[0].enable = (effect_info_src->arsr1p[0].para_mode) & 0x1;
	memcpy(hisifd->effect_info[effect_info_src->disp_panel_id].arsr1p, effect_info_src->arsr1p,
		sizeof(struct arsr1p_info) * ARSR1P_INFO_SIZE);
	hisifd->effect_updated_flag[effect_info_src->disp_panel_id].arsr1p_effect_updated = true;

	if (effect_info_src->arsr1p[1].update == 1)
		hisifd->effect_info[effect_info_src->disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
	// cppcheck-suppress *
	if (effect_info_src->arsr1p[2].update == 1)
		hisifd->effect_info[effect_info_src->disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;

	/* use effect_init_update to set arsr1p update status in dual-panel display effect */
	if (effect_info_src->arsr1p[0].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr1p_update_normal = 1;
	if (effect_info_src->arsr1p[1].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr1p_update_fhd = 1;
	// cppcheck-suppress *
	if (effect_info_src->arsr1p[2].update)
		hisifd->effect_init_update[effect_info_src->disp_panel_id].arsr1p_update_hd = 1;

	return 0;
}

int hisi_effect_save_acm_info(struct hisi_fb_data_type *hisifd, struct dss_effect_info *effect_info_src)
{
	(void *)hisifd;
	(void *)effect_info_src;
	return 0;
}

int hisi_effect_gmp_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src)
{
	(void *)hisifd;
	(void *)lcp_src;
	return 0;
}

int hisi_effect_igm_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src)
{
	(void *)hisifd;
	(void *)lcp_src;
	return 0;
}

int hisi_effect_xcc_info_set(struct hisi_fb_data_type *hisifd, struct lcp_info *lcp_src)
{
	(void *)hisifd;
	(void *)lcp_src;
	return 0;
}

int hisi_effect_gamma_info_set(struct hisi_fb_data_type *hisifd, struct gamma_info *gamma_src)
{
	(void *)hisifd;
	(void *)gamma_src;
	return 0;
}

int hisi_effect_save_post_xcc_info(struct hisi_fb_data_type *hisifd, struct dss_effect_info *effect_info_src)
{
	struct post_xcc_info *post_xcc_dst = NULL;
	struct dss_effect *effect = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("[effect]display effect lock is not init!\n");
		return -EINVAL;
	}

	if (effect_info_src == NULL) {
		HISI_FB_ERR("[effect]fb%d, effect_info_src is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	post_xcc_dst = &(hisifd->effect_info[effect_info_src->disp_panel_id].post_xcc);
	effect = &(hisifd->effect_ctl);

	if (!effect->post_xcc_support) {
		HISI_FB_INFO("[effect]fb%d, post_xcc is not supported!\n", hisifd->index);
		return 0;
	}

	spin_lock(&g_post_xcc_effect_lock);

	post_xcc_dst->enable = effect_info_src->lcp.post_xcc_enable;

	if (post_xcc_dst->enable)
		if (copy_from_user(post_xcc_dst->post_xcc_table,
			effect_info_src->lcp.post_xcc_table, POST_XCC_LUT_LENGTH * sizeof(uint32_t))) {
			HISI_FB_ERR("[effect]fb%d, failed to set post_xcc_table!\n",
				hisifd->index);
			goto err_ret;
		}

	hisifd->effect_updated_flag[effect_info_src->disp_panel_id].post_xcc_effect_updated = true;

	spin_unlock(&g_post_xcc_effect_lock);
	return 0;

err_ret:
	spin_unlock(&g_post_xcc_effect_lock);
	return -EINVAL;
}

int hisi_effect_xcc_info_set_kernel(struct hisi_fb_data_type *hisifd,
	struct dss_display_effect_xcc *lcp_src)
{
	return hisi_effect_xcc_info_set_kernel_multiple(hisifd, lcp_src, hisifd->panel_info.disp_panel_id);
}

int hisi_effect_xcc_info_set_kernel_multiple(struct hisi_fb_data_type *hisifd,
	struct dss_display_effect_xcc *lcp_src, int panel_id)
{
	struct post_xcc_info *post_xcc_dst = NULL;
	struct dss_effect *effect = NULL;
	struct hisi_fb_data_type *hisifd_primary = NULL;

	hisifd_primary = hisifd_list[PRIMARY_PANEL_IDX];

	if (hisifd_primary == NULL) {
		HISI_FB_ERR("hisifd_primary is NULL pointer, return!\n");
		return -EINVAL;
	}

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("[effect]display effect lock is not init!\n");
		return -EINVAL;
	}

	if (lcp_src == NULL) {
		HISI_FB_ERR("[effect]fb%d, post_xcc_src is NULL!\n",
			hisifd->index);
		return -EINVAL;
	}

	post_xcc_dst = &(hisifd->effect_info[panel_id].post_xcc);
	effect = &(hisifd->effect_ctl);

	if (!effect->post_xcc_support) {
		HISI_FB_INFO("[effect]fb%d, post_xcc is not supported!\n",
			hisifd->index);
		return 0;
	}

	spin_lock(&g_post_xcc_effect_lock);

	post_xcc_dst->enable = lcp_src->xcc_enable;

	if (post_xcc_dst->enable)
		memcpy(post_xcc_dst->post_xcc_table, lcp_src->xcc_table,
			BYTES_PER_TABLE_ELEMENT * POST_XCC_LUT_LENGTH);

	hisifd_primary->display_effect_flag = 4;
	hisifd->effect_updated_flag[panel_id].post_xcc_effect_updated = true;
	spin_unlock(&g_post_xcc_effect_lock);
	return 0;
}

static int effect_dbm_save_gmp_info(struct gmp_info *dst_gmp,
	struct lcp_info *lcp_src)
{
	uint32_t i;

	if (dst_gmp == NULL) {
		HISI_FB_ERR("[effect]dst_gmp is NULL!\n");
		return -EINVAL;
	}

	if (lcp_src == NULL) {
		HISI_FB_ERR("[effect]lcp_src is NULL!\n");
		return -EINVAL;
	}

	dst_gmp->gmp_mode = lcp_src->gmp_mode;
	/* only update gmp lut when gmp is enabled */
	if (lcp_src->gmp_mode & GMP_ENABLE) {
		if (copy_from_user(dst_gmp->gmp_lut_high4bit,
			lcp_src->gmp_table_high4,
			(LCP_GMP_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT))) {
			HISI_FB_ERR("[effect]failed to copy gmp high4bit table from user\n");
			return -EINVAL;
		}

		if (copy_from_user(dst_gmp->gmp_lut_low32bit,
			lcp_src->gmp_table_low32,
			(LCP_GMP_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT))) {
			HISI_FB_ERR("[effect]failed to copy gmp low32bit table from user\n");
			return -EINVAL;
		}

		for (i = 0; i < LCP_GMP_LUT_LENGTH; i++) {
			if ((i % 500) == 0)
				HISI_FB_DEBUG("[effect] gmp_table_low32[%d]=0x%x,gmp_table_high4[%d]=0x%x\n",
					i, dst_gmp->gmp_lut_low32bit[i], i, dst_gmp->gmp_lut_high4bit[i]);
		}
	}

	return 0;
}

static int effect_dbm_save_degamma_info(struct degamma_info *dst_degamma,
	struct lcp_info *lcp_src)
{
	if (dst_degamma == NULL) {
		HISI_FB_ERR("[effect]dst_degamma is NULL!\n");
		return -EINVAL;
	}

	if (lcp_src == NULL) {
		HISI_FB_ERR("[effect]lcp_src is NULL!\n");
		return -EINVAL;
	}

	dst_degamma->degamma_enable = lcp_src->igm_enable;

	HISI_FB_DEBUG("dst_degamma->degamma_enable=%u\n", dst_degamma->degamma_enable);

	if (lcp_src->igm_enable) {
		if (copy_from_user(dst_degamma->degamma_r_lut,
			lcp_src->igm_r_table,
			LCP_IGM_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
			HISI_FB_ERR("[effect]failed to set igm_r_table!\n");
			return -EINVAL;
		}

		if (copy_from_user(dst_degamma->degamma_g_lut,
			lcp_src->igm_g_table,
			LCP_IGM_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
			HISI_FB_ERR("[effect]failed to set igm_g_table!\n");
			return -EINVAL;
		}

		if (copy_from_user(dst_degamma->degamma_b_lut,
			lcp_src->igm_b_table,
			LCP_IGM_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
			HISI_FB_ERR("[effect]failed to set igm_b_table!\n");
			return -EINVAL;
		}
	}

	return 0;
}

static int effect_dbm_save_xcc_info(struct xcc_info *dst_xcc,
	struct lcp_info *lcp_src)
{
	if (dst_xcc == NULL) {
		HISI_FB_ERR("[effect]dst_xcc is NULL!\n");
		return -EINVAL;
	}

	if (lcp_src == NULL) {
		HISI_FB_ERR("[effect]lcp_src is NULL!\n");
		return -EINVAL;
	}

	struct xcc_info *tmp_xcc = dst_xcc;

	tmp_xcc->xcc_enable = lcp_src->xcc0_enable;

	if (lcp_src->xcc0_enable) {
		if (copy_from_user(tmp_xcc->xcc_table,
			lcp_src->xcc0_table, LCP_XCC_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
			HISI_FB_ERR("[effect]failed to set xcc_table 0!\n");
			return -EINVAL;
		}
	}

	tmp_xcc = dst_xcc + 1;

	tmp_xcc->xcc_enable = lcp_src->xcc1_enable;
	if (lcp_src->xcc1_enable) {
		if (copy_from_user(tmp_xcc->xcc_table,
			lcp_src->xcc1_table, LCP_XCC_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
			HISI_FB_ERR("[effect]failed to set xcc_table 1!\n");
			return -EINVAL;
		}
	}

	return 0;
}

static void effect_dbm_gamma_lut_set_normal(struct gama_info *gama_dst,
	const struct hisi_panel_info *pinfo)
{
	if (pinfo->gamma_lut_table_R != NULL) {
		memcpy(gama_dst->gama_r_lut, pinfo->gamma_lut_table_R,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]normal mode to set gamma_r_table!\n");
	}

	if (pinfo->gamma_lut_table_G != NULL) {
		memcpy(gama_dst->gama_g_lut, pinfo->gamma_lut_table_G,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]normal mode to set gamma_g_table!\n");
	}

	if (pinfo->gamma_lut_table_B != NULL) {
		memcpy(gama_dst->gama_b_lut, pinfo->gamma_lut_table_B,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]normal mode to set gamma_b_table!\n");
	}
}

static void effect_dbm_gamma_lut_set_cinema(struct gama_info *gama_dst,
	const struct hisi_panel_info *pinfo)
{
	if (pinfo->cinema_gamma_lut_table_R != NULL) {
		memcpy(gama_dst->gama_r_lut, pinfo->cinema_gamma_lut_table_R,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]cinema mode to set gamma_r_table!\n");
	}

	if (pinfo->cinema_gamma_lut_table_G != NULL) {
		memcpy(gama_dst->gama_g_lut, pinfo->cinema_gamma_lut_table_G,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]cinema mode to set gamma_g_table!\n");
	}

	if (pinfo->cinema_gamma_lut_table_B != NULL) {
		memcpy(gama_dst->gama_b_lut, pinfo->cinema_gamma_lut_table_B,
			GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT);
		HISI_FB_DEBUG("[effect]cinema mode to set gamma_b_table!\n");
	}
}

static int effect_dbm_gamma_lut_set_user(struct gama_info *gama_dst,
	const struct gamma_info *gamma_src)
{
	if (copy_from_user(gama_dst->gama_r_lut, gamma_src->gamma_r_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_r_table from user!\n");
		return -EINVAL;
	}

	if (copy_from_user(gama_dst->gama_g_lut, gamma_src->gamma_g_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_g_table from user!\n");
		return -EINVAL;
	}

	if (copy_from_user(gama_dst->gama_b_lut, gamma_src->gamma_b_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_b_table from user!\n");
		return -EINVAL;
	}

	return 0;
}

static int effect_dbm_gamma_lut_set_user_roi(struct gama_info *gama_dst,
	const struct gamma_info *gamma_src)
{
	if (copy_from_user(gama_dst->gama_r_lut, gamma_src->gamma_roi_r_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_roi_r_table from user!\n");
		return -EINVAL;
	}

	if (copy_from_user(gama_dst->gama_g_lut, gamma_src->gamma_roi_g_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_roi_g_table from user!\n");
		return -EINVAL;
	}

	if (copy_from_user(gama_dst->gama_b_lut, gamma_src->gamma_roi_b_table,
		GAMA_LUT_LENGTH * BYTES_PER_TABLE_ELEMENT)) {
		HISI_FB_ERR("[effect]user mode failed to copy gamma_roi_b_table from user!\n");
		return -EINVAL;
	}

	return 0;
}

static int effect_dbm_gamma_lut_set(struct gama_info *gama_dst,
	struct gamma_info *gamma_src, struct hisi_panel_info *pinfo, bool roi_flag)
{
	if (gama_dst == NULL) {
		HISI_FB_ERR("[effect]gama_dst is NULL!\n");
		return -EINVAL;
	}

	if (gamma_src == NULL) {
		HISI_FB_ERR("[effect]gamma_src is NULL!\n");
		return -EINVAL;
	}

	if (pinfo == NULL) {
		HISI_FB_ERR("[effect]pinfo is NULL!\n");
		return -EINVAL;
	}

	if (gamma_src->para_mode == GAMMA_PARA_MODE_NORMAL) {
		// Normal mode
		effect_dbm_gamma_lut_set_normal(gama_dst, pinfo);
	} else if (gamma_src->para_mode == GAMMA_PARA_MODE_CINEMA) {
		// Cinema mode
		effect_dbm_gamma_lut_set_cinema(gama_dst, pinfo);
	} else if (gamma_src->para_mode == GAMMA_PARA_MODE_USER) {
		// User mode
		if (roi_flag)
			return effect_dbm_gamma_lut_set_user_roi(gama_dst, gamma_src);
		else
			return effect_dbm_gamma_lut_set_user(gama_dst, gamma_src);
	} else {
		HISI_FB_ERR("[effect]not supported gamma para_mode!\n");
		return -EINVAL;
	}

	return 0;
}

static int effect_dbm_save_gama_info(struct gama_info *gama_dst,
	struct gamma_info *gamma_src, struct hisi_panel_info *pinfo, bool roi_flag)
{
	if (gama_dst == NULL) {
		HISI_FB_ERR("[effect]gama_dst is NULL!\n");
		return -EINVAL;
	}

	if (gamma_src == NULL) {
		HISI_FB_ERR("[effect]gamma_src is NULL!\n");
		return -EINVAL;
	}

	if (pinfo == NULL) {
		HISI_FB_ERR("[effect]pinfo is NULL!\n");
		return -EINVAL;
	}

	if (roi_flag)
		gama_dst->gama_enable = gamma_src->roi_enable;
	else
		gama_dst->gama_enable = gamma_src->enable;

	gama_dst->para_mode = gamma_src->para_mode;
	if (effect_dbm_gamma_lut_set(gama_dst, gamma_src, pinfo, roi_flag) < 0)
		return -EINVAL;

	return 0;
}


static void effect_dbm_call_workqueue(struct hisi_fb_data_type *hisifd)
{
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!");
		return;
	}

	if (hisifd->effect_thread) {
		HISI_FB_DEBUG("call effect thread!\n");
		hisifd->effect_update = true;
		wake_up_interruptible(&hisifd->effect_wq);
		return;
	}

	// call queue work to config reg
	if (hisifd->gmp_lut_wq) {
		HISI_FB_DEBUG("call gmp workqueue!\n");
		queue_work(hisifd->gmp_lut_wq, &hisifd->gmp_lut_work);
	}
}

/* if success,return 0; else, return 1 */
static uint32_t effect_dbm_gmp_info_set(struct dpp_buf_maneger *dpp_buff_mngr,
	struct lcp_info *lcp_src, uint32_t buff_sel, int disp_panel_id)
{
	HISI_FB_DEBUG("[effect] +");
	int ret = 0;
	uint32_t another_buf = 0;
	struct gmp_info *dst_gmp = NULL;
	bool roi_flag = false;

	if (dpp_buff_mngr == NULL) {
		HISI_FB_ERR("[effect]dpp_buff_mngr is NULL!");
		return DPP_EFFECT_UPDATE_NONE;
	}

	if (lcp_src == NULL)
		HISI_FB_DEBUG("[effect]there is no new gmp parameters this time!");

	if (buff_sel == DPP_EXTENAL_ROI_BUF)
		roi_flag = true;

	// get dst gmp buffer to save gmp info
	dst_gmp = &(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp);
	if (lcp_src != NULL) {
		ret = effect_dbm_save_gmp_info(dst_gmp, lcp_src);
		if (ret != 0) {
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_save_status = DPP_BUF_INVALIED;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status = DPP_BUF_READY_FOR_NONE;
			HISI_FB_ERR("[effect]save gmp info fail! buff_sel:%d\n", buff_sel);
			return DPP_EFFECT_UPDATE_NONE;
		}

		// sdk updated gmp lut, driver need to config the lut reg
		dpp_buff_mngr->online_mode_available = FALSE;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_save_status = DPP_BUF_NEW_UPDATED;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status = DPP_BUF_READY_FOR_BOTH;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_effect_roi = lcp_src->effect_area.gmp_area;
	} else {
		if (!roi_flag) {
			another_buf = buff_sel ? DPP_GENERAL_BUF_0 : DPP_GENERAL_BUF_1;
			// only copy once
			if (dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp_buf_save_status != DPP_BUF_NEW_UPDATED) {
				HISI_FB_DEBUG("[effect]no need to copy! buff_sel=%d, save_status:%d!\n",
					buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp_buf_save_status);
				return DPP_EFFECT_UPDATE_NONE;
			}
			memcpy(dst_gmp, &(dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp), sizeof(*dst_gmp));

			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_effect_roi =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp_effect_roi;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp_buf_cfg_status;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_save_status = DPP_BUF_FROM_ANOTHER;
			dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gmp_buf_save_status = DPP_BUF_COPIED_ONCE;
		}
	}

	HISI_FB_DEBUG("[effect]disp_panel_id:%d gmp buff_sel:%d, roi:0x%x, cfg status:%d, save status:%d, gmp_mode:%d!\n",
		disp_panel_id, buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_effect_roi,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_save_status,dst_gmp->gmp_mode);
	return DPP_EFFECT_UPDATE_SUCCESS;
}

/* if success,return 0; else, return 1 */
static uint32_t effect_dbm_igm_info_set(struct dpp_buf_maneger *dpp_buff_mngr,
	struct lcp_info *lcp_src, uint32_t buff_sel, int disp_panel_id)
{
	struct degamma_info *dst_degamma = NULL;
	int ret;
	uint32_t another_buf = 0;
	bool roi_flag = false;

	if (dpp_buff_mngr == NULL) {
		HISI_FB_ERR("[effect]dpp_buff_mngr is NULL!");
		return DPP_EFFECT_UPDATE_NONE;
	}

	if (lcp_src == NULL)
		HISI_FB_DEBUG("[effect] there is no new igm parameters this time");

	if (buff_sel == DPP_EXTENAL_ROI_BUF)
		roi_flag = true;

	// get dst degamma buffer to save degamma info
	dst_degamma = &(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degamma);

	if (lcp_src != NULL) {
		ret = effect_dbm_save_degamma_info(dst_degamma, lcp_src);
		if (ret != 0) {
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_save_status = DPP_BUF_INVALIED;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status = DPP_BUF_READY_FOR_NONE;
			HISI_FB_ERR("[effect]save igm info fail! buff_sel:%d\n", buff_sel);
			return DPP_EFFECT_UPDATE_NONE;
		}
		// sdk updated degamma lut, driver need to config the lut reg
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_effect_roi = lcp_src->effect_area.igm_area;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status = DPP_BUF_READY_FOR_BOTH;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_save_status = DPP_BUF_NEW_UPDATED;
	} else {
		if (!roi_flag) {
			another_buf = buff_sel ? DPP_GENERAL_BUF_0 : DPP_GENERAL_BUF_1;
			if (dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degama_buf_save_status != DPP_BUF_NEW_UPDATED) {
				HISI_FB_DEBUG("[effect]no need to copy! buff_sel=%d, save_status:%d!\n",
					buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degama_buf_save_status);
				return DPP_EFFECT_UPDATE_NONE;
			}
			memcpy(dst_degamma, &(dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degamma), sizeof(*dst_degamma));

			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_effect_roi =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degama_effect_roi;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degama_buf_cfg_status;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_save_status = DPP_BUF_FROM_ANOTHER;
			dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].degama_buf_save_status = DPP_BUF_COPIED_ONCE;
		}
	}

	HISI_FB_DEBUG("[effect]degamma buff_sel:%d, roi:0x%x, cfg status:%d, save status:%d!\n",
		buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_effect_roi,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_save_status);
	return DPP_EFFECT_UPDATE_SUCCESS;
}

/* if success,return 0; else, return 1 */
static uint32_t effect_dbm_xcc_info_set(struct dpp_buf_maneger *dpp_buff_mngr, struct lcp_info *lcp_src,
	uint32_t buff_sel, int disp_panel_id)
{
	int ret;
	struct xcc_info *dst_xcc = NULL;
	uint32_t another_buf = 0;
	bool roi_flag = false;

	if (dpp_buff_mngr == NULL) {
		HISI_FB_ERR("[effect]dpp_buff_mngr is NULL!");
		return DPP_EFFECT_UPDATE_NONE;
	}

	if (lcp_src == NULL)
		HISI_FB_DEBUG("[effect] there is no new xcc parameters this time");

	if (buff_sel == DPP_EXTENAL_ROI_BUF)
		roi_flag = true;

	// get dst xcc buffer to save xcc info
	dst_xcc = dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc;

	if (lcp_src != NULL) {
		ret = effect_dbm_save_xcc_info(dst_xcc, lcp_src);
		if (ret != 0) {
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_save_status = DPP_BUF_INVALIED;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status = DPP_BUF_READY_FOR_NONE;
			HISI_FB_ERR("[effect]save xcc info fail! buff_sel:%d\n", buff_sel);
			return DPP_EFFECT_UPDATE_NONE;
		}

		// sdk updated xcc lut, driver need to config the lut reg
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc0_effect_roi = lcp_src->effect_area.xcc0_area;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc1_effect_roi = lcp_src->effect_area.xcc1_area;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_save_status = DPP_BUF_NEW_UPDATED;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status = DPP_BUF_READY_FOR_BOTH;
	} else {
		if (!roi_flag) {
			another_buf = buff_sel ? DPP_GENERAL_BUF_0 : DPP_GENERAL_BUF_1;
			if (dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc_buf_save_status != DPP_BUF_NEW_UPDATED) {
				HISI_FB_DEBUG("[effect]no need to copy! buff_sel=%d, save_status:%d!\n",
					buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc_buf_save_status);
				return DPP_EFFECT_UPDATE_NONE;
			}
			memcpy(dst_xcc, dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc, sizeof(*dst_xcc) * 2);

			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc0_effect_roi =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc0_effect_roi;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc1_effect_roi =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc1_effect_roi;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc_buf_cfg_status;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_save_status = DPP_BUF_FROM_ANOTHER;
			dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].xcc_buf_save_status = DPP_BUF_COPIED_ONCE;
		}
	}

	HISI_FB_DEBUG("[effect]xcc buff_sel:%d, roi0:0x%x, roi1:0x%x, cfg status:%d, save status:%d!\n",
		buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc0_effect_roi,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc1_effect_roi,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_save_status);
	return DPP_EFFECT_UPDATE_SUCCESS;
}

/* if success,return 0; else, return 1 */
static uint32_t effect_dbm_gamma_info_set(struct dpp_buf_maneger *dpp_buff_mngr,
	struct gamma_info *gamma_src, struct hisi_panel_info *pinfo, uint32_t buff_sel, int disp_panel_id)
{
	struct gama_info *gama_dst = NULL;
	int ret;
	uint32_t another_buf = 0;
	bool roi_flag = false;

	if (dpp_buff_mngr == NULL) {
		HISI_FB_ERR("[effect]dpp_buff_mngr is NULL!");
		return DPP_EFFECT_UPDATE_NONE;
	}

	if (gamma_src == NULL || pinfo == NULL)
		HISI_FB_DEBUG("[effect] there is no new gama parameters this time");

	if (buff_sel == DPP_EXTENAL_ROI_BUF)
		roi_flag = true;

	// get dst gama buffer to save gama info
	gama_dst = &(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama);

	if (gamma_src != NULL) {
		ret = effect_dbm_save_gama_info(gama_dst, gamma_src, pinfo, roi_flag);
		if (ret != 0) {
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_save_status = DPP_BUF_INVALIED;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status = DPP_BUF_READY_FOR_NONE;
			HISI_FB_ERR("[effect]save gama info fail! buff_sel=%d\n", buff_sel);
			return DPP_EFFECT_UPDATE_NONE;
		}

		// sdk updated gama lut, driver need to config the lut reg
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_save_status = DPP_BUF_NEW_UPDATED;
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status = DPP_BUF_READY_FOR_BOTH;
	} else {
		if (!roi_flag) {
			another_buf = buff_sel ? DPP_GENERAL_BUF_0 : DPP_GENERAL_BUF_1;
			if (dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama_buf_save_status != DPP_BUF_NEW_UPDATED) {
				HISI_FB_DEBUG("[effect]no need to copy! buff_sel=%d, save_status:%d!\n",
					buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama_buf_save_status);
				return DPP_EFFECT_UPDATE_NONE;
			}
			memcpy(gama_dst, &(dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama), sizeof(*gama_dst));

			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_effect_roi =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama_effect_roi;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status =
				dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama_buf_cfg_status;
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_save_status = DPP_BUF_FROM_ANOTHER;
			dpp_buff_mngr->buf_info_list[disp_panel_id][another_buf].gama_buf_save_status = DPP_BUF_COPIED_ONCE;
		}
	}

	HISI_FB_DEBUG("[effect]buff_sel:%d, gamma roi:0x%x, cfg status:%d, save status:%d\n",
		buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_effect_roi,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status,
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_save_status);
	return DPP_EFFECT_UPDATE_SUCCESS;
}

/*lint -e456*/
static bool effect_dbm_dpp_buf_trylock(uint32_t buff_sel, int disp_panel_id)
{
	if (buff_sel == DPP_GENERAL_BUF_0 || buff_sel == DPP_GENERAL_BUF_1) {
		return mutex_trylock(&g_dpp_buf_lock_arr[disp_panel_id][buff_sel]) != 0 ? true : false;
	} else if (buff_sel == DPP_EXTENAL_ROI_BUF) {
		return true;
	} else {
		HISI_FB_ERR("[effect]buff_sel %d is wrong!\n", buff_sel);
		return false;
	}
}

static void effect_dbm_dpp_buf_lock(uint32_t buff_sel, int disp_panel_id)
{
	if (buff_sel == DPP_GENERAL_BUF_0 || buff_sel == DPP_GENERAL_BUF_1)
		mutex_lock(&g_dpp_buf_lock_arr[disp_panel_id][buff_sel]);
	else if (buff_sel == DPP_EXTENAL_ROI_BUF)
		HISI_FB_DEBUG("[effect]buff_sel %d needn't lock!\n", buff_sel);
	else
		HISI_FB_ERR("[effect]buff_sel %d is wrong!\n", buff_sel);
}

static void effect_dbm_dpp_buf_unlock(uint32_t buff_sel, int disp_panel_id)
{
	if (buff_sel == DPP_GENERAL_BUF_0 || buff_sel == DPP_GENERAL_BUF_1)
		mutex_unlock(&g_dpp_buf_lock_arr[disp_panel_id][buff_sel]);
	else if (buff_sel == DPP_EXTENAL_ROI_BUF)
		HISI_FB_DEBUG("[effect]buff_sel %d needn't unlock!\n", buff_sel);
	else
		HISI_FB_ERR("[effect]buff_sel %d is wrong!\n", buff_sel);
}

static bool effect_dbm_dpp_chn_trylock(uint32_t dst_channel)
{
	if (dst_channel == 0)
		return mutex_trylock(&g_dpp_ch0_lock) != 0 ? true : false;
	if (dst_channel == 1)
		return mutex_trylock(&g_dpp_ch1_lock) != 0 ? true : false;

	HISI_FB_ERR("[effect]dst_channel %d is wrong!\n", dst_channel);
	return FALSE;
}

static void effect_dbm_dpp_chn_lock(uint32_t dst_channel)
{
	if (dst_channel == 0)
		mutex_lock(&g_dpp_ch0_lock);
	else if (dst_channel == 1)
		mutex_lock(&g_dpp_ch1_lock);
	else
		HISI_FB_ERR("[effect]dst_channel %d is wrong!\n", dst_channel);
}

static void effect_dbm_dpp_chn_unlock(uint32_t dst_channel)
{
	if (dst_channel == 0)
		mutex_unlock(&g_dpp_ch0_lock);
	else if (dst_channel == 1)
		mutex_unlock(&g_dpp_ch1_lock);
	else
		HISI_FB_ERR("[effect]dst_channel %d is wrong!\n", dst_channel);
}
/* lint +e454, +e455, +e456 */


static void hisi_effect_change_dpp_status(struct hisi_fb_data_type *hisifd,
	uint8_t channel_status)
{
	uint32_t dst_channel = 0;
	uint32_t *ch_status = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return;
	}

	ch_status = hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_chn_status;
	dst_channel = (g_dyn_sw_default & 0x1) ? 0 : 1;
	effect_dbm_dpp_chn_lock(dst_channel);

	*(ch_status + dst_channel) = channel_status;

	effect_dbm_dpp_chn_unlock(dst_channel);

	return;
}

static int hisi_effect_dpp_save_buf_info(struct hisi_fb_data_type *hisifd,
	struct dss_effect_info *effect_info_src, uint32_t buff_sel, bool roi_flag)
{
	uint32_t ret = DPP_EFFECT_UPDATE_NONE;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	struct hisi_panel_info *pinfo = NULL;

	dpp_buff_mngr = &(hisifd->effect_info[effect_info_src->disp_panel_id].dpp_buf);

	effect_dbm_dpp_buf_lock(buff_sel, effect_info_src->disp_panel_id);
	HISI_FB_INFO("disp_panel_id=%d buff_sel=%u roi_flag=%d gmp_mode=%u\n", effect_info_src->disp_panel_id, buff_sel, roi_flag, effect_info_src->lcp.gmp_mode);
	if ((effect_info_src->modules & DSS_EFFECT_MODULE_LCP_GMP) &&
		hisifd->effect_ctl.lcp_gmp_support)
		ret &= effect_dbm_gmp_info_set(dpp_buff_mngr, &effect_info_src->lcp, buff_sel, effect_info_src->disp_panel_id);
	else if (hisifd->effect_ctl.lcp_gmp_support)
		ret &= effect_dbm_gmp_info_set(dpp_buff_mngr, NULL, buff_sel, effect_info_src->disp_panel_id);


	if ((effect_info_src->modules & DSS_EFFECT_MODULE_LCP_IGM) &&
		hisifd->effect_ctl.lcp_igm_support)
		ret &= effect_dbm_igm_info_set(dpp_buff_mngr, &effect_info_src->lcp, buff_sel, effect_info_src->disp_panel_id);
	else if (hisifd->effect_ctl.lcp_igm_support)
		ret &= effect_dbm_igm_info_set(dpp_buff_mngr, NULL, buff_sel, effect_info_src->disp_panel_id);


	if ((effect_info_src->modules & DSS_EFFECT_MODULE_LCP_XCC) &&
		hisifd->effect_ctl.lcp_xcc_support)
		ret &= effect_dbm_xcc_info_set(dpp_buff_mngr, &effect_info_src->lcp, buff_sel, effect_info_src->disp_panel_id);
	else if (hisifd->effect_ctl.lcp_xcc_support)
		ret &= effect_dbm_xcc_info_set(dpp_buff_mngr, NULL, buff_sel, effect_info_src->disp_panel_id);


	if ((effect_info_src->modules & DSS_EFFECT_MODULE_GAMMA) &&
		(hisifd->effect_ctl.gamma_support)) {
		pinfo = &(hisifd->panel_info);
		ret &= effect_dbm_gamma_info_set(dpp_buff_mngr, &effect_info_src->gamma, pinfo, buff_sel, effect_info_src->disp_panel_id);
	} else if (hisifd->effect_ctl.gamma_support) {
		ret &= effect_dbm_gamma_info_set(dpp_buff_mngr, NULL, NULL, buff_sel, effect_info_src->disp_panel_id);
	}
	effect_dbm_dpp_buf_unlock(buff_sel, effect_info_src->disp_panel_id);

	return ret;
}

int hisi_effect_set_dpp_buf_info(struct hisi_fb_data_type *hisifd, const struct dss_effect_info * const effect_info,
	uint32_t buff_sel, bool roi_flag, int update_flag)
{
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;
	int ret = 0;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -EINVAL;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	dpp_buff_mngr = &(hisifd->effect_info[effect_info->disp_panel_id].dpp_buf);

	effect_dbm_dpp_buf_lock(buff_sel, effect_info->disp_panel_id);

	HISI_FB_DEBUG("disp_panel_id=%d buff_sel=%u roi_flag=%d update_flag=%d\n", effect_info->disp_panel_id, buff_sel, roi_flag, update_flag);

	// gmp has updated, need to call workqueue to set reg
	if (update_flag == DPP_EFFECT_UPDATE_NONE) {
		// have no effect module updated
		HISI_FB_INFO("[effect]effect_dbm_gmp_info_set fail, roi_flag=%d\n",
			roi_flag);
		effect_dbm_dpp_buf_unlock(buff_sel, effect_info->disp_panel_id);
		return -EINVAL;
	}

	if (!roi_flag)
		/* the update before dpp_latest_buf must before effect_dbm_call_workqueue */
		dpp_buff_mngr->latest_buf[effect_info->disp_panel_id] = buff_sel;

	/* We just save buf info and do not set reg if updating disp_panel_id is not current panel */
	if (effect_info->disp_panel_id != disp_panel_id) {
		effect_dbm_dpp_buf_unlock(buff_sel, effect_info->disp_panel_id);
		return 0;
	}

	{
		hisi_effect_change_dpp_status(hisifd, DPP_CHN_UPDATE_READY);
		if (dpp_buff_mngr->online_mode_available == TRUE) {
			/* if the latest gmp parameters have been congiged to both dpp chn,
			 * can use online mode config other modules.
			 */
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode = DPP_BUF_ONLINE_CONFIG;
		} else {
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode = DPP_BUF_WORKQ_CONFIG;
			effect_dbm_call_workqueue(hisifd);
		}
	}

	effect_dbm_dpp_buf_unlock(buff_sel, disp_panel_id);
	return ret;
}

int hisi_effect_dpp_buf_info_set(struct hisi_fb_data_type *hisifd,
	struct dss_effect_info *effect_info, bool roi_flag)
{
	uint32_t ret = DPP_EFFECT_UPDATE_NONE;
	uint32_t buff_sel;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -EINVAL;
	}

	if (effect_info == NULL) {
		HISI_FB_ERR("[effect]effect_info is NULL!\n");
		return -EINVAL;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] fb%d, not support!\n", hisifd->index);
		return -EINVAL;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("[effect]display effect lock is not init!\n");
		return -EINVAL;
	}

	dpp_buff_mngr = &(hisifd->effect_info[effect_info->disp_panel_id].dpp_buf);

	if (roi_flag)
		buff_sel = DPP_EXTENAL_ROI_BUF;
	else
		buff_sel = dpp_buff_mngr->latest_buf[effect_info->disp_panel_id] ? DPP_GENERAL_BUF_0 : DPP_GENERAL_BUF_1;
	HISI_FB_DEBUG("[effect]buff_sel=%d roi_flag=%d dpp_latest_buf=%d modules=0x%x! disp_panel_id=%d\n",
		buff_sel, roi_flag, dpp_buff_mngr->latest_buf[effect_info->disp_panel_id],  effect_info->modules, effect_info->disp_panel_id);

	ret = hisi_effect_dpp_save_buf_info(hisifd, effect_info, buff_sel, roi_flag);
	HISI_FB_DEBUG("save_buf_info result=%d\n", ret);

	return hisi_effect_set_dpp_buf_info(hisifd, effect_info, buff_sel, roi_flag, ret);
}

void hisi_effect_acm_set_reg(struct hisi_fb_data_type *hisifd)
{
	(void *)hisifd;
}
/*lint -e679*/

#ifdef CONFIG_HW_DSS_BOOST
#define GMP_LUT_HIGH_BITS 4
#define GMP_LUT_LOW_BITS 32
#define GMP_LUT_STEP_SHIFT 3
#define GMP_LUT_DEBUG_STEP 500
static void effect_lcp_gmp_set_reg_boost(char __iomem *gmp_lut_base,
	uint32_t *gmp_lut_low, uint32_t *gmp_lut_high)
{
	unsigned int i;
	char __iomem *addr = NULL;
	const uint32_t high_mask = (1UL << GMP_LUT_HIGH_BITS) - 1UL;
	const uint32_t high_unmask = ~high_mask;
	const uint32_t low_mask = (1UL << GMP_LUT_LOW_BITS) - 1UL;

	for (i = 0; i < LCP_GMP_LUT_LENGTH; i++) {
		addr = gmp_lut_base + (i << GMP_LUT_STEP_SHIFT);
		writel_relaxed((gmp_lut_low[i] & low_mask), addr);
		writel_relaxed((readl_relaxed(addr + sizeof(uint32_t)) &
			high_unmask) | (gmp_lut_high[i] & high_mask),
			addr + sizeof(uint32_t));
		if ((i % GMP_LUT_DEBUG_STEP) == 0)
			HISI_FB_DEBUG("[effect] gmp_table_low32[%d]=0x%x, gmp_table_high4[%d]=0x%x\n",
				i, gmp_lut_low[i], i, gmp_lut_high[i]);
	}
}
#endif

static bool effect_lcp_gmp_set_reg(char __iomem *gmp_lut_base,
	uint32_t *gmp_lut_low32, uint32_t *gmp_lut_high4)
{
	uint32_t i;

	HISI_FB_DEBUG("[effect] +\n");
	if (gmp_lut_base == NULL) {
		HISI_FB_DEBUG("[effect]gmp_lut_base is NULL!\n");
		return false;
	}

	if (gmp_lut_low32 == NULL) {
		HISI_FB_DEBUG("[effect]gmp_table_low32 is NULL!\n");
		return false;
	}
	if (gmp_lut_high4 == NULL) {
		HISI_FB_DEBUG("[effect]gmp_table_high4 is NULL!\n");
		return false;
	}
#ifdef CONFIG_HW_DSS_BOOST
	if (g_dss_boost_enabled) {
		effect_lcp_gmp_set_reg_boost(gmp_lut_base,
			gmp_lut_low32, gmp_lut_high4);
		return true;
	}
#endif
	for (i = 0; i < LCP_GMP_LUT_LENGTH; i++) {
		set_reg(gmp_lut_base + i * 2 * 4, gmp_lut_low32[i], 32, 0);
		set_reg(gmp_lut_base + i * 2 * 4 + 4, gmp_lut_high4[i], 4, 0);
		if (0 == (i % 500))
			HISI_FB_DEBUG("[effect] gmp_table_low32[%d]=%x,gmp_table_high4[%d]=%x\n",
				i, gmp_lut_low32[i], i, gmp_lut_high4[i]);
	}

	return true;
}

static void effect_lcp_igm_set_reg(char __iomem *degamma_lut_base,
	struct degamma_info *degamma)
{
	uint32_t cnt;

	if (degamma_lut_base == NULL) {
		HISI_FB_DEBUG("[effect]degamma_lut_base is NULL!\n");
		return;
	}

	if (degamma == NULL) {
		HISI_FB_DEBUG("[effect]degamma is NULL!\n");
		return;
	}

	for (cnt = 0; cnt < LCP_IGM_LUT_LENGTH; cnt = cnt + 2) {
		set_reg(degamma_lut_base + (U_DEGAMA_R_COEF + cnt * 2),
			degamma->degamma_r_lut[cnt], 12, 0);
		if (cnt != LCP_IGM_LUT_LENGTH - 1)
			set_reg(degamma_lut_base + (U_DEGAMA_R_COEF + cnt * 2),
				degamma->degamma_r_lut[cnt+1], 12, 16);

		set_reg(degamma_lut_base + (U_DEGAMA_G_COEF + cnt * 2),
			degamma->degamma_g_lut[cnt], 12, 0);
		if (cnt != LCP_IGM_LUT_LENGTH - 1)
			set_reg(degamma_lut_base + (U_DEGAMA_G_COEF + cnt * 2),
				degamma->degamma_g_lut[cnt+1], 12, 16);

		set_reg(degamma_lut_base + (U_DEGAMA_B_COEF + cnt * 2),
			degamma->degamma_b_lut[cnt], 12, 0);
		if (cnt != LCP_IGM_LUT_LENGTH - 1)
			set_reg(degamma_lut_base + (U_DEGAMA_B_COEF + cnt * 2),
				degamma->degamma_b_lut[cnt+1], 12, 16);
	}
}

static void effect_lcp_xcc_set_reg(char __iomem *xcc_base,
	struct xcc_info *xcc)
{
	int cnt;

	if (xcc_base == NULL) {
		HISI_FB_DEBUG("[effect]xcc_base is NULL!\n");
		return;
	}

	if (xcc == NULL) {
		HISI_FB_DEBUG("[effect]xcc is NULL!\n");
		return;
	}

	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++)
		set_reg(xcc_base + XCC_COEF_00 + cnt * 4, xcc->xcc_table[cnt], 17, 0);
}

static void effect_post_xcc_set_reg(char __iomem *post_xcc_base,
	struct post_xcc_info *post_xcc)
{
	int cnt;

	if (post_xcc_base == NULL) {
		HISI_FB_DEBUG("[effect]xcc_base is NULL!\n");
		return;
	}

	if (post_xcc == NULL) {
		HISI_FB_DEBUG("[effect]xcc is NULL!\n");
		return;
	}

	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++)
		set_reg(post_xcc_base + POST_XCC_COEF_00 + cnt * 4,
			post_xcc->post_xcc_table[cnt], 17, 0);
}

static void effect_reset_xcc_reg(char __iomem *xcc_base)
{
	int cnt;
	uint32_t coef_01 = 0;
	uint32_t coef_12 = 0;
	uint32_t coef_23 = 0;
	uint32_t max_coef = 0;

	if (xcc_base == NULL) {
		HISI_FB_DEBUG("[effect]xcc_base is NULL!\n");
		return;
	}

	coef_01 = inp32(xcc_base + XCC_COEF_01);
	coef_12 = inp32(xcc_base + XCC_COEF_12);
	coef_23 = inp32(xcc_base + XCC_COEF_23);
	max_coef = max(coef_01, coef_12);
	max_coef = max(max_coef, coef_23);
	if (max_coef > 0xFFFF) {
		HISI_FB_INFO("xcc coef is negative!\n");
		return;
	}
	if (max_coef != 0) {
		coef_01 = coef_01 * XCC_DEFAULT / max_coef;
		coef_12 = coef_12 * XCC_DEFAULT / max_coef;
		coef_23 = coef_23 * XCC_DEFAULT / max_coef;
	} else {
		coef_01 = XCC_DEFAULT;
		coef_12 = XCC_DEFAULT;
		coef_23 = XCC_DEFAULT;
	}
	set_reg(xcc_base + XCC_COEF_01,  coef_01, 17, 0);
	set_reg(xcc_base + XCC_COEF_12,  coef_12, 17, 0);
	set_reg(xcc_base + XCC_COEF_23,  coef_23, 17, 0);

	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++) {
		if ((cnt != XCC_COEF_INDEX_01) && (cnt != XCC_COEF_INDEX_12) &&
			(cnt != XCC_COEF_INDEX_23))
			set_reg(xcc_base + XCC_COEF_00 + cnt * 4, 0x0, 17, 0);
	}
}

void clear_xcc_table(struct hisi_fb_data_type *hisifd)
{
	char __iomem *xcc_base = NULL;
	int cnt;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is null!\n");
		return;
	}

	xcc_base = hisifd->dss_base + DSS_DPP_POST_XCC_OFFSET;

	for (cnt = 0; cnt < XCC_COEF_LEN; cnt++)
		g_post_xcc_table_temp[cnt] = inp32(xcc_base + POST_XCC_COEF_00 + cnt * 4);


	// bypass post xcc
	effect_reset_xcc_reg(xcc_base);
	g_post_xcc_enable_state = inp32(xcc_base + POST_XCC_EN);
	HISI_FB_INFO("[effect]xcc param before clear, R:0x%x G:0x%x B:0x%x Enable:%d\n",
		g_post_xcc_table_temp[1], g_post_xcc_table_temp[6],
		g_post_xcc_table_temp[11], g_post_xcc_enable_state);
}

void restore_xcc_table(struct hisi_fb_data_type *hisifd)
{
	int cnt;
	char __iomem *xcc_base = NULL;
	struct post_xcc_info *post_xcc_param = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is null!\n");
		return;
	}

	xcc_base = hisifd->dss_base + DSS_DPP_POST_XCC_OFFSET;
	post_xcc_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].post_xcc);

	if (xcc_base == NULL) {
		HISI_FB_DEBUG("[effect]lcp_base is NULL!\n");
		return;
	}

	if (post_xcc_param == NULL) {
		HISI_FB_ERR("[effect]post_xcc_param is null!\n");
		return;
	}

	if (post_xcc_param->post_xcc_table == NULL) {
		HISI_FB_DEBUG("[effect]post_xcc_table is NULL!\n");
		return;
	}

	// enable post xcc
	if (spin_can_lock(&g_post_xcc_effect_lock)) {
		spin_lock(&g_post_xcc_effect_lock);
		if (!hisifd->effect_updated_flag[hisifd->panel_info.disp_panel_id].post_xcc_effect_updated) {
			for (cnt = 0; cnt < XCC_COEF_LEN; cnt++)
				post_xcc_param->post_xcc_table[cnt] = g_post_xcc_table_temp[cnt];

			effect_post_xcc_set_reg(xcc_base, post_xcc_param);
			set_reg(xcc_base + POST_XCC_EN, g_post_xcc_enable_state, 1, 0);
		} else {
			effect_post_xcc_set_reg(xcc_base, post_xcc_param);
			set_reg(xcc_base + POST_XCC_EN, post_xcc_param->enable, 1, 0);
			hisifd->effect_updated_flag[hisifd->panel_info.disp_panel_id].post_xcc_effect_updated = FALSE;
		}
		HISI_FB_INFO("[effect]post_xcc param after restore,"
			" R:0x%x G:0x%x B:0x%x Enable:%d\n",
			post_xcc_param->post_xcc_table[1], post_xcc_param->post_xcc_table[6],
			post_xcc_param->post_xcc_table[11], inp32(xcc_base + POST_XCC_EN));
		spin_unlock(&g_post_xcc_effect_lock);
	} else {
		HISI_FB_INFO("[effect]post_xcc effect param is being updated,"
			" delay set reg to next frame!\n");
	}

}

void hisi_effect_gamma_set_reg(struct hisi_fb_data_type *hisifd)
{
	(void *)hisifd;
}

void hisi_effect_post_xcc_set_reg(struct hisi_fb_data_type *hisifd)
{
	struct dss_effect *effect = NULL;
	char __iomem *post_xcc_base = NULL;
	struct post_xcc_info *post_xcc_param = NULL;
	uint32_t cnt = 0;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!");
		return;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("[effect]display effect lock is not init!\n");
		return;
	}

	effect = &hisifd->effect_ctl;
	post_xcc_base = hisifd->dss_base + DSS_DPP_POST_XCC_OFFSET;

	post_xcc_param = &(hisifd->effect_info[hisifd->panel_info.disp_panel_id].post_xcc);
	if (post_xcc_param == NULL) {
		HISI_FB_ERR("[effect]post_xcc_param is NULL!");
		return;
	}

	// Update POST XCC Coef
	if (effect->post_xcc_support &&
		hisifd->effect_updated_flag[hisifd->panel_info.disp_panel_id].post_xcc_effect_updated &&
		!hisifd->mask_layer_xcc_flag &&
		hisifd->dirty_region_updt_enable == 0) {
		if (spin_can_lock(&g_post_xcc_effect_lock)) {
			spin_lock(&g_post_xcc_effect_lock);
			if (post_xcc_param->post_xcc_table == NULL) {
				HISI_FB_ERR("[effect]post_xcc_table is NULL!\n");
				spin_unlock(&g_post_xcc_effect_lock);
				hisifd->effect_updated_flag[hisifd->panel_info.disp_panel_id].post_xcc_effect_updated = false;
				return;
			}

			for (cnt = 0; cnt < POST_XCC_LUT_LENGTH; cnt++)
				set_reg(post_xcc_base + POST_XCC_COEF_00 + cnt * 4,
					post_xcc_param->post_xcc_table[cnt], 17, 0);


			set_reg(post_xcc_base + POST_XCC_EN, post_xcc_param->enable, 1, 0);
			dc_switch_xcc_updated =
				(hisifd->de_info.amoled_param.dc_brightness_dimming_enable_real !=
				hisifd->de_info.amoled_param.dc_brightness_dimming_enable) ||
				(hisifd->de_info.amoled_param.amoled_diming_enable !=
				hisifd->de_info.amoled_param.amoled_enable_from_hal);
			hisifd->effect_updated_flag[hisifd->panel_info.disp_panel_id].post_xcc_effect_updated = false;
			spin_unlock(&g_post_xcc_effect_lock);
		} else {
			HISI_FB_INFO("[effect]post_xcc effect param is being updated,"
				" delay set reg to next frame!\n");
		}
	}
}

void hisi_dss_dpp_hiace_set_reg(struct hisi_fb_data_type *hisifd)
{
	char __iomem *hiace_base = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_ce_info_t *ce_info = NULL;
	int x_partition = 6;
	uint32_t gamma_ab_shadow;
	int gamma_ab_work = 0;
	time_interval_t interval_lut = {0};
	static delay_record_t delay_lut = { "lut writing", 0, 0xFFFFFFFF, 0, 0 };

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return;
	}

	if (hisifd->dss_base == NULL) {
		HISI_FB_ERR("[effect]dss_base is NULL\n");
		return;
	}

	if (hisifd->panel_info.hiace_support == 0) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME)
			DEBUG_EFFECT_LOG("[effect]HIACE is not support!\n");

		return;
	}

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		ce_ctrl = &(hisifd->ce_ctrl);
		ce_info = &(hisifd->hiace_info[hisifd->panel_info.disp_panel_id]);
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
		if ((hisifd->ov_req.video_idle_status) ||
			(hisifd->ov_req_prev.video_idle_status))
			return;
	} else {
		HISI_FB_ERR("[effect]fb%d, not support!\n", hisifd->index);
		return;
	}

	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] g_enable_effect is %d, ctrl_ce_mode is %d. algorithm_result=%d\n",
		g_enable_effect, ce_ctrl->ctrl_ce_mode, ce_info->algorithm_result);

	if (!(g_enable_effect & ENABLE_EFFECT_HIACE) ||
		ce_ctrl->ctrl_ce_mode == CE_MODE_DISABLE) {
		if (g_debug_effect & DEBUG_EFFECT_FRAME)
			DEBUG_EFFECT_LOG("[effect]g_enable_effect is %d, ctrl_ce_mode is %d.\n",
						g_enable_effect, ce_ctrl->ctrl_ce_mode);

		return;
	}

	//lint -e{438}
	gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x1;
	if (ce_info->algorithm_result == 0 &&
		hisifd->hiace_info[hisifd->panel_info.disp_panel_id].lut_table != NULL) {
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x1;
		HISI_FB_DEBUG("[effect]start set hiace lut! gamma_ab_shadow=%d,"
			"gamma_ab_work=%d,g_sel_gamma_ab_shadow_hdr_lut=%d\n",
			gamma_ab_shadow, gamma_ab_work, g_sel_gamma_ab_shadow_hdr_lut);
		if (gamma_ab_shadow == gamma_ab_work) {
			int i = 0;

			/* write gamma lut */
			set_reg(hiace_base + DPE_GAMMA_EN, 1, 1, 31);

			if (g_debug_effect & DEBUG_EFFECT_DELAY)
				interval_lut.start = get_timestamp_in_us();

			mutex_lock(&ce_info->lut_lock);
			for (i = 0; i < (6 * x_partition * 8); i++)
				outp32(hiace_base + DPE_GAMMA_VxHy_3z2_3z1_3z_W,
					hisifd->hiace_info[hisifd->panel_info.disp_panel_id].lut_table[i]);

			mutex_unlock(&ce_info->lut_lock);

			if (g_debug_effect & DEBUG_EFFECT_DELAY) {
				interval_lut.stop = get_timestamp_in_us();
				count_delay(&delay_lut, interval_lut.stop - interval_lut.start);
			}

			set_reg(hiace_base + DPE_GAMMA_EN, 0, 1, 31);

			gamma_ab_shadow ^= 1;
		}

		ce_info->algorithm_result = 1;
	}
	set_reg(hiace_base + DPE_GAMMA_AB_SHADOW,
		(gamma_ab_shadow & 0x1) | (g_sel_gamma_ab_shadow_hdr_lut & 0xe), 4, 0);
}

/*
 * dppsw:0x20101 ifbcsw:0x403
 * ICH_0---DPP_0----OCH_0
 *      \----DPP_1---/
 */
static void effect_dpp_ch_both_connect(struct hisi_fb_data_type *hisifd,
	char __iomem *disp_glb_base)
{
	uint32_t sw_sig_ctrl;
	uint32_t sw_dat_ctrl;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return;
	}

	if (disp_glb_base == NULL) {
		HISI_FB_ERR("[effect]disp_glb_base is NULL\n");
		return;
	}

	sw_sig_ctrl = inp32(disp_glb_base + DPPSW_SIG_CTRL);
	sw_dat_ctrl = inp32(disp_glb_base + DPPSW_DAT_CTRL);
	// sw_sig_ctrl must equle to sw_dat_ctrl, and must be 0x20101, if not, re-config
	if ((sw_sig_ctrl != sw_dat_ctrl) || (sw_dat_ctrl != 0x20101)) {
		hisifd->set_reg(hisifd, disp_glb_base + DPPSW_SIG_CTRL, 0x20101, 32, 0);
		hisifd->set_reg(hisifd, disp_glb_base + DPPSW_DAT_CTRL, 0x20101, 32, 0);
	}

	sw_sig_ctrl = inp32(disp_glb_base + IFBCSW_SIG_CTRL);
	sw_dat_ctrl = inp32(disp_glb_base + IFBCSW_DAT_CTRL);
	// sw_sig_ctrl must equle to sw_dat_ctrl, and must be 0x403, if not, re-config
	if ((sw_sig_ctrl != sw_dat_ctrl) || (sw_dat_ctrl != 0x403)) {
		hisifd->set_reg(hisifd, disp_glb_base + IFBCSW_SIG_CTRL, 0x403, 32, 0);
		hisifd->set_reg(hisifd, disp_glb_base + IFBCSW_DAT_CTRL, 0x403, 32, 0);
	}
}

int effect_dpp_ch_config_roi(struct hisi_fb_data_type *hisifd,
	char __iomem *disp_glb_base)
{
	struct roi_rect *roi = NULL;
	uint32_t i;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return -EINVAL;
	}

	if (disp_glb_base == NULL) {
		HISI_FB_ERR("[effect]disp_glb_base is NULL\n");
		return -EINVAL;
	}

	roi = hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_buf.buf_roi_region;

	for (i = 0; i < DPP_BUF_ROI_REGION_COUNT; i++) {
		hisifd->set_reg(hisifd, disp_glb_base + ROI1_TOP_LEFT + (8 * i),
			((roi[i].top_left_y << 16) | (roi[i].top_left_x & 0x1fff)), 32, 0);
		hisifd->set_reg(hisifd, disp_glb_base + ROI1_BOTTOM_RIGHT + (8 * i),
			((roi[i].bottom_right_y << 16) | (roi[i].bottom_right_x & 0x1fff)), 32, 0);
		if (g_dpp_cmdlist_delay == CMDLIST_DELAY_STATUS_COUNT)
			g_dpp_cmdlist_delay = CMDLIST_DELAY_STATUS_ENABLE;
		HISI_FB_DEBUG("[effect]roi config [%d, %d, %d, %d]\n",
			roi[i].top_left_x, roi[i].top_left_y,
			roi[i].bottom_right_x, roi[i].bottom_right_y);
	}


	hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_buf.roi_new_updated = false;

	return 0;
}

static int effect_dpp_ch_config_gmp(struct hisi_fb_data_type *hisifd,
	uint32_t config_ch, uint32_t buff_sel)
{
	uint32_t gmp_enable;
	char __iomem *gmp_base = NULL;
	char __iomem *gmp_lut_base = NULL;
	struct gmp_info *gmp = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return -EINVAL;
	}
	if (hisifd->effect_ctl.lcp_gmp_support != true) {
		HISI_FB_DEBUG("[effect]gmp is not support!");
		return -EINVAL;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_save_status == DPP_BUF_INVALIED) {
		HISI_FB_DEBUG("[effect]gmp_buf_save_status is valid!"
			" buff_sel = %d, config_ch = %d\n",
			buff_sel, config_ch);
		return 0;
	}

	if (!(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status & (1 << config_ch))) {
		HISI_FB_DEBUG("[effect]gmp no need to config!");
		return 0;
	}

	gmp_base = hisifd->dss_base + DSS_DPP_GMP_OFFSET + config_ch * 0x40000;
	gmp_lut_base = hisifd->dss_base + DSS_DPP_GMP_LUT_OFFSET + config_ch * 0x10000;
	gmp = &(hisifd->effect_info[disp_panel_id].dpp_buf.buf_info_list[disp_panel_id][buff_sel].gmp);

	gmp_enable = gmp->gmp_mode & GMP_ENABLE;
	if (gmp_enable) {
		bool ret = effect_lcp_gmp_set_reg(gmp_lut_base,
			gmp->gmp_lut_low32bit, gmp->gmp_lut_high4bit);
		if (ret)
			set_reg(gmp_base + GMP_EN, gmp_enable, 1, 0);

		if (gmp->gmp_mode & GMP_LAST_PARAM_SCENE)
			gmp->gmp_mode &= ~GMP_LAST_PARAM_SCENE;
	} else {
		// disable  GMP
		set_reg(gmp_base + GMP_EN, gmp_enable, 1, 0);
	}

	dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status &= ~((uint32_t)1 << config_ch);
	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp_buf_cfg_status == DPP_BUF_READY_FOR_NONE)
		dpp_buff_mngr->online_mode_available = TRUE;

	return 0;
}

static int effect_dpp_ch_config_degamma(struct hisi_fb_data_type *hisifd,
	uint32_t config_ch, uint32_t buff_sel)
{
	uint32_t degamma_enable;
	char __iomem *degamma_base = NULL;
	char __iomem *degamma_lut_base = NULL;
	struct degamma_info *degamma = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->effect_ctl.lcp_igm_support != true) {
		HISI_FB_DEBUG("[effect]degamma is not support!");
		return 0;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_save_status == DPP_BUF_INVALIED) {
		HISI_FB_DEBUG("[effect]degama_buf_save_status is valid!"
			" buff_sel = %d, config_ch = %d\n", buff_sel, config_ch);
		return 0;
	}

	if (!(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status & (1 << config_ch))) {
		HISI_FB_DEBUG("[effect]degamma no need to config config_ch=%d!", config_ch);
		return 0;
	}

	degamma_base = hisifd->dss_base + DSS_DPP_DEGAMMA_OFFSET + config_ch * 0x40000;
	degamma_lut_base = hisifd->dss_base + DSS_DPP_DEGAMMA_LUT_OFFSET + config_ch * 0x40000;
	degamma = &(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degamma);

	degamma_enable = degamma->degamma_enable;
	if (degamma_enable)
		effect_lcp_igm_set_reg(degamma_lut_base, degamma);

	set_reg(degamma_base + DEGAMA_EN, degamma->degamma_enable, 1, 0);

	dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].degama_buf_cfg_status &= ~((uint32_t)1 << config_ch);

	return 0;
}

static int effect_dpp_ch_config_xcc(struct hisi_fb_data_type *hisifd,
	uint32_t config_ch, uint32_t buff_sel, bool roi_mode)
{
	uint32_t xcc_enable;
	char __iomem *xcc_base = NULL;
	struct xcc_info *xcc = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->effect_ctl.lcp_xcc_support != true) {
		HISI_FB_DEBUG("[effect]xcc is not support!");
		return 0;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_save_status == DPP_BUF_INVALIED) {
		HISI_FB_DEBUG("[effect]xcc_buf_save_status is valid!"
			" buff_sel = %d, config_ch = %d\n", buff_sel, config_ch);
		return 0;
	}

	if (!hisifd->mask_layer_xcc_flag &&
		!(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status & (1 << config_ch))) {
		HISI_FB_DEBUG("[effect]xcc no need to config!");
		return 0;
	}

	xcc_base = hisifd->dss_base + DSS_DPP_XCC_OFFSET + config_ch * 0x40000;
	xcc = dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc;

	xcc_enable = xcc->xcc_enable;
	if (xcc_enable)
		effect_lcp_xcc_set_reg(xcc_base, xcc);

	set_reg(xcc_base + XCC_EN, xcc->xcc_enable, 1, 0);

	dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].xcc_buf_cfg_status &= ~((uint32_t)1 << config_ch);

	return 0;
}

static void effect_dpp_ch_gama_lut(char __iomem *gama_lut_base,
	struct gama_info *gama)
{
	uint32_t cnt;

	if (gama_lut_base == NULL) {
		HISI_FB_ERR("[effect]gama_lut_base is NULL\n");
		return;
	}

	if (gama == NULL) {
		HISI_FB_ERR("[effect]gama is NULL\n");
		return;
	}

	for (cnt = 0; cnt < GAMA_LUT_LENGTH; cnt = cnt + 2) {
		set_reg(gama_lut_base + (U_GAMA_R_COEF + cnt * 2),
			gama->gama_r_lut[cnt], 12, 0);
		if (cnt != GAMA_LUT_LENGTH - 1)
			set_reg(gama_lut_base + (U_GAMA_R_COEF + cnt * 2),
				gama->gama_r_lut[cnt+1], 12, 16);

		set_reg(gama_lut_base + (U_GAMA_G_COEF + cnt * 2),
			gama->gama_g_lut[cnt], 12, 0);
		if (cnt != GAMA_LUT_LENGTH - 1)
			set_reg(gama_lut_base + (U_GAMA_G_COEF + cnt * 2),
				gama->gama_g_lut[cnt+1], 12, 16);

		set_reg(gama_lut_base + (U_GAMA_B_COEF + cnt * 2),
			gama->gama_b_lut[cnt], 12, 0);
		if (cnt != GAMA_LUT_LENGTH - 1)
			set_reg(gama_lut_base + (U_GAMA_B_COEF + cnt * 2),
				gama->gama_b_lut[cnt+1], 12, 16);
	}
}

static int effect_dpp_ch_config_gama(struct hisi_fb_data_type *hisifd,
	uint32_t config_ch, uint32_t buff_sel)
{
	uint32_t gama_enable;
	char __iomem *gama_base = NULL;
	char __iomem *gama_lut_base = NULL;
	struct gama_info *gama = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL\n");
		return -EINVAL;
	}

	if (hisifd->effect_ctl.gamma_support != true) {
		HISI_FB_DEBUG("[effect]gama is not support!");
		return 0;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_save_status == DPP_BUF_INVALIED) {
		HISI_FB_DEBUG("[effect]gama_buf_save_status is valid! buff_sel = %d, config_ch = %d\n", buff_sel, config_ch);
		return 0;
	}

	if (!(dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status & (1 << config_ch))) {
		HISI_FB_DEBUG("[effect]gama no need to config config_ch=%d!", config_ch);
		return 0;
	}

	gama_base = hisifd->dss_base + DSS_DPP_GAMA_OFFSET + config_ch * 0x40000;
	gama_lut_base = hisifd->dss_base + DSS_DPP_GAMA_LUT_OFFSET + config_ch * 0x40000;
	gama = &(hisifd->effect_info[disp_panel_id].dpp_buf.buf_info_list[disp_panel_id][buff_sel].gama);

	gama_enable = gama->gama_enable;
	HISI_FB_DEBUG("[effect] gama_enable=%d!", gama_enable);
	if (gama_enable)
		effect_dpp_ch_gama_lut(gama_lut_base, gama);

	set_reg(gama_base + GAMA_EN, gama->gama_enable, 1, 0);

	dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gama_buf_cfg_status &= ~((uint32_t)1 << config_ch);

	return 0;
}

void hisi_effect_dpp_sw_channel(struct hisi_fb_data_type *hisifd,
	char __iomem *disp_glb_base, uint32_t buff_sel)
{
	uint32_t dst_channel = 0;
	uint32_t *ch_status = NULL;
	struct gmp_info *gmp = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	ch_status = hisifd->effect_info[disp_panel_id].dpp_chn_status;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (effect_dbm_dpp_buf_trylock(buff_sel, disp_panel_id)) {
		dst_channel = (inp32(disp_glb_base + DYN_SW_DEFAULT) & 0x1) ? 0 : 1;

		// the workqueue is doing the config to this channel
		if (effect_dbm_dpp_chn_trylock(dst_channel)) {
			gmp = &(hisifd->effect_info[disp_panel_id].dpp_buf.buf_info_list[disp_panel_id][buff_sel].gmp);
			HISI_FB_DEBUG("[effect]1 buf_sel=%d, dst_channel=%d, "
				"dst_ch_status=%d, another_ch_status=%d, gmp_mode=%d\n",
				buff_sel, dst_channel, *(ch_status + dst_channel),
				*(ch_status + ((~dst_channel) & 0x1)), gmp->gmp_mode);

			{
				if ((*(ch_status + dst_channel) == DPP_CHN_CONFIG_DOING) ||
					(*(ch_status + dst_channel) == DPP_CHN_NEED_CONFIG)) {
					HISI_FB_DEBUG("this channel status is %d, this channel no need chang\n",
						*(ch_status + dst_channel));
					goto nor_exit;
				}

				// this channel is config ready or configing in other place, so do nothing and return
				if (*(ch_status + dst_channel) == DPP_CHN_CONFIG_READY) {
					HISI_FB_DEBUG("this channel status is %d, workqueue has done,"
						"gmp_mode:%d, gmp_call_wq_scene:%d	dts:(%d)\n",
						*(ch_status + dst_channel), gmp->gmp_mode,
						dpp_buff_mngr->gmp_call_wq_scene, dst_channel);
					hisifd->set_reg(hisifd, disp_glb_base + DYN_SW_DEFAULT, dst_channel, 1, 0);
					g_dyn_sw_default = dst_channel;
					*(ch_status + ((~dst_channel) & 0x1)) = DPP_CHN_NEED_CONFIG;
					goto nor_exit;
				}

				if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode == DPP_BUF_WORKQ_CONFIG) {
					HISI_FB_DEBUG("this buf:%d is workqueue config mode! the dst_channel:%d status is %d\n",
						buff_sel, dst_channel, *(ch_status + dst_channel));
					goto nor_exit;
				}

				*(ch_status + dst_channel) = DPP_CHN_CONFIG_DOING;

				if (effect_dpp_ch_config_degamma(hisifd, dst_channel, buff_sel))
					goto err_exit;

				if (effect_dpp_ch_config_gama(hisifd, dst_channel, buff_sel))
					goto err_exit;

				if (effect_dpp_ch_config_xcc(hisifd, dst_channel, buff_sel, false))
					goto err_exit;

				*(ch_status + dst_channel) = DPP_CHN_CONFIG_READY;
				*(ch_status + ((~dst_channel) & 0x1)) = DPP_CHN_NEED_CONFIG;

				// switch dpp channel
				hisifd->set_reg(hisifd, disp_glb_base + DYN_SW_DEFAULT, dst_channel, 1, 0);
				g_dyn_sw_default = dst_channel;
				goto nor_exit;
			}
		}  else {
			HISI_FB_INFO("[effect] latest_buf:%d, dst_channel %d is being updated,"
				" delay set reg to next frame!\n", buff_sel, dst_channel);
			goto non_exit;
		}
	} else {
		HISI_FB_INFO("[effect] lcp buff %d is being updated,"
			" delay set reg to next frame!\n", buff_sel);
	}

	return;

err_exit:
	HISI_FB_INFO("[effect] dpp config error");
	*(ch_status + dst_channel) = DPP_CHN_NEED_CONFIG;

nor_exit:
	HISI_FB_DEBUG("[effect]2 buf_sel=%d, dst_channel=%d,"
		" dst_ch_status=%d, another_ch_status=%d\n",
		buff_sel, dst_channel, *(ch_status + dst_channel),
		*(ch_status + ((~dst_channel) & 0x1)));
	effect_dbm_dpp_chn_unlock(dst_channel);

non_exit:
	effect_dbm_dpp_buf_unlock(buff_sel, disp_panel_id);
	return;
}

void hisi_effect_roi_region_config(struct hisi_fb_data_type *hisifd)
{
	char __iomem *disp_glb_base = NULL;

	disp_glb_base = hisifd->dss_base + DSS_DISP_GLB_OFFSET;

	spin_lock(&g_dpproi_effect_lock);
	// config roi  region
	HISI_FB_DEBUG("roi_new_updated is %d\n",
		hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_buf.roi_new_updated);
	if (hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_buf.roi_new_updated)
		(void)effect_dpp_ch_config_roi(hisifd, disp_glb_base);
	spin_unlock(&g_dpproi_effect_lock);
}

void hisi_effect_lcp_set_reg(struct hisi_fb_data_type *hisifd)
{
	uint32_t buff_sel;
	char __iomem *disp_glb_base = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!");
		return;
	}

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_INFO("[effect]fb%d not surpport!\n", hisifd->index);
		return;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return;
	}

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	disp_glb_base = hisifd->dss_base + DSS_DISP_GLB_OFFSET;
	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	// check dpp config status, make sure both dpp is connectted
	effect_dpp_ch_both_connect(hisifd, disp_glb_base);

	hisi_effect_roi_region_config(hisifd);


	down(&hisifd->effect_gmp_sem);

	// in dync switch config mode
	buff_sel = dpp_buff_mngr->latest_buf[disp_panel_id];
	if (buff_sel >= DPP_BUF_MAX_COUNT) {
		HISI_FB_INFO("[effect] select buffer %d\n", buff_sel);
		goto exit;
	}

	/* last gmp queue work not work because panel is power off,
	 * so call gmp queue work here to config reg  again.
	 */
	if (hisifd->gmp_lut_wq &&
		((dpp_buff_mngr->gmp_call_wq_scene & GMP_PANEL_OFF_SCENE) ||
		(dpp_buff_mngr->gmp_call_wq_scene & GMP_LAST_PARAM_SCENE))) {
		HISI_FB_INFO("[effect] scene=%d,call gmp workqueue again!\n",
			dpp_buff_mngr->gmp_call_wq_scene);
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode = DPP_BUF_WORKQ_CONFIG;
		effect_dbm_call_workqueue(hisifd);
	}

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode != DPP_BUF_WORKQ_CONFIG &&
		dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode != DPP_BUF_ONLINE_CONFIG) {
		HISI_FB_DEBUG("[effect] buff_sel=%d, dpp_config_mode=%d not ready\n",
			buff_sel, dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode);
		goto exit;
	}

	hisi_effect_dpp_sw_channel(hisifd, disp_glb_base, buff_sel);

exit:
	up(&hisifd->effect_gmp_sem);
	return;
}

void hisifb_effect_dpp_config(struct hisi_fb_data_type *hisifd, bool enable_cmdlist)
{
	uint32_t buff_sel;
	uint32_t dst_channel;
	uint32_t *ch_status = NULL;
	struct dpp_buf_maneger *dpp_buff_mngr = NULL;
	char __iomem *disp_glb_base = NULL;
	uint32_t gmp_mode;
	int disp_panel_id;

	if (hisifd->index != PRIMARY_PANEL_IDX) {
		HISI_FB_ERR("[effect] not primary panel\n");
		return;
	}

	down(&hisifd->blank_sem_effect_gmp);

	disp_panel_id = hisifd->panel_info.disp_panel_id;
	disp_glb_base = hisifd->dss_base + DSS_DISP_GLB_OFFSET;

	dpp_buff_mngr = &(hisifd->effect_info[disp_panel_id].dpp_buf);

	if (!hisifd->panel_power_on) {
		HISI_FB_INFO("[effect] fb%d, panel is power off!\n", hisifd->index);
		dpp_buff_mngr->gmp_call_wq_scene |= GMP_PANEL_OFF_SCENE;
		up(&hisifd->blank_sem_effect_gmp);
		return;
	}

	hisifb_activate_vsync(hisifd);
	down(&hisifd->effect_gmp_sem);

	ch_status = hisifd->effect_info[disp_panel_id].dpp_chn_status;
	buff_sel = dpp_buff_mngr->latest_buf[disp_panel_id];

	if (buff_sel >= DPP_BUF_MAX_COUNT) {
		HISI_FB_INFO("[effect] select buffer %d\n", buff_sel);
		goto exit;
	}

	if (dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode != DPP_BUF_WORKQ_CONFIG) {
		HISI_FB_INFO("[effect] dpp buffer config mode %d is not correct\n",
			dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].dpp_config_mode);
		goto exit;
	}


	effect_dbm_dpp_buf_lock(buff_sel, disp_panel_id);

	// check dpp config status, make sure both dpp is connectted
	effect_dpp_ch_both_connect(hisifd, disp_glb_base);

	// chosse channel to config effect
	dst_channel = (g_dyn_sw_default & 0x1) ? 0 : 1;
	effect_dbm_dpp_chn_lock(dst_channel);
	gmp_mode = dpp_buff_mngr->buf_info_list[disp_panel_id][buff_sel].gmp.gmp_mode;
	HISI_FB_DEBUG("[effect]1 buf_sel=%d, dst_channel=%d, dst_ch_status=%d,"
		"another_ch_status=%d, gmp_mode=%d, gmp_call_wq_scene=%d\n",
		buff_sel, dst_channel, *(ch_status + dst_channel),
		*(ch_status + ((~dst_channel) & 0x1)), gmp_mode,
		dpp_buff_mngr->gmp_call_wq_scene);

	if (*(ch_status + dst_channel) != DPP_CHN_UPDATE_READY ||
		g_dyn_sw_default != inp32(disp_glb_base + DYN_SW_DEFAULT)) {
		HISI_FB_DEBUG("this channel status is %d,not ready for config!\n",
			*(ch_status + dst_channel));
		if ((gmp_mode & GMP_ENABLE) && (gmp_mode & GMP_LAST_PARAM_SCENE))
			dpp_buff_mngr->gmp_call_wq_scene |= GMP_LAST_PARAM_SCENE;
		effect_dbm_dpp_chn_unlock(dst_channel);
		effect_dbm_dpp_buf_unlock(buff_sel, disp_panel_id);
		goto exit;
	}

	*(ch_status + dst_channel) = DPP_CHN_CONFIG_DOING;

	if (effect_dpp_ch_config_degamma(hisifd, dst_channel, buff_sel))
		goto err_ret;

	if (effect_dpp_ch_config_gama(hisifd, dst_channel, buff_sel))
		goto err_ret;

	if (effect_dpp_ch_config_xcc(hisifd, dst_channel, buff_sel, false))
		goto err_ret;

	if (effect_dpp_ch_config_gmp(hisifd, dst_channel, buff_sel))
		goto err_ret;

	*(ch_status + dst_channel) = DPP_CHN_CONFIG_READY;
	*(ch_status + ((~dst_channel) & 0x1)) = DPP_CHN_NEED_CONFIG;
	dpp_buff_mngr->gmp_call_wq_scene = 0;

	HISI_FB_DEBUG("[effect]2 buf_sel=%d, dst_channel=%d, dst_ch_status=%d,"
		"another_ch_status=%d, gmp_mode=%d, gmp_call_wq_scene=%d\n",
		buff_sel, dst_channel, *(ch_status + dst_channel),
		*(ch_status + ((~dst_channel) & 0x1)), gmp_mode,
		dpp_buff_mngr->gmp_call_wq_scene);

	effect_dbm_dpp_chn_unlock(dst_channel);
	effect_dbm_dpp_buf_unlock(buff_sel, disp_panel_id);

	goto exit;
err_ret:
	*(ch_status + dst_channel) = DPP_CHN_NEED_CONFIG;
	HISI_FB_DEBUG("[effect]3 buf_sel=%d, dst_channel=%d, dst_ch_status=%d,"
		"another_ch_status=%d, gmp_mode=%d, gmp_call_wq_scene=%d\n",
		buff_sel, dst_channel, *(ch_status + dst_channel),
		*(ch_status + ((~dst_channel) & 0x1)), gmp_mode,
		dpp_buff_mngr->gmp_call_wq_scene);

	effect_dbm_dpp_chn_unlock(dst_channel);
	effect_dbm_dpp_buf_unlock(buff_sel, disp_panel_id);

exit:
	up(&hisifd->effect_gmp_sem);
	hisifb_deactivate_vsync(hisifd);
	up(&hisifd->blank_sem_effect_gmp);
}

void hisifb_effect_gmp_lut_workqueue_handler(struct work_struct *work)
{
	struct hisi_fb_data_type *hisifd = NULL;

	if (work == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}
	hisifd = container_of(work, struct hisi_fb_data_type, gmp_lut_work);
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return;
	}

	hisifb_effect_dpp_config(hisifd, false);
}

void hisi_effect_color_dimming_acm_reg_init(struct hisi_fb_data_type *hisifd)
{
	(void *)hisifd;
}

#define ARSR1P_MIN_SIZE 16
#define ARSR1P_MAX_SIZE 8192
#define ARSR1P_MAX_SRC_WIDTH_SIZE 3840

static void effect_arsr_post_config_param(dss_arsr1p_t *dst_arsr1p,
	struct arsr1p_info *src_arsr1p)
{
	if (dst_arsr1p == NULL) {
		HISI_FB_ERR("[effect]dst_arsr1p is NULL!");
		return;
	}

	if (src_arsr1p == NULL) {
		HISI_FB_ERR("[effectsrc_arsr1p is NULL!");
		return;
	}

	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, ~src_arsr1p->enable, 1, 0);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->sharp_enable, 1, 1);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->shoot_enable, 1, 2);
	dst_arsr1p->mode = set_bits32(dst_arsr1p->mode, src_arsr1p->skin_enable, 1, 3);

	dst_arsr1p->skin_thres_y = src_arsr1p->skin_thres_y;
	dst_arsr1p->skin_thres_u = src_arsr1p->skin_thres_u;
	dst_arsr1p->skin_thres_v = src_arsr1p->skin_thres_v;
	dst_arsr1p->skin_cfg0 = src_arsr1p->skin_cfg0;
	dst_arsr1p->skin_cfg1 = src_arsr1p->skin_cfg1;
	dst_arsr1p->skin_cfg2 = src_arsr1p->skin_cfg2;
	dst_arsr1p->shoot_cfg1 = src_arsr1p->shoot_cfg1;
	dst_arsr1p->shoot_cfg2 = src_arsr1p->shoot_cfg2;
	dst_arsr1p->shoot_cfg3 = src_arsr1p->shoot_cfg3;

	dst_arsr1p->sharp_cfg3 = src_arsr1p->sharp_cfg3;
	dst_arsr1p->sharp_cfg4 = src_arsr1p->sharp_cfg4;
	dst_arsr1p->sharp_cfg5 = src_arsr1p->sharp_cfg5;
	dst_arsr1p->sharp_cfg6 = src_arsr1p->sharp_cfg6;
	dst_arsr1p->sharp_cfg7 = src_arsr1p->sharp_cfg7;
	dst_arsr1p->sharp_cfg8 = src_arsr1p->sharp_cfg8;

	dst_arsr1p->sharp_level = src_arsr1p->sharp_level;
	dst_arsr1p->sharp_gain_low = src_arsr1p->sharp_gain_low;
	dst_arsr1p->sharp_gain_mid = src_arsr1p->sharp_gain_mid;
	dst_arsr1p->sharp_gain_high = src_arsr1p->sharp_gain_high;
	dst_arsr1p->sharp_gainctrl_sloph_mf = src_arsr1p->sharp_gainctrl_sloph_mf;
	dst_arsr1p->sharp_gainctrl_slopl_mf = src_arsr1p->sharp_gainctrl_slopl_mf;
	dst_arsr1p->sharp_gainctrl_sloph_hf = src_arsr1p->sharp_gainctrl_sloph_hf;
	dst_arsr1p->sharp_gainctrl_slopl_hf = src_arsr1p->sharp_gainctrl_slopl_hf;
	dst_arsr1p->sharp_mf_lmt = src_arsr1p->sharp_mf_lmt;
	dst_arsr1p->sharp_gain_mf = src_arsr1p->sharp_gain_mf;
	dst_arsr1p->sharp_mf_b = src_arsr1p->sharp_mf_b;
	dst_arsr1p->sharp_hf_lmt = src_arsr1p->sharp_hf_lmt;
	dst_arsr1p->sharp_gain_hf = src_arsr1p->sharp_gain_hf;
	dst_arsr1p->sharp_hf_b = src_arsr1p->sharp_hf_b;
	dst_arsr1p->sharp_lf_ctrl = src_arsr1p->sharp_lf_ctrl;
	dst_arsr1p->sharp_lf_var = src_arsr1p->sharp_lf_var;
	dst_arsr1p->sharp_lf_ctrl_slop = src_arsr1p->sharp_lf_ctrl_slop;
	dst_arsr1p->sharp_hf_select = src_arsr1p->sharp_hf_select;
	dst_arsr1p->sharp_cfg2_h = src_arsr1p->sharp_cfg2_h;
	dst_arsr1p->sharp_cfg2_l = src_arsr1p->sharp_cfg2_l;
	dst_arsr1p->texture_analysis = src_arsr1p->texture_analysis;
	dst_arsr1p->intplshootctrl = src_arsr1p->intplshootctrl;
}


static int effect_arsr_post_set_param(struct hisi_fb_data_type *hisifd,
	dss_arsr1p_t *post_scf, struct arsr1p_info *arsr1p_param, dss_overlay_t *pov_req)
{
	struct hisi_panel_info *pinfo = NULL;
	struct arsr1p_info *arsr1p_rog = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!");
		return -1;
	}

	if (post_scf == NULL) {
		HISI_FB_ERR("post_scf is NULL!");
		return -1;
	}

	if (arsr1p_param == NULL) {
		HISI_FB_ERR("[effect]arsr1p_param is NULL!");
		return -1;
	}

	if (pov_req == NULL) {
		HISI_FB_ERR("[effect]pov_req is NULL!");
		return -1;
	}

	pinfo = &(hisifd->panel_info);

	if (!hisifd->effect_ctl.arsr1p_sharp_support) {
		HISI_FB_DEBUG("[effect]hisifd, arsr1p not support.\n");
		return 0;
	}

	if ((pov_req->res_updt_rect.w != pinfo->xres)
		&& (pov_req->res_updt_rect.h != pinfo->yres)) {
		// compare rect.w with screen'width * %threshold
		if (((uint32_t)pov_req->res_updt_rect.w * 100) < (pinfo->xres * pinfo->scaling_ratio_threshold)) {
			arsr1p_rog = &(hisifd->effect_info[pinfo->disp_panel_id].arsr1p[2]);
			HISI_FB_DEBUG("[effect] ROG HD mode config arsr1p\n");
			if (!(hisifd->effect_info[pinfo->disp_panel_id].arsr1p_rog_initialized & ARSR1P_ROG_HD_FLAG)) {
				effect_arsr_post_init_param(arsr1p_rog);
				hisifd->effect_info[pinfo->disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_HD_FLAG;
			}
		} else {
			arsr1p_rog = &(hisifd->effect_info[pinfo->disp_panel_id].arsr1p[1]);
			HISI_FB_DEBUG("[effect] ROG FHD mode config arsr1p\n");
			if (!(hisifd->effect_info[pinfo->disp_panel_id].arsr1p_rog_initialized & ARSR1P_ROG_FHD_FLAG)) {
				effect_arsr_post_init_param(arsr1p_rog);
				hisifd->effect_info[pinfo->disp_panel_id].arsr1p_rog_initialized |= ARSR1P_ROG_FHD_FLAG;
			}
		}

		effect_arsr_post_config_param(post_scf, arsr1p_rog);
		post_scf->mode = set_bits32(post_scf->mode, 0, 1, 0);
	} else {
		effect_arsr_post_config_param(post_scf, arsr1p_param);
		hisifd->effect_updated_flag[pinfo->disp_panel_id].arsr1p_effect_updated = false;
		HISI_FB_DEBUG("[effect] normal mode config arsr1p.\n");
	}

	return 0;
}

#if defined(CONFIG_HISI_FB_V600) || defined(CONFIG_HISI_FB_V350) || \
	defined(CONFIG_HISI_FB_V510) || defined(CONFIG_HISI_FB_V345) || \
	defined(CONFIG_HISI_FB_V346)
static int effect_arsr_post_set_rect(struct hisi_fb_data_type *hisifd,
	dss_overlay_t *pov_req, dss_arsr1p_t *post_scf, struct hisi_panel_info *pinfo)
{
	int32_t ov_startx_i;
	int32_t ov_starty_i;
	int32_t ov_endx_i;
	int32_t ov_endy_i;
	int32_t startx;
	int32_t starty;
	int32_t endx;
	int32_t endy;
	int32_t startx_i;
	int32_t startx_o;
	int32_t endx_o;
	int32_t endx_i;
	int32_t starty_i;
	int32_t starty_o;
	int32_t endy_i;
	int32_t endy_o;
	int32_t in_w;
	int32_t in_h;
	int32_t out_w;
	int32_t out_h;
	int32_t ihh;
	int32_t ihinc;
	int32_t ivinc;
	int32_t ihleft;
	int32_t ihright;
	int32_t ihleft1;
	int32_t ihright1;
	int32_t ivtop;
	int32_t ivbottom;
	int32_t ivbottom1;
	int32_t extraw;
	int32_t extraw_left;
	int32_t extraw_right;
	dss_rect_t src_rect = {0};
	dss_rect_t dst_rect = {0};

	if ((hisifd == NULL) || (pov_req == NULL) ||
		(post_scf == NULL) || (pinfo == NULL)) {
		HISI_FB_ERR("[effect]hisifd or pov_req or post_scf or pinfo is null pointer\n");
		return -1;
	}

	adjust_dst_rect(pov_req, pinfo, &dst_rect);

	adjust_src_rect(pov_req, pinfo, &src_rect, &dst_rect);

	hisifd->dss_module.post_scf_used = 1;

	if ((src_rect.w < ARSR_POST_SRC_MIN_WIDTH) || (src_rect.h < ARSR_POST_SRC_MIN_HEIGHT)
		|| (src_rect.w > ARSR_POST_SRC_MAX_WIDTH) || (src_rect.h > ARSR_POST_SRC_MAX_HEIGHT)
		|| (dst_rect.w > ARSR_POST_DST_MAX_WIDTH) || (dst_rect.h > ARSR_POST_DST_MAX_HEIGHT)) {
		HISI_FB_ERR("fb%d, src_rect %d,%d,%d,%d should be larger than %d*%d,less than %d*%d!\n"
			"dst_rect %d,%d,%d,%d should be less than %d*%d!\n",
			hisifd->index, src_rect.x, src_rect.y, src_rect.w, src_rect.h,
			ARSR_POST_SRC_MIN_WIDTH, ARSR_POST_SRC_MIN_HEIGHT,
			ARSR_POST_SRC_MAX_WIDTH, ARSR_POST_SRC_MAX_HEIGHT,
			dst_rect.x, dst_rect.y, dst_rect.w, dst_rect.h,
			ARSR_POST_DST_MAX_WIDTH, ARSR_POST_DST_MAX_HEIGHT);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	// step1
	ihh = src_rect.h;

	if (dst_rect.w <= 0 || dst_rect.h <= 0) {
		HISI_FB_ERR("dst_rect.w %d or dst_rect.h %d is invalid\n",
			dst_rect.w, dst_rect.h);
		return -1;
	}
	ihinc = (src_rect.w << SHIFT_16BIT) / dst_rect.w;
	if (src_rect.h > dst_rect.h)
		ivinc = ((src_rect.h << SHIFT_16BIT) + (ARSR1P_INC_FACTOR >> 1) - src_rect.x) / dst_rect.h;
	else
		ivinc = (src_rect.h << SHIFT_16BIT) / dst_rect.h;

	// 0x2000<=ihinc<=ARSR1P_INC_FACTOR; 0x2000<=ivinc<=ARSR1P_INC_FACTOR
	// Constriant is inherited from dssv510
	if ((ihinc < 0x2000) || (ihinc > ARSR1P_INC_FACTOR)
		|| (ivinc < 0x2000) || (ivinc > ARSR1P_INC_FACTOR)) {
		HISI_FB_ERR("invalid ihinc 0x%x, ivinc 0x%x!\n", ihinc, ivinc);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	// step2
	// Constant 4 and 3 below are used for specific algorithm here
	ov_startx_i = src_rect.x - OVERLAP_H16;
	ov_starty_i = src_rect.y - 4;
	ov_endx_i   = (src_rect.x + src_rect.w - 1) + OVERLAP_H16;
	ov_endy_i   = (src_rect.y + src_rect.h - 1) + 3;
	// Make sure not exceeding the screen scope
	if (ov_startx_i < 0)
		ov_startx_i = 0;
	if (ov_starty_i < 0)
		ov_starty_i = 0;
	if ((uint32_t)ov_endx_i >= pinfo->xres)
		ov_endx_i = pinfo->xres - 1;
	if ((uint32_t)ov_endy_i >= pinfo->yres)
		ov_endy_i = pinfo->yres - 1;

	// step3
	startx = (ov_startx_i << SHIFT_16BIT) / ihinc;
	starty = (ov_starty_i << SHIFT_16BIT) / ivinc;
	endx   = ((ov_endx_i + 1) << SHIFT_16BIT) / ihinc - 1;
	endy   = (((ov_endy_i + 1) << SHIFT_16BIT) + ivinc - 1) / ivinc - 1;

	// step 4
	startx_o = startx;
	endx_o   = endx;
	starty_o = starty;
	endy_o   = endy;
	startx_o = (startx_o >> 1) << 1;
	if (endx_o >= dst_rect.w)
		endx_o = dst_rect.w - 1;
	if (endy_o >= dst_rect.h)
		endy_o = dst_rect.h - 1;

	out_w    = endx_o - startx_o;
	out_h    = endy_o - starty_o;

	// step5
	startx_i = ((((startx_o * ihinc) >> SHIFT_16BIT) - OVERLAP_H16) >> 1) << 1;
	starty_i = ((starty_o * ivinc) >> SHIFT_16BIT) - 4;
	endx_i   = ((endx_o * ihinc) >> SHIFT_16BIT) + OVERLAP_H16;
	endy_i   = ((endy_o * ivinc + ARSR1P_INC_FACTOR - 1) >> SHIFT_16BIT) + 3;
	if (startx_i < 0)
		startx_i = 0;
	if (starty_i < 0)
		starty_i = 0;
	if (endx_i >= src_rect.w)
		endx_i = src_rect.w - 1;
	if (endy_i >= src_rect.h)
		endy_i = src_rect.h - 1;

	in_w = endx_i - startx_i;
	in_h = endy_i - starty_i;

	// step6
	extraw = (8 << SHIFT_16BIT) / ihinc;
	extraw_left = (extraw % 2) ? (extraw + 1) : (extraw);
	extraw = (2 << SHIFT_16BIT) / ihinc;
	extraw_right = (extraw % 2) ? (extraw + 1) : (extraw);

	ihleft1 = startx_o * ihinc - (startx_i << SHIFT_16BIT);
	if (ihleft1 < 0)
		ihleft1 = 0;
	// ihleft = ihleft1 - even(8 * 65536 / ihinc) * ihinc;
	ihleft = ihleft1 - extraw_left * ihinc;
	if (ihleft < 0)
		ihleft = 0;

	// ihright1 = endx_o * ihinc - startx_i * 65536
	ihright1 = endx_o * ihinc - (startx_i << SHIFT_16BIT);
	// ihright = ihright1 + even(2 * 65536 / ihinc) * ihinc
	ihright = ihright1 + extraw_right * ihinc;
	// ihright >= img_width * ihinc
	if (ihright >= src_rect.w * ARSR1P_INC_FACTOR)
		ihright = src_rect.w * ARSR1P_INC_FACTOR - 1;

	if (is_arsr_post_need_padding(pov_req, pinfo, ARSR1P_INC_FACTOR)) {
		ihleft1 = ARSR1P_INC_FACTOR * ARSR_POST_COLUMN_PADDING_NUM;
		ihleft = ihleft1 - ((ihleft1 / ihinc) / 2) * 2 *  ihinc;
		ihright1 = (hisifd->panel_info.xres - 1) * ihinc + ihleft1;
		ihright = ihright1;
		HISI_FB_DEBUG("ihleft=%d, ihleft1=%d", ihleft, ihleft1);
	}

	// ivtop = (starty_o * ivinc) - (starty_i << 16)
	ivtop = starty_o * ivinc - (starty_i << SHIFT_16BIT);
	if (ivtop < 0)
		ivtop = 0;
	ivbottom1 = ivtop + out_h * ivinc;
	// ivbottom = ivbottom1 + 16384
	ivbottom = ivbottom1 + 16384;
	if (((ivbottom >> SHIFT_16BIT) > in_h) && (endy_i <= ihh)) {
		endy_i += 1;
		in_h   += 1;
		ivbottom = in_h << SHIFT_16BIT;
	}

	// ivbottom >= img_height * ivinc
	if (ivbottom >= src_rect.h * ARSR1P_INC_FACTOR)
		ivbottom = src_rect.h * ARSR1P_INC_FACTOR - 1;

	// (ihleft1 - ihleft) % (ihinc) == 0;
	if ((ihleft1 - ihleft) % (ihinc)) {
		HISI_FB_ERR("ihleft1 %d - ihleft%d / ihinc %d != 0, invalid!\n",
			ihleft1, ihleft, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	// (ihright1 - ihleft1) % ihinc == 0;
	if ((ihright1 - ihleft1) % ihinc) {
		HISI_FB_ERR("ihright1 %d - ihleft1 %d / ihinc%d != 0, invalid!\n",
			ihright1, ihleft1, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	/* use default param if not config param */
	post_scf->mode &= 0xFFFFFFFE; /* cancel arsr1p bypass */
	post_scf->mode |= 0xc; /* skinctrl, shootdetect */
	post_scf->mode |= 0x10; /* enable direction */
	post_scf->mode |= 0x2; /* enable sharpness */
	if ((ihinc < ARSR1P_INC_FACTOR) || (ivinc < ARSR1P_INC_FACTOR))
		post_scf->mode |= 0x20; /* enable diintplen */
	else
		post_scf->mode |= 0x100; /* only sharp, enable nointplen */


	post_scf->ihleft = set_bits32(post_scf->ihleft, (uint32_t)ihleft, 32, 0);
	post_scf->ihright = set_bits32(post_scf->ihright, (uint32_t)ihright, 32, 0);
	post_scf->ihleft1 = set_bits32(post_scf->ihleft1, (uint32_t)ihleft1, 32, 0);
	post_scf->ihright1 = set_bits32(post_scf->ihright1, (uint32_t)ihright1, 32, 0);
	post_scf->ivtop = set_bits32(post_scf->ivtop, (uint32_t)ivtop, 32, 0);
	post_scf->ivbottom = set_bits32(post_scf->ivbottom, (uint32_t)ivbottom, 32, 0);
	post_scf->ivbottom1 = set_bits32(post_scf->ivbottom1, (uint32_t)ivbottom1, 32, 0);
	post_scf->ihinc = set_bits32(post_scf->ihinc, (uint32_t)ihinc, 32, 0);
	post_scf->ivinc = set_bits32(post_scf->ivinc, (uint32_t)ivinc, 32, 0);

	post_scf->dpp_img_size_bef_sr = set_bits32(post_scf->dpp_img_size_bef_sr,
		(DSS_HEIGHT((uint32_t)src_rect.h) << 16) | DSS_WIDTH((uint32_t)src_rect.w), 32, 0);
	post_scf->dpp_img_size_aft_sr = set_bits32(post_scf->dpp_img_size_aft_sr,
		(DSS_HEIGHT((uint32_t)dst_rect.h) << 16) | DSS_WIDTH((uint32_t)dst_rect.w), 32, 0);
	post_scf->dpp_used = 1;

	return 0;
}

#else
static int effect_arsr_post_set_rect(struct hisi_fb_data_type *hisifd,
	dss_overlay_t *pov_req, dss_arsr1p_t *post_scf, struct hisi_panel_info *pinfo)
{
	int32_t ihinc;
	int32_t ivinc;
	int32_t ihleft;
	int32_t ihright;
	int32_t ihleft1;
	int32_t ihright1;
	int32_t ivtop;
	int32_t ivbottom;
	int32_t extraw;
	int32_t extraw_left;
	int32_t extraw_right;
	dss_rect_t src_rect = {0};
	dss_rect_t dst_rect = {0};

	if ((hisifd == NULL) || (pov_req == NULL) ||
		(post_scf == NULL) || (pinfo == NULL)) {
		HISI_FB_ERR("[effect]hisifd or pov_req or post_scf or pinfo is null pointer\n");
		return -1;
	}

	adjust_dst_rect(pov_req, pinfo, &dst_rect);

	adjust_src_rect(pov_req, pinfo, &src_rect, &dst_rect);

	hisifd->dss_module.post_scf_used = 1;

	if ((src_rect.w < ARSR1P_MIN_SIZE) || (src_rect.h < ARSR1P_MIN_SIZE)
		|| (src_rect.w > ARSR1P_MAX_SRC_WIDTH_SIZE) || (src_rect.h > ARSR1P_MAX_SIZE)
		|| (dst_rect.w > ARSR1P_MAX_SIZE) || (dst_rect.h > ARSR1P_MAX_SIZE)) {
		HISI_FB_ERR("fb%d, invalid input size: src_rect(%d,%d,%d,%d) should be larger than 16*16, less than 3840*8192!\n"
			"invalid output size: dst_rect(%d,%d,%d,%d) should be less than 8192*8192!\n",
			hisifd->index,
			src_rect.x, src_rect.y, src_rect.w, src_rect.h,
			dst_rect.x, dst_rect.y, dst_rect.w, dst_rect.h);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	ihinc = (int32_t)(ARSR1P_INC_FACTOR * (uint64_t)src_rect.w / dst_rect.w);
	ivinc = (int32_t)(ARSR1P_INC_FACTOR * (uint64_t)src_rect.h / dst_rect.h);

	// 0x2000<=ihinc<=ARSR1P_INC_FACTOR; 0x2000<=ivinc<=ARSR1P_INC_FACTOR;
	if ((ihinc < 0x2000) || (ihinc > ARSR1P_INC_FACTOR)
		|| (ivinc < 0x2000) || (ivinc > ARSR1P_INC_FACTOR)) {
		HISI_FB_ERR("invalid ihinc(0x%x), ivinc(0x%x)!\n", ihinc, ivinc);
		// bypass
		post_scf->mode = 0x1;
		return -1;
	}

	extraw = (8 * ARSR1P_INC_FACTOR) / ihinc;
	extraw_left = (extraw % 2) ? (extraw + 1) : (extraw);
	extraw = (2 * ARSR1P_INC_FACTOR) / ihinc;
	extraw_right = (extraw % 2) ? (extraw + 1) : (extraw);

	// ihleft1 = (startX_o * ihinc) - (ov_startX0 << 16)
	ihleft1 = dst_rect.x * ihinc - src_rect.x * ARSR1P_INC_FACTOR;
	if (ihleft1 < 0)
		ihleft1 = 0;
	// ihleft = ihleft1 - even(8 * 65536 / ihinc) * ihinc;
	ihleft = ihleft1 - extraw_left * ihinc;
	if (ihleft < 0)
		ihleft = 0;

	// ihright1 = ihleft1 + (oww-1) * ihinc
	ihright1 = ihleft1 + (dst_rect.w - 1) * ihinc;
	// ihright = ihright1 + even(2 * 65536/ihinc) * ihinc
	ihright = ihright1 + extraw_right * ihinc;
	// ihright >= img_width * ihinc
	if (ihright >= src_rect.w * ARSR1P_INC_FACTOR)
		ihright = src_rect.w * ARSR1P_INC_FACTOR - 1;

	// ivtop = (startY_o * ivinc) - (ov_startY0<<16)
	ivtop = dst_rect.y * ivinc - src_rect.y * ARSR1P_INC_FACTOR;
	if (ivtop < 0)
		ivtop = 0;
	// ivbottom = ivtop + (ohh - 1) * ivinc
	ivbottom = ivtop + (dst_rect.h - 1) * ivinc;
	// ivbottom >= img_height * ivinc
	if (ivbottom >= src_rect.h * ARSR1P_INC_FACTOR)
		ivbottom = src_rect.h * ARSR1P_INC_FACTOR - 1;

	// (ihleft1 - ihleft) % (ihinc) == 0;
	if ((ihleft1 - ihleft) % (ihinc)) {
		HISI_FB_ERR("(ihleft1(%d)-ihleft(%d))  ihinc(%d) != 0, invalid!\n",
			ihleft1, ihleft, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	// (ihright1 - ihleft1) % ihinc == 0;
	if ((ihright1 - ihleft1) % ihinc) {
		HISI_FB_ERR("(ihright1(%d)-ihleft1(%d))  ihinc(%d) != 0, invalid!\n",
			ihright1, ihleft1, ihinc);
		post_scf->mode = 0x1;
		return -1;
	}

	/* use default param if not config param */
	post_scf->mode &= 0xFFFFFFFE; /* cancel arsr1p bypass */
	post_scf->mode |= 0xc; /* skinctrl, shootdetect */
	post_scf->mode |= 0x10; /* enable direction */
	post_scf->mode |= 0x2; /* enable sharpness */
	if ((ihinc < ARSR1P_INC_FACTOR) || (ivinc < ARSR1P_INC_FACTOR)) {
		post_scf->mode |= 0x20; /* enable diintplen */
	} else {
		post_scf->mode |= 0x100; /* only sharp, enable nointplen */
	}


	post_scf->ihleft = set_bits32(post_scf->ihleft, (uint32_t)ihleft, 32, 0);
	post_scf->ihright = set_bits32(post_scf->ihright, (uint32_t)ihright, 32, 0);
	post_scf->ihleft1 = set_bits32(post_scf->ihleft1, (uint32_t)ihleft1, 32, 0);
	post_scf->ihright1 = set_bits32(post_scf->ihright1, (uint32_t)ihright1, 32, 0);
	post_scf->ivtop = set_bits32(post_scf->ivtop, (uint32_t)ivtop, 32, 0);
	post_scf->ivbottom = set_bits32(post_scf->ivbottom, (uint32_t)ivbottom, 32, 0);
	post_scf->ivbottom1 = set_bits32(post_scf->ivbottom1, (uint32_t)ivbottom, 32, 0);
	post_scf->ihinc = set_bits32(post_scf->ihinc, (uint32_t)ihinc, 32, 0);
	post_scf->ivinc = set_bits32(post_scf->ivinc, (uint32_t)ivinc, 32, 0);

	post_scf->dpp_img_size_bef_sr = set_bits32(post_scf->dpp_img_size_bef_sr,
		(DSS_HEIGHT((uint32_t)src_rect.h) << 16) | DSS_WIDTH((uint32_t)src_rect.w), 32, 0);
	post_scf->dpp_img_size_aft_sr = set_bits32(post_scf->dpp_img_size_aft_sr,
		(DSS_HEIGHT((uint32_t)dst_rect.h) << 16) | DSS_WIDTH((uint32_t)dst_rect.w), 32, 0);
	post_scf->dpp_used = 1;

	return 0;
}
#endif

int hisi_effect_arsr1p_config(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req)
{
	struct arsr1p_info *arsr1p_param = NULL;
	struct hisi_panel_info *pinfo = NULL;
	dss_arsr1p_t *post_scf = NULL;
	int ret = 0;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!");
		return -EINVAL;
	}

	if (pov_req == NULL) {
		HISI_FB_ERR("[effect]pov_req is NULL!");
		return -EINVAL;
	}

	if ((!HISI_DSS_SUPPORT_DPP_MODULE_BIT(DPP_MODULE_POST_SCF)) ||
		(hisifd->index != PRIMARY_PANEL_IDX)) {
		return 0;
	}

	pinfo = &(hisifd->panel_info);
	arsr1p_param = &(hisifd->effect_info[pinfo->disp_panel_id].arsr1p[0]);
	post_scf = &(hisifd->dss_module.post_scf);

	if ((arsr1p_param->enable != 1) &&
		((pov_req->res_updt_rect.w == pinfo->xres)
		&& (pov_req->res_updt_rect.h == pinfo->yres))) {
		hisifd->dss_module.post_scf_used = 1;
		post_scf->mode = 0x1;
		return 0;
	}

	if ((pov_req->res_updt_rect.w < 0) || (pov_req->res_updt_rect.h < 0)) {
		HISI_FB_ERR("[effect]fb%d, res_updt_rect[%d,%d, %d,%d] is invalid!\n", hisifd->index,
			pov_req->res_updt_rect.x, pov_req->res_updt_rect.y,
			pov_req->res_updt_rect.w, pov_req->res_updt_rect.h);
		return -EINVAL;
	}

	/* update arsr post rect */
	if (effect_arsr_post_set_rect(hisifd, pov_req, post_scf, pinfo))
		return -EINVAL;

	if (mutex_trylock(&hisifd->effect_lock) == 0) {
		HISI_FB_DEBUG("[effect]fb%d, dss effect param is being updated,"
			" delay set reg to next frame!\n", hisifd->index);
		return 0;
	}

	/* update arsr post effect para */
	if (effect_arsr_post_set_param(hisifd, post_scf, arsr1p_param, pov_req)) {
		HISI_FB_ERR("[effect]fb%d, failed to set arsr post param.\n", hisifd->index);
		ret = -EINVAL;
		goto err_return;
	}

err_return:
	mutex_unlock(&hisifd->effect_lock);
	return ret;
}

static void effect_arsr_pre_config_param(struct hisi_fb_data_type *hisifd, struct dss_arsr2p *arsr2p)
{
	int disp_panel_id = hisifd->panel_info.disp_panel_id;

	if (hisifd->effect_info[disp_panel_id].arsr2p[0].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect),
			&(hisifd->effect_info[disp_panel_id].arsr2p[0]), sizeof(struct arsr2p_info));
		hisifd->effect_info[disp_panel_id].arsr2p[0].update = 0;
	}

	if (hisifd->effect_info[disp_panel_id].arsr2p[1].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect_scale_up),
			&(hisifd->effect_info[disp_panel_id].arsr2p[1]), sizeof(struct arsr2p_info));
		hisifd->effect_info[disp_panel_id].arsr2p[1].update = 0;
	}

	if (hisifd->effect_info[disp_panel_id].arsr2p[2].update == 1) {
		memcpy(&(arsr2p->arsr2p_effect_scale_down),
			&(hisifd->effect_info[disp_panel_id].arsr2p[2]), sizeof(struct arsr2p_info));
		hisifd->effect_info[disp_panel_id].arsr2p[2].update = 0;
	}
}

int hisi_effect_arsr2p_config(struct arsr2p_info *arsr2p_effect_dst,
	int ih_inc, int iv_inc)
{
	struct hisi_fb_data_type *hisifd_primary = NULL;
	struct dss_arsr2p *arsr2p = NULL;

	hisifd_primary = hisifd_list[PRIMARY_PANEL_IDX];
	if (hisifd_primary == NULL) {
		HISI_FB_ERR("[effect]hisifd_primary is NULL pointer, return!\n");
		return -EINVAL;
	}

	if (arsr2p_effect_dst == NULL) {
		HISI_FB_ERR("[effect]arsr2p_effect_dst is NULL pointer, return!\n");
		return -EINVAL;
	}

	arsr2p = &(hisifd_primary->dss_module_default.arsr2p[DSS_RCHN_V0]);

	effect_arsr_pre_config_param(hisifd_primary, arsr2p);

	if ((ih_inc == ARSR2P_INC_FACTOR) &&
		(iv_inc == ARSR2P_INC_FACTOR)) {
		memcpy(arsr2p_effect_dst,
			&(arsr2p->arsr2p_effect), sizeof(struct arsr2p_info));
	} else if ((ih_inc < ARSR2P_INC_FACTOR) ||
		(iv_inc < ARSR2P_INC_FACTOR)) {
		memcpy(arsr2p_effect_dst,
			&(arsr2p->arsr2p_effect_scale_up), sizeof(struct arsr2p_info));
	} else {
		memcpy(arsr2p_effect_dst,
			&(arsr2p->arsr2p_effect_scale_down), sizeof(struct arsr2p_info));
	}

	return 0;
}
int hisifb_ce_service_enable_hiace(struct fb_info *info, const void __user *argp)
{
	struct hisi_panel_info *pinfo = NULL;
	dss_display_effect_ce_t *ce_ctrl = NULL;
	dss_ce_info_t *ce_info = NULL;
	struct hisi_fb_data_type *hisifd = NULL;
	dss_display_effect_metadata_t *metadata_ctrl = NULL;
	struct hiace_enable_set enable_set = { 0 };
	int disp_panel_id;
	int mode = 0;
	int ret;

	if (info == NULL) {
		HISI_FB_ERR("[effect]info is NULL\n");
		return -EINVAL;
	}
	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}
	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}
	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0) {
		effect_debug_log(DEBUG_EFFECT_ENTRY, "[effect] HIACE is not supported!\n");
		return -1;
	}
	if (hisifd->index == PRIMARY_PANEL_IDX) {
		ce_ctrl = &(hisifd->ce_ctrl);
		ce_info = &(hisifd->hiace_info[pinfo->disp_panel_id]);
		metadata_ctrl = &(hisifd->metadata_ctrl);
	} else {
		HISI_FB_ERR("[effect] fb%d, not support!", hisifd->index);
		return -1;
	}
	ret = (int)copy_from_user(&enable_set, argp, sizeof(enable_set));
	if (ret) {
		HISI_FB_ERR("[effect] arg is invalid");
		return -EINVAL;
	}

	disp_panel_id = enable_set.disp_panel_id;
	if ((disp_panel_id >= DISP_PANEL_NUM) || (disp_panel_id < 0)) {
		HISI_FB_ERR("disp_panel_id = %d is overflow.\n", disp_panel_id);
		return -EINVAL;
	}

	mode = enable_set.enable;
	if (mode < 0)
		mode = 0;
	else if (mode >= CE_MODE_SINGLE)
		mode = CE_MODE_SINGLE - 1;

	hisifd->effect_init_update[enable_set.disp_panel_id].hiace_mode = mode;
	if (pinfo->disp_panel_id != disp_panel_id)
		return 0;

#ifdef HIACE_SINGLE_MODE_SUPPORT
	// terminate single mode
	hisifb_hiace_single_mode_terminate(hisifd, false);
#endif

	effect_debug_log(DEBUG_EFFECT_FRAME, "disp_panel_id=%d mode=%d ctrl_ce_mode=%d\n", pinfo->disp_panel_id, mode, ce_ctrl->ctrl_ce_mode);
	if (mode != ce_ctrl->ctrl_ce_mode) {
		mutex_lock(&(ce_ctrl->ctrl_lock));
		ce_ctrl->ctrl_ce_mode = mode;
		mutex_unlock(&(ce_ctrl->ctrl_lock));
		if (mode == CE_MODE_DISABLE && hisifd->panel_power_on) {
			ce_info->gradual_frames = EFFECT_GRADUAL_REFRESH_FRAMES;
			ce_info->to_stop_hdr = true;
		}
		enable_hiace(hisifd, mode);
	}
	return 0;
}
int hisifb_get_reg_val(struct fb_info *info, void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	struct dss_reg reg;
	uint32_t addr;
	uint32_t current_dpp_channel;
	int ret = 0;
	char __iomem *disp_glb_base = NULL;

	if (info == NULL) {
		HISI_FB_ERR("[effect]info is NULL\n");
		return -EINVAL;
	}
	if (argp == NULL) {
		HISI_FB_ERR("[effect] argp is NULL\n");
		return -EINVAL;
	}
	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}

	pinfo = &(hisifd->panel_info);
	if (!pinfo->hiace_support) {
		effect_debug_log(DEBUG_EFFECT_ENTRY, "[effect] Don't support HIACE\n");
		return -EINVAL;
	}
	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] step in\n");
	ret = (int)copy_from_user(&reg, argp, sizeof(struct dss_reg));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d.\n", ret);
		return -2;
	}

	down(&hisifd->blank_sem);
	if (hisifd->panel_power_on == false) {
		HISI_FB_ERR("[effect] panel power off\n");
		up(&hisifd->blank_sem);
		return -EINVAL;
	}
	hisifb_activate_vsync(hisifd);

	disp_glb_base = hisifd->dss_base + DSS_DISP_GLB_OFFSET;
	current_dpp_channel = inp32(disp_glb_base + DYN_SW_DEFAULT) & 0x1;

	switch (reg.tag) {
	case TAG_ARSR_1P_ENABLE:
		addr = DSS_POST_SCF_OFFSET + ARSR_POST_MODE;
		break;
	case TAG_LCP_XCC0_ENABLE:
		addr = DSS_DPP_XCC_OFFSET + XCC_EN;
		break;
	case TAG_LCP_XCC1_ENABLE:
		addr = DSS_DPP1_XCC_OFFSET + XCC_EN;
		break;
	case TAG_LCP_GMP_ENABLE:
		addr = DSS_DPP_GMP_OFFSET + current_dpp_channel * 0x40000 + GMP_EN;
		break;
	case TAG_LCP_IGM_ENABLE:
		addr = DSS_DPP_DEGAMMA_OFFSET + current_dpp_channel * 0x40000 + DEGAMA_EN;
		break;
	case TAG_GAMMA_ENABLE:
		addr = DSS_DPP_GAMA_OFFSET + current_dpp_channel * 0x40000 + GAMA_EN;
		break;
	case TAG_HIACE_LHIST_SFT:
		addr = DSS_HI_ACE_OFFSET + DPE_LHIST_SFT;
		break;
	default:
		HISI_FB_ERR("[effect] invalid tag : %u", reg.tag);
		up(&hisifd->blank_sem);
		return -EINVAL;
	}

	reg.value = (uint32_t)inp32(hisifd->dss_base + addr);

	hisifb_deactivate_vsync(hisifd);
	up(&hisifd->blank_sem);

	ret = (int)copy_to_user(argp, &reg, sizeof(struct dss_reg));
	if (ret)
		HISI_FB_ERR("[effect] copy_to_user failed(param)! ret=%d.\n", ret);

	return 0;
}

int hisifb_hiace_info_set(struct hisi_fb_data_type *hisifd, struct hiace_info *hiace)
{
	int ret = 0;
	int disp_panel_id;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -EINVAL;
	}

	if (hiace == NULL) {
		HISI_FB_ERR("[effect]fb%d, hiace is NULL!\n", hisifd->index);
		return -EINVAL;
	}

	disp_panel_id = hiace->disp_panel_id;

	hisifd->effect_info[disp_panel_id].hiace.lhist_sft = hiace->lhist_sft;
	hisifd->effect_info[disp_panel_id].hiace.roi_start_point = hiace->roi_start_point;
	hisifd->effect_info[disp_panel_id].hiace.roi_width_high = hiace->roi_width_high;
	hisifd->effect_info[disp_panel_id].hiace.roi_mode_ctrl = hiace->roi_mode_ctrl;
	hisifd->effect_info[disp_panel_id].hiace.roi_hist_stat_mode = hiace->roi_hist_stat_mode;
	hisifd->effect_info[disp_panel_id].hiace.hue = hiace->hue;
	hisifd->effect_info[disp_panel_id].hiace.saturation = hiace->saturation;
	hisifd->effect_info[disp_panel_id].hiace.value = hiace->value;
	hisifd->effect_info[disp_panel_id].hiace.skin_gain = hiace->skin_gain;
	hisifd->effect_info[disp_panel_id].hiace.up_low_th = hiace->up_low_th;
	hisifd->effect_info[disp_panel_id].hiace.rgb_blend_weight = hiace->rgb_blend_weight;
	hisifd->effect_info[disp_panel_id].hiace.fna_statistic = hiace->fna_statistic;
	hisifd->effect_info[disp_panel_id].hiace.up_cnt = hiace->up_cnt;
	hisifd->effect_info[disp_panel_id].hiace.low_cnt = hiace->low_cnt;
	hisifd->effect_info[disp_panel_id].hiace.sum_saturation = hiace->sum_saturation;
	hisifd->effect_info[disp_panel_id].hiace.lhist_en = hiace->lhist_en;
	hisifd->effect_info[disp_panel_id].hiace.gamma_w = hiace->gamma_w;
	hisifd->effect_info[disp_panel_id].hiace.gamma_r = hiace->gamma_r;
	hisifd->effect_info[disp_panel_id].hiace.fna_addr = hiace->fna_addr;
	hisifd->effect_info[disp_panel_id].hiace.fna_data = hiace->fna_data;
	hisifd->effect_info[disp_panel_id].hiace.update_fna = hiace->update_fna;
	hisifd->effect_info[disp_panel_id].hiace.fna_valid = hiace->fna_valid;
	hisifd->effect_info[disp_panel_id].hiace.db_pipe_cfg = hiace->db_pipe_cfg;
	hisifd->effect_info[disp_panel_id].hiace.db_pipe_ext_width = hiace->db_pipe_ext_width;
	hisifd->effect_info[disp_panel_id].hiace.db_pipe_full_img_width = hiace->db_pipe_full_img_width;
	hisifd->effect_info[disp_panel_id].hiace.bypass_nr = hiace->bypass_nr;
	hisifd->effect_info[disp_panel_id].hiace.bypass_nr_gain = hiace->bypass_nr_gain;
	hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness01 = hiace->s3_some_brightness01;
	hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness23 = hiace->s3_some_brightness23;
	hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness4 = hiace->s3_some_brightness4;
	hisifd->effect_info[disp_panel_id].hiace.s3_min_max_sigma = hiace->s3_min_max_sigma;
	hisifd->effect_info[disp_panel_id].hiace.s3_green_sigma03 = hiace->s3_green_sigma03;
	hisifd->effect_info[disp_panel_id].hiace.s3_green_sigma45 = hiace->s3_green_sigma45;
	hisifd->effect_info[disp_panel_id].hiace.s3_red_sigma03 = hiace->s3_red_sigma03;
	hisifd->effect_info[disp_panel_id].hiace.s3_red_sigma45 = hiace->s3_red_sigma45;
	hisifd->effect_info[disp_panel_id].hiace.s3_blue_sigma03 = hiace->s3_blue_sigma03;
	hisifd->effect_info[disp_panel_id].hiace.s3_blue_sigma45 = hiace->s3_blue_sigma45;
	hisifd->effect_info[disp_panel_id].hiace.s3_white_sigma03 = hiace->s3_white_sigma03;
	hisifd->effect_info[disp_panel_id].hiace.s3_white_sigma45 = hiace->s3_white_sigma45;
	hisifd->effect_info[disp_panel_id].hiace.s3_filter_level = hiace->s3_filter_level;
	hisifd->effect_info[disp_panel_id].hiace.s3_similarity_coeff = hiace->s3_similarity_coeff;
	hisifd->effect_info[disp_panel_id].hiace.s3_v_filter_weight_adj = hiace->s3_v_filter_weight_adj;
	hisifd->effect_info[disp_panel_id].hiace.s3_hue = hiace->s3_hue;
	hisifd->effect_info[disp_panel_id].hiace.s3_saturation = hiace->s3_saturation;
	hisifd->effect_info[disp_panel_id].hiace.s3_value = hiace->s3_value;
	hisifd->effect_info[disp_panel_id].hiace.s3_skin_gain = hiace->s3_skin_gain;
	hisifd->effect_info[disp_panel_id].hiace.param_update = hiace->param_update;
	hisifd->effect_info[disp_panel_id].hiace.enable = hiace->enable;
	hisifd->effect_info[disp_panel_id].hiace.enable_update = hiace->enable_update;
	hisifd->effect_info[disp_panel_id].hiace.lut_update = hiace->lut_update;
	hisifd->effect_info[disp_panel_id].hiace.hdr10_en = hiace->hdr10_en;
	hisifd->effect_info[disp_panel_id].hiace.loglum_max = hiace->loglum_max;
	hisifd->effect_info[disp_panel_id].hiace.hist_modev = hiace->hist_modev;
	hisifd->effect_info[disp_panel_id].hiace.end_point = hiace->end_point;
	hisifd->effect_info[disp_panel_id].hiace.table_update = hiace->table_update;

	memcpy(&(hisifd->effect_info[disp_panel_id].hiace.hiace_v3_regs),
		&(hiace->hiace_v3_regs), sizeof(struct hiace_v3_register));

	if (hisifd->effect_info[disp_panel_id].hiace.table_update)
		g_table_update = hisifd->effect_info[disp_panel_id].hiace.table_update;

	effect_debug_log(DEBUG_EFFECT_FRAME, "disp_panel_id =%d g_table_update=%d enable=%u HIACE_V3_HIGHLIGHT=%u\n",
		disp_panel_id, g_table_update, hisifd->effect_info[disp_panel_id].hiace.enable,
		hisifd->effect_info[disp_panel_id].hiace.hiace_v3_regs.highlight);

	if (g_table_update) {
		ret = effect_set_hiace_hdr_lut_info(hisifd, hiace);
		if (ret) {
			HISI_FB_ERR("[effect] copy hdr table from user failed! ret=%d\n", ret);
			return -EINVAL;
		}
	}
	return 0;
}
int hisifb_ce_service_set_param(struct fb_info *info, const void __user *argp)
{
	struct hisi_fb_data_type *hisifd = NULL;
	struct hisi_panel_info *pinfo = NULL;
	int ret = 0;
	struct hiace_info hiace;

	if (runmode_is_factory())
		return ret;

	if (info == NULL) {
		HISI_FB_ERR("[effect]info is NULL\n");
		return -EINVAL;
	}

	if (argp == NULL) {
		HISI_FB_ERR("[effect]argp is NULL\n");
		return -EINVAL;
	}

	hisifd = (struct hisi_fb_data_type *)info->par;
	if (hisifd == NULL) {
		HISI_FB_ERR("[effect] hisifd is NULL\n");
		return -EINVAL;
	}
	pinfo = &(hisifd->panel_info);
	if (!pinfo->hiace_support) {
		effect_debug_log(DEBUG_EFFECT_ENTRY, "[effect] Don't support HIACE\n");
		return -EINVAL;
	}
	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] step in\n");

	spin_lock(&g_hiace_table_lock);
	ret = (int)copy_from_user(&hiace, argp, sizeof(struct hiace_info));
	if (ret) {
		HISI_FB_ERR("[effect] copy_from_user(param) failed! ret=%d.\n", ret);
		spin_unlock(&g_hiace_table_lock);
		return -2;
	}

	if ((hiace.disp_panel_id >= DISP_PANEL_NUM) || (hiace.disp_panel_id < 0)) {
		HISI_FB_ERR("disp_panel_id = %d is overflow.\n", hiace.disp_panel_id);
		return -EINVAL;
	}

	ret = hisifb_hiace_info_set(hisifd, &hiace);
	if (ret) {
		HISI_FB_ERR("[effect] hiace info set failed! ret=%d.\n", ret);
		spin_unlock(&g_hiace_table_lock);
		return -2;
	}
	spin_unlock(&g_hiace_table_lock);
	hisifd->effect_updated_flag[hiace.disp_panel_id].hiace_effect_updated = true;
	hisifd->effect_init_update[hiace.disp_panel_id].hiace_param_update = true;
	return ret;
}

static void effect_hiace_hdr_lut_set_reg(struct hisi_fb_data_type *hisifd,
	const char __iomem *hiace_base)
{
	uint32_t gamma_ab_shadow = 0;
	uint32_t gamma_ab_work = 0;
	uint32_t temp = 0;
	uint32_t i = 0;
	uint32_t sel_gamma_ab_shadow = 0;
	int disp_panel_id = hisifd->panel_info.disp_panel_id;

	sel_gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0xe;

	effect_debug_log(DEBUG_EFFECT_FRAME, "g_table_update=0x%x, g_sel_gamma_ab_shadow_hdr_lut=0x%x\n", g_table_update, g_sel_gamma_ab_shadow_hdr_lut);

	if ((g_table_update & DETAIL_WEIGHT_TABLE_UPDATED) &&
		(hisifd->effect_info[disp_panel_id].hiace.detail_weight_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x8;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x8;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write detail_weight lut */
			for (i = 0; i < (DETAIL_WEIGHT_SIZE - 1); i++) {
				temp = ((hisifd->effect_info[disp_panel_id].hiace.detail_weight_table[i * 4]) |
					(hisifd->effect_info[disp_panel_id].hiace.detail_weight_table[i * 4 + 1] << 8) |
					(hisifd->effect_info[disp_panel_id].hiace.detail_weight_table[i * 4 + 2] << 16) |
					(hisifd->effect_info[disp_panel_id].hiace.detail_weight_table[i * 4 + 3] << 24));
				outp32(hisifd->dss_base + HIACE_DETAIL_WEIGHT + i * 4, temp);
				HISI_FB_DEBUG("[effect] detail_weight_table temp[%d]=%d\n", i, temp);
			}
			outp32(hisifd->dss_base + HIACE_DETAIL_WEIGHT + i * 4,
				(hisifd->effect_info[disp_panel_id].hiace.detail_weight_table[HIACE_DETAIL_WEIGHT_TABLE_LEN - 1]));
			g_table_update &= ~DETAIL_WEIGHT_TABLE_UPDATED;

			sel_gamma_ab_shadow ^= 0x8;
		}
	}

	if ((g_table_update & LOGLUM_EOTF_TABLE_UPDATED) &&
		(hisifd->effect_info[disp_panel_id].hiace.loglum_eotf_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x4;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x4;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write loglum_eotf lut */
			for (i = 0; i < (LOG_LUM_EOTF_LUT_SIZE - 1); i++) {
				temp = ((hisifd->effect_info[disp_panel_id].hiace.loglum_eotf_table[i * 2]) |
					(hisifd->effect_info[disp_panel_id].hiace.loglum_eotf_table[i * 2 + 1] << 16));
				outp32(hisifd->dss_base + HIACE_LOG_LUM + i * 4, temp);
				HISI_FB_DEBUG("[effect] loglum_eotf_table temp[%d]=%d\n", i, temp);
			}
			outp32(hisifd->dss_base + HIACE_LOG_LUM + i * 4,
				(hisifd->effect_info[disp_panel_id].hiace.loglum_eotf_table[LOG_LUM_EOTF_LUT_SIZE - 1]));
			g_table_update &= ~LOGLUM_EOTF_TABLE_UPDATED;

			sel_gamma_ab_shadow ^= 0x4;
		}
	}

	if ((g_table_update & LUMA_GAMA_TABLE_UPDATED) &&
		(hisifd->effect_info[disp_panel_id].hiace.luma_gamma_table != NULL)) {
		gamma_ab_shadow = inp32(hiace_base + DPE_GAMMA_AB_SHADOW) & 0x2;
		gamma_ab_work = inp32(hiace_base + DPE_GAMMA_AB_WORK) & 0x2;
		if (gamma_ab_shadow == gamma_ab_work) {
			/* write luma_gama lut */
			for (i = 0; i < LUMA_GAMA_LUT_SIZE; i++) {
				temp = (hisifd->effect_info[disp_panel_id].hiace.luma_gamma_table[i * 3]) |
					(hisifd->effect_info[disp_panel_id].hiace.luma_gamma_table[i * 3 + 1] << 10) |
					(hisifd->effect_info[disp_panel_id].hiace.luma_gamma_table[i * 3 + 2] << 20);
				outp32(hisifd->dss_base + HIACE_LUMA_GAMMA + i * 4, temp);
				HISI_FB_DEBUG("[effect] luma_gamma_table temp[%d]=%d\n", i, temp);
			}
			g_table_update &= ~LUMA_GAMA_TABLE_UPDATED;
			sel_gamma_ab_shadow ^= 0x2;
		}
	}
	g_sel_gamma_ab_shadow_hdr_lut = sel_gamma_ab_shadow;
}
/*lint +e679*/
static int effect_hiace_param_set_reg(struct hisi_fb_data_type *hisifd)
{
	char __iomem *hiace_base = NULL;
	int disp_panel_id = hisifd->panel_info.disp_panel_id;

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_DEBUG("[effect] fb%d, not support!", hisifd->index);
		return 0;
	}
	if (hisifd->fb_shutdown == true) {
		HISI_FB_ERR("[effect] fb_shutdown or panel power down");
		return -EINVAL;
	}
	if (hisifd->effect_updated_flag[disp_panel_id].hiace_effect_updated) {
		spin_lock(&g_hiace_table_lock);
		set_reg(hiace_base + DPE_ROI_START_POINT,
			hisifd->effect_info[disp_panel_id].hiace.roi_start_point, 32, 0);
		set_reg(hiace_base + DPE_ROI_WIDTH_HIGH,
			hisifd->effect_info[disp_panel_id].hiace.roi_width_high, 32, 0);
		set_reg(hiace_base + DPE_ROI_MODE_CTRL,
			hisifd->effect_info[disp_panel_id].hiace.roi_mode_ctrl, 32, 0);
		set_reg(hiace_base + DPE_ROI_HIST_STAT_MODE,
			hisifd->effect_info[disp_panel_id].hiace.roi_hist_stat_mode, 32, 0);
		set_reg(hiace_base + DPE_HUE,
			hisifd->effect_info[disp_panel_id].hiace.hue, 32, 0);
		set_reg(hiace_base + DPE_SATURATION,
			hisifd->effect_info[disp_panel_id].hiace.saturation, 32, 0);
		set_reg(hiace_base + DPE_VALUE,
			hisifd->effect_info[disp_panel_id].hiace.value, 32, 0);
		set_reg(hiace_base + DPE_SKIN_GAIN,
			hisifd->effect_info[disp_panel_id].hiace.skin_gain, 32, 0);
		set_reg(hiace_base + DPE_UP_LOW_TH,
			hisifd->effect_info[disp_panel_id].hiace.up_low_th, 32, 0);
		set_reg(hiace_base + DPE_RGB_BLEND_WEIGHT,
			hisifd->effect_info[disp_panel_id].hiace.rgb_blend_weight, 32, 0);
		set_reg(hiace_base + DPE_FNA_STATISTIC,
			hisifd->effect_info[disp_panel_id].hiace.fna_statistic, 32, 0);
		set_reg(hiace_base + DPE_UP_CNT,
			hisifd->effect_info[disp_panel_id].hiace.up_cnt, 32, 0);
		set_reg(hiace_base + DPE_LOW_CNT,
			hisifd->effect_info[disp_panel_id].hiace.low_cnt, 32, 0);
		set_reg(hiace_base + DPE_SUM_SATURATION,
			hisifd->effect_info[disp_panel_id].hiace.sum_saturation, 32, 0);
		set_reg(hiace_base + DPE_GAMMA_W,
			hisifd->effect_info[disp_panel_id].hiace.gamma_w, 32, 0);
		set_reg(hiace_base + DPE_GAMMA_R,
			hisifd->effect_info[disp_panel_id].hiace.gamma_r, 32, 0);
		set_reg(hiace_base + DPE_FNA_ADDR,
			hisifd->effect_info[disp_panel_id].hiace.fna_addr, 32, 0);
		set_reg(hiace_base + DPE_FNA_DATA,
			hisifd->effect_info[disp_panel_id].hiace.fna_data, 32, 0);
		set_reg(hiace_base + DPE_UPDATE_FNA,
			hisifd->effect_info[disp_panel_id].hiace.update_fna, 32, 0);
		set_reg(hiace_base + DPE_FNA_VALID,
			hisifd->effect_info[disp_panel_id].hiace.fna_valid, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_CFG,
			hisifd->effect_info[disp_panel_id].hiace.db_pipe_cfg, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_EXT_WIDTH,
			hisifd->effect_info[disp_panel_id].hiace.db_pipe_ext_width, 32, 0);
		set_reg(hiace_base + DPE_DB_PIPE_FULL_IMG_WIDTH,
			hisifd->effect_info[disp_panel_id].hiace.db_pipe_full_img_width, 32, 0);
		set_reg(hiace_base + DPE_BYPASS_NR,
			(hisifd->effect_info[disp_panel_id].hiace.bypass_nr |
				(hisifd->effect_info[disp_panel_id].hiace.bypass_nr_gain << 1)), 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS01,
			hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness01, 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS23,
			hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness23, 32, 0);
		set_reg(hiace_base + DPE_S3_SOME_BRIGHTNESS4,
			hisifd->effect_info[disp_panel_id].hiace.s3_some_brightness4, 32, 0);
		set_reg(hiace_base + DPE_S3_MIN_MAX_SIGMA,
			hisifd->effect_info[disp_panel_id].hiace.s3_min_max_sigma, 32, 0);
		set_reg(hiace_base + DPE_S3_GREEN_SIGMA03,
			hisifd->effect_info[disp_panel_id].hiace.s3_green_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_GREEN_SIGMA45,
			hisifd->effect_info[disp_panel_id].hiace.s3_green_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_RED_SIGMA03,
			hisifd->effect_info[disp_panel_id].hiace.s3_red_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_RED_SIGMA45,
			hisifd->effect_info[disp_panel_id].hiace.s3_red_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_BLUE_SIGMA03,
			hisifd->effect_info[disp_panel_id].hiace.s3_blue_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_BLUE_SIGMA45,
			hisifd->effect_info[disp_panel_id].hiace.s3_blue_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_WHITE_SIGMA03,
			hisifd->effect_info[disp_panel_id].hiace.s3_white_sigma03, 32, 0);
		set_reg(hiace_base + DPE_S3_WHITE_SIGMA45,
			hisifd->effect_info[disp_panel_id].hiace.s3_white_sigma45, 32, 0);
		set_reg(hiace_base + DPE_S3_FILTER_LEVEL,
			hisifd->effect_info[disp_panel_id].hiace.s3_filter_level, 32, 0);
		set_reg(hiace_base + DPE_S3_SIMILARITY_COEFF,
			hisifd->effect_info[disp_panel_id].hiace.s3_similarity_coeff, 32, 0);
		set_reg(hiace_base + DPE_S3_V_FILTER_WEIGHT_ADJ,
			hisifd->effect_info[disp_panel_id].hiace.s3_v_filter_weight_adj, 32, 0);
		set_reg(hiace_base + DPE_S3_HUE,
			hisifd->effect_info[disp_panel_id].hiace.s3_hue, 32, 0);
		set_reg(hiace_base + DPE_S3_SATURATION,
			hisifd->effect_info[disp_panel_id].hiace.s3_saturation, 32, 0);
		set_reg(hiace_base + DPE_S3_VALUE,
			hisifd->effect_info[disp_panel_id].hiace.s3_value, 32, 0);
		set_reg(hiace_base + DPE_S3_SKIN_GAIN,
			hisifd->effect_info[disp_panel_id].hiace.s3_skin_gain, 32, 0);
		set_reg(hiace_base + DPE_HDR10_EN,
			hisifd->effect_info[disp_panel_id].hiace.hdr10_en, 32, 0);
		set_reg(hiace_base + DPE_LOGLUM_MAX,
			hisifd->effect_info[disp_panel_id].hiace.loglum_max, 32, 0);
		set_reg(hiace_base + DPE_HIST_MODEV,
			hisifd->effect_info[disp_panel_id].hiace.hist_modev, 32, 0);
		set_reg(hiace_base + DPE_END_POINT,
			hisifd->effect_info[disp_panel_id].hiace.end_point, 32, 0);
		effect_hiace_v3_set_reg(hisifd->dss_base + DSS_DISP_CH0_OFFSET,
			&hisifd->effect_info[disp_panel_id].hiace.hiace_v3_regs);
		effect_hiace_hdr_lut_set_reg(hisifd, hiace_base);
		spin_unlock(&g_hiace_table_lock);
	}
	hisifd->effect_updated_flag[disp_panel_id].hiace_effect_updated = false;
	return 0;
}

int hisi_effect_hiace_config(struct hisi_fb_data_type *hisifd)
{
	char __iomem *hiace_base = NULL;
	struct hisi_panel_info *pinfo = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("[effect]hisifd is NULL!\n");
		return -1;
	}

	pinfo = &(hisifd->panel_info);
	if (pinfo->hiace_support == 0)
		return 0;

	if (hisifd->index == PRIMARY_PANEL_IDX) {
		hiace_base = hisifd->dss_base + DSS_HI_ACE_OFFSET;
	} else {
		HISI_FB_DEBUG("[effect] fb%d, not support!", hisifd->index);
		return 0;
	}
	effect_debug_log(DEBUG_EFFECT_FRAME, "[effect] g_hiace_enable_status=%d hiace_enable=%d hiace_effect_updated=%d\n", g_hiace_enable_status,
		hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable, hisifd->effect_updated_flag[pinfo->disp_panel_id].hiace_effect_updated);
	if (g_hiace_enable_status != hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable) {
		if (hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable) {
			if (hisifd->dirty_region_updt_enable == 0) {
				set_reg(hiace_base + HIACE_BYPASS_ACE, 0x0, 1, 0);
				set_reg(hiace_base + HIACE_INT_STAT, 0x1, 1, 0);
				g_hiace_enable_status = hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable;
			}
		} else {
			set_reg(hiace_base + HIACE_BYPASS_ACE, 0x1, 1, 0);
			g_hiace_enable_status = hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable;
		}
	}

	// set hiace on/off timestamp
	hisifb_panel_set_hiace_timestamp(hisifd, hisifd->hiace_info[pinfo->disp_panel_id].hiace_enable, hisifd->ce_ctrl.ctrl_ce_mode);

	return effect_hiace_param_set_reg(hisifd);
}

void deinit_effect(struct hisi_fb_data_type *hisifd)
{
	uint32_t *ch_status = NULL;

	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL");
		return;
	}

	ch_status = hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_chn_status;
	*ch_status = DPP_CHN_NEED_CONFIG;
	*(ch_status + 1) = DPP_CHN_NEED_CONFIG;
	g_dyn_sw_default = 0x0;
	hisifd->effect_info[hisifd->panel_info.disp_panel_id].dpp_buf.gmp_call_wq_scene = 0;
}

/* lint +e571, +e573, +e737, +e732, +e850, +e730, +e713, +e529, +e574, +e732, +e845, +e570,
+e774 +e568 +e587 +e685 */

#if defined(CONFIG_HISI_FB_V510) || defined(CONFIG_HISI_FB_V600)
void hisi_dss_roi_config(struct hisi_fb_data_type *hisifd,
	dss_overlay_t *pov_req)
{
	int ret;

	if (pov_req == NULL) {
		HISI_FB_ERR("pov_req is NULL!\n");
		return;
	}
	if (hisifd == NULL) {
		HISI_FB_ERR("hisifd is NULL!\n");
		return;
	}

	if (!g_is_effect_lock_init) {
		HISI_FB_INFO("display effect lock is not init!\n");
		return;
	}

	spin_lock(&g_roi_lock);
	ret = hisifb_hiace_roi_info_init(hisifd, pov_req);
	if (ret) {
		spin_unlock(&g_roi_lock);
		return;
	}

	hisifb_hiace_roi_reg_set(hisifd, pov_req);
	spin_unlock(&g_roi_lock);
}

#endif
#pragma GCC diagnostic pop
