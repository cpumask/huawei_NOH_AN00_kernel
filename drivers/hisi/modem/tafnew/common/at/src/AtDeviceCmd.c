/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * foss@huawei.com
 *
 * If distributed as part of the Linux kernel, the following license terms
 * apply:
 *
 * * This program is free software; you can redistribute it and/or modify
 * * it under the terms of the GNU General Public License version 2 and
 * * only version 2 as published by the Free Software Foundation.
 * *
 * * This program is distributed in the hope that it will be useful,
 * * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * * GNU General Public License for more details.
 * *
 * * You should have received a copy of the GNU General Public License
 * * along with this program; if not, write to the Free Software
 * * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
 *
 * Otherwise, the following license terms apply:
 *
 * * Redistribution and use in source and binary forms, with or without
 * * modification, are permitted provided that the following conditions
 * * are met:
 * * 1) Redistributions of source code must retain the above copyright
 * *    notice, this list of conditions and the following disclaimer.
 * * 2) Redistributions in binary form must reproduce the above copyright
 * *    notice, this list of conditions and the following disclaimer in the
 * *    documentation and/or other materials provided with the distribution.
 * * 3) Neither the name of Huawei nor the names of its contributors may
 * *    be used to endorse or promote products derived from this software
 * *    without specific prior written permission.
 *
 * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include "AtDeviceCmd.h"
#include "securec.h"
#include "AtParse.h"
#include "AtCheckFunc.h"
#include "at_mdrv_interface.h"
#include "AtCmdMsgProc.h"
#include "AtInputProc.h"
#include "AtTestParaCmd.h"
#include "AtMtMsgProc.h"

#if (FEATURE_LTE == FEATURE_ON)
#include "at_lte_common.h"
#include "nv_stru_lps.h"
#endif

#include "nv_stru_cas.h"

#include "AtCmdMiscProc.h"

#include "AtMtCommFun.h"


/*
 * 协议栈打印打点方式下的.C文件宏定义
 */
#define THIS_FILE_ID PS_FILE_ID_AT_DEVICECMD_C
#define TASK_DELAY_MILL_SECONDS 10
#define AT_TBAT_PARA_TYPE 0
#define AT_TBAT_PARA_OPR 1
#define AT_TBAT_READ_OPR_PARA_NUM 2
#define AT_TBAT_SET_OPR_PARA_NUM 4
#define AT_TBAT_MIN_HKADC 2
#define AT_TBAT_MAX_HKADC 3
#define AT_PSTANDBY_PARA_NUM 2
#define AT_PSTANDBY_STANDBY_TIME 0
#define AT_PSTANDBY_SWITCH_TIME 1
#define AT_WIWEP_PARA_WIFI_KEY_INDEX 0
#define AT_WIWEP_PARA_INDEX_VAL_0 0
#define AT_WIWEP_PARA_INDEX_VAL_1 1
#define AT_WIWEP_PARA_INDEX_VAL_2 2
#define AT_WIWEP_PARA_WIFI_KEY_CONTENT 1
#define AT_WIWEP_SSID_GROUP_INDEX 2
#define AT_CMDLEN_PARA_NUM 2
#define AT_PC_EXPECT_TX_MSG_LEN 0
#define AT_PC_EXPECT_RX_MSG_LEN 1
#define AT_NVWR_PARA_NVID 0
#define AT_NVWR_PARA_NV_TOTAL_LEN 1
#define AT_NVWR_PARA_NV_LEN 2
#define AT_NVWR_PARA_DATA 3
#define AT_MEID_PARA_MEIDNUM 0
#define AT_TXTASTEST_PARA_NUM 5
#define AT_TXTASTEST_RAT_MODE 0
#define AT_TXTASTEST_TXSAR_FORCED_SWITCH 1
#define AT_TXTASTEST_DL_OPTIMAL_TX 2
#define AT_TXTASTEST_TXSAR_SWITCH 3
#define AT_TXTASTEST_PARA_RESERVED 4
#define AT_NVREAD_STATUS_1 1
#define AT_NVREAD_STATUS_2 2
#define AT_NVREAD_STATUS_3 3
#define AT_NVREAD_STATUS_4 4
#define AT_NVREAD_STATUS_5 5
#define AT_NVREAD_STATUS_6 6
#define AT_NVREAD_STATUS_7 7
#define AT_NVWR_STATUS_1 1
#define AT_NVWR_STATUS_2 2
#define AT_NVWR_STATUS_3 3
#define AT_NVWR_STATUS_4 4
#define AT_NVWR_STATUS_5 5
#define AT_NVWR_STATUS_6 6
#define AT_NVWR_STATUS_7 7
#define AT_NVWR_STATUS_8 8
#define AT_NVWR_STATUS_9 9
#define AT_NVWR_STATUS_10 10
#define AT_NVWR_STATUS_11 11
#define AT_WIWEP_WIFI_KEY_INDEX_2 2
#define AT_WIWEP_WIFI_KEY_INDEX_3 3
#define AT_RFIC_NUM_2 2
#define AT_RFIC_NUM_3 3
#define AT_PARA_LIST_OFFSET_NUM_2 2
#define AT_PARA_LIST_OFFSET_NUM_3 3
#define AT_NVWRSECCTRL_PARA_MAX_NUM   2
#define AT_NVWRSECCTRL_PARA_SECTYPE   0 /* NVWRSECCTRL的第一个参数SECTYPE */
#define AT_NVWRSECCTRL_PARA_SECSTRING 1 /* NVWRSECCTRL的第二个参数SECSTRING */
#define AT_NV_NUM_PER_MAX_NUM 128
#define AT_DEC_MAX_NUM 9

/*
 * 命令受限标志宏定义说明
 * #define CMD_TBL_E5_IS_LOCKED        0x00000001     不受E5锁定控制的命令
 * #define CMD_TBL_PIN_IS_LOCKED       0x00000002     不受PIN码锁定控制的命令
 * #define CMD_TBL_IS_E5_DOCK          0x00000004     E5 DOCK命令
 * #define CMD_TBL_CLAC_IS_INVISIBLE   0x00000008     +CLAC命令中不输出显示的命令
 */

VOS_UINT32 g_nvRead  = 0;
VOS_UINT32 g_nvWrite = 0;

static const AT_ParCmdElement g_atDeviceCmdTbl[] = {
    { AT_CMD_GTIMER,
      AT_SetGTimerPara, AT_NOT_SET_TIME, AT_QryGTimerPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^GTIMER", (VOS_UINT8 *)"(0-429496728)" },

    { AT_CMD_RSIM,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryRsimPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^RSIM", VOS_NULL_PTR },

#if (FEATURE_DCXO_HI1102_SAMPLE_SHARE == FEATURE_ON)
    { AT_CMD_DCXOQRY,
      AT_SetDcxoQryPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DCXOQRY", (TAF_UINT8 *)"(0-3)" },
#endif

    { AT_CMD_PHYNUM,
      AT_SetPhyNumPara, AT_NOT_SET_TIME, AT_QryPhyNumPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PHYNUM", VOS_NULL_PTR },

    { AT_CMD_CSVER,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QryCsVer, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CSVER", VOS_NULL_PTR },

    { AT_CMD_QOS,
      At_SetQosPara, AT_NOT_SET_TIME, At_QryQosPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^QOS", VOS_NULL_PTR },

    { AT_CMD_SDOMAIN,
      At_SetSDomainPara, AT_NOT_SET_TIME, At_QrySDomainPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SDOMAIN", VOS_NULL_PTR },

    { AT_CMD_PLATFORM,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QryPlatForm, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PLATFORM", VOS_NULL_PTR },

    { AT_CMD_FCHAN,
      At_SetFChanPara, AT_SET_PARA_TIME, At_QryFChanPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FCHAN", (VOS_UINT8 *)FCHAN_CMD_PARA_STRING },

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_CLT,
      At_SetCltPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CLT", (VOS_UINT8 *)"(0,1)" },
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_DCXOTEMPCOMP,
      AT_SetDcxotempcompPara, AT_SET_PARA_TIME, AT_QryDcxotempcompPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DCXOTEMPCOMP", (VOS_UINT8 *)"(0,1)" },

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    { AT_CMD_FTEMPRPT,
      AT_QryFtemprptPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FTEMPRPT", (VOS_UINT8 *)"(0,1),(0-65535)" },
#endif
#endif

    { AT_CMD_FTXON,
      At_SetFTxonPara, AT_SET_PARA_TIME, At_QryFTxonPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_FTXON_OTHER_ERR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FTXON", (VOS_UINT8 *)FTXON_CMD_PARA_STRING },

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_CLTINFO,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QryCltInfo, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CLTINFO", VOS_NULL_PTR },
#endif

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_FDAC,
      AT_SetFDac, AT_SET_PARA_TIME, AT_QryFDac, AT_NOT_SET_TIME, At_TestFdacPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FDAC", (VOS_UINT8 *)"(0-65536)" },
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_FRXON,
      At_SetFRxonPara, AT_SET_PARA_TIME, At_QryFRxonPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_FRXON_OTHER_ERR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FRXON", (VOS_UINT8 *)"(0-1)" },

    { AT_CMD_FPA,
      At_SetFpaPara, AT_SET_PARA_TIME, At_QryFpaPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FPA", (VOS_UINT8 *)FPA_CMD_PARA_STRING },

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    /* 设置接收机等级，后面会逐渐用^FAGCGAIN代替^FLNA */
    { AT_CMD_FLNA,
      AT_SetFAgcgainPara, AT_SET_PARA_TIME, AT_QryFAgcgainPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_FLNA_OTHER_ERR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FLNA", (VOS_UINT8 *)"(0-255)" },
#endif

    { AT_CMD_FRSSI,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QryFrssiPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FRSSI", VOS_NULL_PTR },
#endif
    { AT_CMD_MDATE,
      AT_SetMDatePara, AT_NOT_SET_TIME, AT_QryMDatePara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^MDATE", (VOS_UINT8 *)"(@time)" },

    { AT_CMD_FACINFO,
      AT_SetFacInfoPara, AT_NOT_SET_TIME, AT_QryFacInfoPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_ERROR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FACINFO", (VOS_UINT8 *)"(0,1),(@valueInfo)" },


    { AT_CMD_GPIOPL,
      At_SetGPIOPL, AT_SET_PARA_TIME, At_QryGPIOPL, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^GPIOPL", (VOS_UINT8 *)"(@GPIOPL)" },

#if (FEATURE_LTE == FEATURE_ON)

    /* 生产NV恢复 */
    { AT_CMD_INFORRS,
      At_SetInfoRRS, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^INFORRS", VOS_NULL_PTR },
#endif

    { AT_CMD_DATALOCK,
      At_SetDataLock, AT_SET_PARA_TIME, At_QryDataLock, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DATALOCK", (VOS_UINT8 *)"(@nlockCode)" },

    { AT_CMD_VERSION,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QryVersion, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^VERSION", VOS_NULL_PTR },

    { AT_CMD_SIMLOCK,
      VOS_NULL_PTR, AT_NOT_SET_TIME, At_QrySimLockPlmnInfo, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCK", VOS_NULL_PTR },

    { AT_CMD_MAXLCK_TIMES,
      At_SetMaxLockTimes, AT_SET_PARA_TIME, At_QryMaxLockTimes, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^MAXLCKTMS", (VOS_UINT8 *)"(0-429496728)" },

    { AT_CMD_CALLSRV,
      At_SetCallSrvPara, AT_NOT_SET_TIME, At_QryCallSrvPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CALLSRV", (VOS_UINT8 *)"(0,1)" },

    { AT_CMD_CSDFLT,
      At_SetCsdfltPara, AT_NOT_SET_TIME, At_QryCsdfltPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_ERROR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CSDFLT", (VOS_UINT8 *)"(0,1)" },

    { AT_CMD_TMMI,
      AT_SetTmmiPara, AT_NOT_SET_TIME, AT_QryTmmiPara, AT_NOT_SET_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TMMI", (VOS_UINT8 *)"(0,1)" },


    { AT_CMD_TSCREEN,
      AT_SetTestScreenPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TSCREEN", (VOS_UINT8 *)"(0-255),(0-255)" },

    { AT_CMD_BATVOL,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryBatVolPara, AT_QRY_PARA_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TBATVOLT", VOS_NULL_PTR },

    { AT_CMD_WUPWD,
      AT_SetWebPwdPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^WUPWD", (VOS_UINT8 *)"(0,1),(@WUPWD)" },

    { AT_CMD_PRODTYPE,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryProdTypePara, AT_QRY_PARA_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PRODTYPE", VOS_NULL_PTR },

    { AT_CMD_FEATURE,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryFeaturePara, AT_QRY_PARA_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SFEATURE", VOS_NULL_PTR },

    { AT_CMD_PRODNAME,
      AT_SetProdNamePara, AT_NOT_SET_TIME, AT_QryProdNamePara, AT_NOT_SET_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PRODNAME", (VOS_UINT8 *)"(@ProductName)" },

    { AT_CMD_FWAVE,
      AT_SetFwavePara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, At_CmdTestProcERROR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FWAVE", (VOS_UINT8 *)FWAVE_CMD_PARA_STRING },

    { AT_CMD_EQVER,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryEqverPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^EQVER", VOS_NULL_PTR },

    { AT_CMD_NVRD,
      AT_SetNVReadPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_ERROR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^NVRD", (VOS_UINT8 *)"(0-65535)" },



    { AT_CMD_CURC,
      At_SetCurcPara, AT_NOT_SET_TIME, At_QryCurcPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_ERROR, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^CURC", (VOS_UINT8 *)"(0-2)" },

    { AT_CMD_TBAT,
      AT_SetTbatPara, AT_SET_PARA_TIME, AT_QryTbatPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_SET_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^TBAT", (VOS_UINT8 *)"(0,1),(0,1),(0-65535),(0-65535)" },

    { AT_CMD_PSTANDBY,
      AT_SetPstandbyPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_SET_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^PSTANDBY", (VOS_UINT8 *)"(0-65535),(0-65535)" },

    { AT_CMD_WIWEP,
      AT_SetWiwepPara, AT_SET_PARA_TIME, AT_QryWiwepPara, AT_QRY_PARA_TIME, AT_TestWiwepPara, AT_SET_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^WIWEP", (VOS_UINT8 *)"(0-3),(@wifikey),(0-3)" },

    { AT_CMD_CMDLEN,
      AT_SetCmdlenPara, AT_SET_PARA_TIME, AT_QryCmdlenPara, AT_QRY_PARA_TIME, At_CmdTestProcOK, AT_SET_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^CMDLEN", (VOS_UINT8 *)"(0-65535),(0-65535)" },

    { AT_CMD_HUK,
      AT_SetHukPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^HUK", (VOS_UINT8 *)"(@huk)" },

    { AT_CMD_FACAUTHPUBKEYEX,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FACAUTHPUBKEYEX", (VOS_UINT8 *)"(1-20),(1-20),(@Pubkey)" },

    { AT_CMD_IDENTIFYSTART,
      AT_SetIdentifyStartPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^IDENTIFYSTART", (VOS_UINT8 *)"(@Rsa)" },

    { AT_CMD_IDENTIFYEND,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^IDENTIFYEND", VOS_NULL_PTR },

#if (FEATURE_PHONE_SC == FEATURE_ON)
    { AT_CMD_IDENTIFYOTASTART,
      AT_SetIdentifyStartPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^IDENTIFYOTASTART", (VOS_UINT8 *)"(@Rsa)" },

    { AT_CMD_IDENTIFYOTAEND,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^IDENTIFYOTAEND", VOS_NULL_PTR },

    { AT_CMD_SIMLOCKDATAWRITEEX,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKOTADATAWRITE", (VOS_UINT8 *)SIMLOCKDATAWRITEEX_CMD_PARA_STRING },
#endif

#if (FEATURE_SC_NETWORK_UPDATE == FEATURE_ON)
    { AT_CMD_SIMLOCKNWDATAWRITE,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKNWDATAWRITE", (VOS_UINT8 *)SIMLOCKDATAWRITEEX_CMD_PARA_STRING },
#endif

    { AT_CMD_SIMLOCKDATAWRITEEX,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKDATAWRITEEX", (VOS_UINT8 *)SIMLOCKDATAWRITEEX_CMD_PARA_STRING },
#if (FEATURE_PHONE_SC == FEATURE_ON)
    { AT_CMD_SIMLOCKDATAREADEX,
      AT_SimLockDataReadExPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKDATAREADEX", (VOS_UINT8 *)SIMLOCKDATAREADEX_CMD_PARA_STRING },
#endif

    { AT_CMD_SIMLOCKDATAWRITE,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKDATAWRITE", (VOS_UINT8 *)"(@SimlockData)" },

#if (FEATURE_PHONE_SC == FEATURE_ON)
    { AT_CMD_PHONESIMLOCKINFO,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryPhoneSimlockInfoPara, AT_QRY_PARA_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PHONESIMLOCKINFO", VOS_NULL_PTR },

    { AT_CMD_SIMLOCKDATAREAD,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QrySimlockDataReadPara, AT_QRY_PARA_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKDATAREAD", VOS_NULL_PTR },

    { AT_CMD_GETMODEMSCID,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryModemScIdPara, AT_QRY_PARA_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^GETMODEMSCID", VOS_NULL_PTR },
#endif

    { AT_CMD_PHONEPHYNUM,
      VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestHsicCmdPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PHONEPHYNUM", (VOS_UINT8 *)"(@type),(@Phynum),(@Hmac)" },

#if (FEATURE_PHONE_SC == FEATURE_ON)
    { AT_CMD_SIMLOCKUNLOCK,
      AT_SetSimlockUnlockPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, AT_TestSimlockUnlockPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SIMLOCKUNLOCK", (VOS_UINT8 *)"(\"NET\",\"NETSUB\",\"SP\"),(pwd)" },
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_FPLLSTATUS,
      AT_SetFPllStatusQryPara, AT_SET_PARA_TIME, AT_QryFPllStatusPara, AT_QRY_PARA_TIME, AT_TestFPllStatusPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FPLLSTATUS", (VOS_UINT8 *)"(0,1)" },
#endif

    { AT_CMD_FPOWDET,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryFpowdetTPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^FPOWDET", VOS_NULL_PTR },


#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    { AT_CMD_MEID,
      AT_SetMeidPara, AT_SET_PARA_TIME, AT_QryMeidPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^MEID", (VOS_UINT8 *)"(@number)" },

    { AT_CMD_DOSYSEVENT,
      AT_SetEvdoSysEvent, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DOSYSEVENT", (VOS_UINT8 *)"(0-4294967295)" },

    { AT_CMD_DOSIGMASK,
      AT_SetDoSigMask, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DOSIGMASK", (VOS_UINT8 *)"(0-4294967295)" },

#endif

    { AT_CMD_RFICID,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryRficDieIDPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^RFICID", VOS_NULL_PTR },

    { AT_CMD_RFFEID,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryRffeDieIDPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^RFFEID", VOS_NULL_PTR },

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    { AT_CMD_RFICIDEX,
      VOS_NULL_PTR, AT_NOT_SET_TIME, AT_QryRficDieIDExPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^RFICIDEX", VOS_NULL_PTR },
#endif

    { AT_CMD_PMUDIESN,
      AT_SetPmuDieSNPara, AT_SET_PARA_TIME, AT_QryPmuDieSNPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^PMUDIESN", (VOS_UINT8 *)"(0,1,2)" },


#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_SLTTEST,
      AT_SetSltTestPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SLTTEST", (VOS_UINT8 *)AT_SET_SLT_TEST_TYPF },
#endif

    { AT_CMD_BSN,
      At_SetBsn, AT_NOT_SET_TIME, At_QryBsn, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^BSN", VOS_NULL_PTR },

    { AT_CMD_TMODE,
      At_SetTModePara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, At_TestTmodePara, AT_TEST_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TMODE", (VOS_UINT8 *)"(0,1,2,3,4,11,12,13,14,15,16,17,18,19)" },

#if (FEATURE_LTEV == FEATURE_ON)
    { AT_CMD_VMODE,
      At_SetVModePara, AT_SET_PARA_TIME, At_QryVModePara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_TEST_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^VMODE", (VOS_UINT8 *)"(0),(0,1)" },
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_SRCID,
      AT_SetSourceId, AT_SET_PARA_TIME, AT_QrySourceId, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SRCID", (VOS_UINT8 *)"(0-1),(1-16777215)" },
#endif
#endif

    { AT_CMD_INFORBU,
      atSetNVFactoryBack, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^INFORBU", VOS_NULL_PTR },

    { AT_CMD_SN,
      At_SetSnPara, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, At_CmdTestProcOK, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_DEVICE_OTHER_ERROR, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^SN", VOS_NULL_PTR },

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_MIPIRD,
      AT_SetMipiRdPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^MIPIRD", (TAF_UINT8 *)"(0-9),(0-1),(0-15),(0-255)" },

    { AT_CMD_MIPIWREX,
      AT_SetMipiWrParaEx, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      /* extend_flag, mipi_id, secondary_id, reg_addr, byte_cnt, value */
      (TAF_UINT8 *)"^MIPIWREX", (TAF_UINT8 *)"(0,1),(0-15),(0-15),(0-255),(1,2,4),(0-4294967295)" },

    { AT_CMD_MIPIRDEX,
      AT_SetMipiRdParaEx, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      /* extend_flag, mipi_id, secondary_id, reg_addr, byte_cnt, speed_type, */
      (TAF_UINT8 *)"^MIPIRDEX", (TAF_UINT8 *)"(0,1),(0-15),(0-15),(0-255),(1,2,4),(0-65535)" },
#endif

    { AT_CMD_TSELRF,
      AT_SetTSelRfPara, AT_SET_PARA_TIME, AT_QryTSelRfPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_SET_PARA_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^TSELRF", (VOS_UINT8 *)TSELRF_CMD_PARA_STRING },

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_DPACAT,
      At_SetDpaCat, AT_NOT_SET_TIME, At_QryDpaCat, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DPACAT", VOS_NULL_PTR },

    { AT_CMD_HSSPT,
      AT_SetHsspt, AT_NOT_SET_TIME, AT_QryHsspt, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^HSSPT", (VOS_UINT8 *)"(0,1,2,6)" },

#if (FEATURE_LTE == FEATURE_ON)
    { AT_CMD_SFM,
      At_SetSfm, AT_SET_PARA_TIME, At_QrySfm, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^SFM", (VOS_UINT8 *)"(0,1)" },
#endif

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_MIPIWR,
      AT_SetMipiWrPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      /* mode, secondary_id,  address, data,channel */
      (TAF_UINT8 *)"^MIPIWR", (TAF_UINT8 *)"(0-9),(0-15),(0-255),(0-65535),(0-3)" },

    { AT_CMD_SSIWR,
      AT_SetSSIWrPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^SSIWR", (TAF_UINT8 *)"(0-9),(0-1),(0-255),(0-65535)" }, /* mode, channel, address, data */

    { AT_CMD_SSIRD,
      AT_SetSSIRdPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^SSIRD", (TAF_UINT8 *)"(0-9),(0-1),(0-255)" }, /* mode, channel, address */
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    { AT_CMD_DIVERSITYSWITCH,
      AT_SetCdmaAttDiversitySwitch, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^DIVERSITYSWITCH", (VOS_UINT8 *)"(0,1)" },
#endif

    { AT_CMD_TAS_TEST,
      AT_SetTasTestCfg, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TXTASTEST", (VOS_UINT8 *)"(0-4294967295),(0-4294967295),(0-4294967295),(0-4294967295),(0-4294967295)" },

    { AT_CMD_TAS_TEST_QUERY,
      AT_QryTasTestCfgPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8 *)"^TXTASTESTQRY", (VOS_UINT8 *)"(0-4294967295)" },

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    { AT_CMD_MIPIREAD,
      AT_SetMipiReadPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      /* read_type, mipi_id, secondary_id, reg_addr, speed_type, read_bit_mask, reserved1 */
      (TAF_UINT8 *)"^MIPIREAD", (TAF_UINT8 *)"(0,1),(0-15),(0-15),(0-65535),(0-2),(0-255),(0-255)" },

    { AT_CMD_PHYMIPIWRITE,
      AT_SetPhyMipiWritePara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      /* read_type, mipi_id, secondary_id, reg_addr, speed_type, read_bit_mask, reserved1 */
      (TAF_UINT8 *)"^PHYMIPIWRITE", (TAF_UINT8 *)"(0,1),(0-15),(0-15),(0-65535),(0-255),(0-255)" },
#endif
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_FAGCGAIN,
      AT_SetFAgcgainPara, AT_SET_PARA_TIME, AT_QryFAgcgainPara, AT_QRY_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^FAGCGAIN", (VOS_UINT8 *)"(0-255)" },
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    { AT_CMD_MIPIOPERATE,
      AT_SetMipiOpeRatePara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^MIPIOPERATE", (VOS_UINT8 *)"(0,1),(0-15),(0-15),(0-255),(1-4),(0-255)" },

    { AT_CMD_FRBINFO,
      AT_SetFRbInfoPara, AT_SET_PARA_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (TAF_UINT8 *)"^FRBINFO", (VOS_UINT8 *)"(0-4294967295),(0-4294967295)" },
#endif
#endif

#if ((FEATURE_UE_MODE_NR == FEATURE_ON) && defined(FEATURE_PHONE_ENG_AT_CMD) && \
     (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
    { AT_CMD_UARTTEST,
      AT_SetUartTest, AT_SET_PARA_TIME, AT_QryUartTest, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_NO_LIMITED,
      (VOS_UINT8 *)"^UARTTEST", VOS_NULL_PTR },

    { AT_CMD_I2STEST,
      AT_SetI2sTest, AT_SET_PARA_TIME, AT_QryI2sTest, AT_NOT_SET_TIME, VOS_NULL_PTR, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_NO_LIMITED,
      (VOS_UINT8 *)"^I2STEST", VOS_NULL_PTR },
#endif

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
    { AT_CMD_CMUX,
      At_SetCmuxPara, AT_SET_PARA_TIME, At_QryCmuxPara, AT_QRY_PARA_TIME, At_TestCmuxPara, AT_NOT_SET_TIME,
      VOS_NULL_PTR, AT_NOT_SET_TIME,
      AT_CME_INCORRECT_PARAMETERS, CMD_TBL_PIN_IS_LOCKED,
      (VOS_UINT8*)"+CMUX", (VOS_UINT8*)"(0),(0),(1-6),(31-1540),(10-250),(0-10),(10-250),(1-255),(1-7)"},
#endif

};

/*
 * 示例: ^CMDX 命令是不受E5密码保护命令，且在+CLAC列举所有命令时不显示，第一个参数是不带双引号的字符串,
 *      第二个参数是带双引号的字符串，第三个参数是整数型参数
 * !!!!!!!!!!!注意: param1和param2是示例，实际定义命令时应尽量定义的简短(可提高解析效率)!!!!!!!!!!!!!
 *  {AT_CMD_CMDX,
 *  At_SetCmdxPara, AT_SET_PARA_TIME, At_QryCmdxPara, AT_QRY_PARA_TIME, At_TestCmdxPara, AT_NOT_SET_TIME,
 *  AT_ERROR, CMD_TBL_E5_IS_LOCKED | CMD_TBL_CLAC_IS_INVISIBLE,
 *  (VOS_UINT8 *)"^CMDX", (VOS_UINT8 *)"(@param1),(param2),(0-255)"},
 */


VOS_UINT32 At_TestTmodePara(VOS_UINT8 indexNum)
{
#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    AT_DEVICE_CmdCtrl *atDevCmdCtrl = VOS_NULL_PTR;
#else
    AT_MT_Info *atMtInfoCtx = VOS_NULL_PTR;
#endif
    VOS_UINT16 length;

    length = 0;

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    atDevCmdCtrl = AT_GetDevCmdCtrl();
    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s: %d", g_parseContext[indexNum].cmdElement->cmdName,
        atDevCmdCtrl->currentTMode);
#else
    atMtInfoCtx             = AT_GetMtInfoCtx();
    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s: %d", g_parseContext[indexNum].cmdElement->cmdName,
        atMtInfoCtx->currentTMode);
#endif

    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 At_RegisterDeviceCmdTable(VOS_VOID)
{
    return AT_RegisterCmdTable(g_atDeviceCmdTbl, sizeof(g_atDeviceCmdTbl) / sizeof(g_atDeviceCmdTbl[0]));
}


VOS_UINT32 AT_SetTbatPara(VOS_UINT8 indexNum)
{
#if (FEATURE_LTE == FEATURE_ON)
    return atSetTBATPara(indexNum);

#else
    AT_TbatOperationDirectionUint32 tbatOperdirection;
    VBAT_CALIBART_Type              adcInfo;
    VOS_UINT32                      ret;

    /* 参数有效性检查 */
    /* ^TBAT命令设置命令至少带2个参数: 操作类型和方向 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_TBAT_PARA_TYPE].paraLen == 0) || (g_atParaList[AT_TBAT_PARA_OPR].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * ^TBAT命令设置命令参数检查:
     * 数字电池电压设置操作必须有3.7V对应的HKADC值和4.2V对应的HKADC值
     * 数字电池电压查询操作无<value1>和<value2>参数
     */

    /* V3R2-不支持电池模拟电压 */
    if (g_atParaList[AT_TBAT_PARA_TYPE].paraValue == AT_TBAT_BATTERY_ANALOG_VOLTAGE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    tbatOperdirection = g_atParaList[AT_TBAT_PARA_OPR].paraValue;
    if (tbatOperdirection == AT_TBAT_READ_FROM_UUT) {
        if (g_atParaIndex != AT_TBAT_READ_OPR_PARA_NUM) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        if ((g_atParaIndex != AT_TBAT_SET_OPR_PARA_NUM) || (g_atParaList[AT_TBAT_MIN_HKADC].paraLen == 0) ||
            (g_atParaList[AT_TBAT_MAX_HKADC].paraLen == 0)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if (tbatOperdirection == AT_TBAT_READ_FROM_UUT) {
        /* 调用底软接口获取电池数字电压 */
        if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                   DRV_AGENT_HKADC_GET_REQ, VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_TBAT_SET; /* 设置当前操作模式 */
            return AT_WAIT_ASYNC_RETURN;                             /* 等待异步事件返回 */
        } else {
            return AT_ERROR;
        }
    } else {
        /* 写参数到电池校准用的NV项90 NV_ITEM_BATTERY_ADC */
        adcInfo.minValue = (VOS_UINT16)g_atParaList[AT_TBAT_MIN_HKADC].paraValue;
        adcInfo.maxValue = (VOS_UINT16)g_atParaList[AT_TBAT_MAX_HKADC].paraValue;
        ret              = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_BATTERY_ADC, &adcInfo, sizeof(adcInfo));
        if (ret != NV_OK) {
            AT_WARN_LOG("AT_SetTbatPara: Fail to write NV NV_ITEM_BATTERY_ADC.");
            return AT_ERROR;
        }

        return AT_OK;
    }
#endif
    /*
     * 根据参数不同进行下述操作:
     * 1.  支持用户输入AT^TBAT=1,0获取电池电压数字值；
     * 调用底软/OM接口获取电池数字值
     * 2.  支持用户输入AT^TBAT=1,1,<value1>,<value2>设置电池电压数字值，用于电池校准；
     * 写校准电压到NVID 90(NV_ITEM_BATTERY_ADC)，此处有疑问待确认，
     * NV_ITEM_BATTERY_ADC中记录的是下述两个值，而AT命令仅一个参数，如何映射
     * 3.4V 电压对应的ADC值
     * 4.2V 电压对应的ADC值
     */
}


VOS_UINT32 AT_QryTbatPara(VOS_UINT8 indexNum)
{
    /*
     * 调用底软接口获取电池安装方式:
     * <mount type> 电池安装方式
     * 0 无电池
     * 1 可更换电池
     * 2 内置一体化电池
     */
    /* 命令状态类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_DEVICE_OTHER_ERROR;
    }

    if (AT_IsMiscSupport(BSP_MODULE_TYPE_CHARGE) == BSP_MODULE_UNSUPPORT) {
        return AT_ERROR;
    }

    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, DRV_AGENT_TBAT_QRY_REQ,
                               VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_TBAT_QRY; /* 设置当前操作模式 */
        /* 等待异步事件返回 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetPstandbyPara(VOS_UINT8 indexNum)
{
    DRV_AGENT_PstandbyReq pstandbyInfo;

    TAF_MMA_PhoneModePara phoneModePara;

    /* ^PSTANDBY设置命令有且仅有2个参数: 进入待机状态的时间长度和单板进入待机状态的切换时间 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或过少 */
    if ((g_atParaList[AT_PSTANDBY_STANDBY_TIME].paraLen == 0) ||
        (g_atParaList[AT_PSTANDBY_SWITCH_TIME].paraLen == 0) || (g_atParaIndex != AT_PSTANDBY_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    At_FormatResultData(indexNum, AT_OK); /* 需要先回复OK */

    /* 保证返回数据发送完成 */
    VOS_TaskDelay(TASK_DELAY_MILL_SECONDS);

    /*
     * 调用底软和OM接口使单板进入待机状态:
     * ACPU上完成的操作：
     * 1、下电WIFI
     * 2、LED下电
     * 3、USB PowerOff
     * 发消息到C核，指示CCPU上完成的操作：
     * 1、通信模块下电
     * 2、关定时器
     * 3、关中断
     * 4、调用底软接口进入深睡
     */
    pstandbyInfo.standbyTime = g_atParaList[AT_PSTANDBY_STANDBY_TIME].paraValue;
    pstandbyInfo.switchTime  = g_atParaList[AT_PSTANDBY_SWITCH_TIME].paraValue;

    DRV_PWRCTRL_STANDBYSTATEACPU(pstandbyInfo.standbyTime, pstandbyInfo.switchTime);

    /* 发送消息到c核 */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                               DRV_AGENT_PSTANDBY_SET_REQ, (VOS_UINT8 *)&pstandbyInfo, sizeof(pstandbyInfo),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
        AT_ERR_LOG("AT_SetPstandbyPara: AT_FillAndSndAppReqMsg fail.");
    }

    /* V7R2采用关机进入低功耗流程流程 */

    phoneModePara.phMode = TAF_PH_MODE_MINI;

    if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = (AT_CmdCurrentOpt)AT_CMD_PSTANDBY_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_WriteWiWep(VOS_UINT32 indexNum, VOS_UINT8 aucWiWep[], VOS_UINT16 wiWepLen,
                         TAF_AT_MultiWifiSec *wifiSecInfo, VOS_UINT8 group)
{
    errno_t    memResult;
    VOS_UINT32 ret;
    VOS_UINT32 loop;
    VOS_UINT8 *wifiWepKey = VOS_NULL_PTR;

    /* 因为仅修改en_NV_Item_WIFI_KEY中的WIFI KEY子项，所以需要先获取全部NV值，然后更新修改部分 */
    ret = TAF_ACORE_NV_READ_IN_CCORE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_KEY, (VOS_UINT8 *)wifiSecInfo,
                                     sizeof(TAF_AT_MultiWifiSec));
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_WriteWiWep: Fail to read en_NV_Item_WIFI_KEY.");
        return AT_ERROR;
    }

    /* 根据index获取NV中保存的密码 */
    wifiWepKey = ((indexNum == AT_WIWEP_PARA_INDEX_VAL_0) ? wifiSecInfo->wifiWepKey1[group] :
                      ((indexNum == AT_WIWEP_PARA_INDEX_VAL_1) ? wifiSecInfo->wifiWepKey2[group] :
                          ((indexNum == AT_WIWEP_PARA_INDEX_VAL_2) ? wifiSecInfo->wifiWepKey3[group] :
                              wifiSecInfo->wifiWepKey4[group])));

    /* 判断新的WIFI KEY与NV中记录的是否一致 */
    for (loop = 0; loop < AT_WIFI_KEY_LEN_MAX; loop++) {
        if (wifiWepKey[loop] != aucWiWep[loop]) {
            break;
        }
    }

    /* 判断新的WIFI KEY与NV中记录的一致则直接返回操作完成 */
    if (loop == AT_WIFI_KEY_LEN_MAX) {
        return AT_OK;
    }

    /* 更新数据到NV项en_NV_Item_WIFI_KEY */
    (VOS_VOID)memset_s(wifiWepKey, AT_WIFI_KEY_LEN_MAX, 0x00, AT_WIFI_KEY_LEN_MAX);

    if ((wiWepLen > 0) && (wiWepLen <= AT_WIFI_KEY_LEN_MAX)) {
        memResult = memcpy_s(wifiWepKey, AT_WIFI_KEY_LEN_MAX, aucWiWep, wiWepLen);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_WIFI_KEY_LEN_MAX, wiWepLen);
    }

    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_KEY, (VOS_UINT8 *)wifiSecInfo, sizeof(TAF_AT_MultiWifiSec));
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_WriteWiWep: Fail to write NV en_NV_Item_WIFI_KEY.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetWiwepPara(VOS_UINT8 indexNum)
{
    VOS_UINT32           indexTemp;
    VOS_UINT8            group;
    VOS_UINT32           ret;
    TAF_AT_MultiWifiSec *wifiSecInfo = VOS_NULL_PTR;

    if (AT_IsMiscSupport(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT) {
        return AT_ERROR;
    }

    /* 输入参数检查: 有且仅有< index >和< content >两个参数 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    if ((g_atParaList[AT_WIWEP_PARA_WIFI_KEY_INDEX].paraLen == 0) ||
        (g_atParaList[AT_WIWEP_PARA_WIFI_KEY_CONTENT].paraLen == 0) ||
        (g_atParaList[AT_WIWEP_SSID_GROUP_INDEX].paraLen == 0)) {
        return AT_ERROR;
    }

    /* WIFI key 操作受DATALOCK保护 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_ERROR;
    }

    /* < index >必须在0-3范围内，< content >长度小于NV_WLKEY_LEN */
    indexTemp = g_atParaList[AT_WIWEP_PARA_WIFI_KEY_INDEX].paraValue;
    if (indexTemp > AT_WIWEP_CARD_WIFI_KEY_TOTAL) {
        return AT_ERROR;
    }

    if (g_atParaList[AT_WIWEP_PARA_WIFI_KEY_CONTENT].paraLen > AT_NV_WLKEY_LEN) {
        return AT_ERROR;
    }

    group = (VOS_UINT8)g_atParaList[AT_WIWEP_SSID_GROUP_INDEX].paraValue;

    if (group >= AT_WIFI_MAX_SSID_NUM) {
        return AT_ERROR;
    }

    /* 组装WIFI KEY到NV结构并更新数据到NV项en_NV_Item_WIFI_KEY */
    /*lint -save -e830 */
    wifiSecInfo = (TAF_AT_MultiWifiSec *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_AT_MultiWifiSec));
    /*lint -restore */
    if (wifiSecInfo == VOS_NULL_PTR) {
        return AT_ERROR;
    }
    memset_s(wifiSecInfo, sizeof(TAF_AT_MultiWifiSec), 0x00, sizeof(TAF_AT_MultiWifiSec));

    ret = AT_WriteWiWep(indexTemp, g_atParaList[AT_WIWEP_PARA_WIFI_KEY_CONTENT].para,
                        g_atParaList[AT_WIWEP_PARA_WIFI_KEY_CONTENT].paraLen, wifiSecInfo, group);
    /*lint -save -e830 */
    PS_MEM_FREE(WUEPS_PID_AT, wifiSecInfo);
    /*lint -restore */
    return ret;
}


VOS_UINT32 AT_QryWiwepPara(VOS_UINT8 indexNum)
{
    errno_t              memResult;
    VOS_UINT32           ret;
    VOS_UINT32           loop;
    VOS_UINT16           length;
    TAF_AT_MultiWifiSec *wifiSecInfo = VOS_NULL_PTR;
    VOS_UINT8            wifiWepKey[AT_NV_WLKEY_LEN + 1];
    VOS_UINT8            wepKeyLen1[AT_WIFI_MAX_SSID_NUM];
    VOS_UINT8            wepKeyLen2[AT_WIFI_MAX_SSID_NUM];
    VOS_UINT8            wepKeyLen3[AT_WIFI_MAX_SSID_NUM];
    VOS_UINT8            wepKeyLen4[AT_WIFI_MAX_SSID_NUM];
    VOS_UINT8            wepKeyNum;

    if (AT_IsMiscSupport(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT) {
        return AT_ERROR;
    }

    /* 为读取WIFI KEY申请内存，读NV项en_NV_Item_WIFI_KEY获取WIFI KEY信息 */
    wifiSecInfo = (TAF_AT_MultiWifiSec *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_AT_MultiWifiSec));
    if (wifiSecInfo == VOS_NULL_PTR) {
        return AT_ERROR;
    }
    (VOS_VOID)memset_s(wifiSecInfo, sizeof(TAF_AT_MultiWifiSec), 0x00, sizeof(TAF_AT_MultiWifiSec));

    ret = TAF_ACORE_NV_READ_IN_CCORE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_KEY, (VOS_UINT8 *)wifiSecInfo,
                                     sizeof(TAF_AT_MultiWifiSec));
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_QryWiwepPara: Fail to read en_NV_Item_WIFI_KEY.");
        PS_MEM_FREE(WUEPS_PID_AT, wifiSecInfo);
        return AT_ERROR;
    }

    wepKeyNum = 0;
    (VOS_VOID)memset_s(wepKeyLen1, sizeof(wepKeyLen1), 0x00, sizeof(wepKeyLen1));
    (VOS_VOID)memset_s(wepKeyLen2, sizeof(wepKeyLen2), 0x00, sizeof(wepKeyLen2));
    (VOS_VOID)memset_s(wepKeyLen3, sizeof(wepKeyLen3), 0x00, sizeof(wepKeyLen3));
    (VOS_VOID)memset_s(wepKeyLen4, sizeof(wepKeyLen4), 0x00, sizeof(wepKeyLen4));

    for (loop = 0; loop < AT_WIFI_MAX_SSID_NUM; loop++) {
        /* KEY1对应的NV不空表示KEY1有效 */
        wepKeyLen1[loop] = (VOS_UINT8)VOS_StrLen((VOS_CHAR *)wifiSecInfo->wifiWepKey1[loop]);
        if (wepKeyLen1[loop] != 0) {
            wepKeyNum++;
        }

        wepKeyLen2[loop] = (VOS_UINT8)VOS_StrLen((VOS_CHAR *)wifiSecInfo->wifiWepKey2[loop]);
        if (wepKeyLen2[loop] != 0) {
            wepKeyNum++;
        }

        wepKeyLen3[loop] = (VOS_UINT8)VOS_StrLen((VOS_CHAR *)wifiSecInfo->wifiWepKey3[loop]);
        if (wepKeyLen3[loop] != 0) {
            wepKeyNum++;
        }

        wepKeyLen4[loop] = (VOS_UINT8)VOS_StrLen((VOS_CHAR *)wifiSecInfo->wifiWepKey4[loop]);
        if (wepKeyLen4[loop] != 0) {
            wepKeyNum++;
        }
    }

    /* 未解锁时，需要返回已定制0组 */
    if (g_atDataLocked == VOS_TRUE) {
        wepKeyNum = 0;
        (VOS_VOID)memset_s(wepKeyLen1, sizeof(wepKeyLen1), 0x00, sizeof(wepKeyLen1));
        (VOS_VOID)memset_s(wepKeyLen2, sizeof(wepKeyLen2), 0x00, sizeof(wepKeyLen2));
        (VOS_VOID)memset_s(wepKeyLen3, sizeof(wepKeyLen3), 0x00, sizeof(wepKeyLen3));
        (VOS_VOID)memset_s(wepKeyLen4, sizeof(wepKeyLen4), 0x00, sizeof(wepKeyLen4));
    }

    /*
     * 满足工位对接要求，需要输出工位支持的全部数20个WiFi WEP（WIFI的KEY）
     * 打印四组单板支持的WIFI KEY信息
     * 填充16行^WIWEP: <index>,与工位要求的20个的WiFi WEP（WIFI的KEY）一致，
     */
    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s:%d%s", g_parseContext[indexNum].cmdElement->cmdName, wepKeyNum, g_atCrLf);

    for (loop = 0; loop < AT_WIFI_MAX_SSID_NUM; loop++) {
        if (wepKeyLen1[loop] != 0) {
            /* wifikey1 */
            (VOS_VOID)memset_s(wifiWepKey, sizeof(wifiWepKey), 0x00, sizeof(wifiWepKey));

            memResult = memcpy_s(wifiWepKey, sizeof(wifiWepKey), wifiSecInfo->wifiWepKey1[loop], AT_WIFI_KEY_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(wifiWepKey), AT_WIFI_KEY_LEN_MAX);

            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%s:%d,%s,%d%s", g_parseContext[indexNum].cmdElement->cmdName,
                0, wifiWepKey, loop, g_atCrLf);
        }

        if (wepKeyLen2[loop] != 0) {
            /* wifikey1 */
            (VOS_VOID)memset_s(wifiWepKey, sizeof(wifiWepKey), 0x00, sizeof(wifiWepKey));

            memResult = memcpy_s(wifiWepKey, sizeof(wifiWepKey), wifiSecInfo->wifiWepKey2[loop], AT_WIFI_KEY_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(wifiWepKey), AT_WIFI_KEY_LEN_MAX);

            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%s:%d,%s,%d%s", g_parseContext[indexNum].cmdElement->cmdName,
                1, wifiWepKey, loop, g_atCrLf);
        }

        if (wepKeyLen3[loop] != 0) {
            /* wifikey1 */
            (VOS_VOID)memset_s(wifiWepKey, sizeof(wifiWepKey), 0x00, sizeof(wifiWepKey));

            memResult = memcpy_s(wifiWepKey, sizeof(wifiWepKey), wifiSecInfo->wifiWepKey3[loop], AT_WIFI_KEY_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(wifiWepKey), AT_WIFI_KEY_LEN_MAX);

            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%s:%d,%s,%d%s", g_parseContext[indexNum].cmdElement->cmdName,
                AT_WIWEP_WIFI_KEY_INDEX_2, wifiWepKey, loop, g_atCrLf);
        }

        if (wepKeyLen4[loop] != 0) {
            /* wifikey1 */
            (VOS_VOID)memset_s(wifiWepKey, sizeof(wifiWepKey), 0x00, sizeof(wifiWepKey));

            memResult = memcpy_s(wifiWepKey, sizeof(wifiWepKey), wifiSecInfo->wifiWepKey4[loop], AT_WIFI_KEY_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(wifiWepKey), AT_WIFI_KEY_LEN_MAX);

            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%s:%d,%s,%d%s", g_parseContext[indexNum].cmdElement->cmdName,
                AT_WIWEP_WIFI_KEY_INDEX_3, wifiWepKey, loop, g_atCrLf);
        }
    }

    g_atSendDataBuff.bufLen = length - (VOS_UINT16)VOS_StrLen((VOS_CHAR *)g_atCrLf);

    PS_MEM_FREE(WUEPS_PID_AT, wifiSecInfo);

    return AT_OK;
}


VOS_UINT32 AT_TestWiwepPara(VOS_UINT8 indexNum)
{
    if (AT_IsMiscSupport(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT) {
        return AT_ERROR;
    }

    g_atSendDataBuff.bufLen =
        (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s:%d", g_parseContext[indexNum].cmdElement->cmdName,
            AT_WIWEP_TOOLS_WIFI_KEY_TOTAL);

    return AT_OK;
}


VOS_UINT32 AT_SetCmdlenPara(VOS_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或过少 */
    if ((g_atParaList[AT_PC_EXPECT_TX_MSG_LEN].paraLen == 0) ||
        (g_atParaList[AT_PC_EXPECT_RX_MSG_LEN].paraLen == 0) || (g_atParaIndex != AT_CMDLEN_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_PC_EXPECT_TX_MSG_LEN].paraValue > (AT_COM_BUFF_LEN - sizeof("AT"))) {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_QryCmdlenPara(VOS_UINT8 indexNum)
{
    /*
     * 输出单板最大可以直接接收AT命令字符个数(AT_CMD_MAX_LEN - sizeof("AT"))，
     * 该字符个数均不包含AT这两个字符，以及单板通过AT一次最大可以响应的字符个数，
     * BALONG产品响应字符串长度可以分
     * 多次上报，没有最大值概念，工位对该值无处理，此处输出一次上报的最大值AT_CMD_MAX_LEN。
     */
    g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress,
        "%s:%d,%d", g_parseContext[indexNum].cmdElement->cmdName, (AT_COM_BUFF_LEN - VOS_StrLen("AT")),
        AT_CMD_MAX_LEN);

    return AT_OK;
}


VOS_UINT32 AT_UpdateMacPara(VOS_UINT8 aucMac[], VOS_UINT16 macLength)
{
    errno_t    memResult;
    VOS_UINT32 ret;
    VOS_UINT32 loop;
    VOS_UINT32 wifiGlobalMacOffset;
    VOS_UINT32 phyNumMacOffset;
    VOS_UINT8  wifiGlobalMac[AT_MAC_ADDR_LEN];

    /* MAC地址长度检查: 必须12位 */
    if (macLength != AT_PHYNUM_MAC_LEN) {
        return AT_PHYNUM_LENGTH_ERR;
    }

    /* MAC地址格式匹配: 7AFEE22111E4=>7A:FE:E2:21:11:E4 */
    wifiGlobalMacOffset = 0;
    phyNumMacOffset     = 0;
    for (loop = 0; loop < (AT_PHYNUM_MAC_COLON_NUM + 1); loop++) {
        memResult = memcpy_s(&wifiGlobalMac[wifiGlobalMacOffset], AT_MAC_ADDR_LEN - wifiGlobalMacOffset,
                             &aucMac[phyNumMacOffset], AT_WIFIGLOBAL_MAC_LEN_BETWEEN_COLONS);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_MAC_ADDR_LEN - wifiGlobalMacOffset, AT_WIFIGLOBAL_MAC_LEN_BETWEEN_COLONS);
        wifiGlobalMacOffset += AT_WIFIGLOBAL_MAC_LEN_BETWEEN_COLONS;
        phyNumMacOffset += AT_WIFIGLOBAL_MAC_LEN_BETWEEN_COLONS;
        wifiGlobalMac[wifiGlobalMacOffset] = ':';
        wifiGlobalMacOffset++;
    }

    wifiGlobalMac[AT_PHYNUM_MAC_LEN + AT_PHYNUM_MAC_COLON_NUM] = '\0';

    /* 更新MAC地址到NV */
    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WIFI_MAC_ADDR, wifiGlobalMac, AT_MAC_ADDR_LEN);
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_UpdateMacPara: Fail to write NV.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetTmodeAutoPowerOff(VOS_UINT8 indexNum)
{
    TAF_MMA_PhoneModePara phModeSet;

    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;

    memset_s(&phModeSet, sizeof(phModeSet), 0x00, sizeof(TAF_MMA_PhoneModePara));

    systemAppConfig = AT_GetSystemAppConfigAddr();

    if (*systemAppConfig == SYSTEM_APP_WEBUI) {
        /* 发消息给C核通知关机并下电 */
        /*
         * 先通知用户AT命令已执行，用户通过检测端口是否消失来确认任务是否正确执行
         * 此命令执行完成后已下电，无需等待异步返回
         */

        phModeSet.phMode = TAF_PH_MODE_POWEROFF;

        if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phModeSet) == VOS_TRUE) {
            return AT_OK;
        } else {
            return AT_ERROR;
        }
    }

    return AT_ERROR;
}


VOS_VOID AT_GetSpecificPort(VOS_UINT8 portType, VOS_UINT8 aucRewindPortStyle[], VOS_UINT32 *portPos,
                            VOS_UINT32 *portNum)
{
    VOS_UINT32 loop;

    *portPos = AT_DEV_NONE;
    for (loop = 0; loop < AT_SETPORT_PARA_MAX_LEN; loop++) {
        if (aucRewindPortStyle[loop] == 0) {
            break;
        }

        /* 端口值为ucPortType，表示找到指定端口，记录ulLoop为端口在NV项中的偏移 */
        if (portType == aucRewindPortStyle[loop]) {
            *portPos = loop;
        }
    }

    /* 端口值为0或到达循环上限，ulLoop即为单板的端口总数 */
    *portNum = loop;

    return;
}


VOS_UINT32 AT_ExistSpecificPort(VOS_UINT8 portType)
{
    AT_DynamicPidType dynamicPidType;
    VOS_UINT32        portPos;
    VOS_UINT32        portNum;

    memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(dynamicPidType));

    portPos = 0;
    portNum = 0;

    /* 读NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE获取当前的端口状态 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType)) !=
        NV_OK) {
        AT_WARN_LOG("AT_ExistSpecificPort: Read NV fail!");
        return VOS_FALSE;
    }

    /* 判断DIAG端口是否已经打开: 已经打开则直接返回AT_OK */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 查询NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE中是否已经存在DIAG口 */
        AT_GetSpecificPort(portType, dynamicPidType.rewindPortStyle, &portPos, &portNum);

        if (portPos != AT_DEV_NONE) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_OpenDiagPort(VOS_VOID)
{
    AT_DynamicPidType dynamicPidType;
    VOS_UINT32        portPos;
    VOS_UINT32        portNum;

    memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(dynamicPidType));

    portPos = 0;
    portNum = 0;

    /* 读NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE获取当前的端口状态 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType)) !=
        NV_OK) {
        AT_WARN_LOG("AT_OpenDiagPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断DIAG端口是否已经打开: 已经打开则直接返回AT_OK */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 查询NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE中是否已经存在DIAG口 */
        AT_GetSpecificPort(AT_DEV_DIAG, dynamicPidType.rewindPortStyle, &portPos, &portNum);

        if (portPos != AT_DEV_NONE) {
            return AT_OK;
        }

    } else {
        AT_WARN_LOG("AT_OpenDiagPort: NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE is inactive!");
        return AT_OK;
    }

    /* DIAG端口操作权限未获取: 直接返回AT_OK */
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_NO) {
        return AT_OK;
    }

    /* 追加DIAG端口到切换后端口集 */
    if (portNum == AT_SETPORT_PARA_MAX_LEN) {
        return AT_OK;
    }

    dynamicPidType.rewindPortStyle[portNum] = AT_DEV_DIAG;

    /* 更新端口集合数据到NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, (VOS_UINT8 *)&dynamicPidType,
                           sizeof(AT_DynamicPidType)) != NV_OK) {
        AT_ERR_LOG("AT_OpenDiagPort: Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_CloseDiagPort(VOS_VOID)
{
    AT_DynamicPidType dynamicPidType;
    VOS_UINT32        portPos;
    VOS_UINT32        portNum;
    VOS_UINT32        loop;

    memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(dynamicPidType));

    portPos = 0;
    portNum = 0;

    /* 读NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE获取当前的端口状态 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType)) !=
        NV_OK) {
        AT_ERR_LOG("AT_CloseDiagPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断DIAG端口是否已经打开: 已经打开则直接返回AT_OK */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 查询NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE中是否已经存在DIAG口 */
        AT_GetSpecificPort(AT_DEV_DIAG, dynamicPidType.rewindPortStyle, &portPos, &portNum);

        if (portPos == AT_DEV_NONE) {
            return AT_OK;
        }
    } else {
        return AT_OK;
    }

    /* DIAG端口操作权限未获取: 直接返回AT_OK */
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_NO) {
        return AT_OK;
    }

    /* 删除NV项中的DIAG端口 */
    dynamicPidType.rewindPortStyle[portPos] = 0;
    portNum--;
    for (loop = portPos; loop < portNum; loop++) {
        dynamicPidType.rewindPortStyle[loop] = dynamicPidType.rewindPortStyle[loop + 1UL];
    }
    dynamicPidType.rewindPortStyle[portNum] = 0;

    /* 端口异常数据保护: 切换后的设备形态中，第一个设备不能为MASS设备(0xa1,0xa2) */
    if (portNum != 0) {
        if ((dynamicPidType.rewindPortStyle[0] == AT_DEV_CDROM) || (dynamicPidType.rewindPortStyle[0] == AT_DEV_SD)) {
            return AT_OK;
        }
    }

    /* 更新端口集合数据到NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, (VOS_UINT8 *)&dynamicPidType,
                           sizeof(AT_DynamicPidType)) != NV_OK) {
        AT_ERR_LOG("AT_CloseDiagPort: Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_ExistSpecificPortChange(VOS_UINT8 portType, VOS_UINT8 aucOldRewindPortStyle[],
                                      VOS_UINT8 aucNewRewindPortStyle[])
{
    VOS_UINT32 oldPortPos;
    VOS_UINT32 newPortPos;
    VOS_UINT32 portNum;

    oldPortPos = 0;
    newPortPos = 0;
    portNum    = 0;

    AT_GetSpecificPort(portType, aucOldRewindPortStyle, &oldPortPos, &portNum);
    AT_GetSpecificPort(portType, aucNewRewindPortStyle, &newPortPos, &portNum);

    /* 新增一个指定端口 */
    if ((oldPortPos == AT_DEV_NONE) && (newPortPos != AT_DEV_NONE)) {
        return VOS_TRUE;
    }

    /* 删除一个指定端口 */
    if ((oldPortPos != AT_DEV_NONE) && (newPortPos == AT_DEV_NONE)) {
        return VOS_TRUE;
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_CheckSetPortRight(VOS_UINT8 aucOldRewindPortStyle[], VOS_UINT8 aucNewRewindPortStyle[])
{
    VOS_UINT32 ret;

    ret = AT_ExistSpecificPortChange(AT_DEV_DIAG, aucOldRewindPortStyle, aucNewRewindPortStyle);

    if ((ret == VOS_TRUE) && (g_ate5RightFlag == AT_E5_RIGHT_FLAG_NO)) {
        return AT_ERROR;
    }

    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetHsspt(VOS_UINT8 indexNum)
{
    VOS_UINT8 rRCVer;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_DPAUPA_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_DPAUPA_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息:ErrCode:0 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_DATA_UNLOCK_ERROR;
    }

    rRCVer = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 调用写NV接口函数: AT_WriteRrcVerToNV,返回操作结果 */
    if (AT_WriteRrcVerToNV(rRCVer) == VOS_OK) {
        return AT_OK;
    } else {
        AT_WARN_LOG("At_SetHsspt:WARNING:Write NV failed!");
        return AT_DPAUPA_ERROR;
    }
}


VOS_UINT32 AT_QryHsspt(VOS_UINT8 indexNum)
{
    VOS_UINT8  rRCVer;
    VOS_UINT32 result;
    VOS_UINT16 length;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_DPAUPA_ERROR;
    }

    result = AT_ReadRrcVerFromNV(&rRCVer);

    if (result == VOS_OK) {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s:", g_parseContext[indexNum].cmdElement->cmdName);
        length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + length, "%d", (VOS_UINT32)rRCVer);
        g_atSendDataBuff.bufLen = length;
        return AT_OK;
    } else {
        AT_WARN_LOG("AT_QryHspaSpt:WARNING:WAS_MNTN_QueryHspaSpt failed!");
        return AT_DPAUPA_ERROR;
    }
}
#endif


VOS_UINT32 AT_TestHsicCmdPara(VOS_UINT8 indexNum)
{
    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_TestSimlockUnlockPara(VOS_UINT8 indexNum)
{
    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s: (\"NET\",\"NETSUB\",\"SP\")",
        g_parseContext[indexNum].cmdElement->cmdName);

    return AT_OK;
}


VOS_UINT32 AT_String2Hex(VOS_UINT8 *nptr, VOS_UINT16 len, VOS_UINT32 *rtn)
{
    VOS_UINT32 c      = 0; /* current Char */
    VOS_UINT32 total  = 0; /* current total */
    VOS_UINT32 length = 0; /* current Length */

    for (length = 0; length < len; length++) {
        c = (VOS_UINT32)(*nptr); /* get next Char */
        nptr++;

        if ((c >= '0') && (c <= '9')) {
            c = c - '0';
        } else if ((c >= 'a') && (c <= 'f')) {
            /* 将字符串转换成十进制数 */
            c = c - 'a' + 10;
        } else if ((c >= 'A') && (c <= 'F')) {
            /* 将字符串转换成十进制数 */
            c = c - 'A' + 10;
        } else {
            return VOS_ERR;
        }

        if (total > 0x0FFFFFFF) { /* 发生反转 */
            return VOS_ERR;
        } else {
            total = (total << 4) + c; /* accumulate digit */
        }
    }

    /* return result, negated if necessary */
    *rtn = total;
    return AT_SUCCESS;
}


VOS_UINT32 AT_NVWRGetItemValue(VOS_UINT8 *para, VOS_UINT16 paraMaxLen, VOS_UINT8 *value, VOS_UINT8 **paraDst)
{
    VOS_UINT32 tmp   = 0;
    VOS_UINT32 i     = 0;
    VOS_UINT8 *start = para;
    VOS_UINT16 len   = 0;
    VOS_UINT8 *end   = VOS_NULL_PTR;
    VOS_UINT32 ret;

    /* 调用的地方保证pucPara,pucValue,pucParaDst不为NULL */

    /* 直到第一个不是' '的字符 */
    while ((i < paraMaxLen) && (*start == ' ')) {
        start++;
        i++;
    }

    /*
     * at^nvwr写NV项的值，写每个IE项的值时用空格隔开，每项值最大占两个字节
     * 1表示当此项IE项的有效长度为一个字节，2表示有效长度加空格后的长度
     */
    if ((i + 2 < paraMaxLen) && (*(start + 1) == ' ')) {
        len = 1;         /* 1表示当此项IE项的有效长度为一个字节 */
        end = start + 2; /* 2表示有效长度加空格后的长度 */
    /* 2表示当此项IE项的有效长度为两个字节，3表示有效长度加空格后的长度 */
    } else if ((i + 3 < paraMaxLen ) && (*(start + 2) == ' ')) {
        len = 2;         /* 2表示当此项IE项的有效长度为两个字节 */
        end = start + 3; /* 3表示有效长度加空格后的长度 */
    } else {
        return VOS_ERR;
    }

    ret = AT_String2Hex(start, len, &tmp);
    if ((ret != VOS_OK) || (tmp > 0xff)) {
        return VOS_ERR;
    }

    *value   = (VOS_UINT8)tmp;
    *paraDst = end;

    return VOS_OK;
}


VOS_UINT32 AT_NVWRGetParaInfo(AT_ParseParaType *para, VOS_UINT8 *pu8Data, VOS_UINT32 bufLen, VOS_UINT32 *len)
{
    VOS_UINT32 num;
    VOS_UINT8 *pu8Start   = VOS_NULL_PTR;
    VOS_UINT8 *pu8ParaTmp = VOS_NULL_PTR;
    VOS_UINT16 lenTemp;
    VOS_UINT32 ret;
    VOS_UINT16 i = 0;

    /* 调用的地方保证pstPara,pu8Data不为NULL */

    pu8Start = para->para;
    lenTemp  = para->paraLen;

    if (lenTemp < AT_PARA_MAX_LEN) {
        para->para[lenTemp] = ' ';
    } else {
        return VOS_ERR;
    }

    num = 0;
    for (i = 0; i < lenTemp;) {
        /* 因为在上面补了一个空格，后续要访问结束符，所以para的长度值需要+2 */
        ret = AT_NVWRGetItemValue(pu8Start, lenTemp + 2, (pu8Data + num), &pu8ParaTmp);
        if (ret != ERR_MSP_SUCCESS) {
            return ret;
        }

        num++;

        /* 最多128个 */
        /* MAX_NV_NUM_PER_PARA */
        if ((num == bufLen) || (num == AT_NV_NUM_PER_MAX_NUM)) {
            break;
        }

        if (pu8ParaTmp >= (pu8Start + lenTemp)) {
            break;
        }

        i += (VOS_UINT16)(pu8ParaTmp - pu8Start);
        pu8Start = pu8ParaTmp;
    }

    *len = num;
    return VOS_OK;
}


VOS_UINT32 AT_SetNVReadPara(VOS_UINT8 indexNum)
{
    VOS_UINT16    nvId    = 0;
    VOS_UINT32    nvLen   = 0;
    VOS_UINT8    *data    = VOS_NULL_PTR;
    VOS_UINT32    i       = 0;
    ModemIdUint16 modemId = MODEM_ID_0;
    VOS_UINT32    ret;

    AT_PR_LOGI("Rcv Msg");

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        g_nvRead = AT_NVREAD_STATUS_1;
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        g_nvRead = AT_NVREAD_STATUS_2;
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        g_nvRead = AT_NVREAD_STATUS_3;
        return AT_CME_INCORRECT_PARAMETERS;
    } else {
        nvId = (VOS_UINT16)g_atParaList[0].paraValue;
    }

    ret = TAF_ACORE_NV_GET_LENGTH(nvId, &nvLen);

    if (ret != VOS_OK) {
        g_nvRead = AT_NVREAD_STATUS_4;
        return AT_ERROR;
    }

    if (nvLen == 0) {
        AT_WARN_LOG("data cannot malloc space !");
        return AT_ERROR;
    }
    /* 长度大于128，只取前128个字节 */
    /*lint -save -e516 */
    data = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, nvLen);
    /*lint -restore */
    if (data == VOS_NULL_PTR) {
        g_nvRead = AT_NVREAD_STATUS_5;
        return AT_ERROR;
    }
    memset_s(data, nvLen, 0x00, nvLen);

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("AT_SetNVReadPara:Get modem id fail");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, data);
        /*lint -restore */
        g_nvWrite = AT_NVWR_STATUS_8;
        return AT_ERROR;
    }

    ret = TAF_ACORE_NV_READ(modemId, nvId, data, nvLen);

    AT_PR_LOGI("Call interface success!");

    if (ret != VOS_OK) {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, data);
        /*lint -restore */
        g_nvRead = AT_NVREAD_STATUS_6;
        return AT_ERROR;
    }
    g_atSendDataBuff.bufLen = 0;
    g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "^NVRD: %d,", nvLen);

    for (i = 0; i < nvLen; i++) {
        if (i == 0) {
            g_atSendDataBuff.bufLen += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN,
                (VOS_CHAR *)g_atSndCodeAddress, (VOS_CHAR *)g_atSndCodeAddress + g_atSendDataBuff.bufLen, "%02X",
                data[i]);
        } else {
            g_atSendDataBuff.bufLen += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN,
                (VOS_CHAR *)g_atSndCodeAddress, (VOS_CHAR *)g_atSndCodeAddress + g_atSendDataBuff.bufLen, " %02X",
                data[i]);
        }
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, data);
    /*lint -restore */
    g_nvRead = AT_NVREAD_STATUS_7;
    return AT_OK;
}



VOS_VOID AT_GetNvRdDebug(VOS_VOID)
{
    PS_PRINTF_INFO("g_nvRead=0x%x \n", g_nvRead);
    PS_PRINTF_INFO("g_nvWrite=0x%x \n", g_nvWrite);
}



VOS_BOOL AT_IsNVWRAllowedNvId(VOS_UINT16 nvId)
{
    TAF_NV_NvwrSecCtrl nvwrSecCtrlNV;
    VOS_UINT32         loop;
    VOS_UINT8          blockListNum;

    /* 参数初始化 */
    memset_s(&nvwrSecCtrlNV, sizeof(nvwrSecCtrlNV), 0x00, sizeof(nvwrSecCtrlNV));

    /* 读取安全控制NV */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_NVWR_SEC_CTRL, &nvwrSecCtrlNV, sizeof(nvwrSecCtrlNV)) != NV_OK) {
        AT_ERR_LOG("AT_IsNVWRAllowedNvId: TAF_ACORE_NV_READ fail!");
        return VOS_FALSE;
    }

    switch (nvwrSecCtrlNV.secType) {
        case AT_NVWR_SEC_TYPE_OFF:
            return VOS_TRUE;

        case AT_NVWR_SEC_TYPE_ON:
            return VOS_FALSE;

        case AT_NVWR_SEC_TYPE_BLOCKLIST:
            blockListNum = (nvwrSecCtrlNV.blockListNum <= TAF_NV_BLOCK_LIST_MAX_NUM) ? nvwrSecCtrlNV.blockListNum :
                                                                                       TAF_NV_BLOCK_LIST_MAX_NUM;
            for (loop = 0; loop < blockListNum; loop++) {
                if (nvId == nvwrSecCtrlNV.blockList[loop]) {
                    return VOS_FALSE;
                }
            }
            return VOS_TRUE;

        default:
            AT_ERR_LOG1("AT_IsNVWRAllowedNvId: Error SecType:", nvwrSecCtrlNV.secType);
            break;
    }

    return VOS_FALSE;
}



VOS_UINT32 AT_AsciiToHex(VOS_UINT8 *src, VOS_UINT8 *dst)
{
    if ((*src >= '0') && (*src <= '9')) { /* the number is 0-9 */
        *dst = (VOS_UINT8)(*src - '0');
    } else if ((*src >= 'a') && (*src <= 'f')) { /* the number is a-f */
        *dst = (VOS_UINT8)(*src - 'a') + 0x0a;
    } else if ((*src >= 'A') && (*src <= 'F')) { /* the number is A-F */
        *dst = (VOS_UINT8)(*src - 'A') + 0x0a;
    } else {
        return VOS_ERR;
    }

    return VOS_OK;
}



VOS_UINT32 AT_AsciiToHexCode_Revers(VOS_UINT8 *src, VOS_UINT16 dataLen, VOS_UINT8 *dst)
{
    VOS_INT32  loop1;
    VOS_UINT32 loop2;
    VOS_UINT8  temp1;
    VOS_UINT8  temp2;
    VOS_UINT32 rslt;

    loop1 = (VOS_INT32)(dataLen - 1);
    for (loop2 = 0; loop1 >= 0; loop1--, loop2++) {
        rslt = AT_AsciiToHex(&(src[loop1]), &temp1);
        if (rslt == VOS_ERR) {
            return VOS_ERR;
        }

        loop1--;

        if (loop1 < 0) {
            AT_ERR_LOG("AT_AsciiToHexCode_Revers: sLoop1 is invalid.");

            return VOS_ERR;
        }

        rslt = AT_AsciiToHex(&(src[loop1]), &temp2);
        if (rslt == VOS_ERR) {
            return VOS_ERR;
        }

        dst[loop2] = (VOS_UINT8)((temp2 << 4) | temp1);
    }

    return VOS_OK;
}


VOS_UINT32 AT_Hex2Ascii_Revers(VOS_UINT8 aucHex[], VOS_UINT32 length, VOS_UINT8 aucAscii[])
{
    VOS_INT32  loopSrc;
    VOS_UINT32 loopDest;
    VOS_UINT8  temp;

    loopSrc = (VOS_INT32)(length - 1);
    for (loopDest = 0; loopSrc >= 0; loopSrc--, loopDest++) {
        temp = (aucHex[loopSrc] >> 4) & 0x0F;
        if (temp < AT_DEC_MAX_NUM + 1) {
            /* 0~9 */
            aucAscii[loopDest] = temp + 0x30;
        }
        else {
            /* a~f */
            aucAscii[loopDest] = temp + 0x37;
        }

        loopDest++;
        temp = aucHex[loopSrc] & 0x0F;
        if (temp < AT_DEC_MAX_NUM + 1) {
            /* 0~9 */
            aucAscii[loopDest] = temp + 0x30;
        }
        else {
            /* a~f */
            aucAscii[loopDest] = temp + 0x37;
        }
    }

    return VOS_OK;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetMeidPara(VOS_UINT8 indexNum)
{
    AT_MTA_MeidSetReq meIdReq;
    VOS_UINT32        rslt;

    memset_s(&meIdReq, sizeof(meIdReq), 0x00, sizeof(AT_MTA_MeidSetReq));

    /* 命令状态检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不为1或者字符串长度不为14 */
    if ((g_atParaIndex != 1) || (g_atParaList[AT_MEID_PARA_MEIDNUM].paraLen != 14)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_AsciiToHexCode_Revers(g_atParaList[AT_MEID_PARA_MEIDNUM].para,
                                    g_atParaList[AT_MEID_PARA_MEIDNUM].paraLen, meIdReq.meid);

    if (rslt != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  ID_AT_MTA_MEID_SET_REQ, (VOS_UINT8 *)&meIdReq, sizeof(meIdReq), I0_UEPS_PID_MTA);

    if (rslt == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MEID_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetMeidPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_QryMeidPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送消息 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_MEID_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (result == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MEID_QRY;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_QryMeidPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_RcvMtaMeidSetCnf(struct MsgCB *msg)
{
    AT_MTA_Msg       *rcvMsg = VOS_NULL_PTR;
    MTA_AT_ResultCnf *setCnf = VOS_NULL_PTR;
    VOS_UINT8         indexNum;
    VOS_UINT32        rslt;

    /* 初始化 */
    rcvMsg   = (AT_MTA_Msg *)msg;
    setCnf   = (MTA_AT_ResultCnf *)rcvMsg->content;
    indexNum = AT_BROADCAST_CLIENT_INDEX_MODEM_0;

    /* 通过ClientId获取ucIndex */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaMeidSetCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaMeidSetCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_MEID_SET */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_MEID_SET) {
        AT_WARN_LOG("AT_RcvMtaMeidSetCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化AT^MEID命令返回 */
    g_atSendDataBuff.bufLen = 0;

    switch (setCnf->result) {
        case MTA_AT_RESULT_INCORRECT_PARAMETERS:
            rslt = AT_DEVICE_INVALID_PARAMETERS;
            break;

        case MTA_AT_RESULT_DEVICE_SEC_NV_ERROR:
            rslt = AT_DEVICE_NV_WRITE_FAIL_UNKNOWN;
            break;

        case MTA_AT_RESULT_NO_ERROR:
            rslt = AT_OK;
            break;

        default:
            rslt = AT_ERROR;
            break;
    }

    At_FormatResultData(indexNum, rslt);

    return VOS_OK;
}


VOS_UINT32 AT_RcvMtaMeidQryCnf(struct MsgCB *msg)
{
    AT_MTA_Msg        *rcvMsg = VOS_NULL_PTR;
    MTA_AT_MeidQryCnf *qryCnf = VOS_NULL_PTR;
    VOS_UINT8          indexNum;
    VOS_UINT8          meId[2 * MTA_AT_MEID_NV_DATA_LEN_NEW + 1];
    VOS_UINT8          aucpEsn[2 * MTA_AT_PESN_NV_DATA_LEN + 1];
    VOS_UINT8          aucpUimID[2 * UIMID_DATA_LEN + 1];

    memset_s(meId, sizeof(meId), 0x00, sizeof(meId));

    /* 初始化 */
    rcvMsg   = (AT_MTA_Msg *)msg;
    qryCnf   = (MTA_AT_MeidQryCnf *)rcvMsg->content;
    indexNum = AT_BROADCAST_CLIENT_INDEX_MODEM_0;

    /* 通过ClientId获取ucIndex */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_MEID_QRY */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_MEID_QRY) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化AT^MEID命令返回 */
    g_atSendDataBuff.bufLen = 0;

    /* 读取en_NV_Item_MEID */
    if (qryCnf->meIdReadRst != NV_OK) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf:Read NV_ITEM_MEID Nvim Failed");
        return AT_DEVICE_NV_READ_FAILURE;
    }

    /* 读取en_NV_Item_PESN */
    if (qryCnf->pEsnReadRst != NV_OK) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf:Read NV_ITEM_PESN Nvim Failed");
        return AT_DEVICE_NV_READ_FAILURE;
    }

    /* 读取UIMID失败 */
    if (qryCnf->result != MTA_AT_RESULT_NO_ERROR) {
        AT_WARN_LOG("AT_RcvMtaMeidQryCnf:Read UIMID Failed");
    }

    AT_Hex2Ascii_Revers(&(qryCnf->efruimid[1]), UIMID_DATA_LEN, aucpUimID);
    aucpUimID[2 * UIMID_DATA_LEN] = '\0'; /* 数组最后一位为'\0' */

    AT_Hex2Ascii_Revers(&(qryCnf->pEsn[0]), MTA_AT_PESN_NV_DATA_LEN, aucpEsn);
    aucpEsn[2 * MTA_AT_PESN_NV_DATA_LEN] = '\0'; /* 数组最后一位为'\0' */

    AT_Hex2Ascii_Revers(&(qryCnf->meId[0]), MTA_AT_MEID_NV_DATA_LEN_NEW, meId);
    meId[2 * MTA_AT_MEID_NV_DATA_LEN_NEW] = '\0'; /* 数组最后一位为'\0' */

    g_atSendDataBuff.bufLen =
        (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: %s,%s,%s", g_parseContext[indexNum].cmdElement->cmdName, meId,
            aucpEsn, aucpUimID);

    At_FormatResultData(indexNum, AT_OK);

    return VOS_OK;
}

#endif


VOS_UINT32 AT_QryRficDieIDPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送跨核消息到C核, 查询RFIC IDE ID */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 ID_AT_MTA_RFIC_DIE_ID_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (rst != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryRficDieIDPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_RFIC_DIE_ID_QRY;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_RcvMtaRficDieIDQryCnf(struct MsgCB *msg)
{
    AT_MTA_Msg             *rcvMsg          = VOS_NULL_PTR;
    MTA_AT_RficDieIdReqCnf *rficDieIDReqCnf = VOS_NULL_PTR;
    VOS_UINT8               indexNum;
    VOS_UINT16              length;

    /* 初始化局部变量 */
    rcvMsg          = (AT_MTA_Msg *)msg;
    rficDieIDReqCnf = (MTA_AT_RficDieIdReqCnf *)rcvMsg->content;
    indexNum        = AT_BROADCAST_CLIENT_INDEX_MODEM_0;
    length          = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaRficDieIDQryCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaRficDieIDQryCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_RFIC_DIE_ID_QRY */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_RFIC_DIE_ID_QRY) {
        AT_WARN_LOG("AT_RcvMtaRficDieIDQryCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化上报命令 */
    if (rficDieIDReqCnf->result != MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    } else {
        /* 命令结果 *AT_OK */
        if (rficDieIDReqCnf->rfic0DieIdValid == VOS_TRUE) {
            length = AT_RficDieIDOut((VOS_UINT8 *)rficDieIDReqCnf->rfic0DieId, 0, length, indexNum);
        }

        if (rficDieIDReqCnf->rfic1DieIdValid == VOS_TRUE) {
            length = AT_RficDieIDOut((VOS_UINT8 *)rficDieIDReqCnf->rfic1DieId, 1, length, indexNum);
        }

        if (rficDieIDReqCnf->rfic2DieIdValid == VOS_TRUE) {
            length = AT_RficDieIDOut((VOS_UINT8 *)rficDieIDReqCnf->rfic2DieId, AT_RFIC_NUM_2, length, indexNum);
        }
        if (rficDieIDReqCnf->rfic3DieIdValid == VOS_TRUE) {
            length = AT_RficDieIDOut((VOS_UINT8 *)rficDieIDReqCnf->rfic3DieId, AT_RFIC_NUM_3, length, indexNum);
        }

        g_atSendDataBuff.bufLen = length;
        At_FormatResultData(indexNum, AT_OK);
    }

    return VOS_OK;
}


VOS_UINT32 AT_QryRffeDieIDPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送跨核消息到C核, 查询RFFE IDE ID */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 ID_AT_MTA_RFFE_DIE_ID_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (rst != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryRffeDieIDPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_RFFE_DIE_ID_QRY;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT16 AT_RffeDieIDOut(VOS_UINT8 *msg, VOS_UINT32 rffeNum, VOS_UINT16 length, VOS_UINT8 indexNum)
{
    VOS_UINT32 i; /* 循环用 */
    VOS_UINT16 lengthtemp;

    lengthtemp = length;

    lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "%s: %d,\"", g_parseContext[indexNum].cmdElement->cmdName,
        rffeNum);

    /* RFFE ID */
    for (i = 0; i < MTA_AT_MAX_RFFE_DIE_ID_LEN; i++) {
        lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "%02x", msg[i]);
    }

    lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "\"%s", g_atCrLf);
    return lengthtemp;
}


VOS_UINT32 AT_RcvMtaRffeDieIDQryCnf(struct MsgCB *msg)
{
    AT_MTA_Msg             *rcvMsg          = VOS_NULL_PTR;
    MTA_AT_RffeDieIdReqCnf *rffeDieIDReqCnf = VOS_NULL_PTR;
    VOS_UINT8               indexNum;
    VOS_UINT16              dataLen;
    VOS_UINT32              i;

    /* 初始化局部变量 */
    rcvMsg          = (AT_MTA_Msg *)msg;
    rffeDieIDReqCnf = (MTA_AT_RffeDieIdReqCnf *)rcvMsg->content;
    indexNum        = AT_BROADCAST_CLIENT_INDEX_MODEM_0;
    dataLen         = 0;
    i               = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaRffeDieIDQryCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaRffeDieIDQryCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_RFFE_DIE_ID_QRY */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_RFFE_DIE_ID_QRY) {
        AT_WARN_LOG("AT_RcvMtaRffeDieIDQryCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化上报命令 */
    if (rffeDieIDReqCnf->result != MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    } else {
        /* 命令结果 *AT_OK */

        for (i = 0; i < MTA_AT_MAX_RFFE_DIE_ID_COUNT; i++) {
            if (rffeDieIDReqCnf->dieIdData[i].dataValid == MTA_AT_RFFE_DIE_ID_VALID) {
                dataLen = AT_RffeDieIDOut((VOS_UINT8 *)rffeDieIDReqCnf->dieIdData[i].rffeDieId, i, dataLen, indexNum);
            }
        }

        /* 调用At_FormatResultData发送命令结果 */
        g_atSendDataBuff.bufLen = dataLen;
        At_FormatResultData(indexNum, AT_OK);
    }

    return VOS_OK;
}


VOS_UINT16 AT_RficDieIDOut(VOS_UINT8 *msg, VOS_UINT32 rficNum, VOS_UINT16 length, VOS_UINT8 indexNum)
{
    VOS_UINT32 i; /* 循环用 */
    VOS_UINT16 lengthtemp;

    lengthtemp = length;

    lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "%s: %d,\"", g_parseContext[indexNum].cmdElement->cmdName,
        rficNum);

    /* RFIC ID 使用低八位数据, 所以循环值一次加2 */
    for (i = 0; i < (MTA_AT_MAX_DIE_ID_LEN * AT_DOUBLE_LENGTH); i += 2) {
        lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "%02x", msg[i]);
    }

    lengthtemp += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + lengthtemp, "\"%s", g_atCrLf);
    return lengthtemp;
}


VOS_UINT32 AT_SetPmuDieSNPara(VOS_UINT8 indexNum)
{
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    AT_MTA_MultiPmuDieIdSet pmicId;
    VOS_UINT32              result;

    memset_s(&pmicId, (VOS_SIZE_T)sizeof(pmicId), 0x00, (VOS_SIZE_T)sizeof(pmicId));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数长度 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写消息参数 */
    pmicId.pmicId = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送消息给MTA */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_MULTI_PMU_DIE_ID_SET_REQ, (VOS_UINT8 *)&pmicId,
                                    (VOS_SIZE_T)sizeof(pmicId), I0_UEPS_PID_MTA);
    /* 发送失败 */
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetPmuDieSNPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 发送成功，设置当前操作模式 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MULTI_PMU_DIE_ID_QRY;

    /* 等待异步处理时间返回 */
    return AT_WAIT_ASYNC_RETURN;
#else
    return AT_CME_OPERATION_NOT_ALLOWED;
#endif
}


VOS_UINT32 AT_QryPmuDieSNPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送跨核消息到C核, 查询RFIC IDE ID */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 ID_AT_MTA_PMU_DIE_SN_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (rst != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryPmuDieSNPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PMU_DIE_SN_QRY;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_RcvMtaPmuDieSNQryCnf(struct MsgCB *msg)
{
    AT_MTA_Msg            *rcvMsg         = VOS_NULL_PTR;
    MTA_AT_PmuDieSnReqCnf *pmuDieSNReqCnf = VOS_NULL_PTR;
    VOS_INT32              i; /* 循环数 */
    VOS_UINT16             length;
    VOS_UINT8              indexNum;

    /* 初始化局部变量 */
    rcvMsg         = (AT_MTA_Msg *)msg;
    pmuDieSNReqCnf = (MTA_AT_PmuDieSnReqCnf *)rcvMsg->content;
    indexNum       = AT_BROADCAST_CLIENT_INDEX_MODEM_0;
    length         = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaPmuDieSNQryCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaPmuDieSNQryCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_PMU_DIE_SN_QRY */
    if ((g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_PMU_DIE_SN_QRY)
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        && (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_MULTI_PMU_DIE_ID_QRY)
#endif
    ) {
        AT_WARN_LOG("AT_RcvMtaPmuDieSNQryCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化上报命令 */
    if (pmuDieSNReqCnf->result != MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    } else {
        /* 命令结果 *AT_OK */

        /* 最高位,高4 BIT置0 */
        pmuDieSNReqCnf->dieSn[MTA_PMU_MAX_DIE_SN_LEN - 1] = (pmuDieSNReqCnf->dieSn[MTA_PMU_MAX_DIE_SN_LEN - 1] & 0x0F);

        /* 格式化输出查询结果 */
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: 0x", g_parseContext[indexNum].cmdElement->cmdName);

        for (i = (MTA_PMU_MAX_DIE_SN_LEN - 1); i >= 0; i--) {
            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%02x", pmuDieSNReqCnf->dieSn[i]);
        }

        g_atSendDataBuff.bufLen = length;
        At_FormatResultData(indexNum, AT_OK);
    }

    return VOS_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetTasTestCfg(VOS_UINT8 indexNum)
{
    AT_MTA_TasTestCfg tasParamReq;
    VOS_UINT32        result;

    /* 局部变量初始化 */
    memset_s(&tasParamReq, (VOS_SIZE_T)sizeof(tasParamReq), 0x00, (VOS_SIZE_T)sizeof(AT_MTA_TasTestCfg));

    /* 参数检查 */
    if ((g_atParaIndex != AT_TXTASTEST_PARA_NUM) || (g_atParaList[AT_TXTASTEST_RAT_MODE].paraLen == 0) ||
        (g_atParaList[AT_TXTASTEST_TXSAR_FORCED_SWITCH].paraLen == 0) ||
        (g_atParaList[AT_TXTASTEST_DL_OPTIMAL_TX].paraLen == 0) ||
        (g_atParaList[AT_TXTASTEST_TXSAR_SWITCH].paraLen == 0) ||
        (g_atParaList[AT_TXTASTEST_PARA_RESERVED].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_UE_MODE_CDMA != FEATURE_ON)
    if ((g_atParaList[AT_TXTASTEST_RAT_MODE].paraValue == MTA_AT_RATMODE_1X) ||
        (g_atParaList[AT_TXTASTEST_RAT_MODE].paraValue == MTA_AT_RATMODE_HRPD)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    /* 填写消息参数 */
    tasParamReq.ratMode = g_atParaList[AT_TXTASTEST_RAT_MODE].paraValue;
    tasParamReq.para0   = g_atParaList[AT_TXTASTEST_TXSAR_FORCED_SWITCH].paraValue;
    tasParamReq.para1   = g_atParaList[AT_TXTASTEST_DL_OPTIMAL_TX].paraValue;
    tasParamReq.para2   = g_atParaList[AT_TXTASTEST_TXSAR_SWITCH].paraValue;
    tasParamReq.para3   = g_atParaList[AT_TXTASTEST_PARA_RESERVED].paraValue;

    /* 发送消息给MTA */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_TAS_CFG_REQ, (VOS_UINT8 *)&tasParamReq, (VOS_SIZE_T)sizeof(tasParamReq),
                                    I0_UEPS_PID_MTA);
    /* 发送失败 */
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetTasTestCfg: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 发送成功，设置当前操作模式 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_TAS_TEST_SET;

    /* 等待异步处理时间返回 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_QryTasTestCfgPara(VOS_UINT8 indexNum)
{
    VOS_UINT32        result;
    AT_MTA_TasTestQry atMtaTasTestQry;

    /* 参数检查 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_UE_MODE_CDMA != FEATURE_ON)
    if ((g_atParaList[0].paraValue == MTA_AT_RATMODE_1X) ||
        (g_atParaList[0].paraValue == MTA_AT_RATMODE_HRPD)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    /* 填写消息参数 */
    atMtaTasTestQry.ratMode = g_atParaList[0].paraValue;

    /* 发送消息给MTA */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_TAS_QRY_REQ, (VOS_UINT8 *)&atMtaTasTestQry,
                                    (VOS_SIZE_T)sizeof(atMtaTasTestQry), I0_UEPS_PID_MTA);
    /* 发送失败 */
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryTasTestCfgPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 发送成功，设置当前操作模式 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_TAS_TEST_QRY;

    /* 等待异步处理时间返回 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 AT_RcvMtaTasTestCfgCnf(struct MsgCB *msg)
{
    AT_MTA_Msg           *rcvMsg             = VOS_NULL_PTR;
    MTA_AT_TasTestCfgCnf *mtaAtTasTestCfgCnf = VOS_NULL_PTR;

    VOS_UINT8  indexNum;
    VOS_UINT32 result;

    /* 初始化局部变量 */
    rcvMsg             = (AT_MTA_Msg *)msg;
    mtaAtTasTestCfgCnf = (MTA_AT_TasTestCfgCnf *)rcvMsg->content;
    indexNum           = AT_BROADCAST_CLIENT_INDEX_MODEM_0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaTasTestCfgCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaTasTestCfgCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_TAS_TEST_CFG_SET */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_TAS_TEST_SET) {
        AT_WARN_LOG("AT_RcvMtaTasTestCfgCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化上报命令 */
    if (mtaAtTasTestCfgCnf->result == MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_OK */
        result = AT_OK;
    } else {
        /* 命令结果 *AT_ERROR */
        result = AT_ERROR;
    }

    g_atSendDataBuff.bufLen = 0;
    At_FormatResultData(indexNum, result);

    return VOS_OK;
}


VOS_UINT32 AT_RcvMtaTasTestQryCnf(struct MsgCB *msg)
{
    AT_MTA_Msg           *rcvMsg             = VOS_NULL_PTR;
    MTA_AT_TasTestQryCnf *mtaAtTasTestReqCnf = VOS_NULL_PTR;
    VOS_UINT16            length;
    VOS_UINT8             indexNum;

    /* 初始化局部变量 */
    rcvMsg             = (AT_MTA_Msg *)msg;
    mtaAtTasTestReqCnf = (MTA_AT_TasTestQryCnf *)rcvMsg->content;
    length             = 0;
    indexNum           = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaTasTestQryCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaTasTestQryCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 判断当前操作类型是否为AT_CMD_RFIC_DIE_ID_QRY */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_TAS_TEST_QRY) {
        AT_WARN_LOG("AT_RcvMtaTasTestQryCnf: NOT CURRENT CMD OPTION!");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 格式化上报命令 */
    if (mtaAtTasTestReqCnf->result != MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    } else {
        /* 命令结果 *AT_OK */
        length                  = AT_TasTestOut(mtaAtTasTestReqCnf);
        g_atSendDataBuff.bufLen = length;
        At_FormatResultData(indexNum, AT_OK);
    }

    return VOS_OK;
}


VOS_UINT16 AT_TasTestOut(MTA_AT_TasTestQryCnf *mtaAtTasTestReqCnf)
{
    VOS_UINT32 i; /* 循环用 */
    VOS_UINT16 length;

    length = 0;

    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "level index: %d (%d, %d, %d, %d)%s", mtaAtTasTestReqCnf->currLevel,
        mtaAtTasTestReqCnf->levelInfo.uhwSrcAntTimeLength, mtaAtTasTestReqCnf->levelInfo.uhwDestAntTimeLength,
        mtaAtTasTestReqCnf->levelInfo.srcAntTxPowerGain, mtaAtTasTestReqCnf->levelInfo.destAntTxPowerGain, g_atCrLf);

    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "level table:%s", g_atCrLf);

    if (mtaAtTasTestReqCnf->usedTable.uhwLevelNum > MTA_AT_MAX_STATEII_LEVEL_ITEM) {
        mtaAtTasTestReqCnf->usedTable.uhwLevelNum = MTA_AT_MAX_STATEII_LEVEL_ITEM;
    }

    /* 打印表格 */
    for (i = 0; i < mtaAtTasTestReqCnf->usedTable.uhwLevelNum; i++) {
        length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + length, "            (%d, %d, %d, %d)%s",
            mtaAtTasTestReqCnf->usedTable.levelItem[i].uhwSrcAntTimeLength,
            mtaAtTasTestReqCnf->usedTable.levelItem[i].uhwDestAntTimeLength,
            mtaAtTasTestReqCnf->usedTable.levelItem[i].srcAntTxPowerGain,
            mtaAtTasTestReqCnf->usedTable.levelItem[i].destAntTxPowerGain, g_atCrLf);
    }
    return length;
}
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCdmaAttDiversitySwitch(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;
    VOS_UINT8  nVWrLen;
    VOS_UINT8  diversitySwitch;

    if (AT_IsNVWRAllowedNvId(en_NV_Item_CPROC_1X_NVIM_DM_THRESHOLD) != VOS_TRUE) {
        return AT_CME_OPERATION_NOT_ALLOWED;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    diversitySwitch = (VOS_UINT8)g_atParaList[0].paraValue;
    nVWrLen         = sizeof(diversitySwitch);

    ret = TAF_ACORE_NV_WRITE_PART(MODEM_ID_0, en_NV_Item_CPROC_1X_NVIM_DM_THRESHOLD, 0, &diversitySwitch, nVWrLen);
    if (ret != ERR_MSP_SUCCESS) {
        return AT_ERROR;
    }

    return AT_OK;
}
#endif

#endif


VOS_UINT32 AT_RcvMtaSetPhyMipiWriteCnf(struct MsgCB *msg)
{
    AT_MTA_Msg             *rcvMsg             = VOS_NULL_PTR;
    MTA_AT_PhyMipiWriteCnf *setPhyMipiWriteCnf = VOS_NULL_PTR;
    VOS_UINT8               indexNum;

    /* 初始化 */
    rcvMsg             = (AT_MTA_Msg *)msg;
    setPhyMipiWriteCnf = (MTA_AT_PhyMipiWriteCnf *)rcvMsg->content;
    indexNum           = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaSetPhyMipiWriteCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaSetPhyMipiWriteCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 当前AT是否在等待该命令返回 */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_PHYMIPIWRITE_SET) {
        AT_WARN_LOG("AT_RcvMtaSetPhyMipiWriteCnf: NOT AT_CMD_MIPIREAD_SET.");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 判断回复消息中的错误码 */
    if (setPhyMipiWriteCnf->result == MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_OK */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_OK);
    } else {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    }

    return VOS_OK;
}


VOS_UINT32 AT_RcvMtaSetMipiReadCnf(struct MsgCB *msg)
{
    AT_MTA_Msg         *rcvMsg         = VOS_NULL_PTR;
    MTA_AT_MipiReadCnf *setMipiReadCnf = VOS_NULL_PTR;
    VOS_UINT16          length;
    VOS_UINT8           indexNum;

    /* 初始化 */
    rcvMsg         = (AT_MTA_Msg *)msg;
    setMipiReadCnf = (MTA_AT_MipiReadCnf *)rcvMsg->content;
    indexNum       = 0;

    /* 通过clientid获取index */
    if (At_ClientIdToUserId(rcvMsg->appCtrl.clientId, &indexNum) == AT_FAILURE) {
        AT_WARN_LOG("AT_RcvMtaSetMipiReadCnf: WARNING:AT INDEX NOT FOUND!");
        return VOS_ERR;
    }

    if (AT_IS_BROADCAST_CLIENT_INDEX(indexNum)) {
        AT_WARN_LOG("AT_RcvMtaSetMipiReadCnf: AT_BROADCAST_INDEX.");
        return VOS_ERR;
    }

    /* 当前AT是否在等待该命令返回 */
    if (g_atClientTab[indexNum].cmdCurrentOpt != AT_CMD_MIPIREAD_SET) {
        AT_WARN_LOG("AT_RcvMtaSetMipiReadCnf: NOT AT_CMD_MIPIREAD_SET.");
        return VOS_ERR;
    }

    /* 复位AT状态 */
    AT_STOP_TIMER_CMD_READY(indexNum);

    /* 判断回复消息中的错误码 */
    if (setMipiReadCnf->result == MTA_AT_RESULT_NO_ERROR) {
        /* 命令结果 *AT_OK */
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s:%d", g_parseContext[indexNum].cmdElement->cmdName,
            setMipiReadCnf->value);

        g_atSendDataBuff.bufLen = length;
        At_FormatResultData(indexNum, AT_OK);
    } else {
        /* 命令结果 *AT_ERROR */
        g_atSendDataBuff.bufLen = 0;
        At_FormatResultData(indexNum, AT_ERROR);
    }

    return VOS_OK;
}

#if (FEATURE_DCXO_HI1102_SAMPLE_SHARE == FEATURE_ON)

VOS_UINT32 AT_SetDcxoQryPara(VOS_UINT8 indexNum)
{
    VOS_UINT32             rst;
    AT_MTA_DcxoSampeQryReq dcxoSampleQry;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数个数不为1或者字符串长度不为1 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memset_s(&dcxoSampleQry, sizeof(dcxoSampleQry), 0, sizeof(dcxoSampleQry));
    dcxoSampleQry.dcxoSampleType = g_atParaList[0].paraValue;

    /* 发送跨核消息到C核, 查询DCXO_SAMPLE */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 ID_AT_MTA_DCXO_SAMPLE_QRY_REQ, (VOS_UINT8 *)&dcxoSampleQry,
                                 (VOS_SIZE_T)sizeof(AT_MTA_DcxoSampeQryReq), I0_UEPS_PID_MTA);

    if (rst != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryRficDieIDPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 发送成功，设置当前操作模式 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DCXOQRY_QRY;

    /* 等待异步处理时间返回 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetSltTestPara(VOS_UINT8 indexNum)
{
#if (FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
    VOS_INT iResult = MDRV_OK;
#endif
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    AT_MT_Info *atMtInfoCtx = VOS_NULL_PTR;
#endif

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* SLT测试参数有效范围为1~6 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen != 1)) {
        AT_WARN_LOG("AT_SetSltTest: slt test para error!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 根据命令参数执行相应的底软测试接口 */
    switch (g_atParaList[0].paraValue) {
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        case AT_SET_SLT_SERDES_TEST:
        case AT_SET_SLT_ALINK_TEST:
            atMtInfoCtx = AT_GetMtInfoCtx();
            if (At_SndDspIdleSltTestReq() == AT_SUCCESS) {
                atMtInfoCtx->atInfo.indexNum          = indexNum;
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SLT_TEST_SET;

                /* 等待异步处理时间返回 */
                return AT_WAIT_ASYNC_RETURN;
            } else {
                return AT_ERROR;
            }
#endif
        default:
            AT_WARN_LOG("AT_SetSltTest: slt test fail!");
            return AT_ERROR;
    }
#if (FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
    if (iResult != MDRV_OK) {
        AT_WARN_LOG("AT_SetSltTest: slt test fail!");
        return AT_ERROR;
    }

    return AT_OK;
#endif
}

#endif

#if(FEATURE_IOT_HSUART_CMUX == FEATURE_ON)

VOS_UINT32 At_TestCmuxPara(VOS_UINT8 indexNum)
{
    if (AT_CMUX_CheckUartUser(indexNum) != VOS_TRUE) {
        return AT_ERROR;
    }

    g_atSendDataBuff.bufLen = (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN,(TAF_CHAR *)g_atSndCodeAddress,
                                (TAF_CHAR *)g_atSndCodeAddress,
                                "%s+CMUX: (0),(0),(1-6),(31-1540),(10-250),(0-10),(10-250),(1-255),(1-7)%s",
                                g_atCrLf,g_atCrLf);

    At_SendResultData(indexNum, g_atSndCodeAddress, g_atSendDataBuff.bufLen);
    return AT_OK;
}
#endif

