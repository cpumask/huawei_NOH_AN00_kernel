/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2019. All rights reserved.
 * foss@huawei.com
 *
 * If distributed as part of the Linux kernel, the following license terms
 * apply:
 *
 * * This program is free software; you can redistribute it and/or modify
 * * it under the terms of the GNU General Public License version 2 and
 * * only version 2 as published by the Free Software Foundation.
 * *
 * * This program is distributed in the hope that it will be useful,
 * * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * * GNU General Public License for more details.
 * *
 * * You should have received a copy of the GNU General Public License
 * * along with this program; if not, write to the Free Software
 * * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
 *
 * Otherwise, the following license terms apply:
 *
 * * Redistribution and use in source and binary forms, with or without
 * * modification, are permitted provided that the following conditions
 * * are met:
 * * 1) Redistributions of source code must retain the above copyright
 * *    notice, this list of conditions and the following disclaimer.
 * * 2) Redistributions in binary form must reproduce the above copyright
 * *    notice, this list of conditions and the following disclaimer in the
 * *    documentation and/or other materials provided with the distribution.
 * * 3) Neither the name of Huawei nor the names of its contributors may
 * *    be used to endorse or promote products derived from this software
 * *    without specific prior written permission.
 *
 * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "AtSetParaCmd.h"
#include "securec.h"
#include "at_mdrv_interface.h"
#include "taf_type_def.h"
#include "ATCmdProc.h"
#include "AtInputProc.h"
#include "AtCheckFunc.h"
#include "AtParseCmd.h"
#include "ppp_interface.h"
#include "AtMsgPrint.h"
#include "taf_mmi_str_parse.h"
#include "si_app_stk.h"
#include "si_app_pih.h"
#include "at_phy_interface.h"
#include "AtDataProc.h"
#include "taf_drv_agent.h"
#include "mn_comm_api.h"
#include "AtCmdMsgProc.h"
#include "at_rabm_interface.h"
#include "AtSndMsg.h"
#include "AtDeviceCmd.h"
#include "AtRnicInterface.h"
#include "AtTafAgentInterface.h"
#include "TafAgentInterface.h"
#include "taf_app_xsms_interface.h"

#include "TafStdlib.h"
#include "mnmsgcbencdec.h"

#if (FEATURE_LTE == FEATURE_ON)
#include "mdrv_nvim.h"
#include "at_common.h"
#include "gen_msg.h"
#include "at_lte_common.h"
#endif
#if (FEATURE_LTEV == FEATURE_ON)
#include "vnas_at_interface.h"
#endif

#include "nv_stru_gucnas.h"
#include "nv_stru_sys.h"
#include "nv_stru_gas.h"
#include "nv_stru_pam.h"
#include "nv_stru_msp_interface.h"
#include "nv_stru_msp.h"

#include "mn_call_api.h"
#include "AtCtx.h"
#include "app_vc_api.h"
#include "at_imsa_interface.h"
#include "AtInit.h"
#include "at_file_handle.h"

#include "gunas_errno.h"

#include "css_at_interface.h"
#include "AtCmdSimProc.h"
#include "taf_app_mma.h"
#include "taf_mtc_api.h"
#include "AtCmdMiscProc.h"
#include "taf_ccm_api.h"

#if (FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
#if (VOS_OS_VER != VOS_LINUX)
#include "Linuxstub.h"
#endif
#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON)
#include "ads_dev_i.h"
#else
#include "ads_device_interface.h"
#endif
#else
#include "cds_interface.h"
#endif

#include "AtCmdCallProc.h"
#if (VOS_OS_VER == VOS_WIN32)
#include "NasStub.h"
#include "UsimmApi.h"
#endif

#include "imm_interface.h"
#include "cbt_cpm.h"
#include "cbt_scm_soft_decode.h"
#include "at_mbb_common.h"

/*lint -esym(516,free,malloc)*/


/*
 * 协议栈打印打点方式下的.C文件宏定义
 */
#define THIS_FILE_ID PS_FILE_ID_AT_SETPARACMD_C

#define AT_CSND_PLAYLOAD_MAX_LEN 1400
#define AT_CGTFT_PACKET_FILTER_ID 1
#define AT_CGTFT_PRECEDENCE 2
#define AT_CGTFT_PROTOCOL_ID 4
#define AT_CGTFT_DIRECTION 10
#define AT_CGTFT_QRI 12
#define AT_CGTFT_FLOW_LABLE 9
#define AT_CGTFT_SECU_PARA_INDEX 7
#define AT_CGTFT_TYPE_OF_SERVICE 8
#define AT_CGTFT_DESTINATION_PORT_RANGE 5
#define AT_CGTFT_SOURCE_PORT_RANGE 6
#define AT_CPMS_MEM_READOR_DELETE 0
#define AT_CPMS_MEM_SENDOR_WRITE 1
#define AT_CPMS_MEM_STORE 2
#define AT_CMGF_MSG_FORMAT 0
#define AT_CSCA_PARA_SCA 0
#define AT_CSCA_PARA_TOSCA 1
#define AT_CSMP_FO 0
#define AT_CSMP_PID 2
#define AT_CSMP_DCS 3
#define AT_CCUG_CUG_INDEX 10
#define AT_CNMI_PARA_MODE_TYPE 0
#define AT_CNMI_PARA_MT_TYPE 1
#define AT_CNMI_PARA_BM_TYPE 2
#define AT_CNMI_PARA_DS_TYPE 3
#define AT_CNMI_PARA_BFR_TYPE 4
#define AT_CMGL_MSG_STAT 0
#define AT_CMGR_MSG_INDEX 0
#define AT_CNMA_PDU_N_TYPE 0
#define AT_CNMA_TPDU_LEN 1
#define AT_CMSS_MSG_INDEX 0
#define AT_CMSS_MSG_DA 1
#define AT_CMSS_MSG_TODA 2
#define AT_CMGW_MSG_TEXT_STAT 2
#define AT_CMGW_TPDU_LEN 0
#define AT_CMGW_MSG_PDU_STAT 1
#define AT_CMGW_MSG_OA_OR_DA 0
#define AT_CMGW_MSG_TOOA_OR_TODA 1
#define AT_CMGC_MSG_CMD_TYPE 1
#define AT_CMGC_MSG_FO 0
#define AT_CMGC_PDU_LEN 0
#define AT_CMGC_PID 2
#define AT_CMGC_MSG_NO 3
#define AT_CMGC_MSG_OA_OR_DA 4
#define AT_CMGC_MSG_TOOA_OR_TODA 5
#define AT_CMST_MSG_INDEX 0
#define AT_CMST_MSG_DA 1
#define AT_CMST_MSG_TODA 2
#define AT_CMST_MSG_SENT_SM_TIME 3
#define AT_CMSTUB_STUB_TYPE 0
#define AT_CMSTUB_STUB_VALUE 1
#define AT_CMMS_MSG_LINK_CTRL 0
#define AT_CSCB_MIDS 1
#define AT_CSCB_DCSS 2
#define AT_CCUG_MODE_ENABLE 0
#define AT_CCUG_GROUP_INDEX 1
#define AT_CCUG_INFO 2
#define AT_CHLD_OP_CODE 0
#define AT_CHLD_CALL_TYPE 1
#define AT_CHLD_CALL_NUM 2
#define AT_CHLD_RTT_FLG 3
#define AT_DTMF_KEY 1
#define AT_DTMF_ON_LENGTH 2
#define AT_DTMF_CALL_ID 0
#define AT_DTMF_OFF_LENGTH 3
#define AT_CBST_CONN_ELEM 2
#define AT_CGDCONT_D_COMP 4
#define AT_CGDCONT_H_COMP 5
#define AT_CGDCONT_IPV4_ADDR_ALLOC 6
#define AT_CGDCONT_EMERGENCY_INDICATION 7
#define AT_CGDCONT_P_CSCF_DISCOVERY 8
#define AT_CGDCONT_IM_CN_SIGNALLING_FLAG_IND 9
#define AT_CGDCONT_NAS_SIGNALLING_PRIO_IND 10
#define AT_CGDCONT_SSC_MODE 16
#define AT_CGDCONT_PREF_ACCESS_TYPE 18
#define AT_CGDCONT_RQOS_IND 19
#define AT_CGDCONT_ALWAYS_ON_IND 21
#define AT_CGDCONT_APN 2
#define AT_CGDCONT_PDP_ADDRESS 3
#define AT_CGDCONT_S_NSSAI 17
#define AT_CGDCONT_MH6_PDU 20
#define AT_CGDCONT_PDP_D_COMP 2
#define AT_CGDCONT_PDP_H_COMP 3
#define AT_CGDCONT_IM_CN_SIGNAL_FLAG 4
#define AT_CGEQREQ_MAXIMUM_BITRATE_UL 2
#define AT_CGEQREQ_MAXIMUM_BITRATE_DL 3
#define AT_CGEQREQ_GUARANTEED_BITRATE_UL 4
#define AT_CGEQREQ_GUARANTEED_BITRATE_DL 5
#define AT_CGEQREQ_DELIVERY_ORDER 6
#define AT_CGEQREQ_MAXIMUM_SDU_SIZE 7
#define AT_CGEQREQ_SDU_ERROR_RATIO 8
#define AT_CGEQREQ_RESIDUAL_BIT_ERROR_RATIO 9
#define AT_CGEQREQ_DELIVERY_OF_ERR_SDUS 10
#define AT_CGEQREQ_TRANSFER_DELAY 11
#define AT_CGEQREQ_TRAFF_HANDLE_PRIOR 12
#define AT_CGEQREQ_SRC_STATISTICS_DESCRIPTOR 13
#define AT_CGEQREQ_SIGNALLING_INDICATION 14
#define AT_CGANS_CID 2
#define AT_CGTFT_SRC_ADDR_AND_SUBNET_MASK 3
#define AT_CGTFT_LOCAL_ADDR_AND_SUBNET_MASK 11
#define AT_CGDNS_SECDNS 2
#define AT_PDP_AUTH_TYPE_NONE 0
#define AT_PDP_AUTH_TYPE_PAP 1
#define AT_PDP_AUTH_TYPE_CHAP 2
#define AT_PDP_AUTH_TYPE_PAP_OR_CHAP 3
#define AT_ASCII_STR_MIN_LEN 2
#define AT_ASCII_STR_MAX_LEN 255
#define AT_AUC_GSM_DATA_LEN 2
#define AT_PUC_DATA_OFFSET_1 1
#define AT_PUC_DATA_INDEX_2 2
#define AT_PUC_DATA_INDEX_3 3
#define AT_AUC_TMP_LEN 4
#define AT_AUC_TMP_INDEX_2 2
#define AT_AUC_TMP_INDEX_3 3
#define AT_MN_MSG_RCVMSG_ACT_TRANSFER 2
#define AT_TYPE_OF_SERVICE_MAX_VALUE_RANGE 255
#define AT_TYPE_OF_SERVICE_MASK_MAX_VALUE_RANGE 255
#define AT_HIGH_DEST_PORT_MAX_VALUE_RANGE 65535
#define AT_LOW_DEST_PORT_MAX_VALUE_RANGE 65535
#define AT_HIGH_SOURCE_PORT_MAX_VALUE_RANGE 65535
#define AT_LOW_SOURCE_PORT_MAX_VALUE_RANGE 65535
#define AT_RSTRIGGER_MAX_PARA_NUM 2
#define AT_CSMP_MAX_PARA_NUM 4
#define AT_CNMI_MAX_PARA_NUM 5
#define AT_CNMA_MAX_PARA_NUM 2
#define AT_CNMA_RP_ERROR 2
#define AT_MN_MSG_SMS_TPDU_LEN 2
#define AT_CMGS_TEXT_FORMAT_MAX_PARA_NUM 2
#define AT_CMGW_TEXT_FORMAT_MAX_PARA_NUM 3
#define AT_CMGW_PDU_FORMAT_MAX_PARA_NUM 2
#define AT_MSG_DELETE_TYPE_NUM 5
#define AT_CMGD_MAX_PARA_NUM 2
#define AT_CMGC_MAX_PARA_NUM 6
#define AT_CSDF_MAX_PARA_NUM 2
#define AT_CCUG_MAX_PARA_NUM 3
#define AT_CSSN_MAX_PARA_NUM 2
#define AT_MN_CALL_REL_HELD_OR_UDUB 0
#define AT_MN_CALL_REL_ACT_ACPT_OTH 1
#define AT_MN_CALL_HOLD_ACT_ACPT_OTH 2
#define AT_MN_CALL_BUILD_MPTY 3
#define AT_MN_CALL_ECT 4
#define AT_MN_CALL_ACT_CCBS 5
#define AT_MN_CALL_ECONF_REL_USER 6
#define AT_MN_CALL_ECONF_MERGE_CALL 7
#define AT_MN_CALL_ACPT_WAITING_CALL 8
#define AT_MN_CALL_REL_CALL_X 1
#define AT_MN_CALL_HOLD_ALL_EXCPT_X 2
#define AT_CHLD_MAX_PARA_NUM 4
#define AT_CBST_MAX_PARA_NUM 3
#define AT_S_NSSAI_DIGIT_INDEX_2 2
#define AT_S_NSSAI_DIGIT_INDEX_3 3
#define AT_CGDSCONT_MAX_PARA_NUM 5
#define AT_CGEQREQ_MAX_PARA_NUM 15
#define AT_CGACT_MAX_PARA_NUM 2
#define AT_CGANS_MAX_PARA_NUM 3
#define AT_CGDNS_MAX_PARA_NUM 3
#define AT_C5GQOS_MAX_PARA_NUM 6
#define AT_PH_MS_A_MODE 0
#define AT_PH_MS_B_MODE 1
#define AT_PH_MS_CG_MODE 2
#define AT_SET_SS_CODE_CFU 0
#define AT_SET_SS_CODE_CFB 1
#define AT_SET_SS_CODE_CFNRY 2
#define AT_SET_SS_CODE_CFNRC 3
#define AT_SET_SS_CODE_AF 4
#define AT_CMD_TYPE_PERSONALISATION_SET 0
#define AT_CMD_TYPE_PERSONALISATION_RETRIEVE 1
#define AT_ME_PS_DEACTIVE_TYPE 0
#define AT_ME_PS_ACTIVE_TYPE 1
#define AT_CALL_SRV_CLASS_VOICE 1
#define AT_CALL_SRV_CLASS_VIDEO 2
#define AT_CALL_SRV_CLASS_SET_NW 3
#define AT_STAR_NUM1 1
#define AT_STAR_NUM2 2
#define AT_STAR_NUM3 3
#define AT_STAR_NUM4 4
#define AT_UCNUMDPLMNSUB_NUM1 1
#define AT_UCNUMDPLMNSUB_NUM2 2
#define AT_UCNUMDPLMNSUB_NUM3 3

#define AT_PLMNSRCH_LTE_RSRP_THRESHOLD_MIN 44
#define AT_PLMNSRCH_LTE_RSRP_THRESHOLD_MAX 141
#define AT_PLMNSRCH_NR_RSRP_THRESHOLD_MIN 31
#define AT_PLMNSRCH_NR_RSRP_THRESHOLD_MAX 156
#define AT_C5GQOS_CID 0
#define AT_C5GQOS_5QI 1
#define AT_C5GQOS_DL_GFBR 2
#define AT_C5GQOS_UL_GFBR 3
#define AT_C5GQOS_DL_MFBR 4
#define AT_C5GQOS_UL_MFBR 5
#define AT_C5GNSSAA_SNSSAI 0
#define AT_C5GNSSAA_EAPMSG 1
#define AT_C5GNSSAIRDP_NASSAI_TYPE 0
#define AT_C5GNSSAIRDP_PLMN_ID 1
#define AT_CGEQOS_CID 0
#define AT_CGEQOS_5QI 1
#define AT_CGEQOS_DL_GBR 2
#define AT_CGEQOS_UL_GBR 3
#define AT_CGEQOS_DL_MBR 4
#define AT_CGEQOS_UL_MBR 5
#define AT_CPBW_NUMBER 1
#define AT_CPBW_TYPE 2
#define AT_CPBW_TEXT 3
#define AT_CPBW_CODING 4
#define AT_SCPBW_NUM1 1
#define AT_SCPBW_TYPE1 2
#define AT_SCPBW_NUM2 3
#define AT_SCPBW_TYPE2 4
#define AT_SCPBW_NUM3 5
#define AT_SCPBW_TYPE3 6
#define AT_SCPBW_NUM4 7
#define AT_SCPBW_TYPE4 8
#define AT_SCPBW_TEXT 9
#define AT_SCPBW_ALPHATAG_TYPE 10
#define AT_SCPBW_EMAIL 11
#define AT_CCHO_DFNAME 0
#define AT_CCHP_DFNAME 0
#define AT_CGLA_LENGTH 1
#define AT_CGLA_COMMAND 2
#define AT_CSIM_LENGTH 0
#define AT_CSIM_COMMAND 1
#define AT_CRSM_FILEID 1
#define AT_CRSM_P1 2
#define AT_CRSM_P2 3
#define AT_CRSM_P3 4
#define AT_CRSM_DATA 5
#define AT_CRSM_PATHIDE 6
#define AT_CCWA_CLASS 2
#define AT_CCFC_NUMBER 2
#define AT_CCFC_TYPE 3
#define AT_CCFC_CLASS 4
#define AT_CCFC_SUBADDR 5
#define AT_CCFC_SATTYPE 6
#define AT_CCFC_TIME 7
#define AT_CSGIDSRCH_PLMN_ID 0
#define AT_CSGIDSRCH_CSG_ID 1
#define AT_CSGIDSRCH_RAT 2
#define AT_CTFR_NUMBER 0
#define AT_CTFR_SUBADDR 2
#define AT_CUSD_DCS 2
#define AT_CUSD_N 0
#define AT_CUSD_STR 1
#define AT_CPWD_FAC 0
#define AT_CPWD_OLDPWD 1
#define AT_CPWD_NEWPWD 2
#define AT_D_L2P 2
#define AT_STSF_CONFIG 1
#define AT_STSF_TIMEOUT 2
#define AT_FREQLOCK_ENABLE 0
#define AT_FREQLOCK_FREQ 1
#define AT_FREQLOCK_MODE 2
#define AT_FREQLOCK_BAND 3
#define AT_FREQLOCK_PSC 4
#define AT_FREQLOCK_PCI 5
#define AT_FREQLOCK_GSMMAX 1023
#define AT_STGR_RESULT 2
#define AT_STGR_DATA 3
#define AT_CSTR_LEN 0
#define AT_CSTR_CMD_DATE 1
#define AT_CSEN_LEN 0
#define AT_CFPLMN_OPER 1
#define AT_SYSCFGEX_ACQORDER 0
#define AT_SYSCFGEX_BAND 1
#define AT_SYSCFGEX_ROAM 2
#define AT_SYSCFGEX_SRVDOMAIN 3
#define AT_SYSCFGEX_LTEBAND 4
#define AT_NETSCAN_POWER 1
#define AT_NETSCAN_MODE 2
#define AT_NETSCAN_BAND 3
#define AT_SYSCFG_BAND 2
#define AT_SYSCFG_ROAM 3
#define AT_SYSCFG_SRVDOMAIN 4
#define AT_TRIG_NSAPI 1
#define AT_TRIG_LENGTH 2
#define AT_TRIG_TIMES 3
#define AT_TRIG_MILLISECOND 4
#define AT_ADCTEMP_VALUE3 2
#define AT_ADCTEMP_VALUE4 3
#define AT_COPS_MODE 0
#define AT_COPS_OPER 2
#define AT_COPS_RAT 3
#define AT_CPOL_OPER 2
#define AT_CPOL_UTRAN 5
#define AT_CPOL_E_UTRAN 6
#define AT_CPOL_RAT 7
#define AT_AUTHDATA_PLMN 2
#define AT_AUTHDATA_PASSWD_INDEX 3
#define AT_AUTHDATA_USERNAME_INDEX 4
#define AT_CRPN_NAME_INDEX 0
#define AT_CRPN_NAME 1
#define AT_GPIOPL_PL 0
#define AT_CUUS1_MESSAGE 2
#define AT_FACINFO_VALUE_INFO 1
#define AT_CFUN_FUN 0
#define AT_CFUN_RST 1
#define AT_USIMSTUB_CARD_ID 0
#define AT_USIMSTUB_CARD_TYPE 1
#define AT_USIMSTUB_TOTALNUM 2
#define AT_USIMSTUB_EFLEN 3
#define AT_USIMSTUB_FILECONTENT 4
#define AT_REFRESHSTUB_TOTALNUM 2
#define AT_CMLCK_PASSWD_INDEX 2
#define AT_CMLCK_DATA 3
#define AT_CLCK_PASSWD_INDEX 2
#define AT_CLCK_CLASS 3
#define AT_NPLMN_PLMN_ID 1
#define AT_NPLMN_SIMRAT 2
#define AT_RPLMNSTUB_PLMN_ID 1
#define AT_RPLMNSTUB_LAI 2
#define AT_RPLMNSTUB_RAC 3
#define AT_CSGSTUB_UECSG 0
#define AT_CSGSTUB_EFAD 1
#define AT_CSGSTUB_CSGLIST 2
#define AT_RSFW_ITME 5
#define AT_APDS_I 2
#define AT_APDS_G 3
#define AT_APDS_CALL_TYPE 4
#define AT_APDS_CALLDOMAIN 5
#define AT_APDS_SRV_TYPE 6
#define AT_APDS_RTTFLG 7
#define AT_APDS_CALLPULLDIALOGID 8
#define AT_APDS_ENCRYPTFLAG 9
#define AT_CSUNAVAILPLMNSTUB_PLMNID 1
#define AT_COMMBOOSTER_MODULEID 1
#define AT_COMMBOOSTER_LEN 2
#define AT_COMMBOOSTER_PARAM 3
#define AT_NV_CARRIER_PARA_MIN_NUM 1
#define AT_NV_CARRIER_PARA_MAX_NUM 4
#define AT_NV_CARRIER_PARA_NUM 2
#define AT_NV_CARRIER_ENABLE 0
#define AT_NV_CARRIER_NAME 1
#define AT_NV_CARRIER_EFFECTIVEWAY 2
#define AT_NV_CARRIER_NOFLUSH 3
#define AT_CACMIMS_TOTAL_CALLNUM 0
#define AT_CACMIMS_CALL_ADDRESS 2
#define AT_UICCAUTH_RAND 1
#define AT_UICCAUTH_AUTH 2
#define AT_CURSM_COMMAND 1
#define AT_CURSM_FILEID 2
#define AT_CURSM_RECORD_NUMBER 3
#define AT_CURSM_DATA 4
#define AT_CURSM_PATHID 5
#define AT_KSNAFAUTH_NAF_ID 1
#define AT_KSNAFAUTH_IMPI 2
#define AT_EOPLMN_PDULEN 2
#define AT_EOPLMN_PDU 3
#define AT_CALLMODIFYINIT_DEST_CALL_TYPE 2
#define AT_CALLMODIFYANS_DEST_CALL_TYPE 2
#define AT_ECONFDIAL_DIAL_COUNT 0
#define AT_ECONFDIAL_DIAL_I 2
#define AT_ECONFDIAL_CALL_TYPE 3
#define AT_ECONFDIAL_CALLDOMAIN 4
#define AT_ECONFDIAL_ISECONF 5
#define AT_IMSSWITCH_GSM_ENABLE 2
#define AT_CFREQLOCK_SID 1
#define AT_CFREQLOCK_NID 2
#define AT_CFREQLOCK_CDMA_BAND_CLASS 3
#define AT_CFREQLOCK_CDMA_FREQ 4
#define AT_CFREQLOCK_CDMA_PN 5
#define AT_CFREQLOCK_EVDO_BAND_CLASS 6
#define AT_CFREQLOCK_EVDO_FREQ 7
#define AT_CFREQLOCK_EVDO_PN 8
#define AT_CDMACSQ_MODE 0
#define AT_CDMACSQ_TIME_INTERVAL 1
#define AT_CDMACSQ_RSSI_RPT_THRE 2
#define AT_CDMACSQ_ECIO_RPT_THRE 3
#define AT_CLOUDDATA_PARA_LENGTH 0
#define AT_CLOUDDATA_PARA_BS1 1
#define AT_CLOUDDATA_PARA_BS2 2
#define AT_CLOUDDATA_PARA_BS3 3
#define AT_FEMCTRL_PARA2 2
#define AT_FEMCTRL_PARA3 3
#define AT_ECKMC_KEY 1
#define AT_MCCFREQ_OPERATION 2
#define AT_MCCFREQ_LENGTH 3
#define AT_MCCFREQ_BS1 4
#define AT_MCCFREQ_BS2 5
#define AT_MCCFREQ_BS3 6
#define AT_BLOCKCELLLIST_OPERATION 2
#define AT_BLOCKCELLLIST_SYSMODE 3
#define AT_BLOCKCELLLIST_LENGTH 4
#define AT_BLOCKCELLLIST_BS1 5
#define AT_BLOCKCELLLIST_BS2 6
#define AT_BLOCKCELLLIST_BS3 7
#define AT_BORDERINFO_VER 2
#define AT_BORDERINFO_EHPLMNNUM 3
#define AT_BORDERINFO_EHPLMNLIST 4
#define AT_BORDERINFO_COUNT 5
#define AT_BORDERINFO_BS1 6
#define AT_BORDERINFO_BS2 7
#define AT_BORDERINFO_BS3 8
#define AT_DPLMNLIST_EHPLMNNUM 2
#define AT_DPLMNLIST_EHPLMN 3
#define AT_DPLMNLIST_BSCOUNT 4
#define AT_DPLMNLIST_BS1 5
#define AT_DPLMNLIST_BS2 6
#define AT_DPLMNLIST_BS3 7
#define AT_HDRCSQ_PARA_NUM 5
#define AT_HDRCSQ_MODE 0
#define AT_HDRCSQ_TIME_INTERVAL 1
#define AT_HDRCSQ_RSSI_RPT_THRE 2
#define AT_HDRCSQ_SNR_RPT_THRE 3
#define AT_HDRCSQ_ECIO_RPT_THRE 4
#define AT_BESTFREQ_DEVICEID 0
#define AT_BESTFREQ_MODE 1
#define AT_PSEUCELL_PLMN 2
#define AT_PSEUCELL_LAC 3
#define AT_PSEUCELL_CELLID 4
#define AT_CHRALARMRLATCFG_ALARMID_DETAIL 1
#define AT_PLMNSRCH_RAT 2
#define AT_PLMNSRCH_SRCHTYPE 3
#define AT_PLMNSRCH_RSRP 4
#define AT_DETECTPLMN_PLMN 0
#define AT_NVM_INDEX 0
#define AT_NVM_TOTAL 1
#define AT_NVM_ECC_NUM 2
#define AT_NVM_CATEGORY 3
#define AT_NVM_SIMPRESENT 4
#define AT_NVM_MCC 5
#define AT_NVM_ABNORMAL_SERVICE 6
#define AT_PHONEPHYNUM_HMAC_NUMBER 2
#define AT_APRPTPORTSEL_PORTSELTHREE 2
#define AT_CREDIALSTUB_SSREDIALIMSTOCS 2
#define AT_CREDIALSTUB_CALLREDIALCSTOIMS 3
#define AT_CREDIALSTUB_SMSREDIALCSTOTMS 4
#define AT_CREDIALSTUB_SSREDIALCSTOIMS 5
#define AT_DOMAINSTUB_MMLVOICEDOMAINFLAG 2
#define AT_IMSCAPSTUB_SMS 2
#define AT_CURC_MODE 0
#define AT_CURC_REPORT_CFG 1
#define AT_SIMWRITESTUB_MSGLENGTH 1
#define AT_SIMWRITESTUB_RECORDNUM 2
#define AT_NVSTUB_READ_OR_WRITE 0
#define AT_NVSTUB_WRITE 2
#define AT_EONSSTUB_NCNUM 0
#define AT_EONSSTUB_TYPE1 1
#define AT_EONSSTUB_TYPE2 2
#define AT_EONSSTUB_TYPE3 3
#define AT_EONSSTUB_TYPE4 4
#define AT_EONSSTUB_RESTART_FLAG 5
#define AT_C5GOPTION_5GCACCESSMODE 2
#define AT_USIMWRITESTUB_MSG 1
#define AT_USIMWRITESTUB_RECORDNUM 2
#define AT_USIMWRITESTUB_APPTYPE 3
#define AT_RSRPCFG_LEVEL 0
#define AT_RSRPCFG_VALUE 1
#define AT_RSCPCFG_LEVEL 0
#define AT_RSCPCFG_VALUE 1
#define AT_ECIOCFG_LEVEL 0
#define AT_ECIOCFG_VALUE 1
#define AT_PHYNUM_TIMES 2
#define AT_SETPORT_PORT_TYPE 0
#define AT_DAMCFGSTUB_DAM_DISABLE_LTE 2
#define AT_DAMCFGSTUB_IMSI_PLMN_NUM 3
#define AT_CPBW_TEXT_MIN_NUM 128
#define AT_UDP_SRC_PORT 9700
#define AT_MNC_LENGTH 3
#define AT_CGEQOS_PARA_MAX_NUM 6
#define AT_CSND_PARA_MAX_NUM 2
#define AT_CGDATA_PARA_MAX_NUM 2
#define AT_CGCATT_PARA_MAX_NUM 2
#define AT_COPS_PARA_MAX_NUM 4
#define AT_CFUN_PARA_MAX_NUM 2
#define AT_CFUN_PARA_NUM 2
#define AT_CPBW_PRIVATA_PARA_MAX_NUM 5
#define AT_CPBW_PARA_MAX_NUM 4
#define AT_SCPBW_PARA_MAX_NUM 12
#define AT_SCPBR_PARA_MAX_NUM 2
#define AT_CSIM_PARA_MAX_NUM 2
#define AT_CCHP_PARA_MAX_NUM 2
#define AT_CRSM_PARA_MIN_NUM 2
#define AT_CPIN_PARA_MAX_NUM 2
#define AT_CCWA_PARA_MAX_NUM 3
#define AT_CCFC_PARA_MAX_NUM 8
#define AT_CMLCK_PARA_MAX_NUM 4
#define AT_CLCK_PARA_MAX_NUM 4
#define AT_CTFR_PARA_MAX_NUM 4
#define AT_CUSD_PARA_MAX_NUM 3
#define AT_CPWD_PARA_MAX_NUM 3
#define AT_CPAM_PARA_MAX_NUM 2
#define AT_STSF_PARA_MAX_NUM 3
#define AT_CWAS_PARA_MIN_NUM 1
#define AT_CWAS_PARA_MAX_NUM 4
#define AT_CGAS_PARA_MIN_NUM 1
#define AT_CGAS_PARA_MAX_NUM 11
#define AT_CMM_PARA_MAX_NUM 2
#define AT_CCC_PARA_MAX_NUM 2
#define AT_CURC_PARA_MIN_NUM 1
#define AT_CURC_PARA_MAX_NUM 2
#define AT_CFPLMN_PARA_MAX_NUM 2
#define AT_VALID_CHAR_LEN 2
#define AT_C5GPNSSAI_PARA_NUM 2
#define AT_C5GNSSAI_PARA_NUM 2
#define AT_C5GNSSAA_PARA_NUM 2
#define AT_CSGIDSRCH_PARA_NUM 3
#define AT_CPBR_PARA_MIN_NUM 1
#define AT_CPBR_PARA_MAX_NUM 2
#define AT_SET_PORT_PORTTYPE_CHARCOUNT 2
#define AT_SET_PORT_PORTTYPE_CHAR1 2
#define AT_SET_PORT_PORTTYPE_CHAR2 1
#define AT_C5GNSSAIRDP_PARA_MAX_NUM 2
#define AT_C5GNSSAIRDP_PLMN_ID_VAILD_LEN1 5
#define AT_C5GNSSAIRDP_PLMN_ID_VAILD_LEN2 6
#define AT_CSGIDSRCH_PLMN_ID_VAILD_LEN1 5
#define AT_CSGIDSRCH_PLMN_ID_VAILD_LEN2 6
#define AT_CSGIDSRCH_CSG_ID_LEN_MAX 8
#define AT_MODEMSTATUS_PARA_NUM 2
#define AT_CGLA_PARA_NUM 3
#define AT_CRSM_UPDATA_BINARY_PARA_MIN_NUM 6
#define AT_CRSM_PARA_MAX_NUM 7
#define AT_CPIN_PARA_NUM 2
#define AT_CUSD_N_CANCEL_SESSION_VALUE 2
#define AT_STSF_CONFIG_LENGTH_MAX 32
#define AT_CURC_MODE_VAILD_VALUE 2
#define AT_BOOT_PARA_NUM 2
#define AT_BOOT_VAILD_PARA_NUM1 1
#define AT_BOOT_VAILD_PARA_NUM2 2
#define AT_FREQLOCK_PARA_NUM 6
#define AT_FREQLOCK_ENABLE_VAILD_VALUE 1
#define AT_FREQLOCK_FREQ_VAILD_LEN 2
#define AT_FREQLOCK_BAND_VAILD_LEN 2

#define AT_CPBW_NLENGTH 4
#define AT_NOREPCONDTIME_DEFAULT 20
#define AT_CARDMODE_SIM_TYPE_NULL_CARD 0
#define AT_CARDMODE_SIM_TYPE_SIM 1
#define AT_CARDMODE_SIM_TYPE_USIM 2
#define AT_STGR_PARA_MAX_NUM 4
#define AT_HEX_ONEBYTE_VALID_LENTH 2  // HEX_ONEBYTE_VALID_LENTH:一个字节的16进制0x后面两位的长度
#define AT_STGR_DATA_VALID_LENGTH 2
#define AT_DOUBLE_QUOTATION_MARKS_LENGTH 2
#define AT_STGR_MIN_VALID_NUM 3
#define AT_STGR_MAX_VALID_NUM 4
#define AT_STGR_VALID_NUM 2
#define AT_CFPLMN_OPER_MAX_VALID_LEN 6
#define AT_CFPLMN_OPER_MIN_VALID_LEN 5
#define AT_SYSCFG_VALID_NUM 5

#define AT_TRIG_PARA_VALID_NUM 5
#define AT_CERSSI_PARA_MAX_NUM 2
#define AT_CERSSI_MODE 0
#define AT_PHYNUM_PARA_MIN_VALID_NUM 2
#define AT_PHYNUM_PARA_MAX_VALID_NUM 3
#define AT_SETPORT_FIRST_PARA_MIN_NUM 1
#define AT_SETPORT_FIRST_PARA_MAX_NUM 2
#define AT_CMMT_PARA_MAX_NUM 2
#define AT_ADCTEMP_PARA_MAX_NUM 4
#define AT_UE_MODE_NR_AND_LTE_AT_CPOL_PARA_MAX_NUM 8
#define AT_UE_MODE_NR_OR_LTE_AT_CPOL_PARA_MAX_NUM 7
#define AT_OTHER_MODE_AT_CPOL_PARA_MAX_NUM 6
#define AT_RSRPCFG_PARA_VALID_NUM 2
#define AT_RSCPCFG_PARA_VALID_NUM 2
#define AT_ECIOCFG_PARA_VALID_NUM 2
#define AT_AUTHDATA_PARA_MAX_NUM 5
#define AT_CRPN_PARA_VALID_NUM 2
#define AT_ALS_PARA_NUM 2
#define AT_DOUBLE_BCD_NUM 2 // 两个BCD码占一个字节
#define AT_CUUS1_FIRST_AND_SECOND_PARA_COUNT 2 // <n>和<m>两个参数个数总数
#define AT_FACINFO_PARA_VALID_NUM 2
#define AT_VMODE_PARA_VALID_NUM 2
#define AT_CCFC_CLASS_DEDICATED_PAD_ACCESS 128 // dedicated PAD access参数值
#define AT_DATA_MAX_LEN 256
#define AT_NPLMN_MIN_LENGTH 5
#define AT_NPLMN_MAX_LENGTH 6
#define AT_SIMWRITESTUB_PARA_MAX_NUM 3

#define AT_WUPWD_PARA_MAX_NUM 2
#define AT_FASTDORM_PARA_MAX_NUM 2
#define AT_PDPISRSTUB_PARA_MAX_NUM 3
#define AT_IMSRATSTUB_PARA_MAX_NUM 2
#define AT_IMSCAPSTUB_PARA_MAX_NUM 3
#define AT_DOMAINSTUB_PARA_MAX_NUM 3
#define AT_CREDIALSTUB_PARA_MAX_NUM 7
#define AT_APRPTPORTSEL_PARA_MAX_NUM 3
#define AT_RSFR_PARA_VALID_NUM 2
#define AT_RSFW_PARA_MAX_NUM 6
#define AT_PHONEPHYNUM_PARA_MAX_NUM 3
#define AT_NVM_MIN_PARA_NUM 6
#define AT_NVM_MAX_PARA_NUM 7
#define AT_USSD_STRING_CNT 1

#define AT_EVENT_INFO_ARRAY_MAX_LEN 4
#define AT_CUSD_N_EXIT_SESSION 2
#define AT_CLCK_FAC 0
#define AT_CLCK_MODE 1
#define AT_PATH_INDEX_1 1
#define AT_PATH_INDEX_2 2
#define MN_CALL_MAX_ASCII_NUM_LEN (MN_CALL_MAX_BCD_NUM_LEN * 2)
#define AT_REFRESHSTUB_RECEIVED_PID 0
#define AT_REFRESHSTUB_FILE_TYPE 1
#define AT_REFRESHSTUB_FILE_ID 3
#define AT_ADDITION_NUM_ARRAY_INDEX_2 2
#define AT_SCPBW_NUM4_NUM_TYPE 0
#define AT_SRC_OFFSET_1 1
#define AT_GSM_DATA_MAX_LEN 2
#define AT_CGCATT_MODE_EQUALED_3_MAX_PARA_NUM 3
#define AT_CGCATT_MODE 1
#define AT_CGCATT_PS_STATE 2
#define AT_CSUEPOLICY_MAX_PARA_NUM 6
#define AT_CSUEPOLICY_MIN_PARA_NUM 2
#define AT_CSUEPOLICY_PTI 0
#define AT_CSUEPOLICY_MSG_TYPE 1
#define AT_CSUEPOLICY_INFO_LEN 2
#define AT_CSUEPOLICY_CLASS_MARK 3
#define AT_CSUEPOLICY_OS_ID_INFORMATION 4
#define AT_CSUEPOLICY_PROTOCAL_VERSION 5
#define AT_DETECTPLMN_RAT 1
#define AT_DETECTPLMN_PARA_NUM 2
#define AT_PLMN_ID_INDEX_0 0
#define AT_PLMN_ID_INDEX_1 1
#define AT_PLMN_ID_INDEX_2 2
#define AT_OUTPUT_INDEX_0 0
#define AT_OUTPUT_INDEX_1 1
#define AT_OUTPUT_INDEX_2 2
#define AT_OUTPUT_INDEX_3 3
#define AT_INPUT_INDEX_0 0
#define AT_INPUT_INDEX_1 1
#define AT_INPUT_INDEX_2 2
#define AT_INPUT_INDEX_3 3
#define AT_IMSSWITCH_PARA_MAX_NUM 3
#define AT_IMSSWITCH_LTE_ENABLE 0
#define AT_IMSSWITCH_UTRAN_ENABLE 1
#define AT_D_DIAL_STRING 0
#define AT_D_BY_MEM_N_POSITION 1
#define AT_D_BY_NAME 2
#define AT_D_BY_N 2
#define AT_D_MEM_TYPE 2
#define AT_D_MEM_N_NUM 3
#define AT_D_BY_DIAL_STRING 1
#define AT_D_PARA_INDEX_2 2
#define AT_D_PARA_INDEX_3 3
#define AT_D_PARA_INDEX_4 4
#define AT_D_CID 4
#define AT_S_NSSAI_DIGITE_INDEX_0 0
#define AT_S_NSSAI_DIGITE_INDEX_1 1
#define AT_S_NSSAI_PUNC_NUM 2
#define AT_PLMNSRCH_PARA_NUM 4
#define AT_PLMNSRCH_MAX_PARA_NUM 5
#define AT_CHRALARMRLATCFG_MIN_PARA_NUM 1
#define AT_CHRALARMRLATCFG_MAX_PARA_NUM 2
#define AT_CHRALARMRLATCFG_ALARMID 0
#define AT_PSEUCELL_PARA_NUM 5
#define AT_PSEUCELL_NOTIFY_TYPE 0
#define AT_PSEUCELL_RAT 1
#define AT_BESTFREQ_PARA_NUM 2
#define AT_EXCHANGEMODEMINFO_PARA_NUM 2
#define AT_EXCHANGEMODEMINFO_MODEMID1 0
#define AT_EXCHANGEMODEMINFO_MODEMID2 1
#define AT_DPLMNLIST_MIN_PARA_NUM 6
#define AT_DPLMNLIST_VER 1
#define AT_BLOCKCELLLIST_MIN_PARA_NUM 5
#define AT_BLOCKCELLLIST_MAX_PARA_NUM 8
#define AT_BLOCKCELLLIST_SEQ 0
#define AT_BLOCKCELLLIST_VER 1
#define AT_SUB_STR_INDEX_3 3
#define AT_EHPLMN_LEN_FIVE 5
#define AT_EHPLMN_LEN_SIX 6
#define AT_DPLMN_LEN_FIVE 5
#define AT_DPLMN_LEN_SIX 6
#define AT_BORDERINFO_OPERTION_TYPE 0
#define AT_BORDERINFO_MIN_PARA_NUM 7
#define AT_BORDERINFO_MAX_PARA_NUM 9
#define TAF_MMA_BODER_INFO_BUFF_LEN 4
#define AT_CSS_BLOCK_CELL_LIST_SET_REQ_BUFF_LEN 4
#define AT_DTMF_MAX_PARA_NUM 4
#define AT_CCUG_INDEX_VALUE_DENOTES_NO_INDEX 10
#define AT_CSCB_MIDS_MAX_VALID_CHARACTERS_NUM 6
#define AT_CMST_MAX_PARA_NUM 4
#define AT_CMSS_MAX_PARA_NUM 3
#define AT_CSMP_MAX_VP_VALUE 255
#define AT_CSCA_MAX_PARA_NUM 2
#define AT_CPMS_MAX_PARA_NUM 3
#define AT_CSS_MCCINFO_SET_REQ_BUFF_LEN 4
#define AT_CSS_CLOUDDATA_SET_REQ_BUFF_LEN 4
#define AT_MCCFREQ_MIN_PARA_NUM 4
#define AT_MCCFREQ_MAX_PARA_NUM 7
#define AT_CLOUDDATA_MIN_PARA_NUM 2
#define AT_CLOUDDATA_MAX_PARA_NUM 4
#define AT_MCCFREQ_SEQ 0
#define AT_MCCFREQ_VER 1
#define AT_CTOOSCOUNT_PARA_NUM 2
#define AT_CTOOSCOUNT_CL_COUNT 0
#define AT_CTOOSCOUNT_GUL_COUNT 1
#define AT_ECKMC_VER 0
#define AT_ECKMC_PARA_NUM 2
#define AT_CSIDLIST_TRUST_LIST_NUM 0
#define AT_CSIDLIST_PARA_OFFSET_1 1
#define AT_CSIDLIST_PARA_OFFSET_2 2
#define AT_FEMCTRL_MAX_PARA_NUM 4
#define AT_FEMCTRL_CTRL_TYPE 0
#define AT_FEMCTRL_PARA1 1
#define AT_CDMACSQ_MIN_PARA_NUM 4
#define AT_IMSCTRLMSG_PARA_NUM 3
#define AT_IMSCTRLMSG_MSG_ID 0
#define AT_IMSCTRLMSG_MSG_LEN 1
#define AT_IMSCTRLMSG_MSG_LEN_INDEX 2
#define AT_FUSIONCALL_RAW_PARA_NUM 3
#define AT_FUSIONCALL_RAW_MSG_ID_INDEX 0
#define AT_FUSIONCALL_RAW_MSG_LEN_INDEX 1
#define AT_FUSIONCALL_RAW_MSG_DATA_INDEX 2
#define AT_CALLMODIFYINIT_PARA_NUM 3
#define AT_CALLMODIFYINIT_IDX 0
#define AT_CALLMODIFYINIT_CURR_CALL_TYPE 1
#define AT_CALLMODIFYANS_PARA_NUM 3
#define AT_CALLMODIFYANS_IDX 0
#define AT_CALLMODIFYANS_CURR_CALL_TYPE 1
#define AT_ICF_PARA_NUM 2
#define AT_ICF_FORMAT 0
#define AT_ICF_PARITY 1
#define AT_IFC_PARA_NUM 2
#define AT_IFC_DCE_BY_DTE 0
#define AT_IFC_DTE_BY_DCE 1
#define AT_EOPLMN_VERSION 0
#define AT_EOPLMN_INDEX 1
#define AT_KSNAFAUTH_AUTH_TYPE 0
#define AT_KSNAFAUTH_PARA_NUM 3
#define AT_CURSM_MIN_PARA_NUM 4
#define AT_CURSM_MAX_PARA_NUM 6
#define AT_CURSM_APP_TYPE 0
#define AT_UICCAUTH_PARA_NUM 3
#define AT_UICCAUTH_AUTH_TYPE 0
#define AT_CCWAI_PARA_NUM 2
#define AT_CCWAI_MODE 0
#define AT_CCWAI_SERVICE_CLASS 1
#define AT_CACMIMS_IS_ECON 1
#define AT_COMMBOOSTER_PARA_NUM 4
#define AT_BODYSARGSM_MIN_PARA_NUM 1
#define AT_BODYSARGSM_BAND 1
#define AT_BODYSARWCDMA_MIN_PARA_NUM 1
#define AT_BODYSARWCDMA_BAND 1
#define AT_APDS_MAX_PARA_NUM 10
#define AT_SIMLOCKUNLOCK_PARA_NUM 2
#define AT_SIMLOCKUNLOCK_CAT 0
#define AT_SIMLOCKUNLOCK_PWD 1
#define AT_RSFW_ITEM_NAME 0
#define AT_DATA_OFFSET_8 8
#define AT_MNC_MIN_LEN 2
#define AT_MNC_MAX_LEN 3
#define AT_C5GOPTION_PARA_NUM 3
#define AT_C5GOPTION_SA_SUPPORT_FLAG 0
#define AT_C5GOPTION_DC_MODE 1
#define AT_USIMWRITESTUB_MIN_PARA_NUM 3
#define AT_USIMWRITESTUB_MAX_PARA_NUM 4
#define AT_NPLMN_SET_NPLMN_NUM 0
#define AT_NVSTUB_MIN_PARA_NUM 2
#define AT_NVSTUB_MAX_PARA_NUM 3
#define AT_PLMNSRCH_SRCH_MODE_FLAG 0
#define AT_PLMNSRCH_PLMN_LEN 1
#define AT_PHONEPHYNUM_TYPE 0
#define AT_PHONEPHYNUM_RSA_NUM 1

#define AT_CRPN_NAME_MIN_LEN 5
#define AT_CRPN_NAME_MAX_LEN 6
#define AT_COPS_SHORT_OPER_LEN 5
#define AT_COPS_FULL_OPER_LEN 6
#define AT_SETPORT_PORT_TYPE_NUM 3
#define AT_HS_PARA_NUM 2
#define AT_CTZR_VALUE_MAX_VALUE 2
#define AT_TRIG_NSAPI_MIN_VALUE 5
#define AT_TRIG_NSAPI_MAX_VALUE 15
#define AT_SYSCFG_ROAM_INACTIVE_STATUS_MAX_VALUE 2
#define AT_SYSCFG_ROAM_ACTIVATE_STATUS_MAX_VALUE 3

#define AT_CSCA_PARA_NUM 2
#define AT_STGR_CMD_TYPE 0
#define AT_STGR_CMD_NUM 1
#define AT_STGR_MENU_SELECTION 1
#define AT_STGR_NEED_HELP_INFORMATION 2
#define AT_VTFLOWRPT_PARA_NUM 1
#define AT_VTFLOWRPT_RPT_OPER 0
#define AT_TIME_PARA_NUM 1
#define AT_TIME_RPT_FLG 0
#define AT_TIME_RPT_FLG_MAX_VALID_VALUE 2
#define AT_BUF_ARRAY_MAX_LEN 5
#define AT_HS_ID 0
#define AT_HS_ACTION 1
#define AT_CPOL_PARA_NUM 2
#define AT_CPOL_INDEX 0
#define AT_CPOL_FORMAT 1
#define AT_CPOL_GSM_ACTN 3
#define AT_CPOL_GSM_COMPACT_ACTN 4
#define AT_RPLMNSTUB_L_RPLMN 0
#define AT_IMSI_PLMN_LIST_ARRAY_MAX_LEN 16
#define AT_DAM_PLMN_LIST_ARRAY_MAX_LEN 16
#define AT_DAMCFGSTUB_DAM_ACTIVE_FLG 0
#define AT_DAMCFGSTUB_ENABLE_LTE 1
#define AT_EONS_PRIO_TYPE_ARRAY_MAX_LEN 4
#define AT_EONS_PRIO_TYPE_ARRAY_INDEX_0 0
#define AT_EONS_PRIO_TYPE_ARRAY_INDEX_1 1
#define AT_EONS_PRIO_TYPE_ARRAY_INDEX_2 2
#define AT_EONS_PRIO_TYPE_ARRAY_INDEX_3 3
#define AT_APRPTPORTSEL_PORTSEL1 0
#define AT_APRPTPORTSEL_PORTSEL2 1
#define AT_BASE64_DECODE_ARRAY_MAX_LEN 256
#define AT_APDS_DIAL_STRING 0
#define AT_APDS_SUB_STRING 1
#define AT_NVSTUB_NVIM_ID 1
#define AT_RPLMNSTUB_LAI_VALID_LEN 4
#define AT_RPLMNSTUB_RAC_VALID_LEN 2
#define AT_DAMCFGSTUB_IMSI_PLMN_MAX_VALUE 16
#define AT_LETTERS_NUM 26
#define AT_SIMLOCK_MIN_LEN 13

#if (FEATURE_LTEV == FEATURE_ON)
#define AT_VMODE_PARA_DEFAULT_NUM 2
#define AT_SRCID_PARA_MIN_NUM 1
#define AT_SRCID_PARA_MAX_NUM 2
#endif

#define AT_PDP_TYPE_IPV4 0
#define AT_PDP_TYPE_IPV6 1
#define AT_PDP_TYPE_IPV4V6 2
#define AT_PDP_TYPE_PPP 3
#define AT_PDP_TYPE_ETHERNET 4

#define AT_LTESARSTUB_PARA_NUM 1
#define AT_MCC_DIGIT_1 0
#define AT_MCC_DIGIT_2 1
#define AT_MCC_DIGIT_3 2
#define AT_MNC_DIGIT_1 3
#define AT_MNC_DIGIT_2 4
#define AT_PLMN_LEN_SIX_MNC_DIGIT_2 5

#define TAF_MMA_RAT_ORDER_INDEX_0 0
#define TAF_MMA_RAT_ORDER_INDEX_1 1
#define TAF_MMA_RAT_ORDER_INDEX_2 2

#define AT_IMEI_CHECK_NUM_LEN 1
#define AT_USIM_PARA_MAX_NUM 2
#define AT_SIMLOCK_INDEX_A 0
#define AT_SIMLOCK_INDEX_T 1
#define AT_SIMLOCK_INDEX_EQUAL_SIGN 10
#define AT_SIMLOCK_INDEX_1 11
#define AT_SIMLOCK_INDEX_COMMA 12
#define AT_SIMLOCK_UNLOCK_PASSWORD_LEN 8
#define AT_CHAR_AT_LEN 2
#define AT_ECONFDIAL_FIRST_SIX_PARA_NUM 6
#define AT_SEARCH_GSM_NULL_DST_LEN 0
#define AT_SEARCH_GSM_UNICODE_BASIC_DST_LEN 1
#define AT_SEARCH_GSM_UNICODE_EXTEND_DST_LEN 2
#define AT_NVSTUB_WRITE_ITEM_RAT_PRIO_LIST_PARA_LEN 12
#define AT_BORD_MIN_WIDTH 1
#define AT_BORD_MAX_WIDTH 2
#define AT_BASE_64_CODING_CHAR_MAX_NUM 64

#define AT_BYTE_ALIGNMENT_VALUE 4  /* 调用底软的串口数据发送接口时，所传入的指针必需为4字节对齐格式 */
#define AT_HALF_BYTE_BIT_LEN 4
#define AT_OOS_RECORD_LEN (15)

AT_SetPortParaMap g_setPortParaMap[AT_SETPORT_DEV_MAP_LEN] = {
    { "A1", AT_DEV_CDROM, "CDROM" },
    { "A2", AT_DEV_SD, "SD" },
    { "A3", AT_DEV_RNDIS, "RNDIS" },
    { "A", AT_DEV_BLUE_TOOTH, "BLUE TOOTH" },
    { "B", AT_DEV_FINGER_PRINT, "FINGER PRINT" },
    { "D", AT_DEV_MMS, "MMS" },
#if (FEATURE_LTE == FEATURE_ON)
    { "E", AT_DEV_PC_VOICE, "3G PC VOICE" },
    { "1", AT_DEV_MODEM, "3G MODEM" },
    { "2", AT_DEV_PCUI, "3G PCUI" },
    { "3", AT_DEV_DIAG, "3G DIAG" },
#else
    { "E", AT_DEV_PC_VOICE, "PC VOICE" },
    { "1", AT_DEV_MODEM, "MODEM" },
    { "2", AT_DEV_PCUI, "PCUI" },
    { "3", AT_DEV_DIAG, "DIAG" },
#endif
    { "4", AT_DEV_PCSC, "PCSC" },
#if (FEATURE_LTE == FEATURE_ON)
    { "5", AT_DEV_GPS, "3G GPS" },
#else
    { "5", AT_DEV_GPS, "GPS" },
#endif
    { "6", AT_DEV_GPS_CONTROL, "GPS CONTROL" },
    { "7", AT_DEV_NDIS, "3G NDIS" },
    { "16", AT_DEV_NCM, "NCM" },
    { "10", AT_DEV_4G_MODEM, "4G MODEM" },
    { "11", AT_DEV_4G_NDIS, "4G NDIS" },
    { "12", AT_DEV_4G_PCUI, "4G PCUI" },
    { "13", AT_DEV_4G_DIAG, "4G DIAG" },
    { "14", AT_DEV_4G_GPS, "4G GPS" },
    { "15", AT_DEV_4G_PCVOICE, "4G PCVOICE" },
    { "FF", AT_DEV_NONE, "NO FIRST PORT" }
};

/* AT/OM通道的链路索引 */
TAF_UINT8 g_atOmIndex = AT_MAX_CLIENT_NUM;

#if (FEATURE_LTE == FEATURE_ON)
AT_TmodeRatFlag g_tmodeRat      = {0};
VOS_UINT32      g_tmodeNum      = 0;
VOS_UINT32      g_guTmodeCnfNum = 0;
VOS_UINT32      g_lteOnly       = 0;
VOS_UINT32      g_guOnly        = 0;
VOS_UINT32      g_lteIsSend2Dsp = 0;

#endif

/* +CLCK命令参数CLASS与Service Type Code对应表 */
static const AT_ClckClassServiceTbl g_clckClassServiceTbl[] = {
    { AT_CLCK_PARA_CLASS_VOICE, TAF_SS_TELE_SERVICE, TAF_ALL_SPEECH_TRANSMISSION_SERVICES_TSCODE },
    { AT_CLCK_PARA_CLASS_DATA, TAF_SS_BEARER_SERVICE, TAF_ALL_BEARERSERVICES_BSCODE },
    { AT_CLCK_PARA_CLASS_FAX, TAF_SS_TELE_SERVICE, TAF_ALL_FACSIMILE_TRANSMISSION_SERVICES_TSCODE },
    { AT_CLCK_PARA_CLASS_VOICE_FAX, TAF_SS_TELE_SERVICE, TAF_ALL_TELESERVICES_EXEPTSMS_TSCODE },
    { AT_CLCK_PARA_CLASS_VOICE_DATA_FAX, TAF_SS_TELE_SERVICE, TAF_ALL_TELESERVICES_EXEPTSMS_TSCODE },
    { AT_CLCK_PARA_CLASS_SMS, TAF_SS_TELE_SERVICE, TAF_ALL_SMS_SERVICES_TSCODE },
    { AT_CLCK_PARA_CLASS_VOICE_FAX_SMS, TAF_SS_TELE_SERVICE, TAF_ALL_TELESERVICES_TSCODE },
    { AT_CLCK_PARA_CLASS_VOICE_DATA_FAX_SMS, TAF_SS_TELE_SERVICE, TAF_ALL_TELESERVICES_TSCODE },
    { AT_CLCK_PARA_CLASS_DATA_SYNC, TAF_SS_BEARER_SERVICE, TAF_ALL_DATA_CIRCUIT_SYNCHRONOUS_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_ASYNC, TAF_SS_BEARER_SERVICE, TAF_ALL_DATA_CIRCUIT_ASYNCHRONOUS_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_PKT, TAF_SS_BEARER_SERVICE, TAF_ALL_DATAPDS_SERVICES_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_SYNC_PKT, TAF_SS_BEARER_SERVICE, TAF_ALL_SYNCHRONOUS_SERVICES_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_PAD, TAF_SS_BEARER_SERVICE, TAF_ALL_PADACCESSCA_SERVICES_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_ASYNC_PAD, TAF_SS_BEARER_SERVICE, TAF_ALL_ASYNCHRONOUS_SERVICES_BSCODE },
    { AT_CLCK_PARA_CLASS_DATA_SYNC_ASYNC_PKT_PKT, TAF_SS_BEARER_SERVICE, TAF_ALL_BEARERSERVICES_BSCODE },
};

TAF_WRITE_AcoreNv g_writeAcoreNv = {0};

AT_MTA_BodySarStateUint16 g_atBodySarState = AT_MTA_BODY_SAR_OFF;

#if (VOS_WIN32 == VOS_OS_VER)
EXTERN const AT_USIMM_FileNumToId g_atUsimFileNumToIdTab[];
EXTERN const VOS_UINT32 g_atUsimFileNumToIdTabLen;

EXTERN const AT_USIMM_FileNumToId g_atSimFileNumToIdTab[];
EXTERN const VOS_UINT32 g_atSimFileNumToIdTabLen;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
EXTERN const AT_USIMM_FileNumToId g_atCsimFileNumToIdTab[];

EXTERN VOS_UINT32 g_atCsimFileNumToIdTabLen;
#endif

#endif
#if ((FEATURE_UE_MODE_CDMA == FEATURE_ON) && (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON) && \
     (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT == FEATURE_ON))
#define ENCRYPT_VOICE_DATA_FILE_MAX_NUM 5
#endif

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
/* CMUX配置的默认值(协议和需求共同制定):
operating_mode                  < dft = 0 >
subset                          < dft = 0 >
max_cmd_num_tx_times_N2         < dft = 3 >
window_size_k                   < dft = 2 >
port_speed                      < dft = 5 >
max_frame_size_N1               < dft = 31 >
response_timer_T1               < dft = 100 >
response_timer_T2               < dft = 900 >
response_timer_T3               < dft = 10 > */
cmux_info_type g_cmux_info = {0,0,3,2,5,31,100,900,10};
#endif

/*
 * 3 函数、变量声明
 */
#if (VOS_WIN32 == VOS_OS_VER)
/* 输出TAF的回放数据 */
VOS_VOID NAS_MMA_SndNVData(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part1(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part2(VOS_VOID);
VOS_VOID NAS_MSG_SndOutsideContextData_Part3(VOS_VOID);

VOS_VOID NAS_STUB_AT_ResetNplmn(VOS_VOID);
VOS_VOID NAS_STUB_AT_SetNplmn(VOS_UINT8 nplmnNum, TAF_MMA_PlmnWithSimRat *nplmnList);

LOCAL VOS_UINT32 AT_IsSpecRatSupported(TAF_MMA_RatTypeUint8 ratMode, TAF_MMA_MultimodeRatCfg *ratOrder);

LOCAL VOS_UINT32 AT_IsModeConflictingDomain(TAF_MMA_SysCfgPara *sysCfgExSetPara);

#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (MULTI_MODEM_NUMBER >= 2)
LOCAL VOS_UINT32 At_QryCdmaModemSwitchCdmaCapCheck(VOS_UINT32 modem0SupportCMode, VOS_UINT32 modem1SupportCMode,
#if (MULTI_MODEM_NUMBER == 3)
                                                   VOS_UINT32 ulModem2SupportCMode,
#endif
                                                   VOS_UINT32 *pulAllModemNotSupportCMode);
#endif
#endif

/*
 * Function:      AT_CtrlGetPDPAuthType
 * Description:    获取PC设置的PDP上下文中对应类型的数据
 * Return:        0   no auth
 *                1   pap
 *                2   chap
 *   1.Date: 2009-08-03
 *    Modification: Created function
 */
PPP_AuthTypeUint8 AT_CtrlGetPDPAuthType(VOS_UINT32 value, VOS_UINT16 totalLen)
{
    /* 获取验证方法 */
    if (totalLen == 0) {
        return TAF_PDP_AUTH_TYPE_NONE;
    } else {
        if (value == 0) {
            return TAF_PDP_AUTH_TYPE_NONE;
        } else if (value == 1) {
            return TAF_PDP_AUTH_TYPE_PAP;
        } else {
            return TAF_PDP_AUTH_TYPE_CHAP;
        }
    }
}



TAF_PDP_AuthTypeUint8 AT_ClGetPdpAuthType(VOS_UINT32 value, VOS_UINT16 totalLen)
{
    /* 获取验证方法 */
    if (totalLen == 0) {
        return TAF_PDP_AUTH_TYPE_NONE;
    } else {
        switch (value) {
            case AT_PDP_AUTH_TYPE_NONE:
                return TAF_PDP_AUTH_TYPE_NONE;
            case AT_PDP_AUTH_TYPE_PAP:
                return TAF_PDP_AUTH_TYPE_PAP;
            case AT_PDP_AUTH_TYPE_CHAP:
                return TAF_PDP_AUTH_TYPE_CHAP;
            case AT_PDP_AUTH_TYPE_PAP_OR_CHAP:
                return TAF_PDP_AUTH_TYPE_PAP_OR_CHAP;
            default:
                return TAF_PDP_AUTH_TYPE_BUTT;
        }
    }
}

TAF_UINT32 At_SsPrint2Class(TAF_SS_BasicService *bsService, TAF_UINT8 classValue)
{
    VOS_UINT32 loop;
    VOS_UINT32 itemsNum;

    itemsNum = sizeof(g_clckClassServiceTbl) / sizeof(AT_ClckClassServiceTbl);

    /* 查表填写对应Class的服务类型及服务码 */
    for (loop = 0; loop < itemsNum; loop++) {
        if (g_clckClassServiceTbl[loop].classType == classValue) {
            bsService->bsType        = g_clckClassServiceTbl[loop].serviceType;
            bsService->bsServiceCode = g_clckClassServiceTbl[loop].serviceCode;
            return AT_SUCCESS;
        }
    }

    return AT_FAILURE;
}

/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_VOID At_SsPrint2Code(TAF_SS_CODE *ssCode, TAF_UINT8 type)
{
    switch (type) {
        case AT_CLCK_AO_TYPE:
            *ssCode = TAF_BAOC_SS_CODE;
            break;

        case AT_CLCK_OI_TYPE:
            *ssCode = TAF_BOIC_SS_CODE;
            break;

        case AT_CLCK_OX_TYPE:
            *ssCode = TAF_BOICEXHC_SS_CODE;
            break;

        case AT_CLCK_AI_TYPE:
            *ssCode = TAF_BAIC_SS_CODE;
            break;

        case AT_CLCK_IR_TYPE:
            *ssCode = TAF_BICROAM_SS_CODE;
            break;

        case AT_CLCK_AB_TYPE:
            *ssCode = TAF_ALL_BARRING_SS_CODE;
            break;

        case AT_CLCK_AG_TYPE:
            *ssCode = TAF_BARRING_OF_OUTGOING_CALLS_SS_CODE;
            break;

        default:
            *ssCode = TAF_BARRING_OF_INCOMING_CALLS_SS_CODE;
            break;
    }
}

#if (VOS_WIN32 == VOS_OS_VER)

VOS_UINT32 AT_ReadValueFromNvim(const NV_IdU16 nVItemType, VOS_UINT8 *data, VOS_UINT32 dataLen, ModemIdUint16 modemId)
{
    VOS_UINT32 rst;
    rst = TAF_ACORE_NV_READ(modemId, nVItemType, data, dataLen);
    switch (rst) {
        case NV_OK:
            return AT_OK;
        case NV_ID_NOT_EXIST:
        case NV_BUFFER_TOO_LONG:
            return AT_CME_INCORRECT_PARAMETERS;
        default:
            return AT_ERROR;
    }
}
#endif

TAF_UINT32 At_AsciiNum2HexString(TAF_UINT8 *src, TAF_UINT16 *srcLen)
{
    TAF_UINT16 chkLen     = 0;
    TAF_UINT16 tmp        = 0;
    TAF_UINT8  left       = 0;
    TAF_UINT16 srcLenTemp = *srcLen;
    TAF_UINT8 *dst        = src;

    /* 如果是奇数个半字节则返回错误 */
    if ((srcLenTemp % 2) != 0) {
        return AT_FAILURE;
    }

    while (chkLen < srcLenTemp) {
        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            left = src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            left = (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            left = (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        dst[tmp] = 0xf0 & (left << 4);
        chkLen += 1;

        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            dst[tmp] |= src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        chkLen += 1;
        tmp += 1;
    }

    *srcLen = srcLenTemp / 2; /* 计算字节数 */
    return AT_SUCCESS;
}


LOCAL VOS_UINT32 At_CheckAsciiStringLen(VOS_UINT16 srcLen)
{
    if ((srcLen < AT_ASCII_STR_MIN_LEN) || (srcLen > AT_ASCII_STR_MAX_LEN)) {
        return VOS_ERR;
    }

    return VOS_OK;
}


TAF_UINT32 At_AsciiString2HexText(SI_STK_TextString *textStr, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    TAF_UINT16 chkLen = 0;
    TAF_UINT8  tmp    = 0;
    TAF_UINT8  left   = 0;
    TAF_UINT8 *dst    = textStr->text;

    if (At_CheckAsciiStringLen(srcLen) != VOS_OK) {
        AT_ERR_LOG1("At_AsciiString2HexText: usSrcLen is wrong.", srcLen);
        return AT_FAILURE;
    }

    while (chkLen < srcLen) {
        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            left = src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            left = (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            left = (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        dst[tmp] = 0xf0 & (left << 4);

        chkLen += 1;

        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            dst[tmp] |= src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        chkLen += 1;

        tmp += 1;
    }

    textStr->len = tmp;

    return AT_SUCCESS;
}


TAF_UINT32 At_AsciiString2HexSimple(TAF_UINT8 *textStr, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    TAF_UINT16 chkLen = 0;
    TAF_UINT16 tmp    = 0;
    TAF_UINT8  left   = 0;
    TAF_UINT8 *dst    = textStr;

    if (srcLen == 0) {
        return AT_FAILURE;
    }

    while (chkLen < srcLen) {
        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            left = src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            left = (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            left = (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        dst[tmp] = 0xf0 & (left << 4);

        chkLen += 1;

        if ((src[chkLen] >= '0') && (src[chkLen] <= '9')) { /* the number is 0-9 */
            dst[tmp] |= src[chkLen] - '0';
        } else if ((src[chkLen] >= 'a') && (src[chkLen] <= 'f')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'a') + 0x0a;
        } else if ((src[chkLen] >= 'A') && (src[chkLen] <= 'F')) { /* the number is 0-9 */
            dst[tmp] |= (src[chkLen] - 'A') + 0x0a;
        } else {
            return AT_FAILURE;
        }

        chkLen += 1;

        tmp += 1;
    }

    return AT_SUCCESS;
}

/* Del At_AbortCmdProc */


TAF_UINT32 AT_HexToAsciiString(TAF_UINT8 *dstStr, TAF_UINT32 dstLen, TAF_UINT8 *srcStr, TAF_UINT32 srcLen)
{
    TAF_UINT16 chkLen = 0;
    TAF_UINT8  high   = 0;
    TAF_UINT8  low    = 0;
    TAF_UINT8 *read   = srcStr;
    TAF_UINT8 *write  = dstStr;

    if ((srcStr == VOS_NULL_PTR) || (dstStr == VOS_NULL_PTR) || (srcLen == 0)) {
        return AT_ERROR;
    }

    /* 扫完整个字串 */
    while (chkLen++ < srcLen) {
        high = 0x0F & (*read >> 4);
        low  = 0x0F & *read;

        if (high <= 0x09) {
            /* 0-9 */
            *write++ = high + 0x30;
        } else {
            /* A-F */
            *write++ = high + 0x37;
        }

        if (low <= 0x09) {
            *write++ = low + 0x30;
        } else {
            *write++ = low + 0x37;
        }

        /* 下一个字符 */
        read++;
    }
    *write = '\0';
    return AT_OK;
}


TAF_UINT32 At_AsciiNum2BcdNum(TAF_UINT8 *dst, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    TAF_UINT16 chkLen = 0;
    TAF_UINT8  tmp    = 0;
    TAF_UINT8  bcdCode;

    for (chkLen = 0; chkLen < srcLen; chkLen++) {
        tmp = chkLen % 2; /* 判断高低位 */

        if ((src[chkLen] >= 0x30) && (src[chkLen] <= 0x39)) { /* the number is 0-9 */
            bcdCode = src[chkLen] - 0x30;
        } else if (src[chkLen] == '*') {
            bcdCode = 0x0a;
        } else if (src[chkLen] == '#') {
            bcdCode = 0x0b;
        } else if ((src[chkLen] == 'a') || (src[chkLen] == 'b') || (src[chkLen] == 'c')) {
            bcdCode = (VOS_UINT8)((src[chkLen] - 'a') + 0x0c);
        } else {
            return AT_FAILURE;
        }

        tmp = chkLen % 2; /* 判断高低位 */
        if (tmp == 0) {
            dst[chkLen / 2] = bcdCode; /* 低位 */
        } else {
            dst[chkLen / 2] |= (TAF_UINT8)(bcdCode << 4); /* 高位 */
        }
    }

    if ((srcLen % 2) == 1) { /* 判断高低位 */
        dst[srcLen / 2] |= 0xf0; /* 高位 */
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_AsciiNum2Num(TAF_UINT8 *dst, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    TAF_UINT16 chkLen = 0;

    for (chkLen = 0; chkLen < srcLen; chkLen++) {
        if ((src[chkLen] >= 0x30) && (src[chkLen] <= 0x39)) { /* the number is 0-9 */
            dst[chkLen] = src[chkLen] - 0x30;                 /* 低位 */
        } else {
            return AT_FAILURE;
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_CheckDialString(TAF_UINT8 *data, TAF_UINT16 len)
{
    TAF_UINT16 count = 0;
    TAF_UINT8 *tmp   = data;

    if (*tmp == '+') {
        tmp++;
        count++;
    }

    while (count++ < len) {
        if ((*tmp >= '0') && (*tmp <= '9')) {
        } else if ((*tmp >= 'a') && (*tmp <= 'c')) {
        } else if ((*tmp >= 'A') && (*tmp <= 'C')) {
        } else if ((*tmp == '*') || (*tmp == '#')) {
        } else {
            return AT_FAILURE;
        }
        tmp++;
    }
    return AT_SUCCESS;
}


TAF_UINT32 At_CheckPBString(TAF_UINT8 *data, TAF_UINT16 *len)
{
    TAF_UINT16 count      = 0;
    TAF_UINT8 *tmp        = data;
    TAF_UINT8  invalidNum = 0;
    errno_t    returnValue;

    while (count++ < *len) {
        if ((*tmp == '(') || (*tmp == ')') || (*tmp == '-') || (*tmp == '"')) {
            if (count < *len) {
                returnValue = memmove_s(tmp, (VOS_SIZE_T)(*len - count), tmp + 1, (VOS_SIZE_T)(*len - count));
                TAF_MEM_CHK_RTN_VAL(returnValue, (VOS_SIZE_T)(*len - count), (VOS_SIZE_T)(*len - count));
            }
            invalidNum++;
        } else {
            tmp++;
        }
    }

    count = 0;
    tmp   = data;
    *len -= invalidNum;

    while (count++ < *len) {
        if (!(((*tmp >= '0') && (*tmp <= '9')) || (*tmp == '*') || (*tmp == '#') || (*tmp == '?') || (*tmp == ',') ||
              (*tmp == 'P') || (*tmp == 'p'))) {
            return AT_FAILURE;
        }
        tmp++;
    }
    return AT_SUCCESS;
}

/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_CheckNumLen(TAF_UINT16 max, TAF_UINT16 len)
{
    /* 如果号码过长，直接返回错误 */
    if (g_atCscsType == AT_CSCS_UCS2_CODE) {
        if ((max * AT_BYTE_ALIGNMENT_VALUE) < len) {
            return AT_FAILURE;
        }
    } else {
        if (max < len) {
            return AT_FAILURE;
        }
    }
    return AT_SUCCESS;
}

TAF_UINT32 At_CheckUssdNumLen(VOS_UINT8 indexNum, TAF_SS_DATA_CODING_SCHEME dcs, TAF_UINT16 len)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    if (ssCtx->ussdTransMode == AT_USSD_NON_TRAN_MODE) {
        if (len > TAF_SS_MAX_USSDSTRING_LEN) {
            return AT_FAILURE;
        }
    } else {
        if (len > (TAF_SS_MAX_USS_CHAR * AT_DOUBLE_LENGTH)) { /* USSD字符串，最大长度为160个字符 */
            return AT_FAILURE;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo81CalcLength(const TAF_UINT8 *data, TAF_UINT16 len, TAF_UINT16 *baseCode,
                                            TAF_UINT16 *dstLen)
{
    TAF_UINT16 unicodeChar;
    TAF_UINT16 baseCodeTemp = 0;
    TAF_UINT16 indexNum;
    TAF_BOOL   bIsBaseSet = TAF_FALSE;
    TAF_UINT16 dstLenTemp = 0;
    TAF_UINT8  gsmData[AT_AUC_GSM_DATA_LEN];
    TAF_UINT16 gsmDataLen = 0;

    /* 输入参数赋初值 */
    *dstLen   = 0;
    *baseCode = 0;

    for (indexNum = 0; indexNum < (len >> 1); indexNum++) {
        unicodeChar = (*data << 8) | (*(data + AT_PUC_DATA_OFFSET_1));

        data += AT_DOUBLE_LENGTH;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(unicodeChar, gsmData, sizeof(gsmData), &gsmDataLen) == AT_SUCCESS) {
            dstLenTemp += gsmDataLen;

            continue;
        }

        /* 81编码用第8到第15bit进行编码，即0hhh hhhh hXXX XXXX，因此第16bit为1一定不能进行81编码 */
        if ((unicodeChar & 0x8000) != 0) {
            AT_ERR_LOG("At_UnicodeTransferTo81CalcLength error: no16 bit is 1");

            return AT_FAILURE;
        }

        if (bIsBaseSet == TAF_FALSE) {
            /* 取第一个UCS2的第8到第15bit作为BaseCode，BaseCode右移7位即为基址针 */
            bIsBaseSet   = TAF_TRUE;
            baseCodeTemp = unicodeChar & AT_PB_81_CODE_BASE_POINTER;
        } else {
            if (baseCodeTemp != (unicodeChar & AT_PB_81_CODE_BASE_POINTER)) {
                AT_ERR_LOG("At_UnicodeTransferTo81CalcLength error: code base error");

                return AT_FAILURE;
            }
        }

        dstLenTemp++;
    }

    /* 能进行81编码，返回基本码和81编码总长度 */
    *baseCode = baseCodeTemp;
    *dstLen   = dstLenTemp + AT_PB_81CODE_HEADER_LEN;

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo82CalcLength(const TAF_UINT8 *data, TAF_UINT16 len, TAF_UINT16 *baseCode,
                                            TAF_UINT16 *dstLen)
{
    TAF_UINT16 unicodeChar;
    TAF_UINT16 indexNum;
    TAF_BOOL   bIsBaseSet   = TAF_FALSE;
    TAF_UINT16 us82BaseHigh = 0;
    TAF_UINT16 us82BaseLow  = 0;
    TAF_UINT16 dstLenTemp   = 0;
    TAF_UINT8  gsmData[AT_AUC_GSM_DATA_LEN];
    TAF_UINT16 gsmDataLen = 0;

    /* 输入参数赋初值 */
    *dstLen   = 0;
    *baseCode = 0;

    for (indexNum = 0; indexNum < (len >> 1); indexNum++) {
        unicodeChar = (*data << 8) | (*(data + AT_PUC_DATA_OFFSET_1));

        data += AT_DOUBLE_LENGTH;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(unicodeChar, gsmData, sizeof(gsmData), &gsmDataLen) == AT_SUCCESS) {
            dstLenTemp += gsmDataLen;

            continue;
        }

        if (bIsBaseSet == TAF_FALSE) {
            bIsBaseSet   = TAF_TRUE;
            us82BaseHigh = unicodeChar;
            us82BaseLow  = unicodeChar;
        } else {
            if (unicodeChar < us82BaseLow) {
                us82BaseLow = unicodeChar;
            }

            if (unicodeChar > us82BaseHigh) {
                us82BaseHigh = unicodeChar;
            }

            /* UCS2码流中最大编码和最小编码差值超过127就不能进行82编码 */
            if ((us82BaseHigh - us82BaseLow) > AT_PB_GSM7_CODE_MAX_VALUE) {
                AT_ERR_LOG("At_UnicodeTransferTo82CalcLength error: code base error");

                return AT_FAILURE;
            }
        }

        dstLenTemp++;
    }

    /* 能进行82编码，返回基本码和82编码总长度 */
    *baseCode = us82BaseLow;
    *dstLen   = dstLenTemp + AT_PB_82CODE_HEADER_LEN;

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo81(const TAF_UINT8 *data, TAF_UINT16 len, TAF_UINT16 codeBase, TAF_UINT8 *dest)
{
    errno_t    memResult;
    TAF_UINT16 unicodeChar;
    TAF_UINT16 i;
    TAF_UINT8  gsmData[AT_AUC_GSM_DATA_LEN];
    TAF_UINT16 gsmDataLen = 0;
    TAF_UINT16 dstLen     = AT_PB_81CODE_HEADER_LEN;

    for (i = 0; i < (len >> 1); i++) {
        unicodeChar = (*data << 8) | (*(data + AT_PUC_DATA_OFFSET_1));

        data += AT_DOUBLE_LENGTH;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(unicodeChar, gsmData, sizeof(gsmData), &gsmDataLen) == AT_SUCCESS) {
            if (gsmDataLen > 0) {
                memResult = memcpy_s((dest + dstLen), SI_PB_ALPHATAG_MAX_LEN - dstLen, gsmData, gsmDataLen);
                TAF_MEM_CHK_RTN_VAL(memResult, SI_PB_ALPHATAG_MAX_LEN - dstLen, gsmDataLen);
            }
            dstLen += gsmDataLen;

            continue;
        }

        /* 容错处理 */
        if ((codeBase | (unicodeChar & AT_PB_GSM7_CODE_MAX_VALUE)) == unicodeChar) {
            /* 转为81的编码方式 */
            dest[dstLen] = (TAF_UINT8)(AT_PB_CODE_NO8_BIT | (unicodeChar & AT_PB_GSM7_CODE_MAX_VALUE));
            dstLen++;
        } else {
            AT_ERR_LOG("At_UnicodeTransferTo81 error");

            return AT_FAILURE;
        }
    }

    /* 设置81编码header信息 */
    dest[0] = SI_PB_ALPHATAG_TYPE_UCS2_81;
    dest[1] = (TAF_UINT8)(dstLen - AT_PB_81CODE_HEADER_LEN);
    dest[AT_PUC_DATA_INDEX_2] = (TAF_UINT8)((codeBase & AT_PB_81_CODE_BASE_POINTER) >> 7);

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodeTransferTo82(const TAF_UINT8 *data, TAF_UINT16 len, TAF_UINT16 codeBase, TAF_UINT8 *dest)
{
    errno_t    memResult;
    TAF_UINT16 unicodeChar;
    TAF_UINT16 i;
    TAF_UINT8  gsmData[AT_AUC_GSM_DATA_LEN];
    TAF_UINT16 gsmDataLen = 0;
    TAF_UINT16 dstLen     = AT_PB_82CODE_HEADER_LEN;

    for (i = 0; i < (len >> 1); i++) {
        unicodeChar = (*data << 8) | (*(data + AT_PUC_DATA_OFFSET_1));

        data += AT_DOUBLE_LENGTH;

        /* 反向查找GSM到UCS的基本表和扩展表 */
        if (At_OneUnicodeToGsm(unicodeChar, gsmData, sizeof(gsmData), &gsmDataLen) == AT_SUCCESS) {
            if (gsmDataLen > 0) {
                memResult = memcpy_s(dest + dstLen, SI_PB_ALPHATAG_MAX_LEN - dstLen, gsmData, gsmDataLen);
                TAF_MEM_CHK_RTN_VAL(memResult, SI_PB_ALPHATAG_MAX_LEN - dstLen, gsmDataLen);
            }
            dstLen += gsmDataLen;

            continue;
        }

        /* 容错处理 */
        if ((unicodeChar - codeBase) <= AT_PB_GSM7_CODE_MAX_VALUE) {
            /* 转为82的编码方式 */
            dest[dstLen] = ((TAF_UINT8)(unicodeChar - codeBase)) | AT_PB_CODE_NO8_BIT;
            dstLen++;
        } else {
            AT_ERR_LOG("At_UnicodeTransferTo81 error");

            return AT_FAILURE;
        }
    }

    /* 设置82编码header信息 */
    dest[0] = SI_PB_ALPHATAG_TYPE_UCS2_82;
    dest[1] = (TAF_UINT8)(dstLen - AT_PB_82CODE_HEADER_LEN);
    dest[AT_PUC_DATA_INDEX_2] = (TAF_UINT8)((codeBase & 0xff00) >> 8);
    dest[AT_PUC_DATA_INDEX_3] = (TAF_UINT8)(codeBase & 0x00ff);

    return AT_SUCCESS;
}


TAF_UINT32 At_Gsm7BitFormat(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT8 *dst, TAF_UINT8 *dstLen)
{
    TAF_UINT16 indexNum;

    for (indexNum = 0; indexNum < srcLen; indexNum++) {
        /* GSM模式下输入码流大于0x7f时提示用户输入中含有非法字符 */
        if (src[indexNum] > AT_PB_GSM7_CODE_MAX_VALUE) {
            return AT_FAILURE;
        }

        dst[indexNum] = src[indexNum];
    }

    *dstLen = (TAF_UINT8)srcLen;

    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrint2Unicode(TAF_UINT8 *data, TAF_UINT16 *len)
{
    TAF_UINT8 *check   = data;
    TAF_UINT8 *write   = data;
    TAF_UINT8 *read    = data;
    TAF_UINT16 lenTemp = 0;
    TAF_UINT16 chkLen  = 0;
    TAF_UINT8  high    = 0;
    TAF_UINT8  low     = 0;

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while (chkLen++ < *len) {
        if ((*check >= '0') && (*check <= '9')) {
            *check = *check - '0';
        } else if ((*check >= 'a') && (*check <= 'f')) {
            *check = (*check - 'a') + 10; /* 十六进制格式转换 */
        } else if ((*check >= 'A') && (*check <= 'F')) {
            *check = (*check - 'A') + 10; /* 十六进制格式转换 */
        } else {
            return AT_FAILURE;
        }
        check++;
    }

    while (lenTemp < *len) {
        /* 判断结尾 */
        high = *read++; /* 高位 */
        lenTemp++;
        low = *read++; /* 低位 */
        lenTemp++;

        *write++ = (TAF_UINT8)(high * 16) + low; /* 写入UNICODE的一个字节 */
    }

    *len = lenTemp >> 1;
    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrintToAscii(TAF_UINT8 *data, TAF_UINT16 *len)
{
    TAF_UINT8 *check      = data;
    TAF_UINT8 *write      = data;
    TAF_UINT8 *read       = data;
    TAF_UINT16 lenTemp    = 0;
    TAF_UINT16 chkLen     = 0;
    TAF_UINT8  firstByte  = 0;
    TAF_UINT8  secondByte = 0;
    TAF_UINT8  high       = 0;
    TAF_UINT8  low        = 0;

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while (chkLen++ < *len) {
        if ((*check >= '0') && (*check <= '9')) {
            *check = *check - '0';
        } else if ((*check >= 'a') && (*check <= 'f')) {
            *check = (*check - 'a') + 10; /* 十六进制格式转换 */
        } else if ((*check >= 'A') && (*check <= 'F')) {
            *check = (*check - 'A') + 10; /* 十六进制格式转换 */
        } else {
            return AT_FAILURE;
        }
        check++;
    }

    while (lenTemp < *len) {
        /* 判断结尾 */
        firstByte = *read++; /* 前两位必须为0 */
        lenTemp++;
        secondByte = *read++;
        lenTemp++;

        if ((firstByte != 0) || (secondByte != 0)) {
            return AT_FAILURE;
        }

        high = *read++; /* 高位 */
        lenTemp++;
        low = *read++; /* 低位 */
        lenTemp++;

        *write++ = (TAF_UINT8)(high * 16) + low; /* 写入Unicode的一个字节 */
    }

    *len = lenTemp >> 2;
    return AT_SUCCESS;
}


TAF_UINT32 At_UnicodePrint2Ascii(TAF_UINT8 *dst, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    TAF_UINT8 *write = dst;
    TAF_UINT8 *read  = src;
    TAF_UINT8  tmp[AT_AUC_TMP_LEN];
    TAF_UINT16 chkLen   = 0;
    TAF_UINT8  indexNum = 0;

    /* 每4个字符可以转成一个ASCII码 */
    if ((srcLen % 4) != 0) {
        return AT_FAILURE;
    }

    /* 清空临时缓存 */
    (VOS_VOID)memset_s(tmp, sizeof(tmp), 0x00, AT_AUC_TMP_LEN);

    /* 字符均为'0'-'9','a'-'f','A'-'F' */
    while (chkLen++ < srcLen) {
        if ((*read >= '0') && (*read <= '9')) {
            tmp[indexNum] = *read - '0';
            indexNum++;
        } else if ((*read >= 'a') && (*read <= 'f')) {
            tmp[indexNum] = (*read - 'a') + 10; /* 十六进制格式转换 */
            indexNum++;
        } else if ((*read >= 'A') && (*read <= 'F')) {
            tmp[indexNum] = (*read - 'A') + 10; /* 十六进制格式转换 */
            indexNum++;
        } else {
            return AT_FAILURE;
        }

        /* 每四个字符得出一个字符 */
        if (indexNum == 4) {
            /* 必须是数字类型 */
            if ((tmp[0] != 0) || (tmp[1] != 0)) {
                return AT_FAILURE;
            }

            *write++ = (TAF_UINT8)(tmp[AT_AUC_TMP_INDEX_2] * 16) + tmp[AT_AUC_TMP_INDEX_3]; /* 写入一个字节 */
            if (At_CheckDialNum(*(write - 1)) == AT_FAILURE) {
                return AT_FAILURE;
            }
            /* 重新开始 */
            indexNum = 0;
        }

        /* 下一个字符 */
        read++;
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_CheckNameUCS2Code(TAF_UINT8 *data, TAF_UINT16 *len)
{
    TAF_UINT8  alphType = *data;
    TAF_UINT16 alphLen  = *(data + 1);

    if ((alphType == SI_PB_ALPHATAG_TYPE_UCS2_80) && (((*len - 1) % 2) == 0)) {
        /* 80编码，除了标记字节其余长度必须为偶数字节 */
        return AT_SUCCESS;
    }

    /* 3表示81编码格式中81标记字节，表示整个字符串字符个数，以及基址所占字节数，其中一个字节为基址 */
    if ((alphType == SI_PB_ALPHATAG_TYPE_UCS2_81) && (*len >= (alphLen + 3))) {
        /* 81编码，实际字符长度必须大于码流中长度字节的值 */
        *len = alphLen + 3;
        return AT_SUCCESS;
    }

    /* 4表示82编码格式中82标记字节，表示整个字符串字符个数，以及基址所占字节数，其中两个字节为基址 */
    if ((alphType == SI_PB_ALPHATAG_TYPE_UCS2_82) && (*len >= (alphLen + 4))) {
        /* 82编码，同上，区别是基址是2个字节 */
        *len = alphLen + 4;
        return AT_SUCCESS;
    }

    return AT_FAILURE;
}


VOS_VOID AT_PhSendRestoreFactParm(VOS_VOID)
{
    VOS_UINT16 length;
    VOS_UINT32 i;

    for (i = 0; i < AT_MAX_CLIENT_NUM; i++) {
        if (g_atClientTab[i].userType == AT_APP_USER) {
            break;
        }
    }

    /* 未找到E5 User,则不用上报 */
    if (i >= AT_MAX_CLIENT_NUM) {
        return;
    }

    length = 0;
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "^FACTORY");
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);

    At_SendResultData((VOS_UINT8)i, g_atSndCodeAddress, length);
}


VOS_VOID AT_PhSendRestoreFactParmNoReset(VOS_VOID)
{
    VOS_UINT16 length;
    VOS_UINT32 i;

    for (i = 0; i < AT_MAX_CLIENT_NUM; i++) {
        if (g_atClientTab[i].userType == AT_APP_USER) {
            break;
        }
    }

    /* 未找到E5 User,则不用上报 */
    if (i >= AT_MAX_CLIENT_NUM) {
        return;
    }

    length = 0;
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "^NORSTFACT");
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);

    At_SendResultData((VOS_UINT8)i, g_atSndCodeAddress, length);
}

/*
 * Description: 设置UNICODE或者ASCII类型的号码
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetNumTypePara(TAF_UINT8 *dst, TAF_UINT32 dstLen, TAF_UINT8 *src, TAF_UINT16 srcLen)
{
    errno_t    memResult;
    TAF_UINT32 ret;
    TAF_UINT16 asciiStrLen;

    if (g_atCscsType == AT_CSCS_UCS2_CODE) {
        ret = At_UnicodePrint2Ascii(dst, src, srcLen);
        if (ret != AT_SUCCESS) {
            return ret;
        }
    } else {
        memResult = memcpy_s(dst, dstLen, src, srcLen);
        TAF_MEM_CHK_RTN_VAL(memResult, dstLen, srcLen);
    }

    asciiStrLen = (TAF_UINT16)VOS_StrLen((TAF_CHAR *)dst);
    if (At_CheckDialString(dst, asciiStrLen) == AT_SUCCESS) {
        return AT_SUCCESS;
    } else {
        return AT_FAILURE;
    }
}


TAF_UINT32 At_UpdateMsgRcvAct(TAF_UINT8 indexNum, AT_CSMS_MsgVersionUint8 csmsVersion, AT_CNMI_MT_TYPE cnmiMtType,
                              AT_CNMI_DS_TYPE cnmiDsType)
{
    MN_MSG_SetRcvmsgPathParm rcvPath;
    MN_MSG_RcvmsgActUint8    rcvSmAct[AT_CNMI_MT_TYPE_MAX] = {
        MN_MSG_RCVMSG_ACT_STORE,
        MN_MSG_RCVMSG_ACT_STORE,
        MN_MSG_RCVMSG_ACT_TRANSFER_AND_ACK,
        MN_MSG_RCVMSG_ACT_STORE
    };
    MN_MSG_RcvmsgActUint8 rcvStaRptAct[AT_CNMI_DS_TYPE_MAX] = {
        MN_MSG_RCVMSG_ACT_STORE,
        MN_MSG_RCVMSG_ACT_TRANSFER_AND_ACK,
        MN_MSG_RCVMSG_ACT_STORE
    };

    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;
    errno_t         memResult;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&rcvPath, sizeof(rcvPath), 0x00, sizeof(MN_MSG_SetRcvmsgPathParm));

    if ((cnmiMtType >= AT_CNMI_MT_TYPE_MAX) || (cnmiDsType >= AT_CNMI_DS_TYPE_MAX)) {
        return AT_ERROR;
    }

    memResult = memcpy_s(&rcvPath, sizeof(rcvPath), &(smsCtx->cpmsInfo.rcvPath), sizeof(rcvPath));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(rcvPath), sizeof(rcvPath));
    if (csmsVersion == AT_CSMS_MSG_VERSION_PHASE2_PLUS) {
        rcvSmAct[AT_MN_MSG_RCVMSG_ACT_TRANSFER]     = MN_MSG_RCVMSG_ACT_TRANSFER_ONLY;
        rcvStaRptAct[1] = MN_MSG_RCVMSG_ACT_TRANSFER_ONLY;
    }

    rcvPath.rcvSmAct       = rcvSmAct[cnmiMtType];
    rcvPath.rcvStaRptAct   = rcvStaRptAct[cnmiDsType];
    rcvPath.smsServVersion = csmsVersion;

    (VOS_VOID)memset_s(rcvPath.reserve1, sizeof(rcvPath.reserve1), 0x00, sizeof(rcvPath.reserve1));

    /* 将CNMI设置的MT type类型传输给TAF,在<MT>=3，收到CLASS3短信时候，按照CMT方式上报 */
    rcvPath.cnmiMtType = cnmiMtType;

    if (MN_MSG_SetRcvMsgPath(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &rcvPath) !=
        MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    return AT_OK;
}

#if (FEATURE_RSTRIGGER_SMS == FEATURE_ON)

VOS_UINT32 AT_ReadActiveMessage(ModemIdUint16 modemId, MN_MSG_ActiveMessage *activeMessage)
{
    errno_t    memResult;
    VOS_UINT32 ret;
    VOS_UINT8 *activeMessageInfo = VOS_NULL_PTR;
    VOS_UINT8 *evaluate          = VOS_NULL_PTR;

    activeMessageInfo = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, MN_MSG_ACTIVE_MESSAGE_PARA_LEN);
    if (activeMessageInfo == VOS_NULL_PTR) {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to alloc memory . ");
        return MN_ERR_NOMEM;
    }

    (VOS_VOID)memset_s(activeMessageInfo, MN_MSG_ACTIVE_MESSAGE_PARA_LEN, 0x00, MN_MSG_ACTIVE_MESSAGE_PARA_LEN);

    ret = TAF_ACORE_NV_READ(modemId, NV_ITEM_SMS_ACTIVE_MESSAGE_PARA, activeMessageInfo,
                            MN_MSG_ACTIVE_MESSAGE_PARA_LEN);
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to read NVIM . ");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, activeMessageInfo); /*lint !e830*/
        /*lint -restore */
        return MN_ERR_CLASS_SMS_NVIM;
    }

    evaluate = activeMessageInfo;

    activeMessage->activeStatus = *evaluate;
    evaluate++;

    activeMessage->msgCoding = *evaluate;
    evaluate++;

    activeMessage->url.len = *evaluate;
    evaluate++;
    activeMessage->url.len |= (VOS_UINT32)(*evaluate) << 8;
    evaluate++;
    activeMessage->url.len |= (VOS_UINT32)(*evaluate) << 16;
    evaluate++;
    activeMessage->url.len |= (VOS_UINT32)(*evaluate) << 24;
    evaluate++;

    if (activeMessage->url.len > MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN) {
        AT_WARN_LOG("AT_ReadActiveMessage : fail to read NVIM . ");
        activeMessage->url.len = MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN;
    }

    if ((activeMessage->url.len > 0) && (activeMessage->url.len <= sizeof(activeMessage->url.url))){
        memResult = memcpy_s(activeMessage->url.url, sizeof(activeMessage->url.url), evaluate,
                             activeMessage->url.len);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(activeMessage->url.url), activeMessage->url.len);
    }

    PS_MEM_FREE(WUEPS_PID_AT, activeMessageInfo);
    activeMessageInfo = VOS_NULL_PTR;
    return MN_ERR_NO_ERROR;
}
#endif


VOS_UINT32 At_ProcAppReqUssdStr_Nontrans(TAF_SS_UssdString *ussdStr, TAF_SS_DATA_CODING_SCHEME datacodingScheme)
{
    TAF_UINT8        ussdStrInfo[TAF_SS_MAX_USSDSTRING_LEN * 2];
    MN_MSG_CbdcsCode dcsInfo;
    VOS_UINT32       asciiStrLen;
    VOS_UINT32       ret;

    (VOS_VOID)memset_s(ussdStrInfo, sizeof(ussdStrInfo), 0, sizeof(ussdStrInfo));
    (VOS_VOID)memset_s(&dcsInfo, sizeof(dcsInfo), 0, sizeof(dcsInfo));

    /* USSD与CBS的DCS的协议相同，调用CBS的DCS解析函数解码，详细情况参考23038 */
    ret = MN_MSG_DecodeCbsDcs(datacodingScheme, ussdStr->ussdStr, ussdStr->cnt, &dcsInfo);

    if (ret != MN_ERR_NO_ERROR) {
        AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans:WARNING: Decode Failure");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (dcsInfo.msgCoding == MN_MSG_MSG_CODING_UCS2) {
        /* 先进行DCS:UCS2的处理 */
        ret = At_UnicodePrint2Unicode(ussdStr->ussdStr, &(ussdStr->cnt));

        if (ret != AT_SUCCESS) {
            AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans: convert Unicode fail");
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        /* 7Bit8Bit在非透传模式下先做CSCS的处理 */
        if (g_atCscsType == AT_CSCS_UCS2_CODE) {
            ret = At_UnicodePrintToAscii(ussdStr->ussdStr, &(ussdStr->cnt));

            if (ret != AT_SUCCESS) {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : CSCS Proc failed");
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        /* 再将7Bit做压缩编码处理 */
        if (dcsInfo.msgCoding == MN_MSG_MSG_CODING_7_BIT) {
            asciiStrLen = 0;
            /* TAF_SS_MAX_USSDSTRING_LEN * 2 为数组ussdStrInfo的最大长度 */
            ret         = TAF_STD_ConvertAsciiToDefAlpha(ussdStr->ussdStr, ussdStr->cnt, ussdStrInfo, &asciiStrLen,
                                                         TAF_SS_MAX_USSDSTRING_LEN * 2);
            ussdStr->cnt = (VOS_UINT16)asciiStrLen;
            if (ret != MN_ERR_NO_ERROR) {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : Conv7Bit Def Err");
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 清除原码流残余信息 */
            /* TAF_SS_MAX_USSDSTRING_LEN * 2 为数组ussdStrInfo的最大长度 */
            (VOS_VOID)memset_s(ussdStr->ussdStr, TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8), 0,
                TAF_SS_MAX_USSDSTRING_LEN * 2 * sizeof(TAF_UINT8));

            ret = TAF_STD_Pack7Bit(ussdStrInfo, ussdStr->cnt, 0, ussdStr->ussdStr, &asciiStrLen);
            ussdStr->cnt = (VOS_UINT16)asciiStrLen;
            if (ret != MN_ERR_NO_ERROR) {
                AT_WARN_LOG("At_ProcAppReqUssdStr_Nontrans : Conv7Bit pack Err");
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_CheckCgtftParaNum(VOS_UINT8 paraIndex)
{
    if (AT_IsSupportReleaseRst(AT_ACCESS_STRATUM_REL11)) {
        if (paraIndex > AT_SET_CGTFT_PARA_MAX_NUMBER) {
            return AT_FAILURE;
        }
    } else {
        if (paraIndex > AT_SET_CGTFT_PARA_MAX_NUMBER - 1) {
            return AT_FAILURE;
        }
    }

    return AT_SUCCESS;
}


VOS_VOID AT_SetTftPfIdPara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_PACKET_FILTER_ID].paraLen != 0) {
        tftInfo->opPktFilterId  = 1;
        tftInfo->packetFilterId = (VOS_UINT8)g_atParaList[AT_CGTFT_PACKET_FILTER_ID].paraValue;
    }

    return;
}


VOS_VOID AT_SetTftPrecedencePara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_PRECEDENCE].paraLen != 0) {
        tftInfo->opPrecedence = 1;
        tftInfo->precedence   = (VOS_UINT8)g_atParaList[AT_CGTFT_PRECEDENCE].paraValue;
    }

    return;
}


VOS_VOID AT_SetTftProtocolIdPara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_PROTOCOL_ID].paraLen != 0) {
        tftInfo->opProtocolId = 1;
        tftInfo->protocolId   = (VOS_UINT8)g_atParaList[AT_CGTFT_PROTOCOL_ID].paraValue;
    }

    return;
}


VOS_VOID AT_SetTftDirectionPara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_DIRECTION].paraLen != 0) {
        tftInfo->opDirection = 1;
        tftInfo->direction   = (VOS_UINT8)g_atParaList[AT_CGTFT_DIRECTION].paraValue;
    }

    return;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_VOID AT_SetTftQriPara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_QRI].paraLen != 0) {
        tftInfo->opQri = 1;
        tftInfo->qri   = (VOS_UINT8)g_atParaList[AT_CGTFT_QRI].paraValue;
    }

    return;
}
#endif


VOS_VOID AT_SetTftFlowLablePara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_FLOW_LABLE].paraLen != 0) {
        tftInfo->opFlowLable = 1;
        tftInfo->flowLable   = g_atParaList[AT_CGTFT_FLOW_LABLE].paraValue;
    }

    return;
}


TAF_UINT32 AT_SetTftSecuPara(TAF_TFT_Ext *tftInfo)
{
    if (g_atParaList[AT_CGTFT_SECU_PARA_INDEX].paraLen != 0) {
        tftInfo->opSpi = 1;
        /* 需要增加判断大小 */
        if (g_atParaList[AT_CGTFT_SECU_PARA_INDEX].paraLen > 8) { /* 大于FFFFFFFF */
            return AT_FAILURE;
        }

        if (At_String2Hex(g_atParaList[AT_CGTFT_SECU_PARA_INDEX].para, g_atParaList[AT_CGTFT_SECU_PARA_INDEX].paraLen,
                          &g_atParaList[AT_CGTFT_SECU_PARA_INDEX].paraValue) == AT_FAILURE) {
            return AT_FAILURE;
        }
        tftInfo->secuParaIndex = g_atParaList[AT_CGTFT_SECU_PARA_INDEX].paraValue;
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetTftTosPara(TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 low   = 0;
    VOS_UINT32 high  = 0;
    VOS_UINT32 count = 0;

    if (g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].paraLen != 0) {
        count = AT_CountDigit(g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].para,
                              g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].paraLen, '.', 1);
        if ((count == 0) || (g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].para[count] == 0)) {
            return AT_FAILURE;
        }

        tftInfo->opTosMask = 1;

        if (atAuc2ul(g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].para, (VOS_UINT16)(count - 1), &low) == AT_FAILURE) {
            return AT_FAILURE;
        }
        if (atAuc2ul(&g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].para[count],
                     (VOS_UINT16)(g_atParaList[AT_CGTFT_TYPE_OF_SERVICE].paraLen - count), &high) == AT_FAILURE) {
            return AT_FAILURE;
        }

        if ((low > AT_TYPE_OF_SERVICE_MAX_VALUE_RANGE) || (high > AT_TYPE_OF_SERVICE_MASK_MAX_VALUE_RANGE)) {
            return AT_FAILURE;
        } else {
            tftInfo->typeOfServiceMask = (VOS_UINT8)high;
            tftInfo->typeOfService     = (VOS_UINT8)low;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetDestPortRangePara(TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 low   = 0;
    VOS_UINT32 high  = 0;
    VOS_UINT32 count = 0;

    if (g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].paraLen != 0) {
        count = AT_CountDigit(g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].para,
                              g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].paraLen, '.', 1);
        if ((count == 0) || (g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].para[count] == 0)) {
            return AT_FAILURE;
        }

        tftInfo->opDestPortRange = 1;

        if (atAuc2ul(g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].para, (VOS_UINT16)(count - 1), &low) == AT_FAILURE) {
            return AT_FAILURE;
        }
        if (atAuc2ul(&g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].para[count],
                     (VOS_UINT16)(g_atParaList[AT_CGTFT_DESTINATION_PORT_RANGE].paraLen - count),
                     &high) == AT_FAILURE) {
            return AT_FAILURE;
        }

        if ((low > AT_LOW_DEST_PORT_MAX_VALUE_RANGE) || (high > AT_HIGH_DEST_PORT_MAX_VALUE_RANGE) || (low > high)) {
            return AT_FAILURE;
        } else {
            tftInfo->highDestPort = (VOS_UINT16)high;
            tftInfo->lowDestPort  = (VOS_UINT16)low;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 AT_SetSrcPortRangePara(TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 low   = 0;
    VOS_UINT32 high  = 0;
    VOS_UINT32 count = 0;

    if (g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].paraLen != 0) {
        count = AT_CountDigit(g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].para,
                              g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].paraLen, '.', 1);
        if ((count == 0) || (g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].para[count] == 0)) {
            return AT_FAILURE;
        }

        tftInfo->opSrcPortRange = 1;

        if (atAuc2ul(g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].para, (VOS_UINT16)(count - 1), &low) == AT_FAILURE) {
            return AT_FAILURE;
        }
        if (atAuc2ul(&g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].para[count],
                     (VOS_UINT16)(g_atParaList[AT_CGTFT_SOURCE_PORT_RANGE].paraLen - count), &high) == AT_FAILURE) {
            return AT_FAILURE;
        }
        if ((low > AT_LOW_SOURCE_PORT_MAX_VALUE_RANGE) || (high > AT_HIGH_SOURCE_PORT_MAX_VALUE_RANGE) || (low > high)) {
            return AT_FAILURE;
        } else {
            tftInfo->highSourcePort = (VOS_UINT16)high;
            tftInfo->lowSourcePort  = (VOS_UINT16)low;
        }
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_ConvUssdStrInCmd(TAF_SS_UssdString *ussdStr, TAF_SS_DATA_CODING_SCHEME datacodingScheme,
                               VOS_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;
    VOS_UINT32     ret;
    errno_t        memResult;

    if ((g_atParaList[AT_USSD_STRING_CNT].paraLen > 0) &&
        (g_atParaList[AT_USSD_STRING_CNT].paraLen <= sizeof(ussdStr->ussdStr))) {
        memResult = memcpy_s(ussdStr->ussdStr, sizeof(ussdStr->ussdStr), g_atParaList[AT_USSD_STRING_CNT].para,
                             g_atParaList[AT_USSD_STRING_CNT].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(ussdStr->ussdStr), g_atParaList[AT_USSD_STRING_CNT].paraLen);
    }
    ussdStr->cnt = g_atParaList[AT_USSD_STRING_CNT].paraLen;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    if (ssCtx->ussdTransMode == AT_USSD_NON_TRAN_MODE) {
        /* 非透传模式处理下发请求 */
        ret = At_ProcAppReqUssdStr_Nontrans(ussdStr, datacodingScheme);
    } else {
        /* 透传模式 */
        ret = At_AsciiNum2HexString(ussdStr->ussdStr, &(ussdStr->cnt));
    }

    if (ret != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}

#if (FEATURE_RSTRIGGER_SMS == FEATURE_ON)

TAF_UINT32 AT_SetRstriggerPara(TAF_UINT8 indexNum)
{
    MN_MSG_ActiveMessage activeMessage;
    MN_MSG_ActiveMessage orgActiveMessage;
    TAF_UINT32           ret;
    ModemIdUint16        modemId;
    VOS_UINT32           rslt;
    errno_t              memResult;

    modemId = MODEM_ID_0;

    /*
     * 参数检查 ：
     * 个数为0返回AT_CME_INCORRECT_PARAMETERS
     * 个数为2返回AT_TOO_MANY_PARA
     */
    if (g_atParaIndex > AT_RSTRIGGER_MAX_PARA_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_GetModemIdFromClient(indexNum, &modemId);

    if (rslt != VOS_OK) {
        AT_ERR_LOG("AT_SetRstriggerPara: Get modem id fail.");
        return AT_ERROR;
    }

    ret = AT_ReadActiveMessage(modemId, &orgActiveMessage);
    if (ret != MN_ERR_NO_ERROR) {
        AT_LOG1("AT_SetRstriggerPara: fail to get active message information , cause is %d", ret);
        return AT_ERROR;
    }

    /* URL:用户没有设置URL,则保持NVIM中的URL不变;否则，用户设置的URL覆盖NVIM的数据 */
    if (g_atParaIndex == AT_RSTRIGGER_MAX_PARA_NUM) {
        if (g_atParaList[1].paraLen > MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN) {
            activeMessage.url.len = MN_MSG_ACTIVE_MESSAGE_MAX_URL_LEN;
        } else {
            activeMessage.url.len = g_atParaList[1].paraLen;
        }
        if ((VOS_UINT16)activeMessage.url.len > 0) {
            memResult = memcpy_s(activeMessage.url.url, sizeof(activeMessage.url.url), g_atParaList[1].para,
                                 (VOS_UINT16)activeMessage.url.len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(activeMessage.url.url), (VOS_UINT16)activeMessage.url.len);
        }

        activeMessage.msgCoding = MN_MSG_MSG_CODING_8_BIT;
    } else {
        memResult = memcpy_s(&activeMessage.url, sizeof(activeMessage.url), &orgActiveMessage.url,
                             sizeof(activeMessage.url));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(activeMessage.url), sizeof(activeMessage.url));
        activeMessage.msgCoding = orgActiveMessage.msgCoding;
    }

    /* ACTIVE STATUS: */
    activeMessage.activeStatus = (MN_MSG_ActiveMessageStatusUint8)g_atParaList[0].paraValue;

    /* 调用AT_WriteActiveMessage写激活短信的激活状态和URL信息到NVIM； */
    ret = AT_WriteActiveMessage(modemId, &orgActiveMessage, &activeMessage);
    if (ret != MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    return AT_OK;
}
#endif


TAF_UINT32 At_SetCsmsPara(TAF_UINT8 indexNum)
{
    VOS_UINT32      ret;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查: 此处相对于旧代码有修改，待确认 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    g_atClientTab[indexNum].opId = At_GetOpId();
    ret = At_UpdateMsgRcvAct(indexNum, (AT_CSMS_MsgVersionUint8)g_atParaList[0].paraValue, smsCtx->cnmiType.cnmiMtType,
                             smsCtx->cnmiType.cnmiDsType);

    if (ret != AT_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSMS_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}

TAF_UINT32 At_SetCgsmsPara(TAF_UINT8 indexNum)
{
    MN_MSG_SmsSendDomainType sendDomain;
    TAF_UINT32               ret;
    MN_OPERATION_ID_T        opId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        g_atParaList[0].paraValue = MN_MSG_SEND_DOMAIN_CS;
    }

    opId = At_GetOpId();
    (VOS_VOID)memset_s(&sendDomain, sizeof(MN_MSG_SmsSendDomainType), 0x00, sizeof(MN_MSG_SmsSendDomainType));
    sendDomain.smsSendDomain = (MN_MSG_SendDomainUint8)g_atParaList[0].paraValue;

    ret = MN_MSG_SetSmsSendDomain(g_atClientTab[indexNum].clientId, opId, &sendDomain);
    if (ret != MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].opId          = opId;
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGSMS_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_GetSmsStorage(VOS_UINT8 indexNum, MN_MSG_MemStoreUint8 memReadorDelete,
                            MN_MSG_MemStoreUint8 memSendorWrite, MN_MSG_MemStoreUint8 memRcv)
{
    MN_MSG_GetStorageStatusParm memParm;

    (VOS_VOID)memset_s(&memParm, sizeof(MN_MSG_GetStorageStatusParm), 0x00, sizeof(MN_MSG_GetStorageStatusParm));

    if ((memReadorDelete == MN_MSG_MEM_STORE_SIM) || (memSendorWrite == MN_MSG_MEM_STORE_SIM) ||
        (memRcv == MN_MSG_MEM_STORE_SIM)) {
        memParm.mem1Store                                          = MN_MSG_MEM_STORE_SIM;
        g_atClientTab[indexNum].atSmsData.waitForUsimStorageStatus = VOS_TRUE;
    } else {
        memParm.mem1Store                                          = MN_MSG_MEM_STORE_NONE;
        g_atClientTab[indexNum].atSmsData.waitForUsimStorageStatus = VOS_FALSE;
    }
#if (NAS_FEATURE_SMS_FLASH_SMSEXIST == FEATURE_ON)
    if ((memReadorDelete == MN_MSG_MEM_STORE_ME) || (memSendorWrite == MN_MSG_MEM_STORE_ME) ||
        (memRcv == MN_MSG_MEM_STORE_ME)) {
        memParm.mem2Store                                        = MN_MSG_MEM_STORE_ME;
        g_atClientTab[indexNum].atSmsData.waitForNvStorageStatus = VOS_TRUE;
    } else {
        memParm.mem2Store                                        = MN_MSG_MEM_STORE_NONE;
        g_atClientTab[indexNum].atSmsData.waitForNvStorageStatus = VOS_FALSE;
    }
#else
    memParm.mem2Store                                        = MN_MSG_MEM_STORE_NONE;
    g_atClientTab[indexNum].atSmsData.waitForNvStorageStatus = VOS_FALSE;
#endif

    if (MN_MSG_GetStorageStatus(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &memParm) !=
        MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetCpmsPara(TAF_UINT8 indexNum)
{
    MN_MSG_SetRcvmsgPathParm rcvPath;
    AT_ModemSmsCtx          *smsCtx = VOS_NULL_PTR;
    errno_t                  memResult;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&rcvPath, sizeof(rcvPath), 0x00, sizeof(MN_MSG_SetRcvmsgPathParm));
    /* 参数检查 */
    if ((g_atParaIndex > AT_CPMS_MAX_PARA_NUM) || (g_atParaIndex == 0) ||
        (g_atParaList[AT_CPMS_MEM_READOR_DELETE].paraLen == 0)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    smsCtx->cpmsInfo.tmpMemReadorDelete = (MN_MSG_MemStoreUint8)(g_atParaList[AT_CPMS_MEM_READOR_DELETE].paraValue + 1);

    if (g_atParaList[AT_CPMS_MEM_SENDOR_WRITE].paraLen != 0) {
        smsCtx->cpmsInfo.tmpMemSendorWrite =
            (MN_MSG_MemStoreUint8 )(g_atParaList[AT_CPMS_MEM_SENDOR_WRITE].paraValue + 1);
    } else {
        smsCtx->cpmsInfo.tmpMemSendorWrite = smsCtx->cpmsInfo.memSendorWrite;
    }

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    memResult                    = memcpy_s(&rcvPath, sizeof(rcvPath), &(smsCtx->cpmsInfo.rcvPath), sizeof(rcvPath));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(rcvPath), sizeof(rcvPath));

    /* 将CNMI设置的MT type类型传输给TAF,在<MT>=3，收到CLASS3短信时候，按照CMT方式上报 */
    rcvPath.cnmiMtType = smsCtx->cnmiType.cnmiMtType;

    if (g_atParaList[AT_CPMS_MEM_STORE].paraLen != 0) {
        rcvPath.staRptMemStore = (MN_MSG_MemStoreUint8 )(g_atParaList[AT_CPMS_MEM_STORE].paraValue + 1);
        rcvPath.smMemStore     = (MN_MSG_MemStoreUint8 )(g_atParaList[AT_CPMS_MEM_STORE].paraValue + 1);
    }

    if ((smsCtx->cpmsInfo.tmpMemReadorDelete == MN_MSG_MEM_STORE_ME) ||
        (smsCtx->cpmsInfo.tmpMemSendorWrite == MN_MSG_MEM_STORE_ME) || (rcvPath.smMemStore == MN_MSG_MEM_STORE_ME)) {
#if (NAS_FEATURE_SMS_FLASH_SMSEXIST != FEATURE_ON)
        return AT_ERROR;
#else
        if (smsCtx->msgMeStorageStatus != MN_MSG_ME_STORAGE_ENABLE) {
            return AT_ERROR;
        }
#endif
    }

    if (MN_MSG_SetRcvMsgPath(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &rcvPath) !=
        MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].atSmsData.waitForCpmsSetRsp = TAF_TRUE;

    if (At_GetSmsStorage(indexNum, smsCtx->cpmsInfo.tmpMemReadorDelete, smsCtx->cpmsInfo.tmpMemSendorWrite,
                         rcvPath.smMemStore) != AT_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPMS_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


TAF_UINT32 At_SetCmgfPara(TAF_UINT8 indexNum)
{
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (((g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) &&
         (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA)) ||
        (g_atParaIndex > 1)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数为空 */
    if (g_atParaList[AT_CMGF_MSG_FORMAT].paraLen == 0) {
        g_atParaList[AT_CMGF_MSG_FORMAT].paraValue = AT_CMGF_MSG_FORMAT_PDU;
    }

    smsCtx->cmgfMsgFormat = (AT_CmgfMsgFormatUint8)g_atParaList[AT_CMGF_MSG_FORMAT].paraValue;
    return AT_OK;
}


TAF_UINT32 At_SetCscaPara(TAF_UINT8 indexNum)
{
    errno_t                  memResult;
    TAF_UINT8                asciiNum[MN_MAX_ASCII_ADDRESS_NUM + 2]; /* array  of ASCII Num */
    TAF_UINT8                scaType;
    TAF_UINT32               ret;
    MN_MSG_WriteSrvParameter servParm;
    /* 指向实际号码（不包括+号）的指针 */
    TAF_UINT8        *num = VOS_NULL_PTR;
    MN_MSG_SrvParam   parmInUsim;
    MN_OPERATION_ID_T opId   = At_GetOpId();
    AT_ModemSmsCtx   *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&servParm, sizeof(servParm), 0x00, sizeof(MN_MSG_WriteSrvParameter));
    (VOS_VOID)memset_s(&parmInUsim, sizeof(parmInUsim), 0x00, sizeof(MN_MSG_SrvParam));

    /* 参数检查 */
    if ((g_atParaList[AT_CSCA_PARA_SCA].paraLen == 0) || (g_atParaIndex > AT_CSCA_PARA_NUM)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 如果<sca>号码过长，直接返回错误 */
    if (At_CheckNumLen((MN_MAX_ASCII_ADDRESS_NUM + 1), g_atParaList[AT_CSCA_PARA_SCA].paraLen) == AT_FAILURE) {
        return AT_ERROR;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(asciiNum, sizeof(asciiNum), 0x00, sizeof(asciiNum));
    /* 设置<sca> , 将UCS2码转换成ASCII码 */
    ret = At_SetNumTypePara(asciiNum, sizeof(asciiNum), g_atParaList[AT_CSCA_PARA_SCA].para,
                            g_atParaList[AT_CSCA_PARA_SCA].paraLen);
    if (ret != AT_SUCCESS) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    scaType = (TAF_UINT8)At_GetCodeType(asciiNum[0]);
    if (scaType == AT_MSG_INTERNAL_ISDN_ADDR_TYPE) {
        num = &asciiNum[1];
    } else {
        num = asciiNum;
    }

    /* 设置<tosca> */
    if (g_atParaList[AT_CSCA_PARA_TOSCA].paraLen != 0) {
        if (scaType == AT_MSG_INTERNAL_ISDN_ADDR_TYPE) {
            if (scaType != ((TAF_UINT8)g_atParaList[AT_CSCA_PARA_TOSCA].paraValue)) {
                return AT_CMS_OPERATION_NOT_ALLOWED;
            }
        } else {
            scaType = (TAF_UINT8)g_atParaList[AT_CSCA_PARA_TOSCA].paraValue;
        }
    }

    /* 执行命令操作 */
    memResult = memcpy_s(&parmInUsim, sizeof(parmInUsim), &(smsCtx->cscaCsmpInfo.parmInUsim), sizeof(parmInUsim));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(parmInUsim), sizeof(parmInUsim));

    parmInUsim.parmInd &= ~MN_MSG_SRV_PARM_MASK_SC_ADDR;
    parmInUsim.scAddr.addrType = scaType;
    ret = AT_AsciiNumberToBcd((TAF_CHAR *)num, parmInUsim.scAddr.bcdNum, &parmInUsim.scAddr.bcdLen);
    if (ret != MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }
    servParm.memStore  = MN_MSG_MEM_STORE_SIM;
    servParm.writeMode = MN_MSG_WRITE_MODE_REPLACE;

    servParm.index = (VOS_UINT32)smsCtx->cscaCsmpInfo.defaultSmspIndex;

    memResult = memcpy_s(&servParm.srvParm, sizeof(servParm.srvParm), &parmInUsim, sizeof(servParm.srvParm));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(servParm.srvParm), sizeof(servParm.srvParm));
    g_atClientTab[indexNum].opId = opId;
    if (MN_MSG_WriteSrvParam(g_atClientTab[indexNum].clientId, opId, &servParm) == MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSCA_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCsmpPara(TAF_UINT8 indexNum)
{
    errno_t                  memResult;
    MN_MSG_WriteSrvParameter servParm;
    MN_MSG_SrvParam          parmInUsim;
    TAF_UINT32               ret;
    AT_ModemSmsCtx          *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&servParm, sizeof(servParm), 0x00, sizeof(MN_MSG_WriteSrvParameter));
    (VOS_VOID)memset_s(&parmInUsim, sizeof(parmInUsim), 0x00, sizeof(MN_MSG_SrvParam));

    /* 参数检查 */
    if ((g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) || (g_atParaIndex > AT_CSMP_MAX_PARA_NUM)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<fo> */
    if (g_atParaList[AT_CSMP_FO].paraLen != 0) {
        ret = At_ParseCsmpFo(&(smsCtx->cscaCsmpInfo.tmpFo));
        if (ret != AT_SUCCESS) {
            return ret;
        }
    } else {
        smsCtx->cscaCsmpInfo.tmpFo = smsCtx->cscaCsmpInfo.fo;
    }

    memResult = memcpy_s(&parmInUsim, sizeof(parmInUsim), &(smsCtx->cscaCsmpInfo.parmInUsim), sizeof(parmInUsim));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(parmInUsim), sizeof(parmInUsim));

    /* 设置<vp> */
    ret = At_ParseCsmpVp(indexNum, &(smsCtx->cscaCsmpInfo.tmpVp));
    if (ret != AT_SUCCESS) {
        return ret;
    }

    /* 设置<pid> */
    if (g_atParaList[AT_CSMP_PID].paraLen != 0) {
        /* 注意: g_atParaList[2].ulParaValue此时尚未未转换，检查其它命令的这种情况 */
        if (At_Auc2ul(g_atParaList[AT_CSMP_PID].para, g_atParaList[AT_CSMP_PID].paraLen,
                      &g_atParaList[AT_CSMP_PID].paraValue) == AT_FAILURE) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaList[AT_CSMP_PID].paraValue <= AT_CSMP_MAX_VP_VALUE) {
            parmInUsim.parmInd &= ~MN_MSG_SRV_PARM_MASK_PID;
            parmInUsim.pid = (TAF_UINT8)g_atParaList[AT_CSMP_PID].paraValue;
        } else {
            AT_NORM_LOG("At_SetCsmpPara: unsupport VP type.");
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 设置<dcs> */
    if (g_atParaList[AT_CSMP_DCS].paraLen != 0) {
        /* 注意: g_atParaList[3].ulParaValue此时尚未未转换，检查其它命令的这种情况 */
        if (At_Auc2ul(g_atParaList[AT_CSMP_DCS].para, g_atParaList[AT_CSMP_DCS].paraLen,
                      &g_atParaList[AT_CSMP_DCS].paraValue) == AT_FAILURE) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaList[AT_CSMP_DCS].paraValue <= AT_CSMP_MAX_VP_VALUE) {
            parmInUsim.parmInd &= ~MN_MSG_SRV_PARM_MASK_DCS;
            parmInUsim.dcs = (TAF_UINT8)g_atParaList[AT_CSMP_DCS].paraValue;
        } else {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    servParm.memStore  = MN_MSG_MEM_STORE_SIM;
    servParm.writeMode = MN_MSG_WRITE_MODE_REPLACE;

    servParm.index = (VOS_UINT32)smsCtx->cscaCsmpInfo.defaultSmspIndex;

    memResult = memcpy_s(&servParm.srvParm, sizeof(servParm.srvParm), &parmInUsim, sizeof(servParm.srvParm));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(servParm.srvParm), sizeof(servParm.srvParm));
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_WriteSrvParam(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &servParm) ==
        MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSMP_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCsdhPara(TAF_UINT8 indexNum)
{
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        smsCtx->csdhType = (AT_CSDH_TYPE)g_atParaList[0].paraValue;
    } else {
        smsCtx->csdhType = AT_CSDH_NOT_SHOW_TYPE;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCnmiPara(TAF_UINT8 indexNum)
{
    TAF_UINT32      ret;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查和缺省参数配置 */
    /* 不带参数的设置命令，清空所有参数值为默认值 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        smsCtx->cnmiType.cnmiTmpModeType = AT_CNMI_MODE_BUFFER_TYPE;
        smsCtx->cnmiType.cnmiTmpMtType   = AT_CNMI_MT_NO_SEND_TYPE;
        smsCtx->cnmiType.cnmiTmpBmType   = AT_CNMI_BM_NO_SEND_TYPE;
        smsCtx->cnmiType.cnmiTmpDsType   = AT_CNMI_DS_NO_SEND_TYPE;
        smsCtx->cnmiType.cnmiTmpBfrType  = AT_CNMI_BFR_SEND_TYPE;
    }

    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) {
        /* 带参数的设置命令，参数个数不能为0且不能超过最大参数个数 */
        if ((g_atParaIndex == 0) || (g_atParaIndex > AT_CNMI_MAX_PARA_NUM)) {
            return AT_CMS_OPERATION_NOT_SUPPORTED;
        }

        /* 带参数的设置命令，用户未配置的参数不做修改 */
        smsCtx->cnmiType.cnmiTmpModeType = smsCtx->cnmiType.cnmiModeType;
        smsCtx->cnmiType.cnmiTmpMtType   = smsCtx->cnmiType.cnmiMtType;
        smsCtx->cnmiType.cnmiTmpBmType   = smsCtx->cnmiType.cnmiBmType;
        smsCtx->cnmiType.cnmiTmpDsType   = smsCtx->cnmiType.cnmiDsType;
        smsCtx->cnmiType.cnmiTmpBfrType  = smsCtx->cnmiType.cnmiBfrType;

        if (g_atParaList[AT_CNMI_PARA_MODE_TYPE].paraLen != 0) {
            smsCtx->cnmiType.cnmiTmpModeType = (AT_CNMI_MODE_TYPE)g_atParaList[AT_CNMI_PARA_MODE_TYPE].paraValue;
        }

        if (g_atParaList[AT_CNMI_PARA_MT_TYPE].paraLen != 0) {
            smsCtx->cnmiType.cnmiTmpMtType = (AT_CNMI_MT_TYPE)g_atParaList[AT_CNMI_PARA_MT_TYPE].paraValue;
        }

        if (g_atParaList[AT_CNMI_PARA_BM_TYPE].paraLen != 0) {
            smsCtx->cnmiType.cnmiTmpBmType = (AT_CNMI_BM_TYPE)g_atParaList[AT_CNMI_PARA_BM_TYPE].paraValue;
            if ((smsCtx->cnmiType.cnmiTmpBmType != AT_CNMI_BM_CBM_TYPE) &&
                (smsCtx->cnmiType.cnmiTmpBmType != AT_CNMI_BM_NO_SEND_TYPE)) {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }
        }

        if (g_atParaList[AT_CNMI_PARA_DS_TYPE].paraLen != 0) {
            smsCtx->cnmiType.cnmiTmpDsType = (AT_CNMI_DS_TYPE)g_atParaList[AT_CNMI_PARA_DS_TYPE].paraValue;
        }

        if (g_atParaList[AT_CNMI_PARA_BFR_TYPE].paraLen != 0) {
            smsCtx->cnmiType.cnmiTmpBfrType = (AT_CNMI_BFR_TYPE)g_atParaList[AT_CNMI_PARA_BFR_TYPE].paraValue;
        }

        if ((smsCtx->cnmiType.cnmiTmpModeType == AT_CNMI_MODE_BUFFER_TYPE) ||
            (smsCtx->cnmiType.cnmiTmpModeType == AT_CNMI_MODE_SEND_OR_BUFFER_TYPE)) {
            if ((smsCtx->cnmiType.cnmiTmpMtType == AT_CNMI_MT_CMT_TYPE) ||
                (smsCtx->cnmiType.cnmiTmpMtType == AT_CNMI_MT_CLASS3_TYPE)) {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }

            if (smsCtx->cnmiType.cnmiTmpDsType == AT_CNMI_DS_CDS_TYPE) {
                return AT_CMS_OPERATION_NOT_SUPPORTED;
            }
        }
    }

    g_atClientTab[indexNum].opId = At_GetOpId();
    ret                          = At_UpdateMsgRcvAct(indexNum, smsCtx->csmsMsgVersion, smsCtx->cnmiType.cnmiTmpMtType,
                                                      smsCtx->cnmiType.cnmiTmpDsType);
    if (ret != AT_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CNMI_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}

TAF_UINT32 At_SetCmglPara(TAF_UINT8 indexNum)
{
    MN_MSG_ListParm listParm;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if ((g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (g_atParaList[0].paraLen == 0)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* at命令只支持1个参数，增加检查 */
    if (g_atParaIndex > 1) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&listParm, sizeof(listParm), 0x00, sizeof(listParm));

    listParm.isFirstTimeReq = VOS_TRUE;

    /* 设置<stat> */
    if (g_atParaList[AT_CMGL_MSG_STAT].paraLen != 0) {
        listParm.status = (TAF_UINT8)g_atParaList[AT_CMGL_MSG_STAT].paraValue;
    } else {
        listParm.status = (TAF_UINT8)MN_MSG_STATUS_MT_NOT_READ;
    }

    /* 设置读取存储器 */
    listParm.memStore = smsCtx->cpmsInfo.memReadorDelete;

    if (smsCtx->paraCmsr == 0) {
        listParm.changeFlag = TAF_TRUE;
    } else {
        listParm.changeFlag = TAF_FALSE;
        if (g_atParaIndex > 1) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_List(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &listParm) == MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCmgrPara(TAF_UINT8 indexNum)
{
    MN_MSG_ReadParm readParm;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParaList[AT_CMGR_MSG_INDEX].paraLen == 0) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&readParm, sizeof(readParm), 0x00, sizeof(readParm));

    /* 参数设置 */
    readParm.index = g_atParaList[AT_CMGR_MSG_INDEX].paraValue;

    /* 设置读取存储器 */
    readParm.memStore = smsCtx->cpmsInfo.memReadorDelete;

    if (smsCtx->paraCmsr == 0) {
        readParm.changeFlag = TAF_TRUE;
    } else {
        readParm.changeFlag = TAF_FALSE;
        if (g_atParaIndex > 1) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_Read(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &readParm) == MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGR_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCnmaPara(TAF_UINT8 indexNum)
{
    TAF_UINT32          ret;
    TAF_BOOL            bRpAck  = TAF_TRUE;
    MN_MSG_SendAckParm *ackParm = VOS_NULL_PTR;
    AT_ModemSmsCtx     *smsCtx  = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    if (g_atParaIndex > AT_CNMA_MAX_PARA_NUM) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&g_atClientTab[indexNum].atSmsData, sizeof(g_atClientTab[indexNum].atSmsData), 0x00,
             sizeof(g_atClientTab[indexNum].atSmsData));
    if (smsCtx->cmgfMsgFormat == AT_CMGF_MSG_FORMAT_TEXT) { /* TEXT方式 */
        if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    } else { /* PDU方式 */
        if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
            if (g_atParaList[AT_CNMA_PDU_N_TYPE].paraLen == 0) {
                return AT_CMS_OPERATION_NOT_ALLOWED;
            } else {
                /* 设置<n> */
                g_atClientTab[indexNum].atSmsData.cnmaType = (TAF_UINT8)g_atParaList[AT_CNMA_PDU_N_TYPE].paraValue;
            }

            /* 只有参数<n>,决定是否发送RP-ACK或RP-ERROR */
            if ((g_atParaList[AT_CNMA_TPDU_LEN].paraLen != 0) && (g_atParaList[AT_CNMA_TPDU_LEN].paraValue != 0)) {
                if (g_atClientTab[indexNum].atSmsData.cnmaType == 0) {
                    return AT_ERROR;
                }

                /* 设置<length> */
                if (g_atParaList[AT_CNMA_TPDU_LEN].paraValue > AT_MSG_MAX_TPDU_LEN) {
                    AT_NORM_LOG("At_SetCnmaPara: the length of PDU is not support.");
                    return AT_CMS_OPERATION_NOT_ALLOWED; /* 输入字串太长 */
                }

                g_atClientTab[indexNum].atSmsData.pduLen = (TAF_UINT8)g_atParaList[AT_CNMA_TPDU_LEN].paraValue;
                At_SetCmdSubMode(indexNum, AT_SMS_MODE);/* 切换为短信模式 */
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CNMA_PDU_SET;
                return AT_WAIT_SMS_INPUT; /* 返回提示短信内容输入状态 */
            } else {
                if (g_atClientTab[indexNum].atSmsData.cnmaType == AT_CNMA_RP_ERROR) {
                    bRpAck = TAF_FALSE;
                }
            }
        }
    }

    /* CMGF设置了文本格式, 或CNMA无参数，或CNMA参数中<length>为0 */
    ackParm = At_GetAckMsgMem();
    (VOS_VOID)memset_s(ackParm, sizeof(MN_MSG_SendAckParm), 0x00, sizeof(MN_MSG_SendAckParm));

    if (bRpAck == TAF_TRUE) {
        ackParm->rpAck              = TAF_TRUE;
        ackParm->tsRawData.tpduType = MN_MSG_TPDU_DELIVER_RPT_ACK;
    } else {
        ackParm->rpAck              = TAF_FALSE;
        ackParm->rpCause            = MN_MSG_RP_CAUSE_PROTOCOL_ERR_UNSPECIFIED;
        ackParm->tsRawData.tpduType = MN_MSG_TPDU_DELIVER_RPT_ERR;
        ackParm->tsRawData.len      = AT_MN_MSG_SMS_TPDU_LEN;
        ackParm->tsRawData.data[0]  = 0;
        ackParm->tsRawData.data[1]  = 0xff;
    }

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_SendAck(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, ackParm) == MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CNMA_TEXT_SET;
        ret                                   = AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        ret = AT_ERROR;
    }

    return ret;
}


TAF_UINT32 At_SetCmgsPara(TAF_UINT8 indexNum)
{
    TAF_UINT8  smSFormat;
    TAF_UINT32 ret;

    smSFormat = AT_GetModemSmsCtxAddrFromClientId(indexNum)->cmgfMsgFormat;

    /* 参数检查，如果<da>号码或者<length>不存在，直接返回错误 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&g_atClientTab[indexNum].atSmsData, sizeof(g_atClientTab[indexNum].atSmsData), 0x00,
        sizeof(g_atClientTab[indexNum].atSmsData));

    if (smSFormat == AT_CMGF_MSG_FORMAT_TEXT) {                 /* TEXT方式参数检查 */
        if (g_atParaIndex > AT_CMGS_TEXT_FORMAT_MAX_PARA_NUM) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 参数设置 */
        /* 设置<da> <toda> */
        ret = At_GetAsciiOrBcdAddr(g_atParaList[0].para, g_atParaList[0].paraLen, (TAF_UINT8)g_atParaList[1].paraValue,
                                   g_atParaList[1].paraLen, &g_atClientTab[indexNum].atSmsData.asciiAddr, TAF_NULL_PTR);
        if ((ret != AT_OK) || (g_atClientTab[indexNum].atSmsData.asciiAddr.len == 0)) {
            AT_NORM_LOG("At_SetCmgsPara: no da.");
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

    } else {                     /* PDU方式参数检查 */
        if (g_atParaIndex > 1) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaList[0].paraValue > AT_MSG_MAX_TPDU_LEN) {
            AT_NORM_LOG("At_SetCmgsPara: invalid tpdu data length.");
            return AT_ERROR;
        }

        /* 设置<length> */
        g_atClientTab[indexNum].atSmsData.pduLen = (TAF_UINT8)g_atParaList[0].paraValue;
    }

    At_SetCmdSubMode(indexNum, AT_SMS_MODE); /* 切换为短信模式 */

    /* 设置当前操作类型 */
    if (smSFormat == AT_CMGF_MSG_FORMAT_TEXT) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGS_TEXT_SET;
    } else {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGS_PDU_SET;
    }
    return AT_WAIT_SMS_INPUT; /* 返回提示短信内容输入状态 */
}


TAF_UINT32 At_SetCmssPara(TAF_UINT8 indexNum)
{
    MN_MSG_SendFrommemParm sendFromMemParm;
    TAF_UINT32             ret;
    AT_ModemSmsCtx        *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查，如果<index>不存在，直接返回错误 */
    if ((g_atParaList[AT_CMSS_MSG_INDEX].paraLen == 0) || (g_atParaIndex > AT_CMSS_MAX_PARA_NUM)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<da> */
    ret = At_GetAsciiOrBcdAddr(g_atParaList[AT_CMSS_MSG_DA].para, g_atParaList[AT_CMSS_MSG_DA].paraLen,
                               (TAF_UINT8)g_atParaList[AT_CMSS_MSG_TODA].paraValue,
                               g_atParaList[AT_CMSS_MSG_TODA].paraLen, VOS_NULL_PTR, &sendFromMemParm.destAddr);
    if (ret != AT_OK) {
        return AT_ERROR;
    }

    /* 设置发送存储器 */
    sendFromMemParm.memStore = smsCtx->cpmsInfo.memSendorWrite;
    sendFromMemParm.index    = g_atParaList[AT_CMSS_MSG_INDEX].paraValue;

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_SendFromMem(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &sendFromMemParm) ==
        MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt          = AT_CMD_CMSS_SET;
        g_atClientTab[indexNum].atSmsData.msgSentSmNum = 1;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCmgwPara(TAF_UINT8 indexNum)
{
    TAF_UINT8       smSFormat;
    TAF_UINT32      ret;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    smSFormat = smsCtx->cmgfMsgFormat;

    /* 初始化 */
    (VOS_VOID)memset_s(&g_atClientTab[indexNum].atSmsData, sizeof(g_atClientTab[indexNum].atSmsData), 0x00,
             sizeof(g_atClientTab[indexNum].atSmsData));
    if (smSFormat == AT_CMGF_MSG_FORMAT_TEXT) { /* TEXT方式参数检查 */
        /* 参数检查 */
        if ((g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) &&
            (g_atParaList[AT_CMGW_MSG_OA_OR_DA].paraLen == 0)) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaIndex > AT_CMGW_TEXT_FORMAT_MAX_PARA_NUM) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置<oa/da> */
        ret = At_GetAsciiOrBcdAddr(g_atParaList[AT_CMGW_MSG_OA_OR_DA].para, g_atParaList[AT_CMGW_MSG_OA_OR_DA].paraLen,
                                   (TAF_UINT8)g_atParaList[AT_CMGW_MSG_TOOA_OR_TODA].paraValue,
                                   g_atParaList[AT_CMGW_MSG_TOOA_OR_TODA].paraLen,
                                   &g_atClientTab[indexNum].atSmsData.asciiAddr,TAF_NULL_PTR);
        if (ret != AT_OK) {
            return ret;
        }

        /* 设置<stat> */
        if (g_atParaList[AT_CMGW_MSG_TEXT_STAT].paraLen != 0) {
            g_atClientTab[indexNum].atSmsData.smState = (TAF_UINT8)g_atParaList[AT_CMGW_MSG_TEXT_STAT].paraValue;
        } else {
            g_atClientTab[indexNum].atSmsData.smState = MN_MSG_STATUS_MO_NOT_SENT;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGW_TEXT_SET;
    } else { /* PDU方式参数检查 */
        /* 参数检查 */
        if (g_atParaList[AT_CMGW_TPDU_LEN].paraLen == 0) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaIndex > AT_CMGW_PDU_FORMAT_MAX_PARA_NUM) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaList[AT_CMGW_TPDU_LEN].paraValue > AT_MSG_MAX_TPDU_LEN) {
            AT_NORM_LOG("At_SendPduMsgOrCmd: invalid tpdu data length.");
            return AT_ERROR;
        }
        g_atClientTab[indexNum].atSmsData.pduLen = (TAF_UINT8)g_atParaList[AT_CMGW_TPDU_LEN].paraValue;

        /* 设置<stat> */
        if (g_atParaList[AT_CMGW_MSG_PDU_STAT].paraLen != 0) {
            g_atClientTab[indexNum].atSmsData.smState = (TAF_UINT8)g_atParaList[AT_CMGW_MSG_PDU_STAT].paraValue;
        } else {
            g_atClientTab[indexNum].atSmsData.smState = MN_MSG_STATUS_MO_NOT_SENT;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGW_PDU_SET;
    }

    if ((g_atClientTab[indexNum].atSmsData.smState != MN_MSG_STATUS_MT_NOT_READ) &&
        (g_atClientTab[indexNum].atSmsData.smState != MN_MSG_STATUS_MT_READ) &&
        (g_atClientTab[indexNum].atSmsData.smState != MN_MSG_STATUS_MO_NOT_SENT) &&
        (g_atClientTab[indexNum].atSmsData.smState != MN_MSG_STATUS_MO_SENT)) {
        AT_NORM_LOG("At_SetCmgwPara: invalid sm status.");
        return AT_ERROR;
    }

    At_SetCmdSubMode(indexNum, AT_SMS_MODE); /* 切换为短信模式 */

    return AT_WAIT_SMS_INPUT; /* 返回提示短信内容输入状态 */
}


TAF_UINT32 At_SetCmgdPara(TAF_UINT8 indexNum)
{
    MN_MSG_DeleteParam deleteInfo;
    MN_OPERATION_ID_T  opId            = At_GetOpId();
    TAF_UINT32         deleteTypeIndex = 0;
    TAF_UINT32         deleteTypes[AT_MSG_DELETE_TYPE_NUM]  = {
        AT_MSG_DELETE_SINGLE,
        AT_MSG_DELETE_READ,
        (AT_MSG_DELETE_READ + AT_MSG_DELETE_SENT),
        (AT_MSG_DELETE_READ + AT_MSG_DELETE_SENT + AT_MSG_DELETE_UNSENT),
        AT_MSG_DELETE_ALL
    };
    TAF_UINT32      ret;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&deleteInfo, sizeof(deleteInfo), 0x00, sizeof(deleteInfo));

    /* 参数检查 */
    if (g_atParaIndex > AT_CMGD_MAX_PARA_NUM) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<index> */
    deleteInfo.index = g_atParaList[0].paraValue;

    /* 设置删除存储器 */
    deleteInfo.memStore = smsCtx->cpmsInfo.memReadorDelete;

    /* 设置<delflag> */
    if (g_atParaList[1].paraLen != 0) {
        deleteTypeIndex = g_atParaList[1].paraValue;
    } else {
        deleteTypeIndex = 0;
    }

    g_atClientTab[indexNum].atSmsData.msgDeleteTypes = (TAF_UINT8)deleteTypes[deleteTypeIndex];
    if (g_atClientTab[indexNum].atSmsData.msgDeleteTypes == AT_MSG_DELETE_SINGLE) {
        if (g_atParaList[0].paraLen == 0) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
    }

    /* 执行命令操作 */
    ret = At_MsgDeleteCmdProc(indexNum, opId, deleteInfo, g_atClientTab[indexNum].atSmsData.msgDeleteTypes);
    if (ret != AT_OK) {
        return ret;
    }

    g_atClientTab[indexNum].opId          = opId;
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGD_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


TAF_UINT32 At_SetCmgcPara(TAF_UINT8 indexNum)
{
    TAF_UINT8       smSFormat;
    TAF_UINT32      ret;
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    smSFormat = smsCtx->cmgfMsgFormat;

    /* 初始化 */
    (VOS_VOID)memset_s(&g_atClientTab[indexNum].atSmsData, sizeof(g_atClientTab[indexNum].atSmsData), 0x00,
             sizeof(g_atClientTab[indexNum].atSmsData));

    if (smSFormat == AT_CMGF_MSG_FORMAT_TEXT) { /* TEXT方式 */
        /* 如果<ct>或<fo>不存在，直接返回错误 */
        if ((g_atParaList[AT_CMGC_MSG_CMD_TYPE].paraLen == 0) || (g_atParaList[AT_CMGC_MSG_FO].paraLen == 0)) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaIndex > AT_CMGC_MAX_PARA_NUM) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置<fo>.SRR */
        g_atClientTab[indexNum].atSmsData.fo = (TAF_UINT8)g_atParaList[AT_CMGC_MSG_FO].paraValue;

        /* 设置<ct> */
        g_atClientTab[indexNum].atSmsData.commandType = (TAF_UINT8)g_atParaList[AT_CMGC_MSG_CMD_TYPE].paraValue;

        /* 设置<pid> */
        if (g_atParaList[AT_CMGC_PID].paraLen != 0) {
            g_atClientTab[indexNum].atSmsData.pid = (TAF_UINT8)g_atParaList[AT_CMGC_PID].paraValue;
        } else {
            g_atClientTab[indexNum].atSmsData.pid = 0;
        }

        /* 设置<mn> */
        if (g_atParaList[AT_CMGC_MSG_NO].paraLen == 0) {
            g_atClientTab[indexNum].atSmsData.messageNumber = 0;
        } else {
            g_atClientTab[indexNum].atSmsData.messageNumber = (TAF_UINT8)g_atParaList[AT_CMGC_MSG_NO].paraValue;
        }

        /* 设置<oa/da> */
        ret = At_GetAsciiOrBcdAddr(g_atParaList[AT_CMGC_MSG_OA_OR_DA].para, g_atParaList[AT_CMGC_MSG_OA_OR_DA].paraLen,
                                   (TAF_UINT8)g_atParaList[AT_CMGC_MSG_TOOA_OR_TODA].paraValue,
                                   g_atParaList[AT_CMGC_MSG_TOOA_OR_TODA].paraLen,
                                   &g_atClientTab[indexNum].atSmsData.asciiAddr, TAF_NULL_PTR);
        if (ret != AT_OK) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGC_TEXT_SET;
    } else { /* PDU方式 */
        /* 如果<length>不存在，直接返回错误 */
        if (g_atParaList[AT_CMGC_PDU_LEN].paraLen == 0) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaIndex > 1) { /* 参数过多 */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        if (g_atParaList[AT_CMGC_PDU_LEN].paraValue > AT_MSG_MAX_TPDU_LEN) {
            AT_NORM_LOG("At_SetCmgcPara: invalid tpdu data length.");
            return AT_ERROR;
        }

        g_atClientTab[indexNum].atSmsData.pduLen = (TAF_UINT8)g_atParaList[AT_CMGC_PDU_LEN].paraValue;
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGC_PDU_SET;
    }

    At_SetCmdSubMode(indexNum, AT_SMS_MODE); /* 切换为短信模式 */

    return AT_WAIT_SMS_INPUT; /* 返回提示短信内容输入状态 */
}

TAF_UINT32 At_SetCmstPara(TAF_UINT8 indexNum)
{
    MN_MSG_SendFrommemParm sendFromMemParm;
    TAF_UINT32             ret;
    TAF_UINT32             loop;
    MN_OPERATION_ID_T      opId   = At_GetOpId();
    AT_ModemSmsCtx        *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查，如果<index>不存在，直接返回错误 */
    if ((g_atParaList[AT_CMST_MSG_INDEX].paraLen == 0) ||
        (g_atParaList[AT_CMST_MSG_SENT_SM_TIME].paraLen == 0) || (g_atParaIndex > AT_CMST_MAX_PARA_NUM) ||
        (g_atParaList[AT_CMST_MSG_SENT_SM_TIME].paraValue < 1)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<da> */
    ret = At_GetAsciiOrBcdAddr(g_atParaList[AT_CMST_MSG_DA].para, g_atParaList[AT_CMST_MSG_DA].paraLen,
                               (TAF_UINT8)g_atParaList[AT_CMST_MSG_TODA].paraValue,
                               g_atParaList[AT_CMST_MSG_TODA].paraLen, VOS_NULL_PTR, &sendFromMemParm.destAddr);
    if (ret != AT_OK) {
        return AT_ERROR;
    }

    /* 设置发送存储器 */
    sendFromMemParm.memStore = smsCtx->cpmsInfo.memSendorWrite;
    sendFromMemParm.index    = g_atParaList[AT_CMST_MSG_INDEX].paraValue;

    /* 执行命令操作 */
    g_atClientTab[indexNum].atSmsData.msgSentSmNum = (TAF_UINT8)g_atParaList[AT_CMST_MSG_SENT_SM_TIME].paraValue;
    for (loop = 0; loop < g_atClientTab[indexNum].atSmsData.msgSentSmNum; loop++) {
        if (MN_MSG_SendFromMem(g_atClientTab[indexNum].clientId, opId, &sendFromMemParm) != AT_SUCCESS) {
            return AT_ERROR;
        }
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMST_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


VOS_UINT32 At_SetCmStubPara(VOS_UINT8 indexNum)
{
    MN_MSG_StubMsg stubParam;
    VOS_UINT32     ret;

    /* 输入参数检查: <stubtype>类型是否有效，参数个数不允许超过2个 */
    if ((g_atParaIndex != 2) || (g_atParaList[AT_CMSTUB_STUB_TYPE].paraLen == 0) ||
        (g_atParaList[AT_CMSTUB_STUB_VALUE].paraLen == 0)) {
        AT_LOG1("At_SetCmStubPara: invalid parameter.", g_atParaIndex);
        AT_LOG1("At_SetCmStubPara: invalid parameter.", g_atParaList[AT_CMSTUB_STUB_TYPE].paraValue);
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* A核能处理的桩直接处理并退出: 自动回复功能不需要通知C核 */
    if (g_atParaList[AT_CMSTUB_STUB_TYPE].paraValue == MN_MSG_STUB_TYPE_SMS_AUTO_REPLY) {
        AT_StubTriggerAutoReply(indexNum, (VOS_UINT8)g_atParaList[AT_CMSTUB_STUB_VALUE].paraValue);
        return AT_OK;
    }

#if (VOS_WIN32 == VOS_OS_VER)
    if (g_atParaList[AT_CMSTUB_STUB_TYPE].paraValue == MN_MSG_STUB_TYPE_CLASS0_TAILOR) {
        /* CLASS0类短信接收方式涉及A核和C核两部分，所以此处不能直接返回； */
        g_class0Tailor = (VOS_UINT8)g_atParaList[AT_CMSTUB_STUB_VALUE].paraValue;
    }
#endif

    /* 需要C核处理的桩: 发送消息给C核 */
    stubParam.stubType = (MN_MSG_StubTypeUint32 )g_atParaList[AT_CMSTUB_STUB_TYPE].paraValue;
    stubParam.value    = g_atParaList[AT_CMSTUB_STUB_VALUE].paraValue;

    g_atClientTab[indexNum].opId = At_GetOpId();
    ret = MN_MSG_ReqStub(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &stubParam);
    if (ret != MN_ERR_NO_ERROR) {
        return ret;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMSTUB_SET;
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetCmmsPara(TAF_UINT8 indexNum)
{
    MN_MSG_LinkCtrlType setParam;
    TAF_UINT32          ret;
    MN_OPERATION_ID_T   opId = At_GetOpId();

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex == 0) {
        setParam.relayLinkCtrl = MN_MSG_LINK_CTRL_ENABLE;
    } else {
        setParam.relayLinkCtrl = (MN_MSG_LinkCtrlUint8)g_atParaList[AT_CMMS_MSG_LINK_CTRL].paraValue;
    }

    ret = MN_MSG_SetLinkCtrl(g_atClientTab[indexNum].clientId, opId, &setParam);
    if (ret != MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].opId          = opId;
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMMS_SET;
    return AT_WAIT_ASYNC_RETURN;
}
#if ((FEATURE_GCBS == FEATURE_ON) || (FEATURE_WCBS == FEATURE_ON))

VOS_UINT32 AT_ParseCbParm(VOS_UINT8 *inPara, TAF_CBA_CbmiRangeList *cbRange)
{
    VOS_UINT32 i;
    VOS_UINT32 iLoop;
    VOS_UINT32 parmCount;
    TAF_UINT8  temp[TAF_CBA_MAX_CBMID_RANGE_NUM];
    VOS_BOOL   bRange = VOS_FALSE;
    VOS_UINT32 value;
    TAF_CBA_MsgidSrcFlgUint8 midSrcFlg;

    midSrcFlg = TAF_CBA_MSGID_SRC_FLG_NULL;

    cbRange->cbmirNum = 0;
    iLoop             = 0;
    parmCount         = 0;
    i                 = 0;

    while ((inPara[iLoop] != '\0') && (i < TAF_CBA_MAX_CBMID_RANGE_NUM)) {
        i = 0;
        while ((inPara[iLoop] != ',') && (inPara[iLoop] != '-') && (inPara[iLoop] != '\0')) {
            temp[i] = inPara[iLoop];
            i++;
            iLoop++;
            if (i >= AT_CSCB_MIDS_MAX_VALID_CHARACTERS_NUM) {
                return VOS_ERR;
            }
        }

        temp[i] = '\0';
        i++;

        if (VOS_StrLen((VOS_CHAR *)temp) == 0) {
            return VOS_ERR;
        }

        if (bRange) {
            if (At_Auc2ul(temp, (VOS_UINT16)VOS_StrLen((VOS_CHAR *)temp), &value) != AT_SUCCESS) {
                return VOS_ERR;
            }

            if (value > 0xFFFF) {
                return VOS_ERR;
            }

            if (parmCount >= 1) {
                cbRange->cbmiRangeInfo[parmCount - 1].msgIdTo = (VOS_UINT16)value;

                bRange = VOS_FALSE;
            }

        } else {
            if (At_Auc2ul(temp, (VOS_UINT16)VOS_StrLen((VOS_CHAR *)temp), &value) != AT_SUCCESS) {
                return VOS_ERR;
            }

            if (value > 0xFFFF) {
                return VOS_ERR;
            }

            cbRange->cbmiRangeInfo[parmCount].msgIdFrom = (VOS_UINT16)value;
            cbRange->cbmiRangeInfo[parmCount].msgIdTo   = (VOS_UINT16)value;
            /* 用户操作的，需要刷新到卡和NV，所以文件标记为 NV + EFCBMI+ EFCBMIR */
            midSrcFlg = TAF_CBA_MSGID_SRC_FLG_NV;
            midSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMI;
            midSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMIR;

            cbRange->cbmiRangeInfo[parmCount].msgIdSrcFlg = midSrcFlg;
            (cbRange->cbmirNum)++;
            parmCount++;
        }

        if (inPara[iLoop] == '-') {
            bRange = VOS_TRUE;
        } else if (inPara[iLoop] == '\0') {
            return VOS_OK;
        } else {
            bRange = VOS_FALSE;
        }

        iLoop++;

        if (parmCount >= AT_MAX_CBS_MSGID_NUM) {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_ProcCscbWithParm(TAF_UINT8 indexNum, TAF_CBA_CbmiRangeList *cbmirList)
{
    errno_t                memResult;
    VOS_UINT32             ret;
    TAF_CBA_CbmiRangeList *dcssInfo = VOS_NULL_PTR;
    VOS_UINT32             appRet;
    AT_ModemSmsCtx        *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(cbmirList, sizeof(TAF_CBA_CbmiRangeList), 0x00, sizeof(TAF_CBA_CbmiRangeList));

    ret = VOS_ERR;

    /* 表明 <mids> 有效 */
    if (g_atParaList[AT_CSCB_MIDS].paraLen > 0) {
        g_atParaList[AT_CSCB_MIDS].para[g_atParaList[AT_CSCB_MIDS].paraLen] = '\0';
        ret = AT_ParseCbParm(g_atParaList[AT_CSCB_MIDS].para, cbmirList);
    }

    /* 多个参数,MID必须存在,而且还必须合法,否则返回出错 */
    if (ret != VOS_OK) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 表明 <dcss> 有效 */
    if (g_atParaList[AT_CSCB_DCSS].paraLen > 0) {
        /*lint -save -e516 */
        dcssInfo = (TAF_CBA_CbmiRangeList *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_CBA_CbmiRangeList));
        /*lint -restore */
        if (dcssInfo == VOS_NULL) {
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }

        (VOS_VOID)memset_s(dcssInfo, sizeof(TAF_CBA_CbmiRangeList), 0x00, sizeof(TAF_CBA_CbmiRangeList));

        g_atParaList[AT_CSCB_DCSS].para[g_atParaList[AT_CSCB_DCSS].paraLen] = '\0';
        ret = AT_ParseCbParm(g_atParaList[AT_CSCB_DCSS].para, dcssInfo);
        if (ret == VOS_OK) {
            memResult = memcpy_s(&(smsCtx->cbsDcssInfo), sizeof(smsCtx->cbsDcssInfo), dcssInfo,
                                 sizeof(smsCtx->cbsDcssInfo));
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(smsCtx->cbsDcssInfo), sizeof(smsCtx->cbsDcssInfo));
        } else {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, dcssInfo);
            /*lint -restore */
            return AT_CMS_OPERATION_NOT_ALLOWED;
        }
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dcssInfo);
        /*lint -restore */
    }

    if (g_atParaList[0].paraValue == MN_MSG_CBMODE_ACCEPT) {
        appRet = MN_MSG_AddCbMids(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, cbmirList);
    } else {
        appRet = MN_MSG_DelCbMids(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, cbmirList);
    }

    ret = VOS_OK;
    /* 转换API调用结果 */
    if (appRet != MN_ERR_NO_ERROR) {
        ret = VOS_ERR;
    }

    if (ret != VOS_OK) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    return AT_OK;
}


TAF_UINT32 At_SetCscbPara(TAF_UINT8 indexNum)
{
    VOS_UINT32             ret;
    TAF_CBA_CbmiRangeList *cbmirList = VOS_NULL_PTR;
    VOS_UINT32             apiRet;
    TAF_CBA_MsgidSrcFlgUint8 midSrcFlg;

    midSrcFlg = TAF_CBA_MSGID_SRC_FLG_NULL;
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 如果参数个数大于1,则第二个参数必须存在 */
    if ((g_atParaIndex > 1) && (g_atParaList[1].paraLen == 0)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }
    /*lint -save -e516 */
    cbmirList = (TAF_CBA_CbmiRangeList *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_CBA_CbmiRangeList));
    /*lint -restore */
    if (cbmirList == VOS_NULL_PTR) {
        AT_WARN_LOG("At_SetCscbPara: Fail to alloc memory.");
        return AT_CMS_ERROR_IN_MS;
    }
    (VOS_VOID)memset_s(cbmirList, sizeof(TAF_CBA_CbmiRangeList), 0x00, sizeof(TAF_CBA_CbmiRangeList));

    g_atClientTab[indexNum].opId = At_GetOpId();

    ret = AT_OK;
    if ((g_atParaIndex == 0) || ((g_atParaIndex == 1) && (g_atParaList[0].paraValue == MN_MSG_CBMODE_ACCEPT))) {
        /* 当前仅存在一个参数,表明是激活所有CBS消息 */
        cbmirList->cbmirNum                   = 1;
        cbmirList->cbmiRangeInfo[0].msgIdFrom = 0;
        cbmirList->cbmiRangeInfo[0].msgIdTo   = 0xFFFF;
        /* 用户操作的，需要刷新到卡和NV，所以文件标记为 NV + EFCBMI+ EFCBMIR */
        midSrcFlg = TAF_CBA_MSGID_SRC_FLG_NV;
        midSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMI;
        midSrcFlg |= TAF_CBA_MSGID_SRC_FLG_EFCBMIR;

        cbmirList->cbmiRangeInfo[0].msgIdSrcFlg = midSrcFlg;

        apiRet = MN_MSG_AddCbMids(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, cbmirList);

        /* 转换API调用结果 */
        if (apiRet != MN_ERR_NO_ERROR) {
            ret = AT_CMS_OPERATION_NOT_ALLOWED;
        }
    } else if ((g_atParaIndex == 1) && (g_atParaList[0].paraValue == MN_MSG_CBMODE_REJECT)) {
        /* 当前仅存在一个参数,表明是去激活所有CBS消息 */
        apiRet = MN_MSG_EmptyCbMids(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId);

        /* 转换API调用结果 */
        if (apiRet != MN_ERR_NO_ERROR) {
            ret = AT_CMS_OPERATION_NOT_ALLOWED;
        }
    } else {
        /* 处理带有参数等情况 */
        ret = AT_ProcCscbWithParm(indexNum, cbmirList);
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, cbmirList);
    /*lint -restore */
    if (ret != AT_OK) {
        return ret;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSCB_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}

#endif


TAF_UINT32 At_SetClipPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        ssCtx->clipType = (AT_CLIP_TYPE)g_atParaList[0].paraValue;
    } else {
        ssCtx->clipType = AT_CLIP_DISABLE_TYPE;
    }

    return AT_OK;
}


TAF_UINT32 At_SetClirPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        switch (g_atParaList[0].paraValue) {
            case AT_CLIR_AS_SUBSCRIPT:
                ssCtx->clirType = AT_CLIR_AS_SUBSCRIPT;
                break;

            case AT_CLIR_INVOKE:
                ssCtx->clirType = AT_CLIR_INVOKE;
                break;

            case AT_CLIR_SUPPRESS:
                ssCtx->clirType = AT_CLIR_SUPPRESS;
                break;

            default:
                return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        ssCtx->clirType = AT_CLIR_AS_SUBSCRIPT;
    }
    return AT_OK;
}


VOS_UINT32 At_SetColpPara(VOS_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        ssCtx->colpType = (AT_COLP_TYPE)g_atParaList[0].paraValue;
    } else {
        ssCtx->colpType = AT_COLP_DISABLE_TYPE;
    }

    return AT_OK;
}
/*
 * Description: +CSCS=[<chset>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCscsPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        g_atCscsType = (AT_CSCS_TYPE)g_atParaList[0].paraValue;
    } else {
        g_atCscsType = AT_CSCS_IRA_CODE;
    }
    return AT_OK;
}
/*
 * Description: +CMEE=[<n>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCmeePara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        g_atCmeeType = (AT_CMEE_TYPE)g_atParaList[0].paraValue;
    } else {
        g_atCmeeType = AT_CMEE_ONLY_ERROR;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCeerPara(TAF_UINT8 indexNum)
{
    VOS_UINT16 length;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s: %d,%d", g_parseContext[indexNum].cmdElement->cmdName,
        AT_GetCsCallErrCause(indexNum), AT_PS_GetPsCallErrCause(indexNum));

    g_atSendDataBuff.bufLen = length;
    return AT_OK;
}

TAF_UINT32 At_SetCregPara(TAF_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        netCtx->cregType   = (AT_CREG_TYPE)g_atParaList[0].paraValue;
        atCmd.u.cregRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

        /*
         * 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
         * 都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询
         */
    } else {
        netCtx->cregType   = AT_CREG_RESULT_CODE_NOT_REPORT_TYPE;
        atCmd.u.cregRptFlg = AT_CREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    atCmd.reqType = AT_MTA_SET_CREG_RPT_TYPE;

    /* 给MTA发送+creg设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

TAF_UINT32 At_SetCgregPara(TAF_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        netCtx->cgregType   = (AT_CGREG_TYPE)g_atParaList[0].paraValue;
        atCmd.u.cgregRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

        /*
         * 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
         * 都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询
         */
    } else {
        netCtx->cgregType   = AT_CGREG_RESULT_CODE_NOT_REPORT_TYPE;
        atCmd.u.cgregRptFlg = AT_CGREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    atCmd.reqType = AT_MTA_SET_CGREG_RPT_TYPE;

    /* 给MTA发送+cgreg设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCsdfPara(VOS_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CSDF_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    netCtx->csdfCfg.mode    = 1;
    netCtx->csdfCfg.auxMode = 1;

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        netCtx->csdfCfg.mode = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    if (g_atParaList[1].paraLen != 0) {
        netCtx->csdfCfg.auxMode = (VOS_UINT8)g_atParaList[1].paraValue;
    }

    return AT_OK;
}

#if (FEATURE_LTE == FEATURE_ON)

VOS_UINT32 AT_SetCeregPara(VOS_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        netCtx->ceregType   = (AT_CeregTypeUint8)g_atParaList[0].paraValue;
        atCmd.u.ceregRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

        /*
         * 开机默认TAF_EVENT_INFO_CELL_SIGN+TAF_EVENT_INFO_CELL_ID + TAF_EVENT_INFO_CELL_BLER
         * 都打开主动上报，此处无需再通知接入层开启主动上报，目前没有停止，停止了会影响CSQ查询
         */
    } else {
        netCtx->ceregType   = AT_CEREG_RESULT_CODE_NOT_REPORT_TYPE;
        atCmd.u.ceregRptFlg = AT_CEREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    atCmd.reqType = AT_MTA_SET_CEREG_RPT_TYPE;

    /* 给MTA发送+cgreg设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 AT_SetC5gregPara(VOS_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        netCtx->c5gregType   = (AT_C5GREG_TypeUint8)g_atParaList[0].paraValue;
        atCmd.u.c5gregRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    } else {
        netCtx->c5gregType   = AT_C5GREG_RESULT_CODE_NOT_REPORT_TYPE;
        atCmd.u.c5gregRptFlg = AT_C5GREG_RESULT_CODE_NOT_REPORT_TYPE;
    }

    atCmd.reqType = AT_MTA_SET_C5GREG_RPT_TYPE;

    /* 给MTA发送+c5greg设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif


VOS_UINT32 At_SetClccPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                  ret;
    TAF_Ctrl                    ctrl;
    TAF_CALL_QryCallInfoReqPara qryCallInfoPara;
    ModemIdUint16               modemId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&qryCallInfoPara, sizeof(qryCallInfoPara), 0x00, sizeof(qryCallInfoPara));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    qryCallInfoPara.getCallInfoType = TAF_CALL_GET_CALL_INFO_TYPE_CLCC;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发消息到C核获取当前所有通话信息 */
    ret = TAF_CCM_CallCommonReq(&ctrl, &qryCallInfoPara, ID_TAF_CCM_QRY_CALL_INFO_REQ, sizeof(qryCallInfoPara),
                                modemId);

    if (ret != VOS_OK) {
        AT_WARN_LOG("At_SetClccPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCC_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetCpasPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                  ret;
    TAF_Ctrl                    ctrl;
    TAF_CALL_QryCallInfoReqPara qryCallInfoPara;
    ModemIdUint16               modemId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&qryCallInfoPara, sizeof(qryCallInfoPara), 0x00, sizeof(qryCallInfoPara));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    qryCallInfoPara.getCallInfoType = TAF_CALL_GET_CALL_INFO_TYPE_CLCC;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发消息到C核获取当前所有通话信息 */
    ret = TAF_CCM_CallCommonReq(&ctrl, &qryCallInfoPara, ID_TAF_CCM_QRY_CALL_INFO_REQ, sizeof(qryCallInfoPara),
                                modemId);

    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetCpasPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPAS_SET;

    return AT_WAIT_ASYNC_RETURN;
}
/*
 * Description: +CSTA=[<type>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCstaPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    g_atCstaNumType = (AT_CSTA_NumTypeUint8)g_atParaList[0].paraValue;

    return AT_OK;
}

TAF_UINT32 At_SetCcugPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CCUG_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<n> */
    if (g_atParaList[AT_CCUG_MODE_ENABLE].paraLen != 0) {
        ssCtx->ccugCfg.enable = g_atParaList[AT_CCUG_MODE_ENABLE].paraValue;
    } else {
        ssCtx->ccugCfg.enable = 0;
    }

    /* 设置<index> */
    if (g_atParaList[AT_CCUG_GROUP_INDEX].paraLen != 0) {
        if (g_atParaList[AT_CCUG_GROUP_INDEX].paraValue == AT_CCUG_INDEX_VALUE_DENOTES_NO_INDEX) {
            ssCtx->ccugCfg.indexPresent = 0;
            ssCtx->ccugCfg.index = AT_CCUG_CUG_INDEX;
        } else {
            ssCtx->ccugCfg.indexPresent = 1;
            ssCtx->ccugCfg.index        = (TAF_UINT8)g_atParaList[AT_CCUG_GROUP_INDEX].paraValue;
        }
    } else {
        ssCtx->ccugCfg.indexPresent = 0;
        ssCtx->ccugCfg.index = 0;
    }

    /* 设置<info> */
    if (g_atParaList[AT_CCUG_INFO].paraLen != 0) {
        ssCtx->ccugCfg.suppressPrefer = (g_atParaList[AT_CCUG_INFO].paraValue & 0x02) >> 1;
        ssCtx->ccugCfg.suppressOa     = g_atParaList[AT_CCUG_INFO].paraValue & 0x01;
    } else {
        ssCtx->ccugCfg.suppressPrefer = 0;
        ssCtx->ccugCfg.suppressOa     = 0;
    }
    return AT_OK;
}

TAF_UINT32 At_SetCssnPara(TAF_UINT8 indexNum)
{
    VOS_UINT32         rst;
    TAF_Ctrl           ctrl;
    MN_CALL_SetCssnReq cssnReq;
    ModemIdUint16      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&cssnReq, sizeof(cssnReq), 0x00, sizeof(cssnReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CSSN_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    cssnReq.actNum     = MN_CALL_MAX_CSSN_MSG_NUM;
    cssnReq.setType[0] = MN_CALL_SET_CSSN_DEACT;
    cssnReq.setType[1] = MN_CALL_SET_CSSN_DEACT;

    if (g_atParaList[0].paraLen != 0) {
        cssnReq.setType[0] = (MN_CALL_SetCssnTypeUint32)g_atParaList[0].paraValue;
    }

    if (g_atParaList[1].paraLen != 0) {
        cssnReq.setType[1] = (MN_CALL_SetCssnTypeUint32)g_atParaList[1].paraValue;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送消息 */
    rst = TAF_CCM_CallCommonReq(&ctrl, &cssnReq, ID_TAF_CCM_SET_CSSN_REQ, sizeof(cssnReq), modemId);

    if (rst == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSSN_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

TAF_BOOL At_ParseSingleChldPara(TAF_UINT32 paraValue, MN_CALL_SupsParam *callSupsCmd)
{
    switch (paraValue) {
        case AT_MN_CALL_REL_HELD_OR_UDUB:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_REL_HELD_OR_UDUB;
            break;

        case AT_MN_CALL_REL_ACT_ACPT_OTH:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_REL_ACT_ACPT_OTH;
            break;

        case AT_MN_CALL_HOLD_ACT_ACPT_OTH:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_HOLD_ACT_ACPT_OTH;
            break;

        case AT_MN_CALL_BUILD_MPTY:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_BUILD_MPTY;
            break;

        case AT_MN_CALL_ECT:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_ECT;
            break;

        case AT_MN_CALL_ACT_CCBS:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_ACT_CCBS;
            return AT_OK;

        case AT_MN_CALL_ECONF_REL_USER:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_ECONF_REL_USER;
            break;

        case AT_MN_CALL_ECONF_MERGE_CALL:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_ECONF_MERGE_CALL;
            break;

        case AT_MN_CALL_ACPT_WAITING_CALL:
            callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_ACPT_WAITING_CALL;
            break;

        default:
            return AT_ERROR;
    }
    return AT_OK;
}


TAF_BOOL At_ParseChldPara(TAF_UINT32 paraValue, MN_CALL_SupsParam *callSupsCmd)
{
    TAF_BOOL  bRetRst;
    TAF_UINT8 tmp;

    tmp = (TAF_UINT8)(paraValue / 10); /* 除10是为了获取参数值大于10时的操作码 */

    if (paraValue < 10) { /* 参数值小于10直接获取操作码 */
        bRetRst = At_ParseSingleChldPara(paraValue, callSupsCmd);
    } else {
        switch (tmp) {
            case AT_MN_CALL_REL_CALL_X:
                callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_REL_CALL_X;
                callSupsCmd->callId      = (MN_CALL_ID_T)(paraValue % AT_DECIMAL_BASE_NUM);
                bRetRst                  = AT_OK;
                break;

            case AT_MN_CALL_HOLD_ALL_EXCPT_X:
                callSupsCmd->callSupsCmd = MN_CALL_SUPS_CMD_HOLD_ALL_EXCPT_X;
                callSupsCmd->callId      = (MN_CALL_ID_T)(paraValue % AT_DECIMAL_BASE_NUM);
                bRetRst                  = AT_OK;
                break;

            default:
                bRetRst = AT_ERROR;
                break;
        }
    }
    return bRetRst;
}


TAF_UINT32 At_SetChldPara(TAF_UINT8 indexNum)
{
    MN_CALL_SupsParam callChldParam;
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl      ctrl;
    VOS_UINT32    rst;
    ModemIdUint16 modemId;

    AT_PR_LOGH("At_SetChldPara Enter : CmdType = %d", g_atParaList[0].paraValue);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&callChldParam, sizeof(callChldParam), 0x00, sizeof(callChldParam));

    rst = At_ParseChldPara(g_atParaList[0].paraValue, &callChldParam);
    if (rst == AT_ERROR) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&ctrl, &callChldParam, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(callChldParam), modemId) ==
        VOS_OK) {
        /* 停止自动接听 */
        ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);

        if (ccCtx->s0TimeInfo.timerStart == VOS_TRUE) {
            AT_StopRelTimer(ccCtx->s0TimeInfo.timerName, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }

        AT_PR_LOGH("At_SetChldPara success");

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CHLD_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetChldExPara(VOS_UINT8 indexNum)
{
    MN_CALL_SupsParam callChldParam;
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl      ctrl;
    VOS_UINT32    rst;
    ModemIdUint16 modemId;

    /* 参数过多 */
    if (g_atParaIndex > AT_CHLD_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有增强型多方通话踢人的场景下，才有第3个参数，即chld=6,0,"135xxxxxxxx" */
    if ((g_atParaList[AT_CHLD_CALL_NUM].paraLen != 0) && (g_atParaList[AT_CHLD_OP_CODE].paraValue != 6)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ((g_atParaList[AT_CHLD_OP_CODE].paraLen == 0) || (g_atParaList[AT_CHLD_CALL_TYPE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&callChldParam, sizeof(callChldParam), 0x00, sizeof(callChldParam));

    callChldParam.callType = (MN_CALL_TypeUint8)g_atParaList[AT_CHLD_CALL_TYPE].paraValue;

    rst = At_ParseChldPara(g_atParaList[AT_CHLD_OP_CODE].paraValue, &callChldParam);
    if (rst == AT_ERROR) {
        return AT_ERROR;
    }

    /* 如果是需要释放多方通话中成员，需要携带电话号码 */
    if (callChldParam.callSupsCmd == MN_CALL_SUPS_CMD_ECONF_REL_USER) {
        /* 没有携带号码 */
        if (g_atParaList[AT_CHLD_CALL_NUM].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 检查并转换电话号码 */
        if (AT_FillCalledNumPara((VOS_UINT8 *)g_atParaList[AT_CHLD_CALL_NUM].para,
                                 g_atParaList[AT_CHLD_CALL_NUM].paraLen,
                                 &callChldParam.removeNum) != VOS_OK) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    callChldParam.rttFlg = (VOS_UINT8)g_atParaList[AT_CHLD_RTT_FLG].paraValue;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&ctrl, &callChldParam, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(callChldParam), modemId) ==
        VOS_OK) {
        /* 停止自动接听 */
        ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);

        if (ccCtx->s0TimeInfo.timerStart == VOS_TRUE) {
            AT_StopRelTimer(ccCtx->s0TimeInfo.timerName, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CHLD_EX_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetChupPara(VOS_UINT8 indexNum)
{
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl          ctrl;
    MN_CALL_SupsParam supsCmdPara;
    ModemIdUint16     modemId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&supsCmdPara, sizeof(supsCmdPara), 0x00, sizeof(supsCmdPara));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    supsCmdPara.callSupsCmd = MN_CALL_SUPS_CMD_REL_ALL_CALL;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    if (TAF_CCM_CallCommonReq(&ctrl, &supsCmdPara, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(supsCmdPara), modemId) ==
        VOS_OK) {
        /* 停止自动接听 */
        ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);

        if (ccCtx->s0TimeInfo.timerStart == VOS_TRUE) {
            AT_StopRelTimer(ccCtx->s0TimeInfo.timerName, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CHUP_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_CheckDtmfKey(AT_ParseParaType *atPara)
{
    VOS_CHAR key;

    if (atPara->paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_UpString(atPara->para, atPara->paraLen) != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    key = (VOS_CHAR)atPara->para[0];
    if (!(((key >= '0') && (key <= '9')) || (key == '*') || (key == '#') || (key == 'A') || (key == 'B') ||
          (key == 'C') || (key == 'D'))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_SetVtsPara(TAF_UINT8 indexNum)
{
    VOS_UINT32         result;
    TAF_Ctrl           ctrl;
    TAF_CALL_DtmfParam dtmf;
    ModemIdUint16      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&dtmf, sizeof(dtmf), 0x00, sizeof(dtmf));

    /* 参数类型个数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不是1或2，或者第1个参数长度为0，或者参数个数为2但第2个参数长度为0，均返回错误 */
    if (((g_atParaIndex != 1) && (g_atParaIndex != 2)) || (g_atParaList[0].paraLen == 0) ||
        ((g_atParaIndex == 2) && (g_atParaList[1].paraLen == 0))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数值有效性检查 */
    result = AT_CheckDtmfKey(&g_atParaList[0]);

    if (result != AT_SUCCESS) {
        return result;
    }

    /* 发送START DTMF请求 */
    dtmf.key      = (VOS_CHAR)g_atParaList[0].para[0];
    /* 只有1个参数，时长为默认值 */
    if (g_atParaIndex == 1) {
        dtmf.onLength = AT_VTS_DEFAULT_DTMF_LENGTH;
    } else {
        dtmf.onLength = (VOS_UINT16)(g_atParaList[1].paraValue * AT_VTS_DEFAULT_DTMF_LENGTH);
    }

    dtmf.offLength = 0;

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送消息 */
    result = TAF_CCM_CallCommonReq(&ctrl, &dtmf, ID_TAF_CCM_START_DTMF_REQ, sizeof(dtmf), modemId);

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VTS_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_CheckDtmfPara(VOS_VOID)
{
    
    /* 参数有效性检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaIndex > AT_DTMF_MAX_PARA_NUM) || (g_atParaList[AT_DTMF_ON_LENGTH].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * 发送DTMF时,需要带参数ckey,需要检查参数ckey是否合法
     * 停止DTMF时,不需要带参数ckey,不需要检查参数ckey是否合法
     */
    if (g_atParaList[AT_DTMF_ON_LENGTH].paraValue != AT_DTMF_STOP) {
        if (AT_CheckDtmfKey(&g_atParaList[AT_DTMF_KEY]) != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_SetDtmfPara(VOS_UINT8 indexNum)
{
    VOS_UINT32         result;
    TAF_Ctrl           ctrl;
    TAF_CALL_DtmfParam dtmf;
    ModemIdUint16      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&dtmf, sizeof(dtmf), 0x00, sizeof(dtmf));

    /* 参数有效性检查 */
    result = At_CheckDtmfPara();
    if (result != AT_SUCCESS) {
        return result;
    }

    dtmf.callId = (VOS_UINT8)g_atParaList[AT_DTMF_CALL_ID].paraValue;
    dtmf.key    = (VOS_CHAR)g_atParaList[1].para[0];

    /* 如果时长为1，则使用默认DTMF音时长 */
    if (g_atParaList[AT_DTMF_ON_LENGTH].paraValue == AT_DTMF_START) {
        dtmf.onLength = AT_DTMF_DEFAULT_DTMF_LENGTH;
    } else {
        dtmf.onLength = (VOS_UINT16)g_atParaList[AT_DTMF_ON_LENGTH].paraValue;
    }

    if ((g_atParaList[AT_DTMF_OFF_LENGTH].paraValue == 0) || (g_atParaIndex < AT_DTMF_MAX_PARA_NUM)) {
        dtmf.offLength = 0;
    } else {
        dtmf.offLength = (VOS_UINT16)g_atParaList[AT_DTMF_OFF_LENGTH].paraValue;

        if (dtmf.offLength < AT_DTMF_MIN_DTMF_OFF_LENGTH) {
            /* offlength取值为0或者10ms-60000ms，小于10ms，osa无法启动小于10ms定时器，返回参数错误 */
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    if (dtmf.onLength != AT_DTMF_STOP) {
        result = TAF_CCM_CallCommonReq(&ctrl, &dtmf, ID_TAF_CCM_START_DTMF_REQ, sizeof(dtmf), modemId);
    } else {
        result = TAF_CCM_CallCommonReq(&ctrl, &dtmf, ID_TAF_CCM_STOP_DTMF_REQ, sizeof(dtmf), modemId);
    }

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DTMF_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

/* +Vts命令的打断处理函数 */
VOS_UINT32 AT_AbortVtsPara(VOS_UINT8 indexNum)
{
    TAF_Ctrl           ctrl;
    TAF_CALL_DtmfParam dtmfPara;
    ModemIdUint16      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(TAF_Ctrl), 0x00, sizeof(TAF_Ctrl));
    (VOS_VOID)memset_s(&dtmfPara, sizeof(TAF_CALL_DtmfParam), 0x00, sizeof(TAF_CALL_DtmfParam));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    dtmfPara.key      = (VOS_CHAR)g_atParaList[0].para[0];
    dtmfPara.onLength = AT_DTMF_STOP;

    /* DTMF定制特性是否打开 */
    if (AT_GetModemMbbCustCtxAddrFromClientId(indexNum)->dtmfCustFlg == VOS_FALSE) {
        return AT_FAILURE;
    }

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_FAILURE;
    }

    if (TAF_CCM_CallCommonReq(&ctrl, &dtmfPara, ID_TAF_CCM_STOP_DTMF_REQ, sizeof(dtmfPara), modemId) == VOS_OK) {
        return AT_ABORT;
    }

    return AT_FAILURE;
}

/* ^DTMF命令的打断处理函数 */
VOS_UINT32 AT_AbortDtmfPara(VOS_UINT8 indexNum)
{
    TAF_Ctrl           ctrl;
    TAF_CALL_DtmfParam dtmfPara;
    ModemIdUint16      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(TAF_Ctrl), 0x00, sizeof(TAF_Ctrl));
    (VOS_VOID)memset_s(&dtmfPara, sizeof(TAF_CALL_DtmfParam), 0x00, sizeof(TAF_CALL_DtmfParam));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    dtmfPara.key      = (VOS_CHAR)g_atParaList[1].para[0];
    dtmfPara.onLength = AT_DTMF_STOP;

    /* DTMF定制特性是否打开 */
    if (AT_GetModemMbbCustCtxAddrFromClientId(indexNum)->dtmfCustFlg == VOS_FALSE) {
        return AT_FAILURE;
    }

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_FAILURE;
    }

    if (TAF_CCM_CallCommonReq(&ctrl, &dtmfPara, ID_TAF_CCM_STOP_DTMF_REQ, sizeof(dtmfPara), modemId) == VOS_OK) {
        return AT_ABORT;
    }

    return AT_FAILURE;
}


TAF_UINT32 At_SetCrcPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        ssCtx->crcType = (AT_CRC_TYPE)g_atParaList[0].paraValue;
    } else {
        ssCtx->crcType = AT_CRC_DISABLE_TYPE;
    }

    return AT_OK;
}

TAF_UINT32 At_SetCbstPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CBST_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        ssCtx->cbstDataCfg.speed = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        ssCtx->cbstDataCfg.speed = MN_CALL_CSD_SPD_64K_MULTI;
    }
    if (g_atParaList[1].paraLen != 0) {
        ssCtx->cbstDataCfg.name = (TAF_UINT8)g_atParaList[1].paraValue;
    } else {
        ssCtx->cbstDataCfg.name = MN_CALL_CSD_NAME_SYNC_UDI;
    }
    if (g_atParaList[AT_CBST_CONN_ELEM].paraLen != 0) {
        ssCtx->cbstDataCfg.connElem = (TAF_UINT8)g_atParaList[AT_CBST_CONN_ELEM].paraValue;
    } else {
        ssCtx->cbstDataCfg.connElem = MN_CALL_CSD_CE_T;
    }

    return AT_OK;
}

TAF_UINT32 At_SetCmodPara(TAF_UINT8 indexNum)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    ssCtx->cModType = (TAF_UINT8)g_atParaList[0].paraValue;

    return AT_OK;
}


VOS_UINT32 AT_CmmiProcUssd(VOS_UINT8 indexNum, TAF_SS_ProcessUssReq *ussdReq)
{
    TAF_UINT8  ussdStr[TAF_SS_MAX_USSDSTRING_LEN * 2];
    VOS_UINT32 procStrLen;
    VOS_UINT32 ret;

    (VOS_VOID)memset_s(ussdStr, sizeof(ussdStr), 0, sizeof(ussdStr));

    procStrLen = 0;

    /* 由于SSA的7Bit编解码上移至AT，CMMI下发前需将码流从Ascii转到Hex */
    /* TAF_SS_MAX_USSDSTRING_LEN * 2为数组ussdStr定义时的最大长度 */
    ret = TAF_STD_ConvertAsciiToDefAlpha(ussdReq->ussdStr.ussdStr, ussdReq->ussdStr.cnt, ussdStr, &procStrLen,
                                         TAF_SS_MAX_USSDSTRING_LEN * 2);

    ussdReq->ussdStr.cnt = (VOS_UINT16)procStrLen;

    if (ret != MN_ERR_NO_ERROR) {
        AT_WARN_LOG("AT_CmmiProcUssd : Conv7Bit Def Err");
        return TAF_FAILURE;
    }

    /* 清除原码流残余信息 */
    (VOS_VOID)memset_s(ussdReq->ussdStr.ussdStr, sizeof(ussdReq->ussdStr.ussdStr), 0, sizeof(ussdReq->ussdStr.ussdStr));

    ret = TAF_STD_Pack7Bit(ussdStr, ussdReq->ussdStr.cnt, 0, ussdReq->ussdStr.ussdStr, &procStrLen);

    ussdReq->ussdStr.cnt = (VOS_UINT16)procStrLen;

    if (ret != MN_ERR_NO_ERROR) {
        AT_WARN_LOG("AT_CmmiProcUssd : Conv7Bit pack Err");
        return TAF_FAILURE;
    }

    /* CMMI只带USSDString,默认打开主动上报 */
    ussdReq->cusdType = TAF_SS_CUSD_TYPE_ENABLE;

    /* 调用TAF接口发送 */
    if (TAF_ProcessUnstructuredSSReq(g_atClientTab[indexNum].clientId, 0, ussdReq) != TAF_SUCCESS) {
        AT_WARN_LOG("AT_CmmiProcUssd: TAF_ProcessUnstructuredSSReq failed");
        return TAF_FAILURE;
    }

    return TAF_SUCCESS;
}


VOS_UINT32 At_SetCmmiPara(VOS_UINT8 indexNum)
{
    VOS_BOOL               inCall;
    MN_MMI_OperationParam *mmiOpParam      = VOS_NULL_PTR;
    VOS_CHAR              *pcOutRestMmiStr = VOS_NULL_PTR;
    VOS_UINT32             result;
    AT_CmdCurrentOpt       cmdCurrentOpt;
    AT_ModemSsCtx         *ssCtx = VOS_NULL_PTR;
    AT_ModemCcCtx         *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl               ctrl;
    ModemIdUint16          modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);
    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 没有呼叫存在的情况 */
    if (ccCtx->curIsExistCallFlag == VOS_FALSE) {
        inCall = VOS_FALSE;
    } else {
        inCall = VOS_TRUE;
    }
    /*lint -save -e516 */
    mmiOpParam = (MN_MMI_OperationParam *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(MN_MMI_OperationParam));
    /*lint -restore */
    if (mmiOpParam == TAF_NULL_PTR) {
        AT_WARN_LOG("At_SetCmmiPara Mem Alloc FAILURE");
        return AT_ERROR;
    }

    g_clirOperate = MN_CALL_CLIR_AS_SUBS;

    pcOutRestMmiStr                          = (VOS_CHAR *)g_atParaList[0].para;
    pcOutRestMmiStr[g_atParaList[0].paraLen] = '\0';
    result = MN_MmiStringParse((VOS_CHAR *)(g_atParaList[0].para), inCall, mmiOpParam, &pcOutRestMmiStr);
    mmiOpParam->processUssdReq.datacodingScheme = TAF_SS_7bit_LANGUAGE_UNSPECIFIED;

    if (result == MN_ERR_NO_ERROR) {
        switch (mmiOpParam->mmiOperationType) {
            case TAF_MMI_SUPPRESS_CLIR:
            case TAF_MMI_INVOKE_CLIR:

                if (mmiOpParam->mmiOperationType == TAF_MMI_SUPPRESS_CLIR) {
                    g_clirOperate = MN_CALL_CLIR_SUPPRESS;
                } else {
                    g_clirOperate = MN_CALL_CLIR_INVOKE;
                }

                if ((VOS_UINT16)(pcOutRestMmiStr - (VOS_CHAR *)(g_atParaList[0].para)) < g_atParaList[0].paraLen) {
                    result = MN_MmiStringParse(pcOutRestMmiStr, inCall, mmiOpParam, &pcOutRestMmiStr);
                } else {
                    /*lint -save -e516 */
                    PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
                    /*lint -restore */
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                break;
            default:
                break;
        }
        if (result != MN_ERR_NO_ERROR) {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
            /*lint -restore */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 保存密码 */

        /* 调用TAF提供的接口，处理SS命令 */
        cmdCurrentOpt = At_GetMnOptType(mmiOpParam->mmiOperationType);
        if (cmdCurrentOpt == AT_CMD_INVALID) {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
            /*lint -restore */
            return AT_ERROR;
        }
        switch (cmdCurrentOpt) {
            case AT_CMD_D_CS_VOICE_CALL_SET:

                /* AT向CCM发送呼叫请求 */
                if (TAF_CCM_CallCommonReq(&ctrl, &(mmiOpParam->mnCallOrig), ID_TAF_CCM_CALL_ORIG_REQ,
                                          sizeof(mmiOpParam->mnCallOrig), modemId) != VOS_OK) {
                    AT_WARN_LOG("At_SetCmmiPara: MN_CALL_Orig failed.");
                }
                break;
            case AT_CMD_CHLD_SET:

                /* AT向CCM发送补充业务请求 */
                if (TAF_CCM_CallCommonReq(&ctrl, &(mmiOpParam->mnCallSupsReq), ID_TAF_CCM_CALL_SUPS_CMD_REQ,
                                          sizeof(mmiOpParam->mnCallSupsReq), modemId) != VOS_OK) {
                    AT_WARN_LOG("At_SetCmmiPara: MN_CALL_Sups failed.");
                }
                break;
            case AT_CMD_CPIN_UNBLOCK_SET:
                if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->pinReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_CPIN2_UNBLOCK_SET:
                if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->pinReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_CPIN_VERIFY_SET:
                if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->pinReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }

                break;
            case AT_CMD_CPIN2_VERIFY_SET:
                if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->pinReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: Taf_PhonePinHandle failed.");
                }
                break;
            case AT_CMD_SS_REGISTER:
                if (TAF_RegisterSSReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->registerSsReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_RegisterSSReq failed.");
                }
                break;
            case AT_CMD_SS_ERASE:
                if (TAF_EraseSSReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->eraseSsReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_EraseSSReq failed.");
                }
                break;
            case AT_CMD_SS_ACTIVATE:
                if (TAF_ActivateSSReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->activateSsReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_ActivateSSReq failed.");
                }
                break;
            case AT_CMD_SS_DEACTIVATE:
                if (TAF_DeactivateSSReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->deactivateSsReq) !=
                    TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_DeactivateSSReq failed.");
                }
                break;

            case AT_CMD_SS_DEACTIVE_CCBS:
                if (TAF_EraseCCEntryReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->ccbsEraseReq) !=
                    TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_EraseCCEntryReq failed.");
                }
                break;

            case AT_CMD_SS_INTERROGATE:
            case AT_CMD_SS_INTERROGATE_CCBS:
                if (TAF_InterrogateSSReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->interrogateSsReq) !=
                    TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_DeactivateSSReq failed.");
                }
                break;
            case AT_CMD_SS_REGISTER_PSWD:
                if (TAF_RegisterPasswordReq(g_atClientTab[indexNum].clientId, 0, &mmiOpParam->regPwdReq) !=
                    TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: TAF_InterrogateSSReq failed.");
                }
                break;
            /* 删除AT_CMD_SS_GET_PSWD 分支 */
            case AT_CMD_CUSD_REQ:
                if (AT_CmmiProcUssd(indexNum, &mmiOpParam->processUssdReq) != TAF_SUCCESS) {
                    AT_WARN_LOG("At_SetCmmiPara: AT_CmmiProcUssd failed.");
                }
                break;
            case AT_CMD_CLIP_READ:
                ssCtx->clipType = (AT_CLIP_TYPE)g_atParaList[0].paraValue;
                /*lint -save -e516 */
                PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
                /*lint -restore */
                return AT_OK;
            default:
                break;
        }
        g_atClientTab[indexNum].cmdCurrentOpt = cmdCurrentOpt;
        (VOS_VOID)memset_s(g_atParaList[0].para, sizeof(g_atParaList[0].para), 0x00, sizeof(g_atParaList[0].para));
        (VOS_VOID)memset_s(mmiOpParam, sizeof(MN_MMI_OperationParam), 0x00, sizeof(MN_MMI_OperationParam));
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
        /*lint -restore */
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, mmiOpParam);
        /*lint -restore */
        return AT_CME_INCORRECT_PARAMETERS;
    }
}


VOS_UINT32 AT_CheckApnCustomChar(VOS_UINT8 apnCharacter, VOS_UINT16 clientId)
{
    AT_CommPsCtx *commPsCtx = VOS_NULL_PTR;
    VOS_UINT32    i;
    ModemIdUint16 modemId;

    modemId   = MODEM_ID_0;
    commPsCtx = AT_GetCommPsCtxAddr();

    /* 获取modem id */
    if (AT_GetModemIdFromClient(clientId, &modemId) != VOS_OK) {
        AT_WARN_LOG("AT_CheckApnCustomChar: Get ModemId Failed.");
        return VOS_ERR;
    }

    /* 匹配定制字符 */
    for (i = 0; i < commPsCtx->apnCustomFormatCfg[modemId].customCharNum; i++) {
        if (apnCharacter == commPsCtx->apnCustomFormatCfg[modemId].customChar[i]) {
            return VOS_OK;
        }
    }

    return VOS_ERR;
}


VOS_UINT32 AT_CheckApnFirstAndLastChar(VOS_UINT8 apnCharacter, VOS_UINT16 clientId)
{
    if (!(((apnCharacter >= 'A') && (apnCharacter <= 'Z')) || ((apnCharacter >= '0') && (apnCharacter <= '9')) ||
          (AT_CheckApnCustomChar(apnCharacter, clientId) == VOS_OK))) {
        AT_WARN_LOG("AT_CheckApnFirstAndLastChar: WARNING: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckApnFirstAndLastString(VOS_UINT8 *apn, VOS_UINT16 apnLen, VOS_UINT16 clientId)
{
    AT_CommPsCtx *commPsCtx = VOS_NULL_PTR;
    VOS_UINT8     apnInfo[TAF_MAX_APN_LEN + 1];
    errno_t       memResult;
    ModemIdUint16 modemId;

    modemId   = MODEM_ID_0;
    commPsCtx = AT_GetCommPsCtxAddr();
    (VOS_VOID)memset_s(apnInfo, sizeof(apnInfo), 0x00, sizeof(apnInfo));

    /* 获取modem id */
    if (AT_GetModemIdFromClient(clientId, &modemId) != VOS_OK) {
        AT_WARN_LOG("AT_CheckApnFirstAndLastString: Get ModemId Failed.");
        return VOS_OK;
    }

    /* 不需要检查直接返回OK */
    if (commPsCtx->apnCustomFormatCfg[modemId].protocolStringCheckFlag == VOS_FALSE) {
        return VOS_OK;
    }

    /*
     * TS 23.003 9.1.1
     * The APN Network Identifier shall contain at least one label and shall have,
     * after encoding as defined in subclause 9.1 above, a maximum length of 63 octets.
     * An APN Network Identifier shall not start with any of the strings "rac", "lac",
     * "sgsn" or "rnc", and it shall not end in ".gprs", i.e. the last label of the
     * APN Network Identifier shall not be "gprs". Further, it shall not take the value "*".
     */

    if ((apnLen > 0) && (apnLen <= sizeof(apnInfo))) {
        memResult = memcpy_s(apnInfo, sizeof(apnInfo), apn, apnLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(apnInfo), apnLen);
    }

    (VOS_VOID)At_UpString(apnInfo, apnLen);

    /* 判断头部字符串 */
    if (!(TAF_MEM_CMP(apnInfo, "RAC", AT_PS_RAC_STRING_LENGTH) &&
          TAF_MEM_CMP(apnInfo, "LAC", AT_PS_LAC_STRING_LENGTH) &&
          TAF_MEM_CMP(apnInfo, "SGSN", AT_PS_SGSN_STRING_LENGTH) &&
          TAF_MEM_CMP(apnInfo, "RNC", AT_PS_RNC_STRING_LENGTH))) {
        return VOS_ERR;
    }

    /* 判断尾部字符串 */
    if (apnLen >= sizeof("GRPS")) {
        if (!TAF_MEM_CMP(apnInfo + apnLen - AT_PS_GRPS_STRING_LENGTH, "GPRS", AT_PS_GRPS_STRING_LENGTH)) {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckApnFormat(VOS_UINT8 *apn, VOS_UINT16 apnLen, VOS_UINT16 clientId)
{
    VOS_UINT32 i;
    VOS_UINT8  apnCharacter;

    for (i = 0; i < apnLen; i++) {
        /* 转换APN字符为大写 */
        apnCharacter = AT_UPCASE(apn[i]);

        /* 检查APN字符有效性 */
        if (!(((apnCharacter >= 'A') && (apnCharacter <= 'Z')) || ((apnCharacter >= '0') && (apnCharacter <= '9')) ||
              (apnCharacter == '-') || (apnCharacter == '.') ||
              (AT_CheckApnCustomChar(apnCharacter, clientId) == VOS_OK))) {
            AT_WARN_LOG("AT_CheckApnFormat: Invalid character in APN.");
            return VOS_ERR;
        }
    }

    /* 检查APN开始字符有效性 */
    apnCharacter = AT_UPCASE(apn[0]);
    if (AT_CheckApnFirstAndLastChar(apnCharacter, clientId) != VOS_OK) {
        AT_WARN_LOG("AT_CheckApnFormat: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    /* 检查APN末尾字符有效性 */
    apnCharacter = AT_UPCASE(apn[apnLen - 1]);
    if (AT_CheckApnFirstAndLastChar(apnCharacter, clientId) != VOS_OK) {
        AT_WARN_LOG("AT_CheckApnFormat: Invalid begin/end character in APN.");
        return VOS_ERR;
    }

    /* 检查APN开头末尾是否包含不期望的字符串 */
    if (AT_CheckApnFirstAndLastString(apn, apnLen, clientId) != VOS_OK) {
        AT_WARN_LOG("AT_CheckApnFormat: UnexpectString in APN.");
        return VOS_ERR;
    }

    return VOS_OK;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

LOCAL VOS_UINT32 AT_CheckSNssaiFormat(VOS_UINT8 *sNssai, VOS_UINT16 sNssaiLen)
{
    VOS_UINT32 i;
    VOS_UINT8  character;

    for (i = 0; i < sNssaiLen; i++) {
        character = AT_UPCASE(sNssai[i]);

        /* 检查S-NSSAI字符有效性 */
        if (!(((character >= '0') && (character <= '9')) || ((character >= 'A') && (character <= 'F')) ||
              (character == ';') || (character == '.'))) {
            AT_WARN_LOG("AT_CheckSNssaiFormat: WARNING: Invalid character in S-NSSAI.");
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeSNssaiPara(VOS_UINT8 *sNssai, VOS_UINT16 sNssaiLen, AT_SNssaiParse *sNssaiParse)
{
    VOS_UINT32 i;
    VOS_UINT32 digitCount;
    VOS_UINT8  character;

    digitCount = 0;

    for (i = 0; i < sNssaiLen; i++) {
        character = AT_UPCASE(sNssai[i]);

        if ((character >= '0') && (character <= '9')) {
            /* 高位数值左移4bit */
            sNssaiParse->digite[sNssaiParse->digitParaNum] =
                (VOS_UINT32)(sNssaiParse->digite[sNssaiParse->digitParaNum] << AT_OCTET_MOVE_FOUR_BITS);
            sNssaiParse->digite[sNssaiParse->digitParaNum] += (VOS_UINT32)(sNssai[i] - '0');

            digitCount++;
            if (digitCount > AT_S_NSSAI_SD_MAX_DIGIT_NUM) {
                /* 每个参数的位数最多不超过6 */
                return VOS_ERR;
            }
        } else if ((character >= 'A') && (character <= 'F')) {
            /* 高位数值左移4bit */
            sNssaiParse->digite[sNssaiParse->digitParaNum] =
                (VOS_UINT32)(sNssaiParse->digite[sNssaiParse->digitParaNum] << AT_OCTET_MOVE_FOUR_BITS);
            sNssaiParse->digite[sNssaiParse->digitParaNum] += (VOS_UINT32)((character - 'A') + 0x0A);

            digitCount++;
            if (digitCount > AT_S_NSSAI_SD_MAX_DIGIT_NUM) {
                /* 每个参数的位数最多不超过6 */
                return VOS_ERR;
            }
        } else {
            if (digitCount == 0) {
                /* 字符串如果以符号开头，或者字符串中出现连续的符号，则输入错误 */
                return VOS_ERR;
            }

            if ((i + 1) == sNssaiLen) {
                /* 如果最后1个字符是符号，说明少1个数字，需要返回错误 */
                return VOS_ERR;
            }

            /* 数值字符计数清0 */
            digitCount = 0;

            /* 记录字符 */
            sNssaiParse->punctuation[sNssaiParse->punctuationNum] = sNssai[i];

            /* 准备记录下一个数字或者字符 */
            sNssaiParse->digitParaNum++;
            sNssaiParse->punctuationNum++;

            if ((sNssaiParse->digitParaNum > AT_S_NSSAI_MAX_DIGIT_NUM) ||
                (sNssaiParse->punctuationNum > AT_S_NSSAI_MAX_PUNC_NUM)) {
                return VOS_ERR;
            }
        }
    }

    /* 记录最后一个数字后，计数加1 */
    sNssaiParse->digitParaNum++;

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_CheckSNssaiPunctuationPara(AT_SNssaiParse *sNssaiParse)
{
    /*
     * sst                                     only slice/service type (SST) is present
     * sst;mapped_sst                          SST and mapped configured SST are present
     * sst.sd                                  SST and slice differentiator (SD) are present
     * sst.sd;mapped_sst                       SST, SD and mapped configured SST are present
     * sst.sd;mapped_sst.mapped_sd             SST, SD, mapped configured SST and mapped configured SD are present
     */

    VOS_UINT8 puncMould[AT_S_NSSAI_MAX_PUNC_NUM + 1] = { '.', ';', '.', 0 };
    VOS_UINT8 num;

    if (sNssaiParse->punctuationNum == 0) {
        return VOS_OK;
    }

    num = AT_MIN(sNssaiParse->punctuationNum, AT_S_NSSAI_MAX_PUNC_NUM);

    if ((num == 0x01) && (sNssaiParse->punctuation[0] == ';')) {
        /* 此情况是合法的 */
        return VOS_OK;
    }

    if (PS_MEM_CMP(puncMould, sNssaiParse->punctuation, num) != 0) {
        return VOS_ERR;
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_CheckSNssaiDigitPara(AT_SNssaiParse *sNssaiParse)
{
    /* 本函数主要检查SST和MAP SST的取值范围，SD在解析时做了检查 */

    /* 检查第一个数值，应该为SST */
    if (sNssaiParse->digite[0] > 0xFF) {
        return VOS_ERR;
    }

    if (sNssaiParse->punctuationNum == 1) {
        /* 如果为SST;MAP SST的格式，检查MAP SST的参数值 */
        if (sNssaiParse->punctuation[0] == ';') {
            if (sNssaiParse->digite[1] > 0xFF) {
                return VOS_ERR;
            }
        }
    }

    if ((sNssaiParse->punctuationNum == AT_S_NSSAI_PUNC_NUM) ||
        (sNssaiParse->punctuationNum == AT_S_NSSAI_MAX_PUNC_NUM)) {
        /* 如果为SST.SD;map_SST或者SST.map_SD;map_SST.map_SD的格式，检查MAP SST的参数值 */
        if (sNssaiParse->digite[AT_S_NSSAI_DIGIT_INDEX_2] > 0xFF) {
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeSNssai(VOS_UINT8 *sNssai, VOS_UINT16 sNssaiLen, PS_S_NSSAI_STRU *sNssaiOut)
{
    AT_SNssaiParse sNssaiInfo;

    /*
     * 27007 rel15, 10.1.1章节
     * sst                                     only slice/service type (SST) is present
     * sst;mapped_sst                          SST and mapped configured SST are present
     * sst.sd                                  SST and slice differentiator (SD) are present
     * sst.sd;mapped_sst                       SST, SD and mapped configured SST are present
     * sst.sd;mapped_sst.mapped_sd             SST, SD, mapped configured SST and mapped configured SD are present
     */

    (VOS_VOID)memset_s(sNssaiOut, sizeof(PS_S_NSSAI_STRU), 0, sizeof(PS_S_NSSAI_STRU));
    (VOS_VOID)memset_s(&sNssaiInfo, sizeof(sNssaiInfo), 0, sizeof(AT_SNssaiParse));

    /* 检查S-NSSAI字符串中的字符格式是否正确  */
    if (AT_CheckSNssaiFormat(sNssai, sNssaiLen) == VOS_ERR) {
        return VOS_ERR;
    }

    /* 解析S-NSSAI字符串 */
    if (AT_DecodeSNssaiPara(sNssai, sNssaiLen, &sNssaiInfo) == VOS_ERR) {
        return VOS_ERR;
    }

    /* 先检查分割符是否正确 */
    if (AT_CheckSNssaiPunctuationPara(&sNssaiInfo) == VOS_ERR) {
        return VOS_ERR;
    }

    /* 再检查数值是否正确 */
    if (AT_CheckSNssaiDigitPara(&sNssaiInfo) == VOS_ERR) {
        return VOS_ERR;
    }

    /* 赋值 */
    if (sNssaiInfo.digitParaNum == 1) {
        /* SST */
        sNssaiOut->ucSst = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_0];
    } else if (sNssaiInfo.digitParaNum == 2) { /* 2表示S-NSSAI字符串被标点符号分隔为两部分 */
        /* SST.SD或者SST;map_SST */
        sNssaiOut->ucSst = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_0];

        /* 如果解析成功，判断后续字符是"."还是";" */
        if (sNssaiInfo.punctuation[0] == '.') {
            sNssaiOut->bitOpSd = VOS_TRUE;
            sNssaiOut->ulSd    = sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_1];
        } else {
            sNssaiOut->bitOpMappedSst = VOS_TRUE;
            sNssaiOut->ucMappedSst    = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_1];
        }
    } else if (sNssaiInfo.digitParaNum == 3) { /* 3表示S-NSSAI字符串被标点符号分隔为3部分 */
        /* SST.SD;map_SST */
        sNssaiOut->ucSst          = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_0];
        sNssaiOut->bitOpSd        = VOS_TRUE;
        sNssaiOut->ulSd           = sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_1];
        sNssaiOut->bitOpMappedSst = VOS_TRUE;
        sNssaiOut->ucMappedSst    = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGIT_INDEX_2];
    } else {
        /* SST.SD;map_SST.map_SD */
        sNssaiOut->ucSst          = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_0];
        sNssaiOut->bitOpSd        = VOS_TRUE;
        sNssaiOut->ulSd           = sNssaiInfo.digite[AT_S_NSSAI_DIGITE_INDEX_1];
        sNssaiOut->bitOpMappedSst = VOS_TRUE;
        sNssaiOut->ucMappedSst    = (VOS_UINT8)sNssaiInfo.digite[AT_S_NSSAI_DIGIT_INDEX_2];
        sNssaiOut->bitOpMappedSd  = VOS_TRUE;
        sNssaiOut->ulMappedSd     = sNssaiInfo.digite[AT_S_NSSAI_DIGIT_INDEX_3];
    }

    /* SD值如果是全F，是非法的，需要将OP项设置为False */
    if (sNssaiOut->ulSd == 0xffffff) {
        sNssaiOut->bitOpSd = VOS_FALSE;
        sNssaiOut->ulSd    = 0;
    }

    /* SD值如果是全F，是非法的，需要将OP项设置为False */
    if (sNssaiOut->ulMappedSd == 0xffffff) {
        sNssaiOut->bitOpMappedSd = VOS_FALSE;
        sNssaiOut->ulMappedSd    = 0;
    }

    return VOS_OK;
}


LOCAL VOS_UINT32 AT_DecodeMultiSNssaiString(VOS_UINT16 cfgSNssaiLen, VOS_UINT8 *sNssai, VOS_UINT16 sNssaiLen,
                                            PS_CONFIGURED_Nssai *sNssaiInfo)
{
    VOS_UINT8       temp[AT_SINGLE_S_NSSAI_MAX_STR_LEN] = {0};
    PS_S_NSSAI_STRU singleNssai;
    VOS_UINT32      i;
    VOS_UINT32      j;

    (VOS_VOID)memset_s(&singleNssai, sizeof(singleNssai), 0, sizeof(PS_S_NSSAI_STRU));

    /* 对用户配置的长度进行非法校验 */
    if (cfgSNssaiLen > AT_EVT_MULTI_S_NSSAI_LEN) {
        return VOS_ERR;
    }

    /* 如果切片长度为0，直接删除切片 */
    if (sNssaiLen == 0) {
        if (cfgSNssaiLen != 0) {
            return VOS_ERR;
        }

        sNssaiInfo->snssaiNum = 0;

        return VOS_OK;
    }

    /* 首尾的字符串不能是切片间隔符号: */
    if ((sNssai[0] == ':') || (sNssai[sNssaiLen - 1] == ':')) {
        return VOS_ERR;
    }

    j = 0;

    for (i = 0; i < sNssaiLen; i++) {
        if (sNssai[i] != ':') {
            /* 选出单个切片字符串 */
            temp[j] = sNssai[i];

            j++;

            if (j >= AT_SINGLE_S_NSSAI_MAX_STR_LEN) {
                return VOS_ERR;
            }

            if (i != (sNssaiLen - 1)) {
                continue;
            }
        }

        if (j == 0) {
            AT_WARN_LOG("AT_DecodeMultiSNssaiString: WARNING: Invalid S-NSSAI length.");
            return VOS_ERR;
        }

        if (AT_DecodeSNssai(temp, (VOS_UINT16)j, &singleNssai) != VOS_OK) {
            AT_WARN_LOG("AT_DecodeMultiSNssaiString: WARNING: decode single nssai err.");
            return VOS_ERR;
        }

        /* 超出最大规格 */
        if (sNssaiInfo->snssaiNum >= PS_MAX_CFG_S_NSSAI_NUM) {
            AT_WARN_LOG("AT_DecodeMultiSNssaiString: WARNING: too max.");
            return VOS_ERR;
        }

        /* 取出有效切片 */
        sNssaiInfo->snssai[sNssaiInfo->snssaiNum] = singleNssai;

        /* 切片个数累加 */
        sNssaiInfo->snssaiNum++;

        /* 重新将索引设置为0 */
        j = 0;
    }

    return VOS_OK;
}

#endif


VOS_VOID AT_ParseCgdcontPara(TAF_PDP_PrimContextExt *pdpCxtInfo)
{
    /* 设置<d_comp> */
    if (g_atParaList[AT_CGDCONT_D_COMP].paraLen != 0) {
        pdpCxtInfo->opPdpDcomp = VOS_TRUE;
        pdpCxtInfo->pdpDcomp   = (VOS_UINT8)g_atParaList[AT_CGDCONT_D_COMP].paraValue;
    }

    /* 设置<h_comp> */
    if (g_atParaList[AT_CGDCONT_H_COMP].paraLen != 0) {
        pdpCxtInfo->opPdpHcomp = VOS_TRUE;
        pdpCxtInfo->pdpHcomp   = (VOS_UINT8)g_atParaList[AT_CGDCONT_H_COMP].paraValue;
    }

    /* 设置<IPv4AddrAlloc> */
    if (g_atParaList[AT_CGDCONT_IPV4_ADDR_ALLOC].paraLen != 0) {
        pdpCxtInfo->opIpv4AddrAlloc = VOS_TRUE;
        pdpCxtInfo->ipv4AddrAlloc   = (VOS_UINT8)g_atParaList[AT_CGDCONT_IPV4_ADDR_ALLOC].paraValue;
    }

    /* 设置<Emergency Indication> */
    if (g_atParaList[AT_CGDCONT_EMERGENCY_INDICATION].paraLen != 0) {
        pdpCxtInfo->opEmergencyInd = VOS_TRUE;
        pdpCxtInfo->emergencyFlg   = (VOS_UINT8)g_atParaList[AT_CGDCONT_EMERGENCY_INDICATION].paraValue;
    }

    /* 设置<P-CSCF_discovery> */
    if (g_atParaList[AT_CGDCONT_P_CSCF_DISCOVERY].paraLen != 0) {
        pdpCxtInfo->opPcscfDiscovery = VOS_TRUE;
        pdpCxtInfo->pcscfDiscovery   = (VOS_UINT8)g_atParaList[AT_CGDCONT_P_CSCF_DISCOVERY].paraValue;
    }
    /* 设置<IM_CN_Signalling_Flag_Ind> */
    if (g_atParaList[AT_CGDCONT_IM_CN_SIGNALLING_FLAG_IND].paraLen != 0) {
        pdpCxtInfo->opImCnSignalFlg = VOS_TRUE;
        pdpCxtInfo->imCnSignalFlg   = (VOS_UINT8)g_atParaList[AT_CGDCONT_IM_CN_SIGNALLING_FLAG_IND].paraValue;
    }
    /* 设置<NAS_Signalling_Prio_Ind> */
    if (g_atParaList[AT_CGDCONT_NAS_SIGNALLING_PRIO_IND].paraLen != 0) {
        pdpCxtInfo->opNasSigPrioInd = VOS_TRUE;
        pdpCxtInfo->nasSigPrioInd   = (VOS_UINT8)g_atParaList[AT_CGDCONT_NAS_SIGNALLING_PRIO_IND].paraValue;
    }
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    /* 设置<SSC_mode> */
    if (g_atParaList[AT_CGDCONT_SSC_MODE].paraLen != 0) {
        pdpCxtInfo->opSscMode = VOS_TRUE;
        pdpCxtInfo->sscMode   = (VOS_UINT8)g_atParaList[AT_CGDCONT_SSC_MODE].paraValue;
    }

    /* 设置<Pref_access_type> */
    if (g_atParaList[AT_CGDCONT_PREF_ACCESS_TYPE].paraLen != 0) {
        pdpCxtInfo->opPrefAccessType = VOS_TRUE;
        pdpCxtInfo->prefAccessType   = (VOS_UINT8)g_atParaList[AT_CGDCONT_PREF_ACCESS_TYPE].paraValue;
    }

    /* 设置<RQos_ind> */
    if (g_atParaList[AT_CGDCONT_RQOS_IND].paraLen != 0) {
        pdpCxtInfo->opRQosInd = VOS_TRUE;
        pdpCxtInfo->rQosInd   = (VOS_UINT8)g_atParaList[AT_CGDCONT_RQOS_IND].paraValue;
    }

    /* 设置<always on ind> */
    if (g_atParaList[AT_CGDCONT_ALWAYS_ON_IND].paraLen != 0) {
        pdpCxtInfo->opAlwaysOnInd = VOS_TRUE;
        pdpCxtInfo->alwaysOnInd   = (VOS_UINT8)g_atParaList[AT_CGDCONT_ALWAYS_ON_IND].paraValue;
    }
#endif
}


LOCAL AT_RreturnCodeUint32 AT_ParseCgdcontIpType(TAF_PDP_PrimContextExt *pdpCxtInfo)
{
    /*
     * 对比终端的结果，在<PDP_type>参数为""(两个引号)时,则保留原先的值，
     * 若g_TafCidTab[ucCid].ucUsed指示上下文被删除，则使用之前保留下来的值
     */
    if (g_atParaList[1].paraLen != 0) {
        /* IP:1, IPV6:2, IPV4V6:3, PPP:4, Ethernet:8 */
        switch (g_atParaList[1].paraValue) {
            case AT_PDP_TYPE_IPV4:
                pdpCxtInfo->pdpType = TAF_PDP_IPV4;
                break;
            case AT_PDP_TYPE_IPV6:
                pdpCxtInfo->pdpType = TAF_PDP_IPV6;
                break;
            case AT_PDP_TYPE_IPV4V6:
                pdpCxtInfo->pdpType = TAF_PDP_IPV4V6;
                break;
            case AT_PDP_TYPE_PPP:
                pdpCxtInfo->pdpType = TAF_PDP_PPP;
                break;
            case AT_PDP_TYPE_ETHERNET:
                if (AT_GetEthernetCap() == VOS_TRUE) {
                    pdpCxtInfo->pdpType = TAF_PDP_ETHERNET;
                    break;
                } else {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
            default:
                return AT_CME_INCORRECT_PARAMETERS;
        }

        if ((pdpCxtInfo->pdpType == TAF_PDP_IPV6) || (pdpCxtInfo->pdpType == TAF_PDP_IPV4V6)) {
            if (AT_GetIpv6Capability() == AT_IPV6_CAPABILITY_IPV4_ONLY) {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
        pdpCxtInfo->opPdpType = VOS_TRUE;
    }
    return AT_SUCCESS;
}


LOCAL AT_RreturnCodeUint32 AT_ParseCgdcontApn(TAF_PDP_PrimContextExt *pdpCxtInfo, VOS_UINT16 clientId)
{
    errno_t memResult;
    if (g_atParaList[AT_CGDCONT_APN].paraLen > TAF_MAX_APN_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_CGDCONT_APN].paraLen != 0) {
        /* 检查APN */
        if (AT_CheckApnFormat(g_atParaList[AT_CGDCONT_APN].para,
                              g_atParaList[AT_CGDCONT_APN].paraLen, clientId) != VOS_OK) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pdpCxtInfo->opApn = VOS_TRUE;
        memResult = memcpy_s((VOS_CHAR *)pdpCxtInfo->apn, sizeof(pdpCxtInfo->apn),
                             (VOS_CHAR *)g_atParaList[AT_CGDCONT_APN].para,
                             g_atParaList[AT_CGDCONT_APN].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pdpCxtInfo->apn), g_atParaList[AT_CGDCONT_APN].paraLen);
        pdpCxtInfo->apn[g_atParaList[AT_CGDCONT_APN].paraLen] = 0;
    }

    return AT_SUCCESS;
}


LOCAL AT_RreturnCodeUint32 AT_ParseCgdcontIpAddr(TAF_PDP_PrimContextExt *pdpCxtInfo)
{
    if (g_atParaList[AT_CGDCONT_PDP_ADDRESS].paraLen != 0) {
        if (((g_atParaList[1].paraValue + 1) != TAF_PDP_IPV4) ||
            (g_atParaList[AT_CGDCONT_PDP_ADDRESS].paraLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1))) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pdpCxtInfo->opPdpAddr       = VOS_TRUE;
        pdpCxtInfo->pdpAddr.pdpType = TAF_PDP_IPV4;

        /* 把IP地址字符串转换成数字 */
        if (AT_Ipv4AddrAtoi((VOS_CHAR *)g_atParaList[AT_CGDCONT_PDP_ADDRESS].para,
                            (VOS_UINT8 *)pdpCxtInfo->pdpAddr.ipv4Addr,
                            TAF_IPV4_ADDR_LEN) != VOS_OK) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

LOCAL AT_RreturnCodeUint32 AT_ParseCgdcontSNssai(TAF_PDP_PrimContextExt *pdpCxtInfo)
{
    /* 解析S-NSSAI参数 */
    if (g_atParaList[AT_CGDCONT_S_NSSAI].paraLen != 0) {
        if (AT_DecodeSNssai(g_atParaList[AT_CGDCONT_S_NSSAI].para,
            g_atParaList[AT_CGDCONT_S_NSSAI].paraLen, &pdpCxtInfo->sNssai) != VOS_OK) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        pdpCxtInfo->opSNssai = VOS_TRUE;
    }

    return AT_SUCCESS;
}


LOCAL AT_RreturnCodeUint32 AT_ParseCgdcontMhpv6(TAF_PDP_PrimContextExt *pdpCxtInfo)
{
    /* 设置<MH6-PDU> */
    if (g_atParaList[AT_CGDCONT_MH6_PDU].paraLen != 0) {
        pdpCxtInfo->opMh6Pdu = VOS_TRUE;
        pdpCxtInfo->mh6Pdu   = (VOS_UINT8)g_atParaList[AT_CGDCONT_MH6_PDU].paraValue;
    }

    /* 参考24501 6.2.11章节，只有在IPV6或者IPV4V6类型时，才需要支持MHPV6 */
    if (pdpCxtInfo->mh6Pdu == TAF_PS_IPV6_MULTI_HOMING_IND_SUPPORT) {
        if ((pdpCxtInfo->pdpAddr.pdpType != TAF_PDP_IPV6) && (pdpCxtInfo->pdpAddr.pdpType != TAF_PDP_IPV4V6)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}

#endif


VOS_UINT32 AT_SetCgdcontPara(VOS_UINT8 indexNum)
{
    TAF_PDP_PrimContextExt pdpCxtInfo;

    AT_RreturnCodeUint32 errCode;

    /* 初始化 */
    errCode = AT_SUCCESS;
    (VOS_VOID)memset_s(&pdpCxtInfo, sizeof(pdpCxtInfo), 0x00, sizeof(TAF_PDP_PrimContextExt));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_SET_CGDCONT_PARA_MAX_NUMBER) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<CID> */
    pdpCxtInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        pdpCxtInfo.defined = VOS_FALSE;
    } else {
        pdpCxtInfo.defined = VOS_TRUE;

        /* 设置<PDP_type> */
        errCode |= AT_ParseCgdcontIpType(&pdpCxtInfo);

        /* 设置<APN> */
        errCode |= AT_ParseCgdcontApn(&pdpCxtInfo, g_atClientTab[indexNum].clientId);

        /* 设置<PDP_addr> */
        /* 只处理IPV4的IP ADDR，IPV6不使用此AT命令设置的IP ADDR */
        errCode |= AT_ParseCgdcontIpAddr(&pdpCxtInfo);

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        /* 设置<S-NSSAI> */
        errCode |= AT_ParseCgdcontSNssai(&pdpCxtInfo);

        errCode |= AT_ParseCgdcontMhpv6(&pdpCxtInfo);

#endif
        /* 检查<IP TYEP><APN><PDP_addr><S-NSSAI>参数的正确性 */
        if (errCode != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        AT_ParseCgdcontPara(&pdpCxtInfo);
    }

    /* 执行命令操作 */
    if (TAF_PS_SetPrimPdpContextInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                     &pdpCxtInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGDCONT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCgdscontPara(VOS_UINT8 indexNum)
{
    TAF_PDP_SecContextExt pdpCxtInfo;

    /* 初始化 */
    (VOS_VOID)memset_s(&pdpCxtInfo, sizeof(pdpCxtInfo), 0x00, sizeof(TAF_PDP_SecContextExt));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CGDSCONT_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<s_cid> */
    pdpCxtInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        pdpCxtInfo.defined = VOS_FALSE;
    } else {
        pdpCxtInfo.defined = VOS_TRUE;

        /* 设置<p_cid> */
        if (g_atParaList[1].paraLen != 0) {
            pdpCxtInfo.opLinkdCid = VOS_TRUE;
            pdpCxtInfo.linkdCid   = (VOS_UINT8)g_atParaList[1].paraValue;

            if (pdpCxtInfo.cid == pdpCxtInfo.linkdCid) {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        } else {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<d_comp> */
        if (g_atParaList[AT_CGDCONT_PDP_D_COMP].paraLen != 0) {
            pdpCxtInfo.opPdpDcomp = VOS_TRUE;
            pdpCxtInfo.pdpDcomp   = (VOS_UINT8)g_atParaList[AT_CGDCONT_PDP_D_COMP].paraValue;
        }

        /* 设置<h_comp> */
        if (g_atParaList[AT_CGDCONT_PDP_H_COMP].paraLen != 0) {
            pdpCxtInfo.opPdpHcomp = VOS_TRUE;
            pdpCxtInfo.pdpHcomp   = (VOS_UINT8)g_atParaList[AT_CGDCONT_PDP_H_COMP].paraValue;
        }
        /* 设置<IM_CN_Signalling_Flag_Ind> */
        if (g_atParaList[AT_CGDCONT_IM_CN_SIGNAL_FLAG].paraLen != 0) {
            pdpCxtInfo.opImCnSignalFlg = VOS_TRUE;
            pdpCxtInfo.imCnSignalFlg   = (VOS_UINT8)g_atParaList[AT_CGDCONT_IM_CN_SIGNAL_FLAG].paraValue;
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_SetSecPdpContextInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                    &pdpCxtInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGDSCONT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqreqPara(TAF_UINT8 indexNum)
{
    TAF_UMTS_QosExt umtsQosInfo;

    /* 初始化 */
    (VOS_VOID)memset_s(&umtsQosInfo, sizeof(umtsQosInfo), 0x00, sizeof(TAF_UMTS_QosExt));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CGEQREQ_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    umtsQosInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        umtsQosInfo.defined = VOS_FALSE;
    } else {
        umtsQosInfo.defined = VOS_TRUE;

        /* 设置<Traffic class> */
        if (g_atParaList[1].paraLen != 0) {
            umtsQosInfo.opTrafficClass = VOS_TRUE;
            umtsQosInfo.trafficClass   = (VOS_UINT8)g_atParaList[1].paraValue;
        }

        /* 设置<Maximum bitrate UL> */
        if (g_atParaList[AT_CGEQREQ_MAXIMUM_BITRATE_UL].paraLen != 0) {
            umtsQosInfo.opMaxBitUl = VOS_TRUE;
            umtsQosInfo.maxBitUl   = g_atParaList[AT_CGEQREQ_MAXIMUM_BITRATE_UL].paraValue;
        }

        /* 设置<Maximum bitrate DL> */
        if (g_atParaList[AT_CGEQREQ_MAXIMUM_BITRATE_DL].paraLen != 0) {
            umtsQosInfo.opMaxBitDl = VOS_TRUE;
            umtsQosInfo.maxBitDl   = g_atParaList[AT_CGEQREQ_MAXIMUM_BITRATE_DL].paraValue;
        }

        /* 设置<Guaranteed bitrate UL> */
        if (g_atParaList[AT_CGEQREQ_GUARANTEED_BITRATE_UL].paraLen != 0) {
            umtsQosInfo.opGtdBitUl = VOS_TRUE;
            umtsQosInfo.gtdBitUl   = g_atParaList[AT_CGEQREQ_GUARANTEED_BITRATE_UL].paraValue;
        }

        /* 设置<Guaranteed bitrate DL> */
        if (g_atParaList[AT_CGEQREQ_GUARANTEED_BITRATE_DL].paraLen != 0) {
            umtsQosInfo.opGtdBitDl = VOS_TRUE;
            umtsQosInfo.gtdBitDl   = g_atParaList[AT_CGEQREQ_GUARANTEED_BITRATE_DL].paraValue;
        }

        /* 设置<Delivery order> */
        if (g_atParaList[AT_CGEQREQ_DELIVERY_ORDER].paraLen != 0) {
            umtsQosInfo.opDeliverOrder = VOS_TRUE;
            umtsQosInfo.deliverOrder   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_DELIVERY_ORDER].paraValue;
        }

        /* 设置<Maximum SDU size> */
        if (g_atParaList[AT_CGEQREQ_MAXIMUM_SDU_SIZE].paraLen != 0) {
            umtsQosInfo.opMaxSduSize = VOS_TRUE;
            umtsQosInfo.maxSduSize   = (VOS_UINT16)g_atParaList[AT_CGEQREQ_MAXIMUM_SDU_SIZE].paraValue;
        }

        /* 设置<SDU error ratio> */
        if (g_atParaList[AT_CGEQREQ_SDU_ERROR_RATIO].paraLen != 0) {
            umtsQosInfo.opSduErrRatio = VOS_TRUE;
            umtsQosInfo.sduErrRatio   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_SDU_ERROR_RATIO].paraValue;
        }

        /* 设置<Residual bit error ratio> */
        if (g_atParaList[AT_CGEQREQ_RESIDUAL_BIT_ERROR_RATIO].paraLen != 0) {
            umtsQosInfo.opResidualBer = VOS_TRUE;
            umtsQosInfo.residualBer   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_RESIDUAL_BIT_ERROR_RATIO].paraValue;
        }

        /* 设置<Delivery of erroneous SDUs> */
        if (g_atParaList[AT_CGEQREQ_DELIVERY_OF_ERR_SDUS].paraLen != 0) {
            umtsQosInfo.opDeliverErrSdu = VOS_TRUE;
            umtsQosInfo.deliverErrSdu   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_DELIVERY_OF_ERR_SDUS].paraValue;
        }

        /* 设置<Transfer delay> */
        if (g_atParaList[AT_CGEQREQ_TRANSFER_DELAY].paraLen != 0) {
            umtsQosInfo.opTransDelay = VOS_TRUE;
            umtsQosInfo.transDelay   = (VOS_UINT16)g_atParaList[AT_CGEQREQ_TRANSFER_DELAY].paraValue;
        }

        /* 设置<Traffic handling priority> */
        if (g_atParaList[AT_CGEQREQ_TRAFF_HANDLE_PRIOR].paraLen != 0) {
            umtsQosInfo.opTraffHandlePrior = VOS_TRUE;
            umtsQosInfo.traffHandlePrior   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_TRAFF_HANDLE_PRIOR].paraValue;
        }

        /* 设置<Source Statistics Descriptor> */
        if (g_atParaList[AT_CGEQREQ_SRC_STATISTICS_DESCRIPTOR].paraLen != 0) {
            umtsQosInfo.opSrcStatisticsDes = VOS_TRUE;
            umtsQosInfo.srcStatisticsDes   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_SRC_STATISTICS_DESCRIPTOR].paraValue;
        }

        /* 设置<Signalling Indication> */
        if (g_atParaList[AT_CGEQREQ_SIGNALLING_INDICATION].paraLen != 0) {
            umtsQosInfo.opSignalIndication = VOS_TRUE;
            umtsQosInfo.signalIndication   = (VOS_UINT8)g_atParaList[AT_CGEQREQ_SIGNALLING_INDICATION].paraValue;
        }
    }

    /* 执行命令操作 */
    if (g_parseContext[indexNum].cmdElement->cmdIndex == AT_CMD_CGEQREQ) {
        if (TAF_PS_SetUmtsQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                  &umtsQosInfo) != VOS_OK) {
            return AT_ERROR;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQREQ_SET;
    } else {
        if (TAF_PS_SetUmtsQosMinInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                     &umtsQosInfo) != VOS_OK) {
            return AT_ERROR;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQMIN_SET;
    }

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqminPara(TAF_UINT8 indexNum)
{
    return AT_SetCgeqreqPara(indexNum);
}


TAF_UINT32 AT_SetCgpaddrPara(TAF_UINT8 indexNum)
{
    VOS_UINT32   i;
    VOS_UINT32   cidIndex;
    TAF_CID_List cidListInfo;
    VOS_UINT32   loop;

    /* 初始化 */
    cidIndex = 0;
    (VOS_VOID)memset_s(&cidListInfo, sizeof(cidListInfo), 0x00, sizeof(TAF_CID_List));

    /* 参数过多 */
    if (g_atParaIndex > TAF_MAX_CID) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)
    loop = AT_MAX_PARA_NUMBER;
#else
    loop = TAF_MAX_CID;
#endif

    /* 参数设置 */
    if (g_atParaIndex != 0) {
        for (i = 0; i < loop; i++) {
            if (g_atParaList[i].paraLen == 0) {
                break;
            } else {
                cidIndex = g_atParaList[i].paraValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            cidListInfo.cid[cidIndex] = 1;
        }
    } else {
        for (i = 1; i <= TAF_MAX_CID; i++) {
            cidListInfo.cid[i] = 1;
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_GetPdpIpAddrInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                &cidListInfo) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGPADDR_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgeqnegPara(TAF_UINT8 indexNum)
{
    VOS_UINT32   i;
    VOS_UINT32   cidIndex;
    TAF_CID_List cidListInfo;
    VOS_UINT32   loop;

    /* 初始化 */
    cidIndex = 0;
    (VOS_VOID)memset_s(&cidListInfo, sizeof(cidListInfo), 0x00, sizeof(TAF_CID_List));

    /* 参数过多 */
    if (g_atParaIndex > TAF_MAX_CID) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)
    loop = AT_MAX_PARA_NUMBER;
#else
    loop = TAF_MAX_CID;
#endif

    /* 参数设置 */
    /* +CGEQNEG[=<cid>[,<cid>[,...]]] */
    if (g_atParaIndex != 0) {
        for (i = 0; i < loop; i++) {
            if (g_atParaList[i].paraLen == 0) {
                break;
            } else {
                cidIndex = g_atParaList[i].paraValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            cidListInfo.cid[cidIndex] = 1;
        }
    } else {
        for (i = 1; i <= TAF_MAX_CID; i++) {
            cidListInfo.cid[i] = 1;
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_GetDynamicUmtsQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                     &cidListInfo) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQNEG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgcmodPara(TAF_UINT8 indexNum)
{
    VOS_UINT32   i;
    VOS_UINT32   cidIndex;
    TAF_CID_List cidListInfo;

    /* 初始化 */
    cidIndex = 0;
    (VOS_VOID)memset_s(&cidListInfo, sizeof(cidListInfo), 0x00, sizeof(TAF_CID_List));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    if (g_atParaIndex != 0) {
        for (i = 0; i < AT_MAX_PARA_NUMBER; i++) {
            if (g_atParaList[i].paraLen == 0) {
                break;
            } else {
                cidIndex = g_atParaList[i].paraValue;
            }

            /* 以CID作为下标, 标记对应的CID */
            cidListInfo.cid[cidIndex] = VOS_TRUE;
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_CallModify(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &cidListInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGCMOD_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgactPara(TAF_UINT8 indexNum)
{
    VOS_UINT32        i;
    VOS_UINT32        cidIndex;
    TAF_CID_ListState cidListStateInfo;

    /* 初始化 */
    cidIndex = 0;
    (VOS_VOID)memset_s(&cidListStateInfo, sizeof(cidListStateInfo), 0x00, sizeof(TAF_CID_ListState));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != AT_CGACT_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    cidListStateInfo.state = (VOS_UINT8)g_atParaList[0].paraValue;

    for (i = 0; i < (AT_MAX_PARA_NUMBER - 1); i++) {
        if (g_atParaList[i + 1UL].paraLen == 0) {
            break;
        } else {
            cidIndex = g_atParaList[i + 1UL].paraValue;
        }

        /* 以CID作为下标, 标记对应的CID */
        cidListStateInfo.cid[cidIndex] = 1;
    }

    /* 执行命令操作 */
    if (TAF_PS_SetPdpContextState(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                  &cidListStateInfo) != VOS_OK) {
        return AT_ERROR;
    }

    if (cidListStateInfo.state == 1) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGACT_ORG_SET;
    } else {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGACT_END_SET;
    }

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgansPara(TAF_UINT8 indexNum)
{
    VOS_UINT8     rspType;
    TAF_PS_Answer ansInfo;

    /* 初始化 */
    (VOS_VOID)memset_s(&ansInfo, sizeof(ansInfo), 0x00, sizeof(TAF_PS_Answer));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CGANS_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数设置 */
    rspType = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 设置<CID> */
    if (g_atParaList[AT_CGANS_CID].paraLen != 0) {
        ansInfo.cid = (VOS_UINT8)g_atParaList[AT_CGANS_CID].paraValue;
    }

    /* 填充ans扩展标志 */
    if (g_parseContext[indexNum].cmdElement->cmdIndex == AT_CMD_CGANS_EXT) {
        ansInfo.ansExtFlg = VOS_TRUE;
    } else {
        ansInfo.ansExtFlg = VOS_FALSE;
    }

    /* 执行命令操作 */
    if (rspType == 1) {
        if (TAF_PS_CallAnswer(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &ansInfo) ==
            VOS_OK) {
            /* 设置当前操作类型 */
            if (g_parseContext[indexNum].cmdElement->cmdIndex == AT_CMD_CGANS_EXT) {
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGANS_ANS_EXT_SET;
            } else {
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGANS_ANS_SET;
            }

            /* 返回命令处理挂起状态 */
            return AT_WAIT_ASYNC_RETURN;
        } else {
            return AT_ERROR;
        }
    } else {
        /* 0 --  拒绝网络发起的激活指示 */
        if (TAF_PS_CallHangup(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0) == VOS_OK) {
            /* 设置当前操作类型 */
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGANS_ANS_SET;

            /* 返回命令处理挂起状态 */
            return AT_WAIT_ASYNC_RETURN;
        } else {
            return AT_ERROR;
        }
    }
}


VOS_UINT32 AT_CountSpecCharInString(VOS_UINT8 *data, VOS_UINT16 len, VOS_UINT8 charValue)
{
    VOS_UINT8 *read = VOS_NULL_PTR;
    VOS_UINT32 chkLen;
    VOS_UINT32 count;

    if (data == VOS_NULL_PTR) {
        return 0;
    }

    read   = data;
    chkLen = 0;
    count  = 0;

    /* 检查 */
    while (chkLen++ < len) {
        if (charValue == *read) {
            count++;
        }
        read++;
    }

    return count;
}


VOS_UINT32 AT_FillTftIpv4Addr(VOS_UINT8 *data, VOS_UINT16 len, TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 count;
    VOS_UINT32 ret;
    VOS_CHAR  *ptrTmp = VOS_NULL_PTR;

    count  = 0;
    ptrTmp = VOS_NULL_PTR;

    count = AT_CountDigit(data, len, '.', 7); /* 用来获取IPV4地址中'.'第7次出现的地址 */
    if ((count == 0) || (data[count] == 0)) {
        return AT_FAILURE;
    }

    count = AT_CountDigit(data, len, '.', 4); /* 用来获取IPV4地址中'.'第4次出现的地址 */

    tftInfo->opSrcIp              = VOS_TRUE;
    tftInfo->sourceIpaddr.pdpType = TAF_PDP_IPV4;
    tftInfo->sourceIpMask.pdpType = TAF_PDP_IPV4;

    if ((len - count) > TAF_MAX_IPV4_ADDR_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(data[count]);

    ret = AT_Ipv4AddrAtoi(ptrTmp, tftInfo->sourceIpMask.ipv4Addr, TAF_IPV4_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    if ((count - 1) > TAF_MAX_IPV4_ADDR_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp            = (VOS_CHAR *)(data);
    ptrTmp[count - 1] = '\0';

    ret = AT_Ipv4AddrAtoi(ptrTmp, tftInfo->sourceIpaddr.ipv4Addr, TAF_IPV4_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftLocalIpv4Addr(VOS_UINT8 *data, VOS_UINT16 len, TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 count;
    VOS_UINT32 ret;
    VOS_CHAR  *ptrTmp = VOS_NULL_PTR;

    count  = 0;
    ptrTmp = VOS_NULL_PTR;

    count = AT_CountDigit(data, len, '.', 7); /* 用来获取IPV4地址中'.'第7次出现的地址 */
    if ((count == 0) || (data[count] == 0)) {
        return AT_FAILURE;
    }

    count = AT_CountDigit(data, len, '.', 4); /* 用来获取IPV4地址中'.'第4次出现的地址 */

    tftInfo->opLocalIpv4AddrAndMask = VOS_TRUE;

    if ((len - count) > TAF_MAX_IPV4_ADDR_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(data[count]);

    ret = AT_Ipv4AddrAtoi(ptrTmp, tftInfo->localIpv4Mask, TAF_IPV4_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    if ((count - 1) > TAF_MAX_IPV4_ADDR_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp            = (VOS_CHAR *)(data);
    ptrTmp[count - 1] = '\0';

    ret = AT_Ipv4AddrAtoi(ptrTmp, tftInfo->localIpv4Addr, TAF_IPV4_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftIpv6Addr(VOS_UINT8 *data, VOS_UINT16 len, TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 count;
    VOS_UINT32 ret;
    VOS_CHAR  *ptrTmp = VOS_NULL_PTR;

    count  = 0;
    ptrTmp = VOS_NULL_PTR;

    count = AT_CountDigit(data, len, '.', 31); /* 用来获取IPV6地址中'.'第31次出现的地址 */
    if ((count == 0) || (data[count] == 0)) {
        return AT_FAILURE;
    }

    count = AT_CountDigit(data, len, '.', 16); /* 用来获取IPV6地址中'.'第16次出现的地址 */

    tftInfo->opSrcIp              = VOS_TRUE;
    tftInfo->sourceIpaddr.pdpType = TAF_PDP_IPV6;
    tftInfo->sourceIpMask.pdpType = TAF_PDP_IPV6;

    if ((len - count) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(data[count]);

    ret = AT_Ipv6AddrAtoi(ptrTmp, tftInfo->sourceIpMask.ipv6Addr, TAF_IPV6_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    if ((count - 1) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp            = (VOS_CHAR *)(data);
    ptrTmp[count - 1] = '\0';

    ret = AT_Ipv6AddrAtoi(ptrTmp, tftInfo->sourceIpaddr.ipv6Addr, TAF_IPV6_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftLocalIpv6Addr(VOS_UINT8 *data, VOS_UINT16 len, TAF_TFT_Ext *tftInfo)
{
    VOS_UINT32 count;
    VOS_UINT32 ret;
    VOS_CHAR  *ptrTmp = VOS_NULL_PTR;
    VOS_UINT8  localIpv6Mask[APP_MAX_IPV6_ADDR_LEN];

    count  = 0;
    ptrTmp = VOS_NULL_PTR;
    (VOS_VOID)memset_s(localIpv6Mask, sizeof(localIpv6Mask), 0x00, sizeof(localIpv6Mask));

    count = AT_CountDigit(data, len, '.', 31); /* 用来获取IPV6地址中'.'第31次出现的地址 */
    if ((count == 0) || (data[count] == 0)) {
        return AT_FAILURE;
    }

    count = AT_CountDigit(data, len, '.', 16); /* 用来获取IPV6地址中'.'第16次出现的地址 */

    tftInfo->opLocalIpv6AddrAndMask = VOS_TRUE;

    if ((len - count) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp = (VOS_CHAR *)&(data[count]);

    ret = AT_Ipv6AddrAtoi(ptrTmp, localIpv6Mask, sizeof(localIpv6Mask));

    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    tftInfo->localIpv6Prefix = AT_CalcIpv6PrefixLength(localIpv6Mask, sizeof(localIpv6Mask));

    if ((count - 1) > TAF_MAX_IPV6_ADDR_DOT_STR_LEN) {
        return AT_FAILURE;
    }

    ptrTmp            = (VOS_CHAR *)(data);
    ptrTmp[count - 1] = '\0';

    ret = AT_Ipv6AddrAtoi(ptrTmp, tftInfo->localIpv6Addr, TAF_IPV6_ADDR_LEN);
    if (ret != VOS_OK) {
        return AT_FAILURE;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillTftIpAddr(VOS_UINT8 *data, VOS_UINT16 len, TAF_TFT_Ext *tftInfo, VOS_UINT8 ipAddrType)
{
    VOS_UINT32 count;

    /* 获取输入的IP地址中包含的'.'的个数 */
    count = AT_CountSpecCharInString(data, len, '.');

    /* 如果输入为IPV4地址，地址加掩码会有7个'.' */
    /* 例如"10.140.23.144.255.255.255.0"，前4个是IPV4地址，后4个为掩码 */
    if (count == (TAF_IPV4_ADDR_LEN * 2 - 1)) {
        if (ipAddrType == AT_IP_ADDR_TYPE_SOURCE) {
            return (AT_FillTftIpv4Addr(data, len, tftInfo));
        }

        if (ipAddrType == AT_IP_ADDR_TYPE_LOCAL) {
            return (AT_FillTftLocalIpv4Addr(data, len, tftInfo));
        }
    }
    /* 如果输入为IPV6地址，地址加掩码会有31个'.' */
    /* 例如"32.8.0.2.0.2.0.1.0.2.0.1.0.3.21.111.255.255.255.255.255.255.255.255.255.255.255.255.255.255.255.255" */
    /* 前16个为IPV6地址，后16个为掩码 */
    else if ((AT_GetIpv6Capability() != AT_IPV6_CAPABILITY_IPV4_ONLY) && ((TAF_IPV6_ADDR_LEN * 2 - 1) == count)) {
        if (ipAddrType == AT_IP_ADDR_TYPE_SOURCE) {
            return (AT_FillTftIpv6Addr(data, len, tftInfo));
        }

        if (ipAddrType == AT_IP_ADDR_TYPE_LOCAL) {
            return (AT_FillTftLocalIpv6Addr(data, len, tftInfo));
        }
    } else {
        return AT_FAILURE;
    }

    return AT_FAILURE;
}


TAF_UINT32 AT_SetCgtftPara(TAF_UINT8 indexNum)
{
    TAF_TFT_Ext tftInfo;
    VOS_UINT32  ret;

    /* 初始化 */
    (VOS_VOID)memset_s(&tftInfo, sizeof(tftInfo), 0x00, sizeof(TAF_TFT_Ext));

    /* 如果没有cid，则返回失败 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多,<flow label (ipv6)>不支持，<direction>也不再检查 */
    ret = AT_CheckCgtftParaNum(g_atParaIndex);
    if (ret == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    tftInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        tftInfo.defined = VOS_FALSE;
    } else {
        tftInfo.defined = VOS_TRUE;

        /* 设置<packet filter identifier> */
        AT_SetTftPfIdPara(&tftInfo);

        /* 设置<evaluation precedence index> */
        AT_SetTftPrecedencePara(&tftInfo);

        /* 设置<source address and subnet mask> */
        if (g_atParaList[AT_CGTFT_SRC_ADDR_AND_SUBNET_MASK].paraLen != 0) {
            ret = AT_FillTftIpAddr(g_atParaList[AT_CGTFT_SRC_ADDR_AND_SUBNET_MASK].para,
                                   g_atParaList[AT_CGTFT_SRC_ADDR_AND_SUBNET_MASK].paraLen, &tftInfo,
                                   AT_IP_ADDR_TYPE_SOURCE);
            if (ret == AT_FAILURE) {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        /* 设置<protocol number (ipv4) / next header (ipv6)> */
        AT_SetTftProtocolIdPara(&tftInfo);

        /* 设置<destination port range> */
        ret = AT_SetDestPortRangePara(&tftInfo);
        if (ret == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<source port range> */
        ret = AT_SetSrcPortRangePara(&tftInfo);
        if (ret == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<ipsec security parameter index (spi)> */
        ret = AT_SetTftSecuPara(&tftInfo);
        if (ret == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<type of service (tos) (ipv4) and mask / traffic class (ipv6) and mask> */
        ret = AT_SetTftTosPara(&tftInfo);
        if (ret == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* <flow label (ipv6)> */
        AT_SetTftFlowLablePara(&tftInfo);

        /* <direction> */
        AT_SetTftDirectionPara(&tftInfo);

        if (AT_IsSupportReleaseRst(AT_ACCESS_STRATUM_REL11)) {
            /* 设置<local address and subnet mask> */
            if (g_atParaList[AT_CGTFT_LOCAL_ADDR_AND_SUBNET_MASK].paraLen != 0) {
                ret = AT_FillTftIpAddr(g_atParaList[AT_CGTFT_LOCAL_ADDR_AND_SUBNET_MASK].para,
                                       g_atParaList[AT_CGTFT_LOCAL_ADDR_AND_SUBNET_MASK].paraLen, &tftInfo,
                                       AT_IP_ADDR_TYPE_LOCAL);
                if (ret == AT_FAILURE) {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
            }

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
            /* <qri> */
            AT_SetTftQriPara(&tftInfo);
#endif
        }
    }

    if (TAF_PS_SetTftInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &tftInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGTFT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgdnsPara(TAF_UINT8 indexNum)
{
    TAF_PDP_DnsExt pdpDnsInfo;

    VOS_UINT8  tempIpv4Addr[TAF_IPV4_ADDR_LEN];
    VOS_UINT32 rslt;
    errno_t    memResult;

    /* 初始化 */
    (VOS_VOID)memset_s(&pdpDnsInfo, sizeof(pdpDnsInfo), 0x00, sizeof(TAF_PDP_DnsExt));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CGDNS_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<cid> */
    pdpDnsInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        pdpDnsInfo.defined = VOS_FALSE;
    } else {
        pdpDnsInfo.defined = VOS_TRUE;

        /* 设置<PriDns> */
        if (g_atParaList[1].paraLen != 0) {
            /* 如果<PriDns>过长，直接返回错误 */
            if (g_atParaList[1].paraLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1)) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            rslt = AT_Ipv4AddrAtoi((VOS_CHAR *)g_atParaList[1].para, &tempIpv4Addr[0], TAF_IPV4_ADDR_LEN);

            if (rslt != VOS_OK) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            pdpDnsInfo.opPrimDnsAddr = VOS_TRUE;
            memResult                = memcpy_s(pdpDnsInfo.primDnsAddr, sizeof(pdpDnsInfo.primDnsAddr), tempIpv4Addr,
                                                TAF_IPV4_ADDR_LEN);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pdpDnsInfo.primDnsAddr), TAF_IPV4_ADDR_LEN);
        }

        /* 设置<SecDns> */
        if (g_atParaList[AT_CGDNS_SECDNS].paraLen != 0) {
            /* 如果<SecDns>过长，直接返回错误 */
            if (g_atParaList[AT_CGDNS_SECDNS].paraLen > (TAF_MAX_IPV4_ADDR_STR_LEN - 1)) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 此处存储的是字符串格式的DNS所以转换出来结果不使用 */
            rslt = AT_Ipv4AddrAtoi((VOS_CHAR *)g_atParaList[AT_CGDNS_SECDNS].para,
                                   &tempIpv4Addr[0], TAF_IPV4_ADDR_LEN);

            if (rslt != VOS_OK) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            pdpDnsInfo.opSecDnsAddr = VOS_TRUE;
            memResult = memcpy_s(pdpDnsInfo.secDnsAddr, sizeof(pdpDnsInfo.secDnsAddr), tempIpv4Addr, TAF_IPV4_ADDR_LEN);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pdpDnsInfo.secDnsAddr), TAF_IPV4_ADDR_LEN);
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_SetPdpDnsInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &pdpDnsInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGDNS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCgautoPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 ansMode;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<n> */
    ansMode = g_atParaList[0].paraValue;

    /* 执行命令操作 */
    if (TAF_PS_SetAnsModeInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, ansMode) !=
        VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGAUTO_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 AT_SetC5gqosPara(VOS_UINT8 indexNum)
{
    TAF_5G_QosExt st5QosInfo;

    (VOS_VOID)memset_s(&st5QosInfo, sizeof(st5QosInfo), 0x00, sizeof(TAF_5G_QosExt));

    if (g_atParaList[AT_C5GQOS_CID].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_C5GQOS_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    st5QosInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        st5QosInfo.defined = VOS_FALSE;
    } else {
        st5QosInfo.defined = VOS_TRUE;
        if (g_atParaList[AT_C5GQOS_5QI].paraLen != 0) {
            st5QosInfo.op5Qi = 1;
            st5QosInfo.uc5Qi = (VOS_UINT8)g_atParaList[AT_C5GQOS_5QI].paraValue;
        }

        if (g_atParaList[AT_C5GQOS_DL_GFBR].paraLen != 0) {
            st5QosInfo.opDlgfbr = 1;
            st5QosInfo.dlgfbr   = g_atParaList[AT_C5GQOS_DL_GFBR].paraValue;
        }

        if (g_atParaList[AT_C5GQOS_UL_GFBR].paraLen != 0) {
            st5QosInfo.opUlgfbr = 1;
            st5QosInfo.ulgfbr   = g_atParaList[AT_C5GQOS_UL_GFBR].paraValue;
        }

        /* ULGFBR和DLGFBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
        if (st5QosInfo.opDlgfbr != st5QosInfo.opUlgfbr) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_C5GQOS_DL_MFBR].paraLen != 0) {
            st5QosInfo.opDlmfbr = 1;
            st5QosInfo.dlmfbr   = g_atParaList[AT_C5GQOS_DL_MFBR].paraValue;
        }

        if (g_atParaList[AT_C5GQOS_UL_MFBR].paraLen != 0) {
            st5QosInfo.opUlmfbr = 1;
            st5QosInfo.ulmfbr   = g_atParaList[AT_C5GQOS_UL_MFBR].paraValue;
        }

        /* ULMFBR和DLMFBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
        if (st5QosInfo.opDlmfbr != st5QosInfo.opUlmfbr) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if (TAF_PS_Set5QosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &st5QosInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GQOS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gqosRdpPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 cid;

    cid = 0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        cid = (VOS_UINT8)g_atParaList[0].paraValue;
    } else {
        cid = 0xff;
    }

    if (TAF_PS_GetDynamic5gQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, cid) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GQOSRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gPNssaiPara(VOS_UINT8 indexNum)
{
    AT_MTA_5GNssaiSetReq preferNssai;
    VOS_UINT32           rslt;

    /* +C5GPNSSAI=[<Preferred_NSSAI_3gpp_length>,[<Preferred_NSSAI_3gpp>]],[<Preferred_NSSAI_non3gpp_length>,[<Preferred_NSSAI_non3gpp>]]
     */
    /* 初始化 */
    (VOS_VOID)memset_s(&preferNssai, sizeof(preferNssai), 0x00, sizeof(AT_MTA_5GNssaiSetReq));

    preferNssai.sNssaiSetType = AT_MTA_NSSAI_SET_PREFER_NSSAI;

    if (g_atParaIndex == 0) {
        /* 1个参数也没有，删除Prefer切片信息 */
        preferNssai.st5gNssai.snssaiNum = 0;
    } else if (g_atParaIndex == 1) {
        if (g_atParaList[0].paraValue != 0) {
            /* 如果length字段值不为0，但只有length这1个字段，无切片信息，AT格式不合法 */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        preferNssai.st5gNssai.snssaiNum = 0;
    } else if (g_atParaIndex == AT_C5GPNSSAI_PARA_NUM) {
        if (VOS_OK != AT_DecodeMultiSNssaiString((VOS_UINT16)g_atParaList[0].paraValue, g_atParaList[1].para,
                                                 g_atParaList[1].paraLen, &preferNssai.st5gNssai)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (preferNssai.st5gNssai.snssaiNum > PS_MAX_PREFER_S_NSSAI_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  ID_AT_MTA_5G_NSSAI_SET_REQ, (VOS_UINT8 *)&preferNssai,
                                  (VOS_SIZE_T)sizeof(preferNssai), I0_UEPS_PID_MTA);

    if (rslt != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetC5gPNssaiPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GPNSSAI_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gNssaiPara(VOS_UINT8 indexNum)
{
    AT_MTA_5GNssaiSetReq defCfgNssai;
    VOS_UINT32           rslt;

    /* +C5GNSSAI=<default_configured_nssai_length>,<default_configured_nssai> */
    /* 初始化 */
    (VOS_VOID)memset_s(&defCfgNssai, sizeof(defCfgNssai), 0x00, sizeof(AT_MTA_5GNssaiSetReq));

    defCfgNssai.sNssaiSetType = AT_MTA_NSSAI_SET_DEF_CFG_NSSAI;

    if (g_atParaIndex == AT_C5GNSSAI_PARA_NUM) {
        if (VOS_OK != AT_DecodeMultiSNssaiString((VOS_UINT16)g_atParaList[0].paraValue, g_atParaList[1].para,
                                                 g_atParaList[1].paraLen, &defCfgNssai.st5gNssai)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        /* 参数个数不对 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  ID_AT_MTA_5G_NSSAI_SET_REQ, (VOS_UINT8 *)&defCfgNssai,
                                  (VOS_SIZE_T)sizeof(defCfgNssai), I0_UEPS_PID_MTA);

    if (rslt != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetC5gNssaiPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GDFTCFGNSSAI_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetC5gNssaaPara(VOS_UINT8 indexNum)
{
    AT_MTA_5GNwSliceAuthCmplReq *cmplReq = VOS_NULL_PTR;
    VOS_UINT32                   rslt;

    if (g_atParaIndex != AT_C5GNSSAA_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_C5GNSSAA_SNSSAI].paraLen == 0 || g_atParaList[AT_C5GNSSAA_EAPMSG].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    cmplReq = (AT_MTA_5GNwSliceAuthCmplReq *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(AT_MTA_5GNwSliceAuthCmplReq));
    if (cmplReq == VOS_NULL_PTR) {
        AT_WARN_LOG("AT_SetC5gNssaaPara: PS_MEM_ALLOC fail.");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(cmplReq, sizeof(*cmplReq), 0x00, sizeof(*cmplReq));

    cmplReq->eapMsg.eapMsgSize = AT_MIN((g_atParaList[AT_C5GNSSAA_EAPMSG].paraLen) / 2, AT_PARA_MAX_LEN + 1);
    cmplReq->eapMsg.eapMsgSize = AT_MIN(cmplReq->eapMsg.eapMsgSize, AT_MTA_EAP_MSG_MAX_NUM);

    if (AT_DecodeSNssai(g_atParaList[AT_C5GNSSAA_SNSSAI].para,
        g_atParaList[AT_C5GNSSAA_SNSSAI].paraLen, &cmplReq->sNssai) != VOS_OK) {
        PS_MEM_FREE(WUEPS_PID_AT, cmplReq);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiString2HexSimple(cmplReq->eapMsg.eapMsg, g_atParaList[AT_C5GNSSAA_EAPMSG].para,
                                 g_atParaList[AT_C5GNSSAA_EAPMSG].paraLen) == AT_FAILURE) {
        PS_MEM_FREE(WUEPS_PID_AT, cmplReq);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
        ID_AT_MTA_NW_SLICE_AUTH_CMPL_REQ, (VOS_UINT8 *)cmplReq, sizeof(*cmplReq), I0_UEPS_PID_MTA);
    if (rslt != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetC5gNssaaPara: AT_FillAndSndAppReqMsg fail.");
        PS_MEM_FREE(WUEPS_PID_AT, cmplReq);
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GNSSAA_SET;

    PS_MEM_FREE(WUEPS_PID_AT, cmplReq);

    return AT_OK;
}


VOS_UINT32 AT_ConvertPlmnStrToHex(VOS_UINT8 *para, VOS_UINT16 len, PS_NR_PlmnId *plmn)
{
    VOS_UINT32 temp;

    temp = 0;

    /* check整个码流中是否有不符合字符，如果有的话直接按照解析失败处理 */
    if (At_String2Hex(para, len, &temp) == AT_FAILURE) {
        return AT_ERROR;
    }

    /* MCC digit1 */
    At_String2Hex(&para[AT_MCC_DIGIT_1], 1, &temp);

    plmn->plmnId[AT_PLMN_ID_INDEX_0] = (VOS_UINT8)temp;

    /* MCC digit2 */
    At_String2Hex(&para[AT_MCC_DIGIT_2], 1, &temp);

    plmn->plmnId[AT_PLMN_ID_INDEX_0] |= ((VOS_UINT8)(temp << 4));

    /* MCC digit3 */
    At_String2Hex(&para[AT_MCC_DIGIT_3], 1, &temp);

    plmn->plmnId[AT_PLMN_ID_INDEX_1] = (VOS_UINT8)temp;

    /* MNC digit1 */
    At_String2Hex(&para[AT_MNC_DIGIT_1], 1, &temp);

    plmn->plmnId[AT_PLMN_ID_INDEX_2] = (VOS_UINT8)temp;

    /* MNC digit2 */
    At_String2Hex(&para[AT_MNC_DIGIT_2], 1, &temp);

    plmn->plmnId[AT_PLMN_ID_INDEX_2] |= ((VOS_UINT8)(temp << 4));

    if (len == AT_PLMN_LEN_SIX) {
        /* MNC digit2 */
        At_String2Hex(&para[AT_PLMN_LEN_SIX_MNC_DIGIT_2], 1, &temp);

        plmn->plmnId[AT_PLMN_ID_INDEX_1] |= ((VOS_UINT8)(temp << 4));
    } else {
        plmn->plmnId[AT_PLMN_ID_INDEX_1] |= 0xf0;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetC5gNssaiRdpPara(VOS_UINT8 indexNum)
{
    AT_MTA_5GNssaiQryReq st5gNssaiQryReq;
    PS_NR_PlmnId         plmn;
    VOS_UINT32           rslt;

    /* +C5GNSSAIRDP[=<nssai_type>[,<plmn_id>]] */
    /* 初始化 */
    (VOS_VOID)memset_s(&st5gNssaiQryReq, sizeof(st5gNssaiQryReq), 0x00, sizeof(AT_MTA_5GNssaiQryReq));
    (VOS_VOID)memset_s(&plmn, sizeof(plmn), 0x00, sizeof(PS_NR_PlmnId));

    if (g_atParaIndex == 0) {
        st5gNssaiQryReq.sNssaiQryType = AT_MTA_NSSAI_QRY_DEF_CFG_AND_REJ_AND_CFG_AND_ALLOWED_NSSAI;
        st5gNssaiQryReq.opPlmn        = VOS_FALSE;
    } else if (g_atParaIndex == 1) {
        st5gNssaiQryReq.sNssaiQryType = g_atParaList[AT_C5GNSSAIRDP_NASSAI_TYPE].paraValue;
        st5gNssaiQryReq.opPlmn        = VOS_FALSE;
    } else if (g_atParaIndex == AT_C5GNSSAIRDP_PARA_MAX_NUM) {
        st5gNssaiQryReq.sNssaiQryType = g_atParaList[AT_C5GNSSAIRDP_NASSAI_TYPE].paraValue;

        /* PLMN为5个或者6个digit */
        if ((g_atParaList[AT_C5GNSSAIRDP_PLMN_ID].paraLen > AT_C5GNSSAIRDP_PLMN_ID_VAILD_LEN2) ||
            (g_atParaList[AT_C5GNSSAIRDP_PLMN_ID].paraLen < AT_C5GNSSAIRDP_PLMN_ID_VAILD_LEN1)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (AT_ConvertPlmnStrToHex(g_atParaList[AT_C5GNSSAIRDP_PLMN_ID].para,
            g_atParaList[AT_C5GNSSAIRDP_PLMN_ID].paraLen, &plmn) != AT_OK) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        st5gNssaiQryReq.opPlmn = VOS_TRUE;
        st5gNssaiQryReq.plmn   = plmn;
    } else {
        /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  ID_AT_MTA_5G_NSSAI_QRY_REQ, (VOS_UINT8 *)&st5gNssaiQryReq,
                                  (VOS_SIZE_T)sizeof(st5gNssaiQryReq), I0_UEPS_PID_MTA);

    if (rslt != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetC5gNssaiRdpPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_C5GNSSAIRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_TransUePolicyProtocalVer(VOS_UINT32 protocalVer)
{
    VOS_UINT32 loop = protocalVer;
    VOS_UINT32 rslt = 0;
    VOS_UINT8 singleDigit = 0;
    VOS_UINT8 moveBit = 0;

    while (loop != 0) {
        singleDigit = loop % 10;
        loop = loop / 10;

        rslt += (singleDigit << moveBit);
        moveBit += 4;
    }

    return rslt;
}


VOS_UINT32 AT_SetCsUePolicy(VOS_UINT8 clientId)
{
    errno_t               memResult;
    TAF_PS_5GUePolicyInfo uePolicyInfo;
    AT_ModemUePolicyCtx  *uePolicyCtx = VOS_NULL_PTR;

    uePolicyCtx = AT_GetModemUePolicyCtxAddrFromClientId(clientId);

    /*
     * +CSUEPOLICY=<PTI>,<message_type>[,<UE_policy_information_length>[,<UE_policy_classmark>
     * [,<OS_Id_infomation>]]]
     */
    /* 参数个数不合法 */
    if ((g_atParaIndex > AT_CSUEPOLICY_MAX_PARA_NUM) || (g_atParaIndex < AT_CSUEPOLICY_MIN_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(uePolicyCtx, sizeof(AT_ModemUePolicyCtx), 0x00, sizeof(AT_ModemUePolicyCtx));

    /* 记录参数 */
    if (g_atParaList[AT_CSUEPOLICY_PTI].paraLen != 0) {
        uePolicyCtx->pti = (VOS_UINT8)g_atParaList[AT_CSUEPOLICY_PTI].paraValue;
    }

    if (g_atParaList[AT_CSUEPOLICY_MSG_TYPE].paraLen != 0) {
        uePolicyCtx->uePolicyMsgType = (TAF_PS_PolicyMsgTypeUint8)g_atParaList[AT_CSUEPOLICY_MSG_TYPE].paraValue;
    }

    /* 处理<UE_policy_classmark> */
    if (g_atParaList[AT_CSUEPOLICY_CLASS_MARK].paraLen != 0) {
        /* 对码流长度做长度检测 */
        if (g_atParaList[AT_CSUEPOLICY_CLASS_MARK].paraLen > (TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN * 2)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (At_AsciiString2HexSimple(uePolicyCtx->classMark, g_atParaList[AT_CSUEPOLICY_CLASS_MARK].para,
                                     (VOS_UINT16)g_atParaList[AT_CSUEPOLICY_CLASS_MARK].paraLen) != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        uePolicyCtx->classMarkLen = (VOS_UINT8)(g_atParaList[AT_CSUEPOLICY_CLASS_MARK].paraLen / 2);
    }

    /* 处理<OS_Id_infomation> */
    if (g_atParaList[AT_CSUEPOLICY_OS_ID_INFORMATION].paraLen != 0) {
        /* 对码流长度做长度检测 */
        if (g_atParaList[AT_CSUEPOLICY_OS_ID_INFORMATION].paraLen > (TAF_PS_UE_OS_ID_INFO_MAX_LEN * 2)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (At_AsciiString2HexSimple(uePolicyCtx->ueOsIdInfo, g_atParaList[AT_CSUEPOLICY_OS_ID_INFORMATION].para,
                                     (VOS_UINT16)g_atParaList[AT_CSUEPOLICY_OS_ID_INFORMATION].paraLen) != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        uePolicyCtx->ueOsIdLen = (VOS_UINT8)(g_atParaList[AT_CSUEPOLICY_OS_ID_INFORMATION].paraLen / 2);
    }

    /* 处理<protocal version> */
    if (g_atParaList[AT_CSUEPOLICY_PROTOCAL_VERSION].paraLen != 0) {
        uePolicyCtx->protocalVer = AT_TransUePolicyProtocalVer(g_atParaList[AT_CSUEPOLICY_PROTOCAL_VERSION].paraValue);
    }

    if ((g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraLen != 0) && (g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue != 0)) {
        if (g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue % 2 != 0) {
            AT_ERR_LOG("AT_SetCsUePolicy: policy length is invalid!");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 为准备输入的UE POLICY码流申请内存 */
        uePolicyCtx->uePolicyHead = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT,
                                                              g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue);
        if (uePolicyCtx->uePolicyHead == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_SetCsUePolicy: Memory malloc failed!");
            return AT_ERROR;
        }

        uePolicyCtx->uePolicyCur = uePolicyCtx->uePolicyHead;
        uePolicyCtx->uePolicyLen = g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue;
        (VOS_VOID)memset_s(uePolicyCtx->uePolicyHead, g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue, 0x00,
                           g_atParaList[AT_CSUEPOLICY_INFO_LEN].paraValue);

        /* 切换为UE POLICY码流输入模式 */
        At_SetCmdSubMode(clientId, AT_UE_POLICY_MODE);

        return AT_WAIT_UE_POLICY_INPUT;
    }

    (VOS_VOID)memset_s(&uePolicyInfo, sizeof(uePolicyInfo), 0x00, sizeof(uePolicyInfo));

    uePolicyInfo.protocalVer     = uePolicyCtx->protocalVer;
    uePolicyInfo.pti             = uePolicyCtx->pti;
    uePolicyInfo.uePolicyMsgType = uePolicyCtx->uePolicyMsgType;
    uePolicyInfo.classMarkLen    = uePolicyCtx->classMarkLen;
    memResult = memcpy_s(uePolicyInfo.classMark, TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN, uePolicyCtx->classMark,
                         TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN);

    TAF_MEM_CHK_RTN_VAL(memResult, TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN, TAF_PS_UE_POLICY_CLASSMARK_MAX_LEN);

    uePolicyInfo.ueOsIdLen = uePolicyCtx->ueOsIdLen;
    memResult              = memcpy_s(uePolicyInfo.ueOsIdInfo, TAF_PS_UE_OS_ID_INFO_MAX_LEN, uePolicyCtx->ueOsIdInfo,
                                      TAF_PS_UE_OS_ID_INFO_MAX_LEN);

    TAF_MEM_CHK_RTN_VAL(memResult, TAF_PS_UE_OS_ID_INFO_MAX_LEN, TAF_PS_UE_OS_ID_INFO_MAX_LEN);

    /* 调用DSM提供的设置接口 */
    if (TAF_PS_SetCsUePolicy(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[clientId].clientId), 0, &uePolicyInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetImsUrsp(VOS_UINT8 clientId)
{
    AT_ModemUePolicyCtx  *uePolicyCtx = VOS_NULL_PTR;
    AT_IMSA_ImsUrspSetReq urspSetReq;
    VOS_UINT32            rst;

    /* 参数个数不合法 */
    if (g_atParaIndex != 2) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    uePolicyCtx = AT_GetModemUePolicyCtxAddrFromClientId(clientId);

    (VOS_VOID)memset_s(uePolicyCtx, sizeof(AT_ModemUePolicyCtx), 0x00, sizeof(AT_ModemUePolicyCtx));
    (VOS_VOID)memset_s(&urspSetReq, sizeof(AT_IMSA_ImsUrspSetReq), 0x00, sizeof(AT_IMSA_ImsUrspSetReq));

    uePolicyCtx->imsUrspVer = (VOS_UINT8)g_atParaList[0].paraValue;

    if (g_atParaList[1].paraValue != 0) {
        if ((g_atParaList[1].paraValue % 2) != 0) {
            AT_ERR_LOG("AT_SetImsUrsp: length is invalid!");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 为准备输入的IMS URSP码流申请内存 */
        uePolicyCtx->imsUrspHead = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, g_atParaList[1].paraValue);
        if (uePolicyCtx->imsUrspHead == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_SetImsUrsp: Memory malloc failed!");
            return AT_ERROR;
        }

        uePolicyCtx->imsUrspCur = uePolicyCtx->imsUrspHead;
        uePolicyCtx->imsUrspLen = g_atParaList[1].paraValue;
        (VOS_VOID)memset_s(uePolicyCtx->imsUrspHead, g_atParaList[1].paraValue, 0x00, g_atParaList[1].paraValue);

        /* 切换为UE POLICY码流输入模式 */
        At_SetCmdSubMode(clientId, AT_IMS_URSP_MODE);

        return AT_WAIT_IMSA_URSP_INPUT;
    }

    urspSetReq.version = (VOS_UINT16)uePolicyCtx->imsUrspVer;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[clientId].clientId, g_atClientTab[clientId].opId,
              ID_AT_IMSA_IMS_URSP_SET_REQ, (VOS_UINT8 *)(&urspSetReq.version),
              (VOS_UINT32)(sizeof(urspSetReq.version) + sizeof(urspSetReq.length) + urspSetReq.length), PS_PID_IMSA);
    if (rst != TAF_SUCCESS) {
        AT_ERR_LOG("AT_SetImsUrsp: AT_FillAndSndAppReqMsg FAIL");
        return AT_ERROR;
    }

    g_atClientTab[clientId].cmdCurrentOpt = AT_CMD_IMSURSP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetLadnRptPara(VOS_UINT8 idx)
{
    AT_MTA_SetLadnRptReq ladnRptReq;
    VOS_UINT32           result;

    (VOS_VOID)memset_s(&ladnRptReq, sizeof(ladnRptReq), 0x00, sizeof(ladnRptReq));

    if (g_atParaIndex == 1) {
        ladnRptReq.unsolicitedRptFlg = g_atParaList[0].paraValue;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    result = AT_FillAndSndAppReqMsg(g_atClientTab[idx].clientId, g_atClientTab[idx].opId, ID_AT_MTA_SET_LADN_RPT_REQ,
                                    (VOS_UINT8 *)&ladnRptReq, (VOS_SIZE_T)sizeof(ladnRptReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetLadnRptPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
    g_atClientTab[idx].cmdCurrentOpt = AT_CMD_CLADN_SET;
    return AT_WAIT_ASYNC_RETURN;
}

#endif


VOS_UINT32 AT_SetMcsPara(VOS_UINT8 indexNum)
{
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;
    VOS_UINT32      result;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    netCtx->mcsDirection = (AT_McsDirectionUint8)g_atParaList[0].paraValue;

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_MCS_SET_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MCS_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetRrcStatPara(VOS_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    atCmd.u.rrcStatRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    atCmd.reqType         = AT_MTA_SET_RRCSTAT_RPT_TYPE;

    /* 给MTA发送^RRCSTAT设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetHfreqInfoPara(VOS_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    atCmd.u.hfreqInfoRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    atCmd.reqType           = AT_MTA_SET_HFREQINFO_RPT_TYPE;

    /* 给MTA发送^HFREQINFO设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

VOS_UINT32 atSetCgeqosPara(VOS_UINT8 indexNum)
{
    TAF_EPS_QosExt epsQosInfo;

    (VOS_VOID)memset_s(&epsQosInfo, sizeof(epsQosInfo), 0x00, sizeof(TAF_EPS_QosExt));

    if (g_atParaList[AT_CGEQOS_CID].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_CGEQOS_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    epsQosInfo.cid = (VOS_UINT8)g_atParaList[AT_CGEQOS_CID].paraValue;

    if (g_atParaList[AT_CGEQOS_5QI].paraLen != 0) {
        epsQosInfo.opQci = 1;
        epsQosInfo.qci   = (VOS_UINT8)g_atParaList[AT_CGEQOS_5QI].paraValue;
    }

    if (g_atParaList[AT_CGEQOS_DL_GBR].paraLen != 0) {
        epsQosInfo.opDlgbr = 1;
        epsQosInfo.dlgbr   = g_atParaList[AT_CGEQOS_DL_GBR].paraValue;
    }

    if (g_atParaList[AT_CGEQOS_UL_GBR].paraLen != 0) {
        epsQosInfo.opUlgbr = 1;
        epsQosInfo.ulgbr   = g_atParaList[AT_CGEQOS_UL_GBR].paraValue;
    }

    /* ULGBR和DLGBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
    if (epsQosInfo.opDlgbr != epsQosInfo.opUlgbr) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_CGEQOS_DL_MBR].paraLen != 0) {
        epsQosInfo.opDlmbr = 1;
        epsQosInfo.dlmbr   = g_atParaList[AT_CGEQOS_DL_MBR].paraValue;
    }

    if (g_atParaList[AT_CGEQOS_UL_MBR].paraLen != 0) {
        epsQosInfo.opUlmbr = 1;
        epsQosInfo.ulmbr   = g_atParaList[AT_CGEQOS_UL_MBR].paraValue;
    }

    /* ULMBR和DLMBR需要同时设置才有效;不同时设置，认为无效。参考3gpp 27.007 */
    if (epsQosInfo.opDlmbr != epsQosInfo.opUlmbr) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_PS_SetEpsQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &epsQosInfo) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQOS_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 atQryCgeqosPara(VOS_UINT8 indexNum)
{
    if (TAF_PS_GetEpsQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQOS_READ;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 atSetCgeqosrdpPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 cid;

    cid = 0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        cid = (VOS_UINT8)g_atParaList[0].paraValue;
    } else {
        cid = 0xff;
    }

    if (TAF_PS_GetDynamicEpsQosInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, cid) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGEQOSRDP_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 atSetCgcontrdpPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 cid;

    cid = 0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        cid = (VOS_UINT8)g_atParaList[0].paraValue;
    } else {
        cid = 0xff;
    }

    if (TAF_PS_GetDynamicPrimPdpContextInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                            cid) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGCONTRDP_SET;

    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


VOS_UINT32 atSetCgscontrdpPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 cid;

    cid = 0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        cid = (VOS_UINT8)g_atParaList[0].paraValue;
    } else {
        cid = 0xff;
    }

    if (TAF_PS_GetDynamicSecPdpContextInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                           cid) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGSCONTRDP_SET;

    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


VOS_UINT32 atSetCgtftrdpPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 cid;

    cid = 0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        cid = (VOS_UINT8)(g_atParaList[0].paraValue);
    } else {
        cid = 0xff;
    }

    if (TAF_PS_GetDynamicTftInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, cid) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGTFTRDP_SET;

    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


IMM_Zc* At_CsndBuildUdpPacket(const VOS_UINT32 ipAddr, const VOS_UINT16 length)
{
    IMM_Zc    *immZc = VOS_NULL_PTR;
    VOS_UINT8 *data  = VOS_NULL_PTR;
    VOS_UINT32 srcAddr;
    VOS_UINT32 destAddr;
    VOS_UINT16 destPort;
    VOS_UINT16 srcPort;
    VOS_UINT16 totalLen;
    VOS_UINT16 macHeaderLen;

    totalLen = length + AT_IP_HDR_LEN + AT_UDP_HDR_LEN;
#if (FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
    macHeaderLen = IMM_MAC_HEADER_RES_LEN;
#else
    macHeaderLen = 0;
#endif

    /* 申请跨核零拷贝内存 */
    immZc = IMM_ZcStaticAlloc(totalLen + macHeaderLen);
    if (immZc == VOS_NULL_PTR) {
        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcStaticAlloc fail!");
        return VOS_NULL_PTR;
    }
    IMM_ZcReserve(immZc, macHeaderLen);

    srcAddr  = ipAddr;
    destAddr = ipAddr + 1;
    destPort = AT_UART_BAUDRATE_9600;
    srcPort  = AT_UDP_SRC_PORT;

    data = (VOS_UINT8 *)IMM_ZcPut(immZc, totalLen);
    if (data == VOS_NULL_PTR) {
        IMM_ZcFree(immZc);

        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcPut fail!");

        return VOS_NULL_PTR;
    }

#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON && FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
    immZc->protocol = htons(ETH_P_IP); /*lint !e778*/
#endif

    /* 构造UDP头 */
    if (AT_BuildUdpHdr((AT_UdpPacketFormat *)data, length, srcAddr, destAddr, srcPort, destPort) != VOS_OK) {
        IMM_ZcFree(immZc);

        AT_ERR_LOG("At_CsndBuildUdpPacket: IMM_ZcPut fail!");

        return VOS_NULL_PTR;
    }

    return immZc;
}

#if (FEATURE_DATA_SERVICE_NEW_PLATFORM == FEATURE_ON)
#if (FEATURE_ACORE_MODULE_TO_CCORE == FEATURE_OFF)
VOS_UINT32 AT_IfaceTx(VOS_UINT8 ifaceId, IMM_Zc *buff)
{
    return (VOS_UINT32)ads_iface_tx(ifaceId, buff);
}
#else
VOS_UINT32 AT_IfaceTx(VOS_UINT8 ifaceId, IMM_Zc *buff)
{
    return CDS_IfaceTx(ifaceId, (TTF_Mem *)buff);
}
#endif


VOS_UINT32 At_SetCsndPara(VOS_UINT8 indexNum)
{
    IMM_Zc          *immZc = VOS_NULL_PTR;
    VOS_UINT32       ipAddr;
    VOS_UINT16       length;
    PS_IFACE_IdUint8 ifaceId;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CSND_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ifaceId = (PS_IFACE_IdUint8)g_atParaList[0].paraValue;
    if (ifaceId >= PS_IFACE_ID_BUTT) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 计算UDP报文长度 */
    length = (VOS_UINT16)g_atParaList[1].paraValue;
    length = (length > AT_CSND_PLAYLOAD_MAX_LEN) ? (AT_CSND_PLAYLOAD_MAX_LEN) : length;

    ipAddr = AT_PS_GetIpAddrByIfaceId(indexNum, ifaceId);

    immZc = At_CsndBuildUdpPacket(ipAddr, length);

    if (immZc == VOS_NULL_PTR) {
        AT_ERR_LOG("At_SetCsndPara: At_CsndBuildUdpPacket fail!");
        return AT_ERROR;
    }

    /* 发送上行数据包 */
    if (AT_IfaceTx(ifaceId, immZc) != VOS_OK) {
        AT_ERR_LOG("At_SetCsndPara: ads_iface_tx fail!");
        return AT_ERROR;
    }

    return AT_OK;
}
#else

VOS_UINT32 At_SetCsndPara(VOS_UINT8 indexNum)
{
    IMM_Zc *immZc = VOS_NULL_PTR;
    VOS_UINT8 rabId;
    VOS_UINT16 length;
    ModemIdUint16 modemId;
    VOS_UINT32 ipAddr;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CSND_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* RABID有效性检查[5,15] */
    rabId = (VOS_UINT8)g_atParaList[0].paraValue;

    if (!AT_PS_IS_RABID_VALID(rabId)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 计算UDP报文长度 */
    length = (VOS_UINT16)g_atParaList[1].paraValue;
    length = (length > AT_CSND_PLAYLOAD_MAX_LEN) ? (AT_CSND_PLAYLOAD_MAX_LEN) : length;

    ipAddr = AT_PS_GetIpAddrByRabId(indexNum, rabId);

    immZc = At_CsndBuildUdpPacket(ipAddr, length);

    if (immZc == VOS_NULL_PTR) {
        AT_ERR_LOG("At_SetCsndPara: At_CsndBuildUdpPacket fail!");
        return AT_ERROR;
    }

    modemId = MODEM_ID_0;
    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        IMM_ZcFree(immZc);
        AT_ERR_LOG("At_SetCsndPara: Get modem id fail.");
        return AT_ERROR;
    }

    if (modemId != MODEM_ID_0) {
        rabId |= AT_PS_RABID_MODEM_1_MASK;
    }

    /* 发送上行数据包 */
    if (ADS_UL_SendPacket(immZc, rabId) != VOS_OK) {
        AT_ERR_LOG("At_SetCsndPara: ADS_UL_SendPacket fail!");
        return AT_ERROR;
    }

    return AT_OK;
}
#endif


TAF_UINT32 At_SetCgdataPara(TAF_UINT8 indexNum)
{
    VOS_UINT32        cidIndex;
    TAF_CID_ListState cidListStateInfo;

    /* 初始化 */
    cidIndex = 0;
    (VOS_VOID)memset_s(&cidListStateInfo, sizeof(cidListStateInfo), 0x00, sizeof(TAF_CID_ListState));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多, 目前最多支持一个CID */
    if (g_atParaIndex > AT_CGDATA_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <L2P>不处理 */

    /* 参数设置 */
    cidListStateInfo.state = 1;

    if (g_atParaList[1].paraLen == 0) {
        cidIndex = 1;
    } else {
        cidIndex = g_atParaList[1].paraValue;
    }

    /* 以CID作为下标, 标记对应的CID */
    cidListStateInfo.cid[cidIndex] = 1;

    /* 执行命令操作 */
    if (TAF_PS_SetPdpContextState(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                  &cidListStateInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGDATA_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetCgattPara(TAF_UINT8 indexNum)
{
    TAF_MMA_DetachPara detachPara;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (g_atParaList[0].paraValue == 0) {
        /* 执行Detach操作 */
        (VOS_VOID)memset_s(&detachPara, sizeof(detachPara), 0x00, sizeof(TAF_MMA_DetachPara));
        detachPara.detachCause  = TAF_MMA_DETACH_CAUSE_USER_DETACH;
        detachPara.detachDomain = TAF_MMA_SERVICE_DOMAIN_PS;

        if (TAF_MMA_DetachReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &detachPara) == VOS_TRUE) {
            /* 设置当前操作类型 */
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGATT_DETAACH_SET;
            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        } else {
            return AT_ERROR;
        }
    } else {
        /* 执行Attach操作 */
        if (TAF_MMA_AttachReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, TAF_MMA_ATTACH_TYPE_GPRS) ==
            VOS_TRUE) {
            /* 设置当前操作类型 */
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGATT_ATTACH_SET;
            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        } else {
            return AT_ERROR;
        }
    }
}


TAF_UINT32 At_SetCgcattParaDetach(TAF_UINT8 ucIndex)
{
    TAF_MMA_DetachPara stDetachPara;

    /* 执行Detach操作 */
    (VOS_VOID)memset_s(&stDetachPara, sizeof(stDetachPara), 0x00, sizeof(TAF_MMA_DetachPara));
    stDetachPara.detachCause = TAF_MMA_DETACH_CAUSE_USER_DETACH;

    /* 只有detach mode=3时 可支持三个参数，其他情况都是两个参数 */
    if (g_atParaList[AT_CGCATT_MODE].paraValue == TAF_MMA_ATTACH_TYPE_GPRS_IMSI) {
        if (g_atParaIndex > AT_CGCATT_MODE_EQUALED_3_MAX_PARA_NUM) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_CGCATT_PS_STATE].paraValue > 1) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_CGCATT_PS_STATE].paraValue == 1) {
            stDetachPara.detachCause = TAF_MMA_DETACH_CAUSE_SMS_ANTI_ATTACK;
        }
    } else {
        if (g_atParaIndex > AT_CGCATT_PARA_MAX_NUM) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 转换用户的DETACH类型 */
    stDetachPara.detachDomain = At_ConvertDetachTypeToServiceDomain(g_atParaList[1].paraValue);

    if (TAF_MMA_DetachReq(WUEPS_PID_AT, g_atClientTab[ucIndex].clientId, 0, &stDetachPara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        switch (g_atParaList[1].paraValue) {
            case AT_CGCATT_MODE_PS:
                g_atClientTab[ucIndex].cmdCurrentOpt = AT_CMD_CGCATT_PS_DETAACH_SET;
                break;

            case AT_CGCATT_MODE_CS:
                g_atClientTab[ucIndex].cmdCurrentOpt = AT_CMD_CGCATT_CS_DETAACH_SET;
                break;

            default:
                g_atClientTab[ucIndex].cmdCurrentOpt = AT_CMD_CGCATT_PS_CS_DETAACH_SET;
                break;
        }
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCgcattPara(TAF_UINT8 indexNum)
{
    TAF_MMA_AttachTypeUint8 attachType;
    attachType = TAF_MMA_ATTACH_TYPE_BUTT;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* detach 处理封装成子函数 */
    if (g_atParaList[0].paraValue == 0) {
        return At_SetCgcattParaDetach(indexNum);
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CGCATT_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 转换用户的ATTACH类型 */
    attachType = At_ConvertCgcattModeToAttachType(g_atParaList[1].paraValue);

    /* 执行Attach操作 */
    if (TAF_MMA_AttachReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, attachType) == VOS_TRUE) {
        /* 设置当前操作类型 */
        switch (g_atParaList[1].paraValue) {
            case AT_CGCATT_MODE_PS:
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGCATT_PS_ATTACH_SET;
                break;

            case AT_CGCATT_MODE_CS:
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGCATT_CS_ATTACH_SET;
                break;

            default:
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGCATT_PS_CS_ATTACH_SET;
                break;
        }
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

VOS_VOID At_SetCopsActPara(TAF_MMA_RatTypeUint8 *phRat, VOS_UINT16 paraLen, VOS_UINT32 paraValue)
{
    /* 如果参数长度为0，使用无效值 */
    if (paraLen == 0) {
        *phRat = TAF_MMA_RAT_BUTT;

        return;
    }

    /* 根据用户输入的参数值,转换为AT与MMA的接口定义的接入技术参数 */
    if (paraValue == AT_COPS_RAT_GSM) {
        *phRat = TAF_MMA_RAT_GSM;
    } else if (paraValue == AT_COPS_RAT_WCDMA) {
        *phRat = TAF_MMA_RAT_WCDMA;
    }
#if (FEATURE_LTE == FEATURE_ON)
    else if (paraValue == AT_COPS_RAT_LTE) {
        *phRat = TAF_MMA_RAT_LTE;
    }
#endif
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    else if (paraValue == AT_COPS_RAT_NR) {
        *phRat = TAF_MMA_RAT_NR;
    }
#endif
    else {
        *phRat = TAF_MMA_RAT_BUTT;
    }

    return;
}


VOS_UINT32 AT_DigitString2Hex(VOS_UINT8 *digitStr, VOS_UINT16 len, VOS_UINT32 *destHex)
{
    VOS_UINT32 currValue;
    VOS_UINT32 totalVaue;
    VOS_UINT8  length;

    currValue = 0;
    totalVaue = 0;
    length    = 0;
    currValue = (VOS_UINT32)*digitStr++;

    while (length++ < len) {
        if ((currValue >= '0') && (currValue <= '9')) {
            currValue = currValue - '0';
        } else {
            return VOS_FALSE;
        }

        if (totalVaue > 0x0FFFFFFF) { /* 发生反转 */
            return VOS_FALSE;
        } else {
            totalVaue = (totalVaue << AT_OCTET_MOVE_FOUR_BITS) + currValue; /* accumulate digit */
            currValue = (VOS_UINT32)(VOS_UINT8)*digitStr++;                 /* get next Char */
        }
    }

    *destHex = totalVaue;
    return VOS_TRUE;
}


VOS_UINT32 AT_FormatNumericPlmnStr2PlmnId(TAF_PLMN_Id *plmn, VOS_UINT16 oprNameLen, VOS_CHAR *oprName)
{
    if (AT_DigitString2Hex((VOS_UINT8 *)oprName, AT_MBMS_MCC_LENGTH, &plmn->mcc) == VOS_FALSE) {
        return VOS_FALSE;
    }

    if (AT_DigitString2Hex((VOS_UINT8 *)&oprName[AT_MBMS_MCC_LENGTH], oprNameLen - AT_MBMS_MNC_MAX_LENGTH,
                           &plmn->mnc) == VOS_FALSE) {
        return VOS_FALSE;
    }

    plmn->mcc |= 0xFFFFF000;
    /* mnc一个数字只占半个字节，也就是4bit */
    plmn->mnc |= (0xFFFFFFFF << ((oprNameLen - AT_MBMS_MNC_MAX_LENGTH) * 4));

    return VOS_TRUE;
}

#if (FEATURE_CSG == FEATURE_ON)

VOS_UINT32 AT_SetCsgIdSearchPara(VOS_UINT8 indexNum)
{
    /* 检查输入at命令参数是否合法，合法通知mma */
    TAF_MMA_CsgSpecSearchInfo csgIdUserSel;
    VOS_UINT32                ratType;

    csgIdUserSel.plmnId.mcc = TAF_MMA_INVALID_MCC;
    csgIdUserSel.plmnId.mnc = TAF_MMA_INVALID_MNC;
    csgIdUserSel.csgId      = TAF_MMA_INVALID_CSG_ID_VALUE;
    csgIdUserSel.ratType    = TAF_MMA_RAT_BUTT;
    ratType                 = TAF_MMA_RAT_BUTT;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不是3个 */
    if (g_atParaIndex != AT_CSGIDSRCH_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* @oper长度非法 */
    if ((g_atParaList[AT_CSGIDSRCH_PLMN_ID].paraLen != AT_CSGIDSRCH_PLMN_ID_VAILD_LEN1) &&
        (g_atParaList[AT_CSGIDSRCH_PLMN_ID].paraLen != AT_CSGIDSRCH_PLMN_ID_VAILD_LEN2)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* CSG ID长度非法 */
    if ((g_atParaList[AT_CSGIDSRCH_CSG_ID].paraLen == 0) ||
        (g_atParaList[AT_CSGIDSRCH_CSG_ID].paraLen > AT_CSGIDSRCH_CSG_ID_LEN_MAX)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_String2Hex(g_atParaList[AT_CSGIDSRCH_RAT].para,
                      g_atParaList[AT_CSGIDSRCH_RAT].paraLen, &ratType) != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 指定的接入技术不为LTE，目前的阶段只支持指定搜LTE的CSG ID，后续如果支持其他接入技术，删除此判断即可 */
    if ((ratType != AT_COPS_RAT_LTE)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<AcT> */
    At_SetCopsActPara(&csgIdUserSel.ratType, g_atParaList[AT_CSGIDSRCH_RAT].paraLen, ratType);

    /* 生成PLMN ID */
    if (AT_FormatNumericPlmnStr2PlmnId(&csgIdUserSel.plmnId, g_atParaList[AT_CSGIDSRCH_PLMN_ID].paraLen,
                                       (VOS_CHAR *)g_atParaList[AT_CSGIDSRCH_PLMN_ID].para) != VOS_TRUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 生成CSG ID */
    if (AT_String2Hex(g_atParaList[AT_CSGIDSRCH_CSG_ID].para, g_atParaList[AT_CSGIDSRCH_CSG_ID].paraLen,
                      &csgIdUserSel.csgId) != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_SetCsgIdSearch(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                               &csgIdUserSel) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSG_SPEC_SEARCH;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}
#endif


LOCAL VOS_UINT32 AT_ProcCopsSetMode0(VOS_UINT8 indexNum)
{
    TAF_MMA_Ctrl     ctrl;
    TAF_PLMN_UserSel plmnUserSel;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&plmnUserSel, sizeof(plmnUserSel), 0x00, sizeof(TAF_PLMN_UserSel));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    plmnUserSel.bgSrchFlag = VOS_FALSE;
    plmnUserSel.srchType   = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    if (TAF_MMA_PlmnSearchReq(&ctrl, TAF_MMA_SEARCH_TYPE_AUTO, &plmnUserSel) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COPS_SET_AUTOMATIC;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode1(VOS_UINT8 indexNum)
{
    TAF_MMA_Ctrl         ctrl;
    TAF_PLMN_UserSel     plmnUserSel;
    VOS_UINT32           getOperNameRst;
    TAF_MMA_RatTypeUint8 phRat;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&plmnUserSel, sizeof(plmnUserSel), 0x00, sizeof(TAF_PLMN_UserSel));

    /* 参数为空 */
    if (g_atParaList[AT_COPS_OPER].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口信息 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    /* 设置<AcT> */
    At_SetCopsActPara(&phRat, g_atParaList[AT_COPS_RAT].paraLen, g_atParaList[AT_COPS_RAT].paraValue);

    plmnUserSel.formatType = (VOS_UINT8)g_atParaList[1].paraValue;
    plmnUserSel.accessMode = phRat;

    plmnUserSel.bgSrchFlag = VOS_FALSE;
    plmnUserSel.srchType   = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    /* 根据输入PLMN的类型来保存到TAF_PLMN_UserSel结构中，发送到MMA模块，有MMA进行转换并处理指定搜。 */
    getOperNameRst = AT_GetOperatorNameFromParam(&plmnUserSel.operNameLen, plmnUserSel.operName,
                                                 sizeof(plmnUserSel.operName), plmnUserSel.formatType);

    if (getOperNameRst != AT_OK) {
        return getOperNameRst;
    }

    if (TAF_MMA_PlmnSearchReq(&ctrl, TAF_MMA_SEARCH_TYPE_MANUAL, &plmnUserSel) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COPS_SET_MANUAL;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode2(VOS_UINT8 indexNum)
{
    TAF_MMA_DetachPara detachPara;

    (VOS_VOID)memset_s(&detachPara, sizeof(detachPara), 0x00, sizeof(TAF_MMA_DetachPara));

    detachPara.detachCause = TAF_MMA_DETACH_CAUSE_COPS;

    /* 转换用户的DETACH类型 */
    detachPara.detachDomain = TAF_MMA_SERVICE_DOMAIN_CS_PS;

    if (TAF_MMA_DetachReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &detachPara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COPS_SET_DEREGISTER;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode3(VOS_UINT8 indexNum)
{
    TAF_MMA_CopsFormatTypeSetReq copsFormatSetReq;

    (VOS_VOID)memset_s(&copsFormatSetReq, sizeof(copsFormatSetReq), 0x00, sizeof(copsFormatSetReq));

    copsFormatSetReq.copsFormatType = (VOS_UINT8)g_atParaList[1].paraValue;

    Taf_SetCopsFormatTypeReq(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &copsFormatSetReq);

    return AT_OK;
}


LOCAL VOS_UINT32 AT_ProcCopsSetMode4(VOS_UINT8 indexNum)
{
    TAF_MMA_Ctrl         ctrl;
    TAF_PLMN_UserSel     plmnUserSel;
    VOS_UINT32           getOperNameRst;
    TAF_MMA_RatTypeUint8 phRat;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&plmnUserSel, sizeof(plmnUserSel), 0x00, sizeof(TAF_PLMN_UserSel));

    /* 参数为空 */
    if (g_atParaList[AT_COPS_OPER].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口信息 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    /* 设置<AcT> */
    At_SetCopsActPara(&phRat, g_atParaList[AT_COPS_RAT].paraLen, g_atParaList[AT_COPS_RAT].paraValue);

    plmnUserSel.formatType = (VOS_UINT8)g_atParaList[1].paraValue;
    plmnUserSel.accessMode = phRat;
    plmnUserSel.bgSrchFlag = VOS_FALSE;
    plmnUserSel.srchType   = TAF_MMA_EXTEND_SEARCH_TYPE_FULLBAND;

    /* 根据输入PLMN的类型来保存到TAF_PLMN_UserSel结构中，发送到MMA模块，有MMA进行转换并处理指定搜。 */
    getOperNameRst = AT_GetOperatorNameFromParam(&plmnUserSel.operNameLen, plmnUserSel.operName,
                                                 sizeof(plmnUserSel.operName), plmnUserSel.formatType);

    if (getOperNameRst != AT_OK) {
        return getOperNameRst;
    }

    if (TAF_MMA_PlmnSearchReq(&ctrl, TAF_MMA_SEARCH_TYPE_MANUAL_AUTO, &plmnUserSel) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COPS_SET_MANUAL_AUTOMATIC_MANUAL;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetCopsPara(TAF_UINT8 indexNum)
{
    AT_ModemNetCtx             *netCtx = VOS_NULL_PTR;
    VOS_UINT32                  i;
    const AT_UserReselProcTbl   userReselProcTbl[] = {
        /*   user option     reserved     proc func            */
        { 0, 0, AT_ProcCopsSetMode0 }, { 1, 0, AT_ProcCopsSetMode1 }, { 2, 0, AT_ProcCopsSetMode2 },
        { 3, 0, AT_ProcCopsSetMode3 }, { 4, 0, AT_ProcCopsSetMode4 },
    };

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_COPS_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[AT_COPS_MODE].paraLen == 0) {
        g_atParaList[AT_COPS_MODE].paraValue = 0;
    }

    /*
     * 设置<mode> A32D07158
     * only in case of mode = 3(change the format), should the new format be saved.
     */
    /* 设置<format> */
    if ((g_atParaList[1].paraLen != 0) && (g_atParaList[AT_COPS_MODE].paraValue == 3)) {
        /* 在每次进行搜索时，不论是成功还是失败，PLMN要根据用户指定的最新的格式显示要求进行显示 */
        netCtx->copsFormatType = (VOS_UINT8)g_atParaList[1].paraValue;
    }

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    if (At_CheckCurrRatModeIsCL((VOS_UINT8)(g_atClientTab[indexNum].clientId)) == VOS_TRUE) {
        if ((g_atParaList[AT_COPS_MODE].paraValue != 3) && (g_atParaList[AT_COPS_MODE].paraValue != 0)) {
            return AT_CME_OPERATION_NOT_ALLOWED_IN_CL_MODE;
        }
    }
#endif


    for (i = 0; i < sizeof(userReselProcTbl) / sizeof(userReselProcTbl[0]); i++) {
        if (g_atParaList[AT_COPS_MODE].paraValue == userReselProcTbl[i].userResel) {
            return userReselProcTbl[i].userReselProc(indexNum);
        }
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetCesqPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 result;

    result = TAF_MMA_QryCerssiReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId);

    /* 执行命令操作 */
    if (result == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CESQ_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCgclassPara(TAF_UINT8 indexNum)
{
    TAF_PH_MS_CLASS_TYPE msClass;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<class> */
    switch (g_atParaList[0].paraValue) {
        case AT_PH_MS_A_MODE:
            msClass = TAF_PH_MS_CLASS_A;
            break;

        case AT_PH_MS_B_MODE:
            msClass = TAF_PH_MS_CLASS_B;
            break;

        case AT_PH_MS_CG_MODE:
            msClass = TAF_PH_MS_CLASS_CG;
            break;

        default:
            msClass = TAF_PH_MS_CLASS_CC;
            break;
    }

    if (msClass == TAF_PH_MS_CLASS_A) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_CheckUserRebootSupportFlg(VOS_VOID)
{
    TAF_NVIM_UserRebootSupport userRebootSupport;
    VOS_UINT32                 result;
    VOS_UINT32                 len;

    len = sizeof(TAF_NVIM_UserRebootSupport);

    (VOS_VOID)memset_s(&userRebootSupport, len, 0x00, len);

    result = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_USER_REBOOT_SUPPORT_FLG, &userRebootSupport, len);

    if (result != NV_OK) {
        AT_WARN_LOG("TAF_MMA_IsUserRebootSupport:Read Nvim Failed");
        return VOS_FALSE;
    }

    if (userRebootSupport.userRebootConfig == 0xEF) {
        return VOS_TRUE;
    }

    return VOS_FALSE;
}


TAF_UINT32 At_SetCfunPara(TAF_UINT8 indexNum)
{
    TAF_MMA_PhoneModePara phoneModePara;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CFUN_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (((g_atParaList[AT_CFUN_FUN].paraLen == 0) || (g_atParaList[AT_CFUN_RST].paraLen == 0)) &&
        (g_atParaIndex == AT_CFUN_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fun> */
    if (g_atParaList[AT_CFUN_FUN].paraValue >= TAF_PH_MODE_NUM_MAX) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

/* 输出TAF的回放数据 */
#if (VOS_WIN32 == VOS_OS_VER)
    NAS_MSG_SndOutsideContextData_Part1();
    NAS_MSG_SndOutsideContextData_Part2();
    NAS_MSG_SndOutsideContextData_Part3();
#endif
    /* 输出TAF的回放数据 */

    (VOS_VOID)memset_s(&phoneModePara, sizeof(phoneModePara), 0x00, sizeof(TAF_MMA_PhoneModePara));
    phoneModePara.phMode = (VOS_UINT8)g_atParaList[AT_CFUN_FUN].paraValue;

    if (g_atParaIndex == AT_CFUN_PARA_NUM) {
        phoneModePara.phReset = (VOS_UINT8)g_atParaList[AT_CFUN_RST].paraValue;

        /* NV项打开时AT+CFUN=1,1直接在A核触发整机复位 */
        if ((AT_CheckUserRebootSupportFlg() == VOS_TRUE) && (phoneModePara.phMode == TAF_PH_MODE_FULL) &&
            (phoneModePara.phReset == TAF_PH_OP_MODE_RESET)) {
            g_atSendDataBuff.bufLen = 0;
            At_FormatResultData(indexNum, AT_OK);
            VOS_TaskDelay(300); /* wait 300 tick */
            (VOS_VOID)TAF_ACORE_NV_FLUSH();
            AT_OmSystemError(NAS_REBOOT_MOD_ID_USER, 0, 0, VOS_NULL_PTR, 0);
            return AT_SUCCESS;
        }
    }

    if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CFUN_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgmiPara(TAF_UINT8 indexNum)
{
    VOS_UINT8 mfrId[TAF_MAX_MFR_ID_STR_LEN + 1];

    (VOS_VOID)memset_s(mfrId, TAF_MAX_MFR_ID_STR_LEN + 1, 0x00, TAF_MAX_MFR_ID_STR_LEN + 1);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_FMRID, mfrId, TAF_MAX_MFR_ID_STR_LEN) != NV_OK) {
        return AT_ERROR;
    } else {
        g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (TAF_CHAR *)g_atSndCodeAddress, "%s", mfrId);

        return AT_OK;
    }
}

TAF_UINT32 At_SetCgmmPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_MSID_QRY_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGMM_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgmrPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_MSID_QRY_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGMR_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetCgsnPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* AT命令状态检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息 ID_AT_MTA_CGSN_QRY_REQ 给 MTA 处理， */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, ID_AT_MTA_CGSN_QRY_REQ,
                                 VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGSN_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCimiPara(TAF_UINT8 indexNum)
{
    TAF_AT_NvimCimiPortCfg cimiPortCfg;

    cimiPortCfg.cimiPortCfg = 0;

    /* 根据NV项配置参数，对命令下发的通道进行判断 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_CIMI_PORT_CFG, &cimiPortCfg, sizeof(cimiPortCfg)) != NV_OK) {
        cimiPortCfg.cimiPortCfg = 0;
    }

    /* 该通道对应的Bit位不为0，则直接返回AT_ERROR */
    if ((cimiPortCfg.cimiPortCfg & ((VOS_UINT32)1 << indexNum)) != 0) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (SI_PIH_CimiSetReq(g_atClientTab[indexNum].clientId, 0) == AT_SUCCESS)
    {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CIMI_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCsqPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_QryCsqReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSQ_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetCpdwPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 通过给C CPU发ID_TAF_MMA_CPLS_SET_REQ消息通知MT下电 */
    rst = TAF_MMA_MtPowerDownReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0);

    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MMA_MT_POWER_DOWN;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif

TAF_UINT32 At_SetSnPara(TAF_UINT8 indexNum)
{
    TAF_PH_SerialNum serialNum;
    TAF_UINT16       length;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) {
        return At_WriteSnPara(indexNum);
    }
    /* 从NV中读取 Serial Num,上报显示，返回 */

    (VOS_VOID)memset_s(&serialNum, sizeof(serialNum), 0x00, sizeof(TAF_PH_SerialNum));

    length = TAF_SERIAL_NUM_NV_LEN;
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_SERIAL_NUM, serialNum.serialNum, length) != NV_OK) {
        AT_WARN_LOG("At_SetSnPara:WARNING:NVIM Read NV_ITEM_SERIAL_NUM falied!");
        return AT_ERROR;
    } else {
        (VOS_VOID)memset_s((serialNum.serialNum + TAF_SERIAL_NUM_LEN),
                 (VOS_SIZE_T)((TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN) * sizeof(serialNum.serialNum[0])),
                 0x00, (VOS_SIZE_T)((TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN) * sizeof(serialNum.serialNum[0])));
        length = 0;
        length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (TAF_CHAR *)g_atSndCodeAddress + length, "%s:", g_parseContext[indexNum].cmdElement->cmdName);
        length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (TAF_CHAR *)g_atSndCodeAddress + length, "%s", serialNum.serialNum);
    }
    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 At_WriteSnPara(VOS_UINT8 indexNum)
{
    TAF_PH_SerialNum serialNum;
    errno_t          memResult;

    /* 参数个数不为1 */
    if (g_atParaIndex != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 如果参数长度不等于16，直接返回错误 */
    if (g_atParaList[0].paraLen != TAF_SERIAL_NUM_LEN) {
        return AT_SN_LENGTH_ERROR;
    }

    /* 检查当前参数是否为数字字母字符串,不是则直接返回错误 */
    if (At_CheckNumCharString(g_atParaList[0].para, g_atParaList[0].paraLen) == AT_FAILURE) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 拷贝设置的16位SN参数到结构体变量stSerialNum.aucSerialNum中 */
    memResult = memcpy_s(serialNum.serialNum, sizeof(serialNum.serialNum), g_atParaList[0].para, TAF_SERIAL_NUM_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(serialNum.serialNum), TAF_SERIAL_NUM_LEN);

    /* 将stSerialNum.aucSerialNum后四位填充为0xFF */
    (VOS_VOID)memset_s((serialNum.serialNum + TAF_SERIAL_NUM_LEN), TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN, 0xFF,
             (TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN));

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_SERIAL_NUM, serialNum.serialNum, TAF_SERIAL_NUM_NV_LEN) != NV_OK) {
        AT_WARN_LOG("At_WriteSnPara:WARNING:TAF_ACORE_NV_WRITE NV_ITEM_SERIAL_NUM failed!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return AT_OK;
}

VOS_UINT32 At_SetHwVerPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息DRV_AGENT_HARDWARE_QRY给AT AGENT处理，该消息无参数结构 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, DRV_AGENT_HARDWARE_QRY,
                                 VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DRV_AGENT_HARDWARE_QRY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

VOS_UINT32 At_SetFHVerPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息DRV_AGENT_FULL_HARDWARE_QRY给AT AGENT处理，该消息无参数结构 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), DRV_AGENT_FULL_HARDWARE_QRY,
                                 VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DRV_AGENT_FULL_HARDWARE_QRY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetPfverPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 发消息到C核获取充电状态和电池电量 */
    ret = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 DRV_AGENT_PFVER_QRY_REQ, VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT);
    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetPfverPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PFVER_READ;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetCLACPara(VOS_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    g_atSendDataBuff.bufLen = 0;

    /* 依次输出支持的可显示的AT命令 */
    AT_ClacCmdProc();

    return AT_OK;
}


TAF_UINT32 At_SetCpbsPara(TAF_UINT8 indexNum)
{
    SI_PB_StorateTypeUint32 storage = SI_PB_STORAGE_UNSPECIFIED;
    TAF_UINT32              i;

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* VOS_StrCmp需要做指针非空检查，切记! */
    if ((TAF_CHAR *)g_atStringTab[AT_STRING_SM].text == TAF_NULL_PTR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((TAF_CHAR *)g_atStringTab[AT_STRING_ON].text == TAF_NULL_PTR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((TAF_CHAR *)g_atStringTab[AT_STRING_EN].text == TAF_NULL_PTR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((TAF_CHAR *)g_atStringTab[AT_STRING_FD].text == TAF_NULL_PTR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((TAF_CHAR *)g_atStringTab[AT_STRING_BD].text == TAF_NULL_PTR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < g_atParaList[0].paraLen; i++) {
        g_atParaList[0].para[i] = At_UpChar(g_atParaList[0].para[i]);
    }

    if (VOS_StrCmp((TAF_CHAR *)g_atStringTab[AT_STRING_ON].text, (TAF_CHAR *)g_atParaList[0].para) == 0) {
        storage = SI_PB_STORAGE_ON;
    } else if (VOS_StrCmp((TAF_CHAR *)g_atStringTab[AT_STRING_SM].text, (TAF_CHAR *)g_atParaList[0].para) == 0) {
        storage = SI_PB_STORAGE_SM;
    } else if (VOS_StrCmp((TAF_CHAR *)g_atStringTab[AT_STRING_FD].text, (TAF_CHAR *)g_atParaList[0].para) == 0) {
        storage = SI_PB_STORAGE_FD;
    } else if (VOS_StrCmp((TAF_CHAR *)g_atStringTab[AT_STRING_EN].text, (TAF_CHAR *)g_atParaList[0].para) == 0) {
        storage = SI_PB_STORAGE_EC;
    } else if (VOS_StrCmp((TAF_CHAR *)g_atStringTab[AT_STRING_BD].text, (TAF_CHAR *)g_atParaList[0].para) == 0) {
        storage = SI_PB_STORAGE_BD;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (SI_PB_Set(g_atClientTab[indexNum].clientId, 0, storage) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBS_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCpbr2Para(TAF_UINT8 indexNum)
{
    AT_CommPbCtx *commPbCntxt = VOS_NULL_PTR;
    VOS_UINT32    result;
    VOS_UINT16    index1;
    VOS_UINT16    index2;

    commPbCntxt = AT_GetCommPbCtxAddr();

    /* 命令格式检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 命令参数个数检查 */
    if ((g_atParaIndex < AT_CPBR_PARA_MIN_NUM) || (g_atParaIndex > AT_CPBR_PARA_MAX_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AT+CPBR=, */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<index1> */
    index1 = (VOS_UINT16)g_atParaList[0].paraValue;

    if (g_atParaIndex > AT_CPBR_PARA_MIN_NUM) {
        if (g_atParaList[1].paraLen == 0) {
            /* AT+CPBR=<index1>, */
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            /* AT+CPBR=<index1>,<index2> */
            index2 = (VOS_UINT8)g_atParaList[1].paraValue;
        }
    } else {
        /* AT+CPBR=<index1> */
        index2 = index1;
    }

    /* HSUART端口受限发送瓶颈, 需要逐条发送 */
    if (AT_CheckHsUartUser(indexNum) == VOS_TRUE) {
        commPbCntxt->currIdx       = index1;
        commPbCntxt->lastIdx       = index2;
        commPbCntxt->singleReadFlg = (index1 == index2) ? VOS_TRUE : VOS_FALSE;

        result = SI_PB_Read(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, commPbCntxt->currIdx,
                            commPbCntxt->currIdx);
    } else {
        result = SI_PB_Read(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, index1, index2);
    }

    if (result == TAF_SUCCESS) {
        g_pbPrintTag                          = TAF_FALSE;
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBR2_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCpbrPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CPBR_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[1].paraLen == 0) {
        g_atParaList[1].paraValue = g_atParaList[0].paraValue;
    }

    if (AT_CheckHsUartUser(indexNum) == VOS_TRUE) {
        AT_GetCommPbCtxAddr()->currIdx       = (VOS_UINT16)g_atParaList[0].paraValue;
        AT_GetCommPbCtxAddr()->lastIdx       = (VOS_UINT16)g_atParaList[1].paraValue;
        AT_GetCommPbCtxAddr()->singleReadFlg = (g_atParaList[0].paraValue == g_atParaList[1].paraValue) ? VOS_TRUE :
                                                                                                          VOS_FALSE;

        result = SI_PB_Read(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED,
                            AT_GetCommPbCtxAddr()->currIdx, AT_GetCommPbCtxAddr()->currIdx);
    } else {
        result = SI_PB_Read(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED,
                            (TAF_UINT16)g_atParaList[0].paraValue, (TAF_UINT16)g_atParaList[1].paraValue);
    }

    if (result == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBR_SET;

        g_pbPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_PbDeleteProc(TAF_UINT8 indexNum)
{
    /* 针对AT+CPBW=,和AT+CPBW=0的情况 */
    if (g_atParaList[0].paraLen == 0 || g_atParaList[0].paraValue == 0) {
        return AT_CME_INVALID_INDEX;
    }

    if (SI_PB_Delete(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED,
                     (TAF_UINT16)g_atParaList[0].paraValue) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    AT_ERR_LOG("At_PbDeleteProc error: delete pb record failed");

    return AT_ERROR;
}


SI_PB_AlphaTagTypeUint32 AT_SetCpbwAlphaTagType(VOS_VOID)
{
    SI_PB_AlphaTagTypeUint32 alphaTagType;
    if ((g_atParaList[AT_CPBW_CODING].paraValue == AT_CSCS_UCS2_CODE) &&
        (g_atParaIndex == AT_CPBW_PRIVATA_PARA_MAX_NUM)) {
        alphaTagType = AT_CSCS_UCS2_CODE;
    } else if ((g_atParaList[AT_CPBW_CODING].paraValue == AT_CSCS_IRA_CODE) &&
               (g_atParaIndex == AT_CPBW_PRIVATA_PARA_MAX_NUM)) {
        alphaTagType = AT_CSCS_IRA_CODE;
    } else if (g_atParaIndex == AT_CPBW_NLENGTH) {
        alphaTagType = AT_CSCS_IRA_CODE;
    } else {
        alphaTagType = AT_CSCS_IRA_CODE;
    }
    return alphaTagType;
}

TAF_UINT32 At_SetCpbwPara(TAF_UINT8 indexNum)
{
    SI_PB_Record records;
    TAF_UINT8   *number = VOS_NULL_PTR;
    TAF_UINT16   len;
    TAF_UINT16   alphaTagLength;
    TAF_UINT32   result;
    TAF_UINT32   resultTemp;
    errno_t      memResult;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) { /* 参数检查 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_CPBW_PRIVATA_PARA_MAX_NUM) { /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (g_atParaIndex == 1) {
        result = At_PbDeleteProc(indexNum);

        return result;
    }

    if ((g_atParaList[AT_CPBW_NUMBER].paraLen == 0) && (g_atParaList[AT_CPBW_TEXT].paraLen == 0)) {
        return AT_ERROR;
    }

    /* 确认编码类型，UNICODE或是ASCII码 */
    (VOS_VOID)memset_s(&records, sizeof(records), 0x00, sizeof(records)); /* 初始化 */

    records.alphaTagType = AT_SetCpbwAlphaTagType();

    if (g_atParaList[0].paraLen != 0) { /* 设置<index> */
        records.index = (TAF_UINT16)g_atParaList[0].paraValue;
    }

    if (g_atParaList[AT_CPBW_NUMBER].paraLen != 0) { /* 设置<number> */
        number = g_atParaList[AT_CPBW_NUMBER].para;
        len    = g_atParaList[AT_CPBW_NUMBER].paraLen;

        if (g_atParaList[AT_CPBW_NUMBER].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[AT_CPBW_NUMBER].para + 1;
            len    = g_atParaList[AT_CPBW_NUMBER].paraLen - 1;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        if (len > SI_PB_PHONENUM_MAX_LEN) {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records.number, sizeof(records.number), number, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records.number), len);
        }

        records.numberLength = (TAF_UINT8)len;
    }

    if (g_atParaList[AT_CPBW_TYPE].paraLen != 0) { /* 设置<type> */
        /* 号码类型待修改 */
        records.numberType = (At_GetCodeType(g_atParaList[AT_CPBW_NUMBER].para[0]) == PB_NUMBER_TYPE_INTERNATIONAL) ?
                                 PB_NUMBER_TYPE_INTERNATIONAL :
                                 (TAF_UINT8)g_atParaList[AT_CPBW_TYPE].paraValue;
    } else {
        records.numberType = (TAF_UINT8)At_GetCodeType(g_atParaList[AT_CPBW_NUMBER].para[0]);
    }

    if (records.numberType < AT_CPBW_TEXT_MIN_NUM) {
        return AT_CME_INVALID_INDEX;
    }

    if (g_atParaList[AT_CPBW_TEXT].paraLen != 0) { /* 设置<text> */
        /* 如果输入的AT命令已经指示是UNICODE编码要进行编码转换成ASCII码 */
        alphaTagLength = g_atParaList[AT_CPBW_TEXT].paraLen;

        if (records.alphaTagType == AT_CSCS_UCS2_CODE) {
            /* 当ASCII位数必须是UNICODE的偶数倍 */
            if ((alphaTagLength % 2) != 0) {
                return AT_ERROR;
            }

            if (At_UnicodePrint2Unicode(g_atParaList[AT_CPBW_TEXT].para, &alphaTagLength) == AT_FAILURE) {
                return AT_ERROR;
            }

            if (At_CheckNameUCS2Code(g_atParaList[AT_CPBW_TEXT].para, &alphaTagLength) == AT_FAILURE) {
                return AT_ERROR;
            }

            records.alphaTagType = g_atParaList[AT_CPBW_TEXT].para[0];
        }

        /*
         * 最终得到的姓名字段的长度不能超过TAF_PB_RECORD_STRU
         * 结构中的最大长度，否则会导致堆栈溢出
         */
        if (alphaTagLength > SI_PB_ALPHATAG_MAX_LEN) {
            alphaTagLength = SI_PB_ALPHATAG_MAX_LEN;
        }

        if (alphaTagLength > 0) {
            memResult = memcpy_s(records.alphaTag, sizeof(records.alphaTag), g_atParaList[AT_CPBW_TEXT].para,
                                 alphaTagLength);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records.alphaTag), alphaTagLength);
        }

        records.alphaTagLength = (TAF_UINT8)alphaTagLength;
    }

    if (g_atParaList[0].paraLen == 0) { /* 添加 */
        if (SI_PB_Add(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }

        return AT_ERROR;
    }

    result     = SI_PB_GetSPBFlag();
    resultTemp = SI_PB_GetStorateType();

    if ((result == 1) && (resultTemp == SI_PB_STORAGE_SM)) {
        if (SI_PB_SModify(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }
    }

    if (SI_PB_Modify(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_CME_INCORRECT_PARAMETERS;
}


TAF_VOID At_PbIraToUnicode(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT8 *dst, TAF_UINT16 *dstLen)
{
    TAF_UINT16 indexNum;
    TAF_UINT16 ucs2;

    for (indexNum = 0; indexNum < srcLen; indexNum++) {
        /* 查IRA到UNICODE转义表， 将IRA字符转换为unicode编码 */
        ucs2 = g_iraToUnicode[src[indexNum]].unicode;
        *dst = (TAF_UINT8)(ucs2 >> 8);
        dst++;
        *dst = (TAF_UINT8)ucs2;
        dst++;
    }

    /* 转换后长度为原来的2倍 */
    *dstLen = (TAF_UINT16)(srcLen << 1);

    return;
}


TAF_UINT32 At_OneUnicodeToGsm(TAF_UINT16 src, TAF_UINT8 *dst, TAF_UINT32 dstBufLen, TAF_UINT16 *dstLen)
{
    TAF_UINT16 indexNum;

    /* 避免输入码流为A0A1时存入SIM卡内容为1B40读出时上报为007C */
    if (src == 0x00A0) {
        AT_LOG1("At_OneUnicodeToGsm no found one unicode[0x%x] to gsm", src);

        return AT_FAILURE;
    }

    if (dstBufLen < AT_GSM_DATA_MAX_LEN) {
        AT_LOG1("At_OneUnicodeToGsm Dst len[%d] is not enough.", dstBufLen);
        return AT_FAILURE;
    }

    /* 查找GSM 到 UNICODE基本表 */
    for (indexNum = 0; indexNum < AT_PB_GSM_MAX_NUM; indexNum++) {
        if (src == g_gsmToUnicode[indexNum].unicode) {
            *dst = g_gsmToUnicode[indexNum].octet;

            *dstLen = AT_SEARCH_GSM_UNICODE_BASIC_DST_LEN;

            return AT_SUCCESS;
        }
    }

    /* 查找GSM 到 UNICODE扩展表 */
    for (indexNum = 0; indexNum < AT_PB_GSM7EXT_MAX_NUM; indexNum++) {
        if (src == g_gsm7extToUnicode[indexNum].unicode) {
            *dst++ = AT_PB_GSM7EXT_SYMBOL;
            *dst   = g_gsm7extToUnicode[indexNum].octet;

            *dstLen = AT_SEARCH_GSM_UNICODE_EXTEND_DST_LEN;

            return AT_SUCCESS;
        }
    }

    /* 未查找到时返回失败 */
    *dstLen = AT_SEARCH_GSM_NULL_DST_LEN;

    AT_LOG1("At_OneUnicodeToGsm no found one unicode[0x%x] to gsm", src);

    return AT_FAILURE;
}


TAF_UINT32 At_UnicodeTransferToGsmCalcLength(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT16 *dstLen)
{
    TAF_UINT16 indexNum;
    TAF_UINT16 unicodeChar;
    TAF_UINT8  gsmData[AT_GSM_DATA_MAX_LEN];
    TAF_UINT16 gsmDataLen;

    for (indexNum = 0; indexNum < (srcLen >> 1); indexNum++) {
        unicodeChar = (*src << 8) | (*(src + AT_SRC_OFFSET_1));

        /* 判断UNICODE是否可以转义为GSM7BIT */
        if (At_OneUnicodeToGsm(unicodeChar, gsmData, sizeof(gsmData), &gsmDataLen) != AT_SUCCESS) {
            AT_ERR_LOG("At_UnicodeTransferToGsmCalcLength error");

            return AT_FAILURE;
        }

        src += 2; /* Unicode编码占两字节，每次偏移量为2 */

        *dstLen += gsmDataLen;
    }

    return AT_SUCCESS;
}


TAF_VOID At_PbUnicodeParse(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT32 *alphaTagType, TAF_UINT16 *dstLen,
                           TAF_UINT16 *codeBase)
{
    TAF_UINT16 gsmCodeLen  = 0;
    TAF_UINT16 us81CodeLen = 0;
    TAF_UINT16 us82CodeLen = 0;
    TAF_UINT16 us81Base;
    TAF_UINT16 us82Base;
    TAF_UINT16 minCodeLen;
    TAF_UINT32 alphaTagTypeTemp;
    TAF_UINT16 codeBaseTemp;

    /* 先尝试转成GSM模式,如果能转换成功，则返回 */
    if (At_UnicodeTransferToGsmCalcLength(src, srcLen, &gsmCodeLen) == AT_SUCCESS) {
        *alphaTagType = SI_PB_ALPHATAG_TYPE_GSM;
        *dstLen       = gsmCodeLen;
        *codeBase     = 0;

        return;
    }

    /*
     * 默认置为80编码
     */
    minCodeLen       = srcLen + 1;
    alphaTagTypeTemp = SI_PB_ALPHATAG_TYPE_UCS2_80;
    codeBaseTemp     = 0;

    /* 计算81编码长度,选定最小编码长度及相应的编码方式 */
    if (At_UnicodeTransferTo81CalcLength(src, srcLen, &us81Base, &us81CodeLen) == AT_SUCCESS) {
        if (us81CodeLen <= minCodeLen) {
            minCodeLen       = us81CodeLen;
            alphaTagTypeTemp = SI_PB_ALPHATAG_TYPE_UCS2_81;
            codeBaseTemp     = us81Base;
        }
    }

    /* 计算82编码长度,选定最小编码长度及相应的编码方式 */
    if (At_UnicodeTransferTo82CalcLength(src, srcLen, &us82Base, &us82CodeLen) == AT_SUCCESS) {
        if (us82CodeLen <= minCodeLen) {
            minCodeLen       = us82CodeLen;
            alphaTagTypeTemp = SI_PB_ALPHATAG_TYPE_UCS2_82;
            codeBaseTemp     = us82Base;
        }
    }

    *dstLen       = minCodeLen;
    *codeBase     = codeBaseTemp;
    *alphaTagType = alphaTagTypeTemp;

    return;
}


TAF_UINT32 At_UnicodeTransferToGsm(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT8 *dst, TAF_UINT32 dstLen)
{
    TAF_UINT16 indexNum;
    TAF_UINT16 unicodeChar;
    TAF_UINT16 gsmDataLen = 0;

    for (indexNum = 0; indexNum < (srcLen >> 1); indexNum++) {
        unicodeChar = (*src << 8) | (*(src + AT_SRC_OFFSET_1));

        /* 逐个字符进行转换 */
        if (At_OneUnicodeToGsm(unicodeChar, dst, (dstLen - gsmDataLen), &gsmDataLen) != AT_SUCCESS) {
            AT_ERR_LOG("At_UnicodeTransferToGsm error");

            return AT_FAILURE;
        }

        dst += gsmDataLen;
        src += 2; /* UCS2 Unicode编码占两字节，每次偏移量为2 */
    }

    return AT_SUCCESS;
}


TAF_VOID At_UnicodeTransferTo80(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT8 *dst)
{
    errno_t    memResult;
    VOS_UINT32 srcSize;
    dst[0] = SI_PB_ALPHATAG_TYPE_UCS2_80;

    srcSize = TAF_STD_MemFunc_Min(SI_PB_ALPHATAG_MAX_LEN - 1, srcLen);
    if (srcSize > 0) {
        memResult = memcpy_s(&dst[1], SI_PB_ALPHATAG_MAX_LEN - 1, src, srcSize);
        TAF_MEM_CHK_RTN_VAL(memResult, SI_PB_ALPHATAG_MAX_LEN - 1, srcLen);
    }

    return;
}


TAF_UINT32 At_PbUnicodeTransfer(TAF_UINT8 *src, TAF_UINT16 srcLen, SI_PB_Record *record, TAF_UINT16 codeBase)
{
    TAF_UINT32 result = AT_FAILURE;

    switch (record->alphaTagType) {
        case SI_PB_ALPHATAG_TYPE_GSM:
            result = At_UnicodeTransferToGsm(src, srcLen, record->alphaTag, sizeof(record->alphaTag));

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_81:
            result = At_UnicodeTransferTo81(src, srcLen, codeBase, record->alphaTag);

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_82:
            result = At_UnicodeTransferTo82(src, srcLen, codeBase, record->alphaTag);

            break;

        case SI_PB_ALPHATAG_TYPE_UCS2_80:
            At_UnicodeTransferTo80(src, srcLen, record->alphaTag);
            result = AT_SUCCESS;

            break;

        default:

            break;
    }

    if (result != AT_SUCCESS) {
        AT_ERR_LOG("At_PbUnicodeTransfer: UCS2 transfer to gsm, 80, 81 or 82 error");
    }

    return result;
}


TAF_UINT32 At_PbAlphaTagProc(SI_PB_Record *record, AT_ParseParaType *atParaList)
{
    errno_t    memResult;
    TAF_UINT8 *alphaTag = VOS_NULL_PTR;
    TAF_UINT16 alphaTagLen;
    TAF_UINT16 alphaCodeLen;
    TAF_UINT16 codeBase;

    /* 姓名字段为空时，不用处理姓名字段，但电话号码应该保存，所以返回成功 */
    if (atParaList->paraLen == 0) {
        return AT_SUCCESS;
    }

    if (g_atCscsType == AT_CSCS_GSM_7Bit_CODE) {
        if (atParaList->paraLen > g_pbatInfo.nameMaxLen) {
            AT_ERR_LOG("At_PbAlphaTagProc error: text string to long in gsm7");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        record->alphaTagType = SI_PB_ALPHATAG_TYPE_GSM;

        /* GSM模式下判断是否所有输入码流小于0x7f，若大于0x7f时提示用户输入中含有非法字符 */
        if (At_Gsm7BitFormat(atParaList->para, atParaList->paraLen, record->alphaTag, &record->alphaTagLength) !=
            AT_SUCCESS) {
            AT_ERR_LOG("At_PbAlphaTagProc: error:the eighth bit is 1 in gsm7");

            return AT_CME_INVALID_CHARACTERS_IN_TEXT_STRING;
        }

        return AT_SUCCESS;
    }

    /* 分配空间用于存储中间转换的姓名字段，最多保存为80编码，因此最大空间为输入长度2倍 */
    alphaTagLen = (TAF_UINT16)(atParaList->paraLen << 1);

    alphaTag = (TAF_UINT8 *)VOS_MemAlloc(WUEPS_PID_AT, DYNAMIC_MEM_PT, alphaTagLen);

    if (alphaTag == VOS_NULL_PTR) {
        AT_ERR_LOG("At_PbAlphaTagProc error:malloc failed");

        return AT_FAILURE;
    }

    (VOS_VOID)memset_s(alphaTag, alphaTagLen, 0x00, alphaTagLen);

    /* IRA模式输入时先查表转换为UCS2，再处理 */
    if (g_atCscsType == AT_CSCS_IRA_CODE) {
        At_PbIraToUnicode(atParaList->para, atParaList->paraLen, alphaTag, &alphaTagLen);
    } else {
        /* UCS2编码方式下，两字节标识一个字符，即码流是四的倍数 */
        if ((atParaList->paraLen % 4) != 0) {
            VOS_MemFree(WUEPS_PID_AT, alphaTag);

            AT_LOG1("At_PbAlphaTagProc error: ucs2 codes length [%d] is nor 4 multiple", atParaList->paraLen);

            return AT_ERROR;
        }

        if (At_UnicodePrint2Unicode(atParaList->para, &(atParaList->paraLen)) == AT_FAILURE) {
            VOS_MemFree(WUEPS_PID_AT, alphaTag);

            AT_ERR_LOG("At_PbAlphaTagProc error: Printunicode to unicode failed");

            return AT_ERROR;
        }

        alphaTagLen = atParaList->paraLen;

        memResult = memcpy_s(alphaTag, alphaTagLen, atParaList->para, alphaTagLen);
        TAF_MEM_CHK_RTN_VAL(memResult, alphaTagLen, alphaTagLen);
    }

    /* 对UCS2或IRA模式转换后的UCS2码流确定存储格式 */
    At_PbUnicodeParse(alphaTag, alphaTagLen, &record->alphaTagType, &alphaCodeLen, &codeBase);

    /* 最终确定的编码长度大于电话本姓名字段能存储的长度时，提醒用户输入太长 */
    if (alphaCodeLen > g_pbatInfo.nameMaxLen) {
        VOS_MemFree(WUEPS_PID_AT, alphaTag);

        AT_LOG1("At_PbAlphaTagProc error: name length [%d] too long", alphaCodeLen);

        return AT_CME_TEXT_STRING_TOO_LONG;
    }

    record->alphaTagLength = (TAF_UINT8)alphaCodeLen;

    if (At_PbUnicodeTransfer(alphaTag, alphaTagLen, record, codeBase) != AT_SUCCESS) {
        VOS_MemFree(WUEPS_PID_AT, alphaTag);

        AT_ERR_LOG("At_PbAlphaTagProc: fail to convert UCS2");

        return AT_ERROR;
    }

    VOS_MemFree(WUEPS_PID_AT, alphaTag);

    return AT_SUCCESS;
}


TAF_UINT32 At_PbEmailTransferToGsm(TAF_UINT8 *src, TAF_UINT16 srcLen, TAF_UINT8 *dst, VOS_UINT32 dstBufLen,
                                   VOS_UINT32 *dstLen)
{
    TAF_UINT16 gsmCodeLen = 0;
    TAF_UINT8  emailUCS2[2 * SI_PB_EMAIL_MAX_LEN];
    TAF_UINT16 uCS2Len;

    (VOS_VOID)memset_s(emailUCS2, sizeof(emailUCS2), 0x00, sizeof(emailUCS2));

    /* 先将输入码流转换为UCS2再做处理 */
    At_PbIraToUnicode(src, srcLen, emailUCS2, &uCS2Len);

    /* 判断UCS2能否转换为GSM7bit存储 */
    if (At_UnicodeTransferToGsmCalcLength(emailUCS2, uCS2Len, &gsmCodeLen) != AT_SUCCESS) {
        AT_ERR_LOG("At_PbEmailTransferToGsm error: failed to transfer to Gsm");

        return AT_CME_INVALID_CHARACTERS_IN_TEXT_STRING;
    }

    /* EMAIL的长度大于电话本EMAIL字段能存储的长度时，提醒用户输入太长 */
    if (gsmCodeLen > g_pbatInfo.emailLen) {
        AT_LOG1("At_PbEmailTransferToGsm error: mail length [%d] too long", gsmCodeLen);

        return AT_CME_TEXT_STRING_TOO_LONG;
    }

    *dstLen = gsmCodeLen;

    /* 若能转换为GSM7bit则进行转换 */
    At_UnicodeTransferToGsm(emailUCS2, uCS2Len, dst, dstBufLen);

    return AT_SUCCESS;
}


TAF_UINT32 At_SetCpbfPara(TAF_UINT8 indexNum)
{
    SI_PB_StorateTypeUint32 storage = SI_PB_STORAGE_UNSPECIFIED;
    SI_PB_Record            records;
    TAF_UINT32              result;

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    result = At_PbAlphaTagProc(&records, &g_atParaList[0]);

    if (result != AT_SUCCESS) {
        AT_ERR_LOG("At_SetCpbfPara:something wrong in At_PbAlphaTagProc");
        return result;
    }

    /* 执行命令操作 */
    if (SI_PB_Search(g_atClientTab[indexNum].clientId, 0, storage, records.alphaTagLength, records.alphaTag) ==
        AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBF_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetModemStatusPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数不符合 */
    if (g_atParaIndex != AT_MODEMSTATUS_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 内容长度不符合 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaList[1].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是balong modem复位，不需要处理该命令 */
    if (g_atParaList[0].paraValue == 0) {
        return AT_OK;
    }

    rst = AT_FillAndSndCSIMAMsg(g_atClientTab[indexNum].clientId, g_atParaList[1].paraValue);

    if (rst == VOS_OK) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCpbwPara2(TAF_UINT8 indexNum)
{
    SI_PB_Record records;
    TAF_UINT8   *number = VOS_NULL_PTR;
    TAF_UINT16   len;
    TAF_UINT32   result;
    TAF_UINT32   resultTemp;
    errno_t      memResult;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) { /* 参数检查 */
        AT_ERR_LOG("At_SetCpbwPara2 error:incorect parameters");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_CPBW_PARA_MAX_NUM) { /* 参数过多 */
        AT_ERR_LOG("At_SetCpbwPara2 error: too many parameters");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (g_atParaIndex == 1) {
        result = At_PbDeleteProc(indexNum);

        return result;
    }

    if ((g_atParaList[AT_CPBW_NUMBER].paraLen == 0) && (g_atParaList[AT_CPBW_TEXT].paraLen == 0)) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&records, sizeof(records), 0x00, sizeof(records)); /* 初始化 */

    if (g_atParaList[0].paraLen != 0) { /* 设置<index> */
        records.index = (TAF_UINT16)g_atParaList[0].paraValue;
    }

    if (g_atParaList[1].paraLen != 0) { /* 设置<number> */
        number = g_atParaList[1].para;
        len    = g_atParaList[1].paraLen;
        if (g_atParaList[1].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[1].para + 1;
            len    = g_atParaList[1].paraLen - 1;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            AT_ERR_LOG("At_SetCpbwPara2 error: invalid characters in dial string");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (len > SI_PB_PHONENUM_MAX_LEN) {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records.number, sizeof(records.number), number, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records.number), len);
        }

        records.numberLength = (TAF_UINT8)len;
    }

    result = At_PbAlphaTagProc(&records, &g_atParaList[AT_CPBW_TEXT]);

    if (result != AT_SUCCESS) {
        AT_ERR_LOG("At_SetCpbwPara2:something wrong in At_PbAlphaTagProc");
        return result;
    }

    if (g_atParaList[AT_CPBW_TYPE].paraLen != 0) { /* 设置<type> */
        /* 号码类型待修改 */
        records.numberType = (At_GetCodeType(g_atParaList[1].para[0]) == PB_NUMBER_TYPE_INTERNATIONAL) ?
                              PB_NUMBER_TYPE_INTERNATIONAL :
                              (TAF_UINT8)g_atParaList[AT_CPBW_TYPE].paraValue;
    } else {
        records.numberType = (TAF_UINT8)At_GetCodeType(g_atParaList[1].para[0]);
    }

    if (records.numberType < AT_CPBW_TEXT_MIN_NUM) {
        AT_ERR_LOG("At_SetCpbwPara2 error: invalid index");

        return AT_CME_INVALID_INDEX;
    }

    if (g_atParaList[0].paraLen == 0) {
        /* 添加记录 */
        if (SI_PB_Add(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }

        AT_ERR_LOG("At_SetCpbwPara2 error: add pb record failed");

        return AT_ERROR;
    }

    /* 修改记录 */
    result     = SI_PB_GetSPBFlag();
    resultTemp = SI_PB_GetStorateType();

    if ((result == 1) && (resultTemp == SI_PB_STORAGE_SM)) {
        if (SI_PB_SModify(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }
    }

    if (SI_PB_Modify(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    AT_ERR_LOG("At_SetCpbwPara2 error: modify pb record failed");

    return AT_ERROR;
}

TAF_UINT32 At_SetScpbwNum1Type1(SI_PB_Record *records)
{
    TAF_UINT8 *number = VOS_NULL_PTR;
    errno_t    memResult;
    TAF_UINT16 len;

    if (g_atParaList[AT_SCPBW_NUM1].paraLen != 0) { /* 设置<num1> */
        if (g_atParaList[AT_SCPBW_NUM1].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[AT_SCPBW_NUM1].para + 1;
            len    = g_atParaList[AT_SCPBW_NUM1].paraLen - 1;
        } else {
            number = g_atParaList[AT_SCPBW_NUM1].para;
            len    = g_atParaList[AT_SCPBW_NUM1].paraLen;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            AT_ERR_LOG("At_SetScpbwNum1Type1: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (len > SI_PB_PHONENUM_MAX_LEN) {
            AT_ERR_LOG("At_SetScpbwNum1Type1: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records->number, sizeof(records->number), number, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records->number), len);
        }

        records->numberLength = (TAF_UINT8)len;
    }

    /* 当号码为空时，类型字段按协议置为0xFF */
    if (g_atParaList[AT_SCPBW_NUM1].paraLen == 0) {
        records->numberType   = 0xFF;
        records->numberLength = 0;
    } else {
        if (g_atParaList[AT_SCPBW_TYPE1].paraLen != 0) { /* 设置<type1> */
            /* 号码类型待修改 */
            records->numberType = (At_GetCodeType(g_atParaList[AT_SCPBW_NUM1].para[0]) == PB_NUMBER_TYPE_INTERNATIONAL)
                                   ? PB_NUMBER_TYPE_INTERNATIONAL :
                                   (TAF_UINT8)g_atParaList[AT_SCPBW_TYPE1].paraValue;
        } else {
            records->numberType = (TAF_UINT8)At_GetCodeType(g_atParaList[AT_SCPBW_NUM1].para[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum2Type2(SI_PB_Record *records)
{
    TAF_UINT8 *number = VOS_NULL_PTR;
    errno_t    memResult;
    TAF_UINT16 len;

    if (g_atParaList[AT_SCPBW_NUM2].paraLen != 0) { /* 设置<num2> */
        if (g_atParaList[AT_SCPBW_NUM2].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[AT_SCPBW_NUM2].para + 1;
            len    = g_atParaList[AT_SCPBW_NUM2].paraLen - 1;
        } else {
            number = g_atParaList[AT_SCPBW_NUM2].para;
            len    = g_atParaList[AT_SCPBW_NUM2].paraLen;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            AT_ERR_LOG("At_SetScpbwNum2Type2: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (len > (SI_PB_PHONENUM_MAX_LEN + 2)) { /* +2是为了防止写越界 */
            AT_ERR_LOG("At_SetScpbwNum2Type2: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records->additionNumber[0].number, sizeof(records->additionNumber[0].number), number,
                                 len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records->additionNumber[0].number), len);
        }

        records->additionNumber[0].numberLength = (TAF_UINT8)len;
    }

    if (g_atParaList[AT_SCPBW_NUM2].paraLen == 0) {
        records->additionNumber[0].numberType   = 0xFF;
        records->additionNumber[0].numberLength = 0;
    } else {
        if (g_atParaList[AT_SCPBW_TYPE2].paraLen != 0) { /* 设置<type2> */
            /* 号码类型待修改 */
            records->additionNumber[0].numberType = (At_GetCodeType(g_atParaList[AT_SCPBW_NUM2].para[0]) ==
                                                     PB_NUMBER_TYPE_INTERNATIONAL) ?
                                                     PB_NUMBER_TYPE_INTERNATIONAL :
                                                     (TAF_UINT8)g_atParaList[AT_SCPBW_TYPE2].paraValue;
        } else {
            records->additionNumber[0].numberType = (TAF_UINT8)At_GetCodeType(g_atParaList[AT_SCPBW_NUM2].para[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum3Type3(SI_PB_Record *records)
{
    TAF_UINT8 *number = VOS_NULL_PTR;
    errno_t    memResult;
    TAF_UINT16 len;

    if (g_atParaList[AT_SCPBW_NUM3].paraLen != 0) { /* 设置<num3> */
        if (g_atParaList[AT_SCPBW_NUM3].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[AT_SCPBW_NUM3].para + 1;
            len    = g_atParaList[AT_SCPBW_NUM3].paraLen - 1;
        } else {
            number = g_atParaList[AT_SCPBW_NUM3].para;
            len    = g_atParaList[AT_SCPBW_NUM3].paraLen;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            AT_ERR_LOG("At_SetScpbwNum3Type3: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (len > (SI_PB_PHONENUM_MAX_LEN + 2)) { /* +2是为了防止写越界 */
            AT_ERR_LOG("At_SetScpbwNum3Type3: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records->additionNumber[1].number, sizeof(records->additionNumber[1].number), number,
                                 len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records->additionNumber[1].number), len);
        }

        records->additionNumber[1].numberLength = (TAF_UINT8)len;
    }

    if (g_atParaList[AT_SCPBW_NUM3].paraLen == 0) {
        records->additionNumber[1].numberType   = 0xFF;
        records->additionNumber[1].numberLength = 0;
    } else {
        if (g_atParaList[AT_SCPBW_TYPE3].paraLen != 0) { /* 设置<type3> */
            /* 号码类型待修改 */
            records->additionNumber[1].numberType = (At_GetCodeType(g_atParaList[AT_SCPBW_NUM3].para[0]) ==
                                                     PB_NUMBER_TYPE_INTERNATIONAL) ?
                                                     PB_NUMBER_TYPE_INTERNATIONAL :
                                                     (TAF_UINT8)g_atParaList[AT_SCPBW_TYPE3].paraValue;
        } else {
            records->additionNumber[1].numberType = (TAF_UINT8)At_GetCodeType(g_atParaList[AT_SCPBW_NUM3].para[0]);
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwNum4Type4(SI_PB_Record *records)
{
    TAF_UINT8 *number = VOS_NULL_PTR;
    errno_t    memResult;
    TAF_UINT16 len;
    if (g_atParaList[AT_SCPBW_NUM4].paraLen != 0) { /* 设置<num4> */
        if (g_atParaList[AT_SCPBW_NUM4].para[0] == '+') { /* 判断号码地址类型 */
            number = g_atParaList[AT_SCPBW_NUM4].para + 1;
            len    = g_atParaList[AT_SCPBW_NUM4].paraLen - 1;
        } else {
            number = g_atParaList[AT_SCPBW_NUM4].para;
            len    = g_atParaList[AT_SCPBW_NUM4].paraLen;
        }

        if (At_CheckPBString(number, &len) == AT_FAILURE) {
            AT_ERR_LOG("At_SetScpbwNum4Type4: invalid characters in dial string!");

            return AT_CME_INVALID_CHARACTERS_IN_DIAL_STRING;
        }

        /* 长度保护 */
        if (len > (SI_PB_PHONENUM_MAX_LEN + 2)) { /* +2是为了防止写越界 */
            AT_ERR_LOG("At_SetScpbwNum4Type4: text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        if (len > 0) {
            memResult = memcpy_s(records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].number,
                                 sizeof(records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].number), number, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].number), len);
        }

        records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].numberLength = (TAF_UINT8)len;
    }

    if (g_atParaList[AT_SCPBW_NUM4].paraLen == 0) {
        records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].numberType   = 0xFF;
        records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].numberLength = 0;
    } else {
        if (g_atParaList[AT_SCPBW_TYPE4].paraLen != 0) { /* 设置<type4> */
            /* 号码类型待修改 */
            records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].numberType =
                (At_GetCodeType(g_atParaList[AT_SCPBW_NUM4].para[AT_SCPBW_NUM4_NUM_TYPE]) ==
                PB_NUMBER_TYPE_INTERNATIONAL) ?
                PB_NUMBER_TYPE_INTERNATIONAL :
                (TAF_UINT8)g_atParaList[AT_SCPBW_TYPE4].paraValue;
        } else {
            records->additionNumber[AT_ADDITION_NUM_ARRAY_INDEX_2].numberType =
                (TAF_UINT8)At_GetCodeType(g_atParaList[AT_SCPBW_NUM4].para[AT_SCPBW_NUM4_NUM_TYPE]);
        }
    }

    return AT_SUCCESS;
}

VOS_VOID At_SetScpbwAlphaTagType(SI_PB_Record *records)
{
    if (g_atParaList[AT_SCPBW_ALPHATAG_TYPE].paraValue == AT_CSCS_UCS2_CODE) {
        records->alphaTagType = AT_CSCS_UCS2_CODE;
    } else if (g_atParaList[AT_SCPBW_ALPHATAG_TYPE].paraValue == AT_CSCS_IRA_CODE) {
        records->alphaTagType = AT_CSCS_IRA_CODE;
    } else {
        records->alphaTagType = AT_CSCS_IRA_CODE;
    }
}

TAF_UINT32 At_SetScpbwText(SI_PB_Record *records)
{
    errno_t    memResult;
    TAF_UINT16 alphaTagLength;

    if (g_atParaList[AT_SCPBW_TEXT].paraLen != 0) { /* 设置<text> */
        /* 如果输入的AT命令已经指示是UNICODE编码要进行编码转换成ASCII码 */
        alphaTagLength = g_atParaList[AT_SCPBW_TEXT].paraLen;

        if (records->alphaTagType == AT_CSCS_UCS2_CODE) {
            /* 当ASCII位数必须是UNICODE的偶数倍 */
            if ((alphaTagLength % 2) != 0) {
                return AT_ERROR;
            }

            if (At_UnicodePrint2Unicode(g_atParaList[AT_SCPBW_TEXT].para, &alphaTagLength) == AT_FAILURE) {
                return AT_ERROR;
            }

            if (At_CheckNameUCS2Code(g_atParaList[AT_SCPBW_TEXT].para, &alphaTagLength) == AT_FAILURE) {
                return AT_ERROR;
            }

            records->alphaTagType = g_atParaList[AT_SCPBW_TEXT].para[0];
        }

        /*
         * 最终得到的姓名字段的长度不能超过TAF_PB_RECORD_STRU
         * 结构中的最大长度，否则会导致堆栈溢出
         */
        if (alphaTagLength > SI_PB_ALPHATAG_MAX_LEN) {
            AT_ERR_LOG("At_SetScpbwText: cme incorrect parameters!");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (alphaTagLength > 0) {
            memResult = memcpy_s(records->alphaTag, sizeof(records->alphaTag), g_atParaList[AT_SCPBW_TEXT].para,
                                 alphaTagLength);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(records->alphaTag), alphaTagLength);
        }

        records->alphaTagLength = (TAF_UINT8)alphaTagLength;
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_SetScpbwEmail(SI_PB_Record *records)
{
    TAF_UINT32 result;

    if (g_atParaList[AT_SCPBW_EMAIL].paraLen != 0) { /* 设置<email> */
        if (g_atParaList[AT_SCPBW_EMAIL].paraLen > SI_PB_EMAIL_MAX_LEN) {
            AT_ERR_LOG("At_SetScpbwEmail: cme text string too long!");

            return AT_CME_TEXT_STRING_TOO_LONG;
        }

        result = At_PbEmailTransferToGsm(g_atParaList[AT_SCPBW_EMAIL].para, g_atParaList[AT_SCPBW_EMAIL].paraLen,
                                         records->email.email, sizeof(records->email.email), &records->email.emailLen);

        if (result != AT_SUCCESS) {
            return result;
        }
    }

    return AT_SUCCESS;
}

TAF_UINT32 At_CheckScpbwPara(TAF_UINT8 indexNum)
{
    TAF_UINT32 result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) { /* 参数检查 */
        AT_ERR_LOG("At_CheckScpbwPara: cmd opt type error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_SCPBW_PARA_MAX_NUM) { /* 参数过多 */
        AT_ERR_LOG("At_CheckScpbwPara: para num too many");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 只有一个参数时为删除操作 */
    if (g_atParaIndex == 1) {
        result = At_PbDeleteProc(indexNum);

        return result;
    }

    if ((g_atParaList[AT_SCPBW_NUM1].paraLen == 0) && (g_atParaList[AT_SCPBW_NUM2].paraLen == 0) &&
        (g_atParaList[AT_SCPBW_NUM3].paraLen == 0) && (g_atParaList[AT_SCPBW_NUM4].paraLen == 0) &&
        (g_atParaList[AT_SCPBW_TEXT].paraLen == 0) && (g_atParaList[AT_SCPBW_EMAIL].paraLen == 0)) {
        AT_ERR_LOG("At_CheckScpbwPara: para len error");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_SetScpbwPara(TAF_UINT8 indexNum)
{
    SI_PB_Record records;
    TAF_UINT32   rslt;

    rslt = At_CheckScpbwPara(indexNum);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    /* 确认编码类型，UNICODE或是ASCII码 */
    (VOS_VOID)memset_s(&records, sizeof(records), 0x00, sizeof(records)); /* 初始化 */

    /* 设置<index> */
    if (g_atParaList[0].paraLen != 0) {
        records.index = (TAF_UINT16)g_atParaList[0].paraValue;
    }

    rslt = At_SetScpbwNum1Type1(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    rslt = At_SetScpbwNum2Type2(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    rslt = At_SetScpbwNum3Type3(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    rslt = At_SetScpbwNum4Type4(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    /* 设置ucAlphaTagType */
    At_SetScpbwAlphaTagType(&records);

    /* 设置text */
    rslt = At_SetScpbwText(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    /* 设置Email */
    rslt = At_SetScpbwEmail(&records);

    if (rslt != AT_SUCCESS) {
        return rslt;
    }

    if (g_atParaList[0].paraLen == 0) { /* 添加 */
        if (SI_PB_SAdd(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }

        return AT_ERROR;
    }

    /* 修改 */
    if (SI_PB_SModify(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED, &records) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPBW_SET; /* 设置当前操作类型 */

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

/*
 * Description: ^SCPBR
 * History:
 *  1.Date: 2009-05-23
 *    Modification: Created
 */
TAF_UINT32 At_SetScpbrPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_SCPBR_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[1].paraLen == 0) {
        g_atParaList[1].paraValue = g_atParaList[0].paraValue;
    }

    if (SI_PB_SRead(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_UNSPECIFIED,
                    (TAF_UINT16)g_atParaList[0].paraValue, (TAF_UINT16)g_atParaList[1].paraValue) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SCPBR_SET;

        g_pbPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: +CNUM
 * History:
 *  1.Date: 2007-06-11
 *    Modification: Created function
 */
TAF_UINT32 At_SetCnumPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (SI_PB_Read(g_atClientTab[indexNum].clientId, 0, SI_PB_STORAGE_ON, 0, 0) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CNUM_READ;

        g_pbPrintTag = TAF_FALSE;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCsimPara(TAF_UINT8 indexNum)
{
    SI_PIH_CsimCommand command;
    errno_t            memResult;

    /* 参数检查 */
    if ((g_atParaList[AT_CSIM_LENGTH].paraLen == 0) || (g_atParaList[AT_CSIM_COMMAND].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CSIM_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&command, sizeof(command), 0x00, sizeof(command));

    if ((g_atParaList[AT_CSIM_LENGTH].paraValue % AT_DOUBLE_LENGTH) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CSIM_COMMAND].paraLen % AT_DOUBLE_LENGTH) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_CSIM_COMMAND].para,
                              &g_atParaList[AT_CSIM_COMMAND].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_CSIM_LENGTH].paraValue !=
        (TAF_UINT32)(g_atParaList[AT_CSIM_COMMAND].paraLen * AT_DOUBLE_LENGTH)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<length> */
    command.len = g_atParaList[AT_CSIM_COMMAND].paraLen;

    /* 设置<command> */
    memResult = memcpy_s((TAF_VOID *)command.command, sizeof(command.command),
                         (TAF_VOID *)g_atParaList[AT_CSIM_COMMAND].para, (VOS_UINT16)command.len);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command.command), (VOS_UINT16)command.len);

    /* 执行命令操作 */
    if (SI_PIH_GenericAccessReq(g_atClientTab[indexNum].clientId, 0, &command) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSIM_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: +CCHO=<dfname>
 * History:
 *  1.Date: 2013-05-15
 *    Modification: Created function
 */
TAF_UINT32 At_SetCchoPara(TAF_UINT8 indexNum)
{
    SI_PIH_CchoCommand cchoCmd;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((g_atParaList[AT_CCHO_DFNAME].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[AT_CCHO_DFNAME].para,
                              &g_atParaList[AT_CCHO_DFNAME].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_SetCchoPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    cchoCmd.aidLen  = g_atParaList[AT_CCHO_DFNAME].paraLen;
    cchoCmd.adfName = g_atParaList[AT_CCHO_DFNAME].para;

    /* 执行命令操作 */
    if (SI_PIH_CchoSetReq(g_atClientTab[indexNum].clientId, 0, &cchoCmd) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCHO_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCchpPara(TAF_UINT8 indexNum)
{
    SI_PIH_CchpCommand cchpCmd;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CCHP_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((g_atParaList[AT_CCHP_DFNAME].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[AT_CCHP_DFNAME].para,
                              &g_atParaList[AT_CCHP_DFNAME].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_SetCchopPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    cchpCmd.aidLen  = g_atParaList[AT_CCHP_DFNAME].paraLen;
    cchpCmd.adfName = g_atParaList[AT_CCHP_DFNAME].para;
    cchpCmd.apdup2  = (VOS_UINT8)g_atParaList[1].paraValue;

    /* 执行命令操作 */
    if (SI_PIH_CchpSetReq(g_atClientTab[indexNum].clientId, 0, &cchpCmd) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCHP_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetPrivateCchoPara(TAF_UINT8 indexNum)
{
    SI_PIH_CchoCommand cchoCmd = {0};

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((g_atParaList[AT_CCHO_DFNAME].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[0].para, &g_atParaList[0].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_SetPrivateCchoPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    cchoCmd.aidLen  = g_atParaList[0].paraLen;
    cchoCmd.adfName = g_atParaList[0].para;

    /* 执行命令操作 */
    if (SI_PIH_PrivateCchoSetReq(g_atClientTab[indexNum].clientId, 0, &cchoCmd) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PRIVATECCHO_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetPrivateCchpPara(TAF_UINT8 indexNum)
{
    SI_PIH_CchpCommand cchpCmd = {0};

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CCHP_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((g_atParaList[AT_CCHP_DFNAME].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[AT_CCHP_DFNAME].para,
                              &g_atParaList[AT_CCHP_DFNAME].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_SetPrivateCchpPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    cchpCmd.aidLen   = g_atParaList[AT_CCHP_DFNAME].paraLen;
    cchpCmd.adfName  = g_atParaList[AT_CCHP_DFNAME].para;
    cchpCmd.apdup2   = (VOS_UINT8)g_atParaList[1].paraValue;

    /* 执行命令操作 */
    if (SI_PIH_PrivateCchpSetReq(g_atClientTab[indexNum].clientId, 0, &cchpCmd) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PRIVATECCHP_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

/*
 * Description: +CCHC=<sessionid>
 * History:
 *  1.Date: 2013-05-15
 *    Modification: Created function
 */
TAF_UINT32 At_SetCchcPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (SI_PIH_CchcSetReq(g_atClientTab[indexNum].clientId, 0, g_atParaList[0].paraValue) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCHC_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

/*
 * Description: +CGLA=<sessionid>,<length>,<command>
 * History:
 *  1.Date: 2013-05-15
 *    Modification: Created function
 */
TAF_UINT32 At_SetCglaPara(TAF_UINT8 indexNum)
{
    SI_PIH_CglaCommand cglaCmd;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != AT_CGLA_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <length>需要为2的整数倍 */
    if ((g_atParaList[AT_CGLA_LENGTH].paraValue % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串长度不为2的整数倍 */
    if ((g_atParaList[AT_CGLA_COMMAND].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[AT_CGLA_COMMAND].para,
                              &g_atParaList[AT_CGLA_COMMAND].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_SetCglaPara: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* length字段是实际命令长度的2倍 */
    if (g_atParaList[AT_CGLA_LENGTH].paraValue != (TAF_UINT32)(g_atParaList[AT_CGLA_COMMAND].paraLen * 2)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    cglaCmd.sessionID = g_atParaList[0].paraValue;
    cglaCmd.len       = g_atParaList[AT_CGLA_COMMAND].paraLen;
    cglaCmd.command   = g_atParaList[AT_CGLA_COMMAND].para;

    /* 执行命令操作 */
    if (SI_PIH_CglaSetReq(g_atClientTab[indexNum].clientId, 0, &cglaCmd) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGLA_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

TAF_UINT32 At_SetCardATRPara(TAF_UINT8 indexNum)
{
    if (SI_PIH_GetCardATRReq(g_atClientTab[indexNum].clientId, 0) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CARD_ATR_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetUsimStub(VOS_UINT8 indexNum)
{
    TAF_MMA_UsimStubSetReq usimStub;
    VOS_UINT32             ef;
    VOS_UINT32             totalNum;
    VOS_UINT32             efId;
    VOS_UINT32             efLen;
    VOS_UINT32             apptype;
    VOS_UINT8              i;
    VOS_UINT8              num;
#if (VOS_WIN32 != VOS_OS_VER)
    ModemIdUint16                       modemID;
    TAF_NVIM_EnhancedOperNameServiceCfg operNameServiceCfg;
    VOS_UINT32                          ret;
#endif
    errno_t memResult;

    num      = 0;
    ef       = 0;
    totalNum = 0;
    apptype  = 0;
    efId     = 0;
    efLen    = 0;
    (VOS_VOID)memset_s(&usimStub, sizeof(usimStub), 0x00, sizeof(usimStub));

    /* 读取nv项，nv项关闭，返回失败 */

#if (VOS_WIN32 != VOS_OS_VER)
    (VOS_VOID)memset_s(&operNameServiceCfg, sizeof(operNameServiceCfg), 0x00, sizeof(operNameServiceCfg));
    modemID = MODEM_ID_0;

    ret = AT_GetModemIdFromClient(indexNum, &modemID);

    if (ret != VOS_OK) {
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(modemID, NV_ITEM_ENHANCED_OPERATOR_NAME_SRV_CFG, &operNameServiceCfg,
                                   sizeof(TAF_NVIM_EnhancedOperNameServiceCfg))) {
        return AT_ERROR;
    }

    if (operNameServiceCfg.reserved5 == VOS_FALSE) {
        return AT_ERROR;
    }
#endif

    (VOS_VOID)At_String2Hex(g_atParaList[AT_USIMSTUB_CARD_ID].para, g_atParaList[AT_USIMSTUB_CARD_ID].paraLen, &efId);
    (VOS_VOID)At_String2Hex(g_atParaList[AT_USIMSTUB_CARD_TYPE].para, g_atParaList[AT_USIMSTUB_CARD_TYPE].paraLen, &apptype);
    (VOS_VOID)At_String2Hex(g_atParaList[AT_USIMSTUB_TOTALNUM].para,
                            g_atParaList[AT_USIMSTUB_TOTALNUM].paraLen, &totalNum);
    (VOS_VOID)At_String2Hex(g_atParaList[AT_USIMSTUB_EFLEN].para,
                            g_atParaList[AT_USIMSTUB_EFLEN].paraLen, &efLen);

    usimStub.totalNum = (VOS_UINT8)totalNum;
    usimStub.efId     = (VOS_UINT16)efId;
    usimStub.efLen    = (VOS_UINT16)efLen;
    usimStub.apptype  = (VOS_UINT8)apptype;

    for (i = 0; i < (g_atParaList[AT_USIMSTUB_FILECONTENT].paraLen / AT_HEX_ONEBYTE_VALID_LENTH); i++) {
        (VOS_VOID)At_String2Hex(g_atParaList[AT_USIMSTUB_FILECONTENT].para + AT_HEX_ONEBYTE_VALID_LENTH * i,
                                AT_HEX_ONEBYTE_VALID_LENTH, &ef);

        if (num >= TAF_MMA_MAX_EF_LEN) {
            return AT_ERROR;
        }

        memResult = memcpy_s(&usimStub.ef[num], TAF_MMA_MAX_EF_LEN - num, &ef, AT_CONST_NUM_1);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_EF_LEN - num, AT_CONST_NUM_1);
        num++;
    }

    TAF_SetUsimStub(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &usimStub);

    return AT_OK;
}


VOS_UINT32 At_SetRefreshStub(VOS_UINT8 indexNum)
{
    TAF_MMA_RefreshStubSetReq refreshStub;
    VOS_UINT8                 i;
    VOS_UINT32                totalNum;
    VOS_UINT32                refreshFileType;
    VOS_UINT32                receivePid;
    VOS_UINT32                fileId;
#if (VOS_WIN32 != VOS_OS_VER)
    TAF_NVIM_EnhancedOperNameServiceCfg operNameServiceCfg;
    ModemIdUint16                       modemID;
    VOS_UINT32                          ret;
#endif

    totalNum        = 0;
    refreshFileType = 0;
    receivePid      = 0;
    fileId          = 0;
    (VOS_VOID)memset_s(&refreshStub, sizeof(refreshStub), 0x00, sizeof(refreshStub));

    /* 读取nv项，nv项关闭，返回失败 */
#if (VOS_WIN32 != VOS_OS_VER)
    (VOS_VOID)memset_s(&operNameServiceCfg, sizeof(operNameServiceCfg), 0x00, sizeof(operNameServiceCfg));
    modemID = MODEM_ID_0;

    ret = AT_GetModemIdFromClient(indexNum, &modemID);

    if (ret != VOS_OK) {
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_READ(modemID, NV_ITEM_ENHANCED_OPERATOR_NAME_SRV_CFG, &operNameServiceCfg,
                                   sizeof(TAF_NVIM_EnhancedOperNameServiceCfg))) {
        return AT_ERROR;
    }

    if (operNameServiceCfg.reserved5 == VOS_FALSE) {
        return AT_ERROR;
    }
#endif

    (VOS_VOID)At_String2Hex(g_atParaList[AT_REFRESHSTUB_RECEIVED_PID].para,
                            g_atParaList[AT_REFRESHSTUB_RECEIVED_PID].paraLen, &receivePid);
    (VOS_VOID)At_String2Hex(g_atParaList[AT_REFRESHSTUB_FILE_TYPE].para, g_atParaList[AT_REFRESHSTUB_FILE_TYPE].paraLen,
                            &refreshFileType);
    (VOS_VOID)At_String2Hex(g_atParaList[AT_REFRESHSTUB_TOTALNUM].para,
                            g_atParaList[AT_REFRESHSTUB_TOTALNUM].paraLen, &totalNum);

    refreshStub.receivePid      = receivePid;
    refreshStub.totalNum        = (VOS_UINT8)totalNum;
    refreshStub.refreshFileType = (VOS_UINT8)refreshFileType;

    if (refreshStub.totalNum > TAF_MMA_MAX_FILE_ID_NUM) {
        refreshStub.totalNum = TAF_MMA_MAX_FILE_ID_NUM;
    }

    for (i = 0; i < refreshStub.totalNum; i++) {
        (VOS_VOID)At_String2Hex(g_atParaList[i + AT_REFRESHSTUB_FILE_ID].para,
                                g_atParaList[i + AT_REFRESHSTUB_FILE_ID].paraLen, &fileId);
        refreshStub.efId[i] = (VOS_UINT16)fileId;
    }

    TAF_SetRefreshStub(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &refreshStub);

    return AT_OK;
}
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetAutoReselStub(VOS_UINT8 indexNum)
{
    TAF_MMA_AutoReselStubSetReq autoReselStub;

    (VOS_VOID)memset_s(&autoReselStub, sizeof(autoReselStub), 0x00, sizeof(autoReselStub));

    autoReselStub.activeFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    TAF_SetAutoReselStub(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &autoReselStub);

    return AT_OK;
}
#endif
#if (VOS_WIN32 == VOS_OS_VER)

VOS_UINT32 At_SetDelayBgStub(VOS_UINT8 indexNum)
{
    VOS_UINT32 delayLen;
    VOS_UINT32 onOff;

    delayLen = 0;
    onOff    = 0;

    At_String2Hex(g_atParaList[0].para, g_atParaList[0].paraLen, &onOff);
    At_String2Hex(g_atParaList[1].para, g_atParaList[1].paraLen, &delayLen);

    NAS_SetHighPrioPlmnRefreshTriggerBGSearchCfg((VOS_UINT8)onOff, delayLen);

    return AT_OK;
}
#endif


TAF_UINT32 At_CrsmFilePathCheck(TAF_UINT32 efId, TAF_UINT8 *filePath, TAF_UINT16 *pathLen)
{
    errno_t    memResult;
    TAF_UINT16 len;
    TAF_UINT16 path[USIMM_MAX_PATH_LEN]    = {0};
    TAF_UINT16 tmpPath[USIMM_MAX_PATH_LEN] = {0};
    TAF_UINT16 pathLenTemp;
    TAF_UINT16 i;

    pathLenTemp = *pathLen;
    len         = 0;

    if (pathLenTemp > USIMM_MAX_PATH_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < (pathLenTemp / sizeof(TAF_UINT16)); i++) {
        /* 将UINT8存入UINT16时，高8位存偶数位，低8位存奇数位 */
        tmpPath[i] = ((filePath[i * 2] << 0x08) & 0xFF00) + filePath[(i * 2) + 1];
    }

    /* 如果路径不是以3F00开始，需要添加3F00作开头 */
    if (tmpPath[0] != MFID) {
        if (pathLenTemp == USIMM_MAX_PATH_LEN) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        path[0] = MFID;

        len++;
    }

    if (pathLenTemp > 0) {
        memResult = memcpy_s(&path[len], (USIMM_MAX_PATH_LEN - len) * ((VOS_SIZE_T)sizeof(TAF_UINT16)), tmpPath,
                             pathLenTemp);
        TAF_MEM_CHK_RTN_VAL(memResult, (USIMM_MAX_PATH_LEN - len) * ((VOS_SIZE_T)sizeof(TAF_UINT16)), pathLenTemp);
    }

    len += (pathLenTemp / sizeof(TAF_UINT16));

    if ((efId & 0xFF00) == EFIDUNDERMF) {
        len = 1;
    }
    /* 4F文件要在5F下，路径长度为3 */
    else if ((efId & 0xFF00) == EFIDUNDERMFDFDF) {
        if ((len != 3) || ((path[AT_PATH_INDEX_1] & 0xFF00) != DFIDUNDERMF) ||
            ((path[AT_PATH_INDEX_2] & 0xFF00) != DFIDUNDERMFDF)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    /* 6F文件要在7F下，路径长度为2 */
    else if ((efId & 0xFF00) == EFIDUNDERMFDF) {
        if ((len != 2) || ((path[AT_PATH_INDEX_1] & 0xFF00) != DFIDUNDERMF)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
    }

    *pathLen = len;

    if (len > 0) {
        /* 将UINT8存入UINT16时，长度变为原来的2倍 */
        memResult = memcpy_s(filePath, AT_PARA_MAX_LEN + 1, path, (VOS_SIZE_T)(len * 2));
        TAF_MEM_CHK_RTN_VAL(memResult, AT_PARA_MAX_LEN + 1, (VOS_SIZE_T)(len * 2));
    }

    return AT_SUCCESS;
}

/*
 * Function:       At_CrsmApduParaCheck
 * Description:    执行CRSM命令输入的参数的匹配检查
 * Return:         AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
TAF_UINT32 At_CrsmApduParaCheck(VOS_VOID)
{
    TAF_UINT16 fileTag;

    /* 命令类型参数检查，第一个参数不能为空 */
    if (g_atParaList[0].paraLen == 0) {
        AT_ERR_LOG("At_SetCrsmPara: command type null");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 除STATUS命令外，文件ID输入不能为空 */
    if ((g_atParaList[AT_CRSM_FILEID].paraValue == 0) && (g_atParaList[0].paraValue != USIMM_STATUS)) {
        AT_ERR_LOG("At_CrsmApduParaCheck: File Id null.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取文件ID前两位 */
    fileTag = (g_atParaList[AT_CRSM_FILEID].paraValue >> 8) & (0x00FF);

    /* 输入的文件ID必须是EF文件，前两位不可以是3F/5F/7F */
    if ((fileTag == MFLAB) || (fileTag == DFUNDERMFLAB) || (fileTag == DFUNDERDFLAB)) {
        AT_ERR_LOG("At_CrsmApduParaCheck: File Id error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <P1><P2><P3>这三个参数全部为空 */
    if ((g_atParaList[AT_CRSM_P1].paraLen == 0) && (g_atParaList[AT_CRSM_P2].paraLen == 0) &&
        (g_atParaList[AT_CRSM_P3].paraLen == 0)) {
        return AT_SUCCESS;
    }

    /* <P1><P2><P3>这三个参数全部不为空 */
    if ((g_atParaList[AT_CRSM_P1].paraLen != 0) && (g_atParaList[AT_CRSM_P2].paraLen != 0) &&
        (g_atParaList[AT_CRSM_P3].paraLen != 0)) {
        return AT_SUCCESS;
    }

    /* 其它情况下属于输入AT命令参数不完整 */
    return AT_CME_INCORRECT_PARAMETERS;
}

/*
 * Function:       At_CrsmFilePathParse
 * Description:    执行CRSM命令输入的路径进行解析
 * Return:          AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
TAF_UINT32 At_CrsmFilePathParse(SI_PIH_Crsm *command)
{
    errno_t    memResult;
    TAF_UINT32 result;

    /* 如果词法解析器解析第七个参数为空，说明没有文件路径输入，直接返回成功 */
    if ((g_atParaList[AT_CRSM_PATHIDE].paraLen == 0) && (command->efId != VOS_NULL_WORD)) {
        return AT_SUCCESS;
    }

    /* 在转换前输入的文件路径长度必须是4的整数倍 */
    if ((g_atParaList[AT_CRSM_PATHIDE].paraLen % 4) != 0) {
        AT_ERR_LOG("At_CrsmFilePathParse: Path error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将输入的字符串转换成十六进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[AT_CRSM_PATHIDE].para,
                              &g_atParaList[AT_CRSM_PATHIDE].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_CrsmFilePathParse: At_AsciiNum2HexString error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果有填写文件ID和路径，要做文件路径检查，输入的路径长度以U16为单位 */
    result = At_CrsmFilePathCheck((TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue,
                                  g_atParaList[AT_CRSM_PATHIDE].para,
                                  &g_atParaList[AT_CRSM_PATHIDE].paraLen);

    if (result != AT_SUCCESS) {
        AT_ERR_LOG("At_CrsmFilePathParse: At_CrsmFilePathCheck error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充文件路径和长度 */
    command->pathLen = g_atParaList[AT_CRSM_PATHIDE].paraLen;

    /* 文件路径长度是U16为单位的，路径拷贝的长度要乘2 */
    if ((g_atParaList[AT_CRSM_PATHIDE].paraLen > 0) &&
        (((VOS_SIZE_T)(g_atParaList[AT_CRSM_PATHIDE].paraLen * sizeof(VOS_UINT16))) <= sizeof(command->path))) {
        memResult = memcpy_s(command->path, sizeof(command->path), g_atParaList[AT_CRSM_PATHIDE].para,
                             (VOS_SIZE_T)(g_atParaList[AT_CRSM_PATHIDE].paraLen * sizeof(VOS_UINT16)));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command->path),
                            (VOS_SIZE_T)(g_atParaList[AT_CRSM_PATHIDE].paraLen * sizeof(VOS_UINT16)));
    }

    return AT_SUCCESS;
}

/*
 * Function:       At_CrsmParaStatusCheck
 * Description:    执行CRSM命令对STATUS命令的参数检查
 * Return:          AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
TAF_UINT32 At_CrsmParaStatusCheck(SI_PIH_Crsm *command)
{
    /* STATUS命令如果没有输入文件ID，就不需要做选文件操作，直接发STATUS命令 */
    if (g_atParaList[AT_CRSM_FILEID].paraValue == 0) {
        command->efId = VOS_NULL_WORD;
    } else {
        command->efId = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->cmdType = USIMM_STATUS;

    return At_CrsmFilePathParse(command);
}

/*
 * Function:       At_CrsmParaReadBinaryCheck
 * Description:    执行CRSM命令对Read Binary命令的参数检查
 * Return:          AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
TAF_UINT32 At_CrsmParaReadBinaryCheck(SI_PIH_Crsm *command)
{
    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->efId    = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    command->cmdType = USIMM_READ_BINARY;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(command);
}

/*
 * Function:       At_CrsmParaReadBinaryCheck
 * Description:    执行CRSM命令对Read Record的参数检查
 * Return:         AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
TAF_UINT32 At_CrsmParaReadRecordCheck(SI_PIH_Crsm *command)
{
    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->efId    = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    command->cmdType = USIMM_READ_RECORD;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(command);
}

/*
 * Function:       At_CrsmParaGetRspCheck
 * Description:    执行CRSM命令的Get Response命令参数检查
 * Return:         AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
VOS_UINT32 At_CrsmParaGetRspCheck(SI_PIH_Crsm *command)
{
    /* 参数个数不能少于2个，至少要有命令类型和文件ID */
    if (g_atParaIndex < AT_CRSM_PARA_MIN_NUM) {
        AT_ERR_LOG("At_CrsmParaGetRspCheck: Para less than 2.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->efId    = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    command->cmdType = USIMM_GET_RESPONSE;

    /* 如果有输入文件路径需要检查输入参数 */
    return At_CrsmFilePathParse(command);
}

/*
 * Function:       At_CrsmParaUpdateBinaryCheck
 * Description:    执行CRSM命令的Update Binary参数检查
 * Return:         AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
VOS_UINT32 At_CrsmParaUpdateBinaryCheck(SI_PIH_Crsm *command)
{
    errno_t memResult;

    /* Update Binary命令至少要有6个参数，可以没有文件路径 */
    if (g_atParaIndex < AT_CRSM_UPDATA_BINARY_PARA_MIN_NUM) {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: Para less than 6.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->efId    = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    command->cmdType = USIMM_UPDATE_BINARY;

    /* 第六个参数输入的<data>字符串在转换前数据长度必须是2的倍数且不能为0 */
    if (((g_atParaList[AT_CRSM_DATA].paraLen % 2) != 0) || (g_atParaList[AT_CRSM_DATA].paraLen == 0)) {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_CRSM_DATA].para, &g_atParaList[AT_CRSM_DATA].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (g_atParaList[AT_CRSM_DATA].paraLen > sizeof(command->content)) {
        AT_ERR_LOG("At_CrsmParaUpdateBinaryCheck: g_atParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    memResult = memcpy_s((TAF_VOID *)command->content, sizeof(command->content),
                         (TAF_VOID *)g_atParaList[AT_CRSM_DATA].para, g_atParaList[AT_CRSM_DATA].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command->content), g_atParaList[AT_CRSM_DATA].paraLen);

    return At_CrsmFilePathParse(command);
}

/*
 * Function:       At_CrsmParaUpdateRecordCheck
 * Description:    执行CRSM命令的参数检查
 * Return:         AT_SUCCESS：成功，其他为失败
 * History:
 * 1.Date: 2012-05-04
 *   Modification: Created function
 */
VOS_UINT32 At_CrsmParaUpdateRecordCheck(SI_PIH_Crsm *command)
{
    errno_t memResult;

    /* Update Binary命令至少要有6个参数，可以没有文件路径 */
    if (g_atParaIndex < AT_CRSM_UPDATA_BINARY_PARA_MIN_NUM) {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: Para less than 6.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1      = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2      = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3      = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;
    command->efId    = (TAF_UINT16)g_atParaList[AT_CRSM_FILEID].paraValue;
    command->cmdType = USIMM_UPDATE_RECORD;

    /* 第六个参数输入的<data>字符串数据长度必须是2的倍数且不能为0 */
    if (((g_atParaList[AT_CRSM_DATA].paraLen % 2) != 0) || (g_atParaList[AT_CRSM_DATA].paraLen == 0)) {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_CRSM_DATA].para,
                              &g_atParaList[AT_CRSM_DATA].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (g_atParaList[AT_CRSM_DATA].paraLen > sizeof(command->content)) {
        AT_ERR_LOG("At_CrsmParaUpdateRecordCheck: g_atParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    memResult = memcpy_s(command->content, sizeof(command->content),
                         g_atParaList[AT_CRSM_DATA].para, g_atParaList[AT_CRSM_DATA].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command->content), g_atParaList[AT_CRSM_DATA].paraLen);

    return At_CrsmFilePathParse(command);
}


VOS_UINT32 At_CrsmParaSearchRecordCheck(SI_PIH_Crsm *command)
{
    /* Search Record命令至少要有7个参数 */
    if (g_atParaIndex < AT_CRSM_UPDATA_BINARY_PARA_MIN_NUM) {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: Para less than 7.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写数据结构中的<P1><P2><P3>对应的IE项 */
    command->p1 = (TAF_UINT8)g_atParaList[AT_CRSM_P1].paraValue;
    command->p2 = (TAF_UINT8)g_atParaList[AT_CRSM_P2].paraValue;
    command->p3 = (TAF_UINT8)g_atParaList[AT_CRSM_P3].paraValue;

    /* 填写数据结构中的<fileid> */
    command->efId = (TAF_UINT16)g_atParaList[1].paraValue;

    command->cmdType = USIMM_SEARCH_RECORD;

    /* 第六个参数输入的<data>字符串数据长度必须是2的倍数且不能为0 */
    if (((g_atParaList[AT_CRSM_DATA].paraLen % 2) != 0) || (g_atParaList[AT_CRSM_DATA].paraLen == 0)) {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: <data> error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_CRSM_DATA].para, &g_atParaList[AT_CRSM_DATA].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: At_AsciiNum2HexString fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 防止因为数据长度过长导致单板复位 */
    if (g_atParaList[AT_CRSM_DATA].paraLen > sizeof(command->content)) {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: g_atParaList[5] too long.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<data>，其长度由<data>参数输入确定，P3参数照常下发，不关心<data>的长度是否和P3的值匹配 */
    if (memcpy_s(command->content, sizeof(command->content),
                 g_atParaList[AT_CRSM_DATA].para, g_atParaList[AT_CRSM_DATA].paraLen) != EOK) {
        AT_ERR_LOG("At_CrsmParaSearchRecordCheck: memcpy_s fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return At_CrsmFilePathParse(command);
}

/*
 * Description: +CRSM=<command>[,<fileid>[,<P1>,<P2>,<P3>[,<data>,<pathid>]]]
 * History:
 *  1.Date: 2008-03-02
 *    Modification: Created function
 *  2.Date: 2012-05-05
 *    Modification: 增加对第七个参数的处理
 */
TAF_UINT32 At_SetCrsmPara(TAF_UINT8 indexNum)
{
    SI_PIH_Crsm command;
    TAF_UINT32  result;

    /* 参数过多 */
    if (g_atParaIndex > AT_CRSM_PARA_MAX_NUM) {
        AT_ERR_LOG("At_SetCrsmPara: too many para");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果有输入<P1><P2><P3>，这三个参数不能只填写部分参数 */
    if (At_CrsmApduParaCheck() != AT_SUCCESS) {
        AT_ERR_LOG("At_SetCrsmPara: At_CrsmApduParaCheck fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&command, sizeof(command), 0x00, sizeof(SI_PIH_Crsm));

    switch (g_atParaList[0].paraValue) {
        case USIMM_STATUS:
            result = At_CrsmParaStatusCheck(&command);
            break;
        case USIMM_READ_BINARY:
            result = At_CrsmParaReadBinaryCheck(&command);
            break;
        case USIMM_READ_RECORD:
            result = At_CrsmParaReadRecordCheck(&command);
            break;
        case USIMM_GET_RESPONSE:
            result = At_CrsmParaGetRspCheck(&command);
            break;
        case USIMM_UPDATE_BINARY:
            result = At_CrsmParaUpdateBinaryCheck(&command);
            break;
        case USIMM_UPDATE_RECORD:
            result = At_CrsmParaUpdateRecordCheck(&command);
            break;
        case USIMM_SEARCH_RECORD:
            result = At_CrsmParaSearchRecordCheck(&command);
            break;
        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }

    if (result != AT_SUCCESS) {
        AT_ERR_LOG("At_SetCrsmPara: para parse fail");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (SI_PIH_CrsmSetReq(g_atClientTab[indexNum].clientId, 0, &command) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CRSM_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_CheckCpinPara(VOS_VOID)
{
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;

    systemAppConfig = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CPIN_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    /* 如果<pin>过长或过短，直接返回错误 */
    if ((g_atParaList[0].paraLen > TAF_PH_PINCODELENMAX) || (g_atParaList[0].paraLen < TAF_PH_PINCODELENMIN)) {
        if (*systemAppConfig != SYSTEM_APP_ANDROID) {
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            /* AP-MODEM形态下，当参数个数为1时, 第一个参数允许长度为16 */
            if ((g_atParaList[0].paraLen != TAF_PH_UNLOCKCODELEN) || (g_atParaIndex != 1)) {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }
    }

    /* 如果两个参数时，<newpin>过长或过短，直接返回错误 */
    if (g_atParaIndex == AT_CPIN_PARA_NUM) {
        if ((g_atParaList[1].paraLen > TAF_PH_PINCODELENMAX) || (g_atParaList[1].paraLen < TAF_PH_PINCODELENMIN)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_SUCCESS;
}


TAF_UINT32 At_SetCpinPara(TAF_UINT8 indexNum)
{
    errno_t          memResult;
    TAF_UINT32       result;
    MN_PH_SetCpinReq setCPinReq;

    /* 参数检查 */
    result = At_CheckCpinPara();
    if (result != AT_SUCCESS) {
        return result;
    }

    setCPinReq.para0Len = g_atParaList[0].paraLen;
    setCPinReq.para1Len = g_atParaList[1].paraLen;
    if (setCPinReq.para0Len > 0) {
        memResult = memcpy_s(setCPinReq.para0, sizeof(setCPinReq.para0), g_atParaList[0].para, setCPinReq.para0Len);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(setCPinReq.para0), setCPinReq.para0Len);
    }
    if (setCPinReq.para1Len > 0) {
        memResult = memcpy_s(setCPinReq.para1, sizeof(setCPinReq.para1), g_atParaList[1].para, setCPinReq.para1Len);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(setCPinReq.para1), setCPinReq.para1Len);
    }

    /* 通过TAF_MSG_MMA_SET_PIN 消息来设置CPIN */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), TAF_MSG_MMA_SET_PIN,
                                    (VOS_UINT8 *)&setCPinReq, sizeof(setCPinReq), I0_WUEPS_PID_MMA);

    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MSG_MMA_SET_PIN;
        (VOS_VOID)memset_s(&setCPinReq, sizeof(setCPinReq), 0x0, sizeof(setCPinReq));
        (VOS_VOID)memset_s(g_atParaList[0].para, sizeof(g_atParaList[0].para), 0x0, sizeof(g_atParaList[0].para));
        (VOS_VOID)memset_s(g_atParaList[1].para, sizeof(g_atParaList[1].para), 0x0, sizeof(g_atParaList[1].para));
        return AT_WAIT_ASYNC_RETURN;
    }

    (VOS_VOID)memset_s(&setCPinReq, sizeof(setCPinReq), 0x0, sizeof(setCPinReq));
    (VOS_VOID)memset_s(g_atParaList[0].para, sizeof(g_atParaList[0].para), 0x0, sizeof(g_atParaList[0].para));
    (VOS_VOID)memset_s(g_atParaList[1].para, sizeof(g_atParaList[1].para), 0x0, sizeof(g_atParaList[1].para));
    return AT_ERROR;
}

TAF_UINT32 At_SetCpin2Para(TAF_UINT8 indexNum)
{
    errno_t        memResult;
    TAF_PH_PinData pinData;
    TAF_UINT32     result;

    /* 参数检查 */
    result = At_CheckCpinPara();
    if (result != AT_SUCCESS) {
        return result;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));

    /* 设置<pin> */
    if (g_atParaList[0].paraLen != 0) {
        memResult = memcpy_s((TAF_VOID *)pinData.oldPin, sizeof(pinData.oldPin), (TAF_VOID *)g_atParaList[0].para,
                             g_atParaList[0].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pinData.oldPin), g_atParaList[0].paraLen);
    }

    /* 设置<newpin> */
    if (g_atParaList[1].paraLen != 0) {
        memResult = memcpy_s((TAF_VOID *)pinData.newPin, sizeof(pinData.newPin), (TAF_VOID *)g_atParaList[1].para,
                             g_atParaList[1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pinData.newPin), g_atParaList[1].paraLen);
    }

    /* 设置CmdType */
    if (g_atParaList[1].paraLen == 0) {
        pinData.pinType = TAF_SIM_PIN2;
        pinData.cmdType = TAF_PIN_VERIFY;
    } else {
        pinData.pinType = TAF_SIM_PUK2;
        pinData.cmdType = TAF_PIN_UNBLOCK;
    }

    /* 执行命令操作 */
    if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &pinData) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        if (g_atParaList[1].paraLen == 0) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPIN2_VERIFY_SET;
        } else {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPIN2_UNBLOCK_SET;
        }
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: ^ICCID
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetIccidPara(TAF_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 直接返回AT_OK */
    return AT_OK;
}


TAF_UINT32 At_SetPNNPara(TAF_UINT8 indexNum)
{
    TAF_PH_QryUsimInfo usimInfo;

    (VOS_VOID)memset_s(&usimInfo, sizeof(usimInfo), 0x00, sizeof(usimInfo));

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (g_atParaList[0].paraValue == 0) {
        usimInfo.icctype = TAF_PH_ICC_SIM;
    } else {
        usimInfo.icctype = TAF_PH_ICC_USIM;
    }
    usimInfo.efId = TAF_PH_PNN_FILE;
    /* linear fixed file only support 254 reocrd */
    if (g_atParaList[1].paraLen != 0) {
        if ((g_atParaList[1].paraValue > 0xFE) || (g_atParaList[1].paraValue == 0)) {
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            usimInfo.recNum = g_atParaList[1].paraValue;
        }
    } else {
        usimInfo.recNum = 0;

        /* 在读取PNN列表的时候进行分次下发，每次只读取TAF_MMA_PNN_INFO_MAX_NUM个，以防止A核申请内存失败造成复位 */
        /* 第一次下发的时候，Index为0，后面在收到TAF的CNF消息的时候再进行分批次下发 */
        usimInfo.pnnQryIndex.pnnCurrIndex = 0;
        usimInfo.pnnQryIndex.pnnNum       = TAF_MMA_PNN_INFO_MAX_NUM;
    }

    /* 执行命令操作 */
    if (TAF_QryUsimInfo(g_atClientTab[indexNum].clientId, 0, &usimInfo) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PNN_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCPNNPara(TAF_UINT8 indexNum)
{
    TAF_PH_IccType iccType;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (g_atParaList[0].paraValue == 0) {
        iccType = TAF_PH_ICC_SIM;
    } else {
        iccType = TAF_PH_ICC_USIM;
    }

    /* 执行命令操作 */
    if (TAF_QryCpnnInfo(g_atClientTab[indexNum].clientId, 0, iccType) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPNN_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

/*
 * *Function: At_SetOPLPara
 * *Description: 该函数主要负责检查输出的AT命令的参数，通过调用Taf_ParaQuery的接口执
 *               行AT命令的操作，调用Taf_ParaQuery时OpId参数为0xFF，标识查询OPL文件内
 *               容操作。
 * *Return: TAF_UINT32
 *   1.Date: 2008-03-06
 *     Modification: Created function
 */
TAF_UINT32 At_SetOPLPara(TAF_UINT8 indexNum)
{
    TAF_PH_QryUsimInfo usimInfo;

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 0) {
        usimInfo.icctype = TAF_PH_ICC_SIM;
    } else {
        usimInfo.icctype = TAF_PH_ICC_USIM;
    }
    usimInfo.efId = TAF_PH_OPL_FILE;
    /* linear fixed file only support 254 reocrd */
    if ((g_atParaList[1].paraLen != 0)) {
        if ((g_atParaList[1].paraValue > 0xFE) || (g_atParaList[1].paraValue == 0)) {
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            usimInfo.recNum = g_atParaList[1].paraValue;
        }
    } else {
        usimInfo.recNum = 0;
    }

    /* 执行命令操作 */
    if (TAF_QryUsimInfo(g_atClientTab[indexNum].clientId, 0, &usimInfo) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_OPL_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
/*
 * Description: ^CARDLOCK
 * History:
 *  1.Date: 2008-03-15
 *    Author: luojian
 *    Modification: Created function
 */
TAF_UINT32 At_SetCardlockPara(TAF_UINT8 indexNum)
{
    TAF_ME_PersonalisationData mePersonalisationData;
    errno_t                    memResult;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <unlock_code>必须为长度为8的数字字符串 */
    if (g_atParaList[0].paraLen == TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) {
        if (At_CheckNumString(g_atParaList[0].para, TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00,
                sizeof(TAF_ME_PersonalisationData));
            /* 复制用户解锁码 */
            memResult = memcpy_s(mePersonalisationData.oldPwd, sizeof(mePersonalisationData.oldPwd),
                                 g_atParaList[0].para, TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mePersonalisationData.oldPwd), TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
        }
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 安全命令类型为校验密码 */
    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_VERIFY;
    /* 锁卡操作为锁网络 */
    mePersonalisationData.mePersonalType = TAF_OPERATOR_PERSONALISATION;
    /* 执行命令操作 */
    if (Taf_MePersonalisationHandle(g_atClientTab[indexNum].clientId, 0, &mePersonalisationData) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CARD_LOCK_SET;
        (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00,
            sizeof(TAF_ME_PersonalisationData));
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00,
            sizeof(TAF_ME_PersonalisationData));
        return AT_ERROR;
    }
}


VOS_UINT32 AT_FillSsBsService(TAF_SS_ErasessReq *sSPara, AT_ParseParaType *atPara)
{
    if ((atPara->paraLen == 0) || (atPara->paraValue == AT_CLCK_PARA_CLASS_ALL)) {
        /* 默认值 */
        sSPara->opBsService = 0;
    } else {
        if (At_SsPrint2Class(&(sSPara->bsService), (VOS_UINT8)atPara->paraValue) == AT_FAILURE) {
            return VOS_ERR;
        }
        sSPara->opBsService = 1;
    }

    return VOS_OK;
}


VOS_UINT32 AT_FillSsNoRepCondTime(VOS_UINT8 ssCode, AT_ParseParaType *atPara, TAF_SS_RegisterssReq *sSPara)
{
    if ((ssCode == TAF_ALL_FORWARDING_SS_CODE) || (ssCode == TAF_ALL_COND_FORWARDING_SS_CODE) ||
        (ssCode == TAF_CFNRY_SS_CODE)) {
        if (atPara->paraLen) {
            sSPara->opNoRepCondTime = 1;
            sSPara->noRepCondTime   = (TAF_SS_NOREPLYCONDITIONTIME)atPara->paraValue;
        } else {
            /* 默认值 */
            sSPara->opNoRepCondTime = 1;
            sSPara->noRepCondTime   = AT_NOREPCONDTIME_DEFAULT;
        }
    }

    return VOS_OK;
}


TAF_UINT32 At_SetCcwaPara(TAF_UINT8 indexNum)
{
    TAF_SS_ErasessReq para;
    AT_ModemSsCtx    *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CCWA_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));

    /* 设置SsCode */
    para.ssCode = TAF_CW_SS_CODE;

    /* 设置<n> */
    if (g_atParaList[0].paraLen != 0) {
        ssCtx->ccwaType = (AT_CCWA_TYPE)g_atParaList[0].paraValue;
    } else {
        ssCtx->ccwaType = AT_CCWA_DISABLE_TYPE;
    }

    if (g_atParaList[1].paraLen == 0) {
        return AT_OK;
    }

    /* 设置<class> */
    if (AT_FillSsBsService(&para, &g_atParaList[AT_CCWA_CLASS]) != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    switch (g_atParaList[1].paraValue) {
        case 0: /* disable */
            if (TAF_DeactivateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCWA_DISABLE;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

        case 1: /* enable */
            if (TAF_ActivateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCWA_ENABLE;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

        default: /* query status */
            g_atClientTab[indexNum].temp = g_atParaList[AT_CCWA_CLASS].paraValue;
            para.opBsService             = 0;
            if (TAF_InterrogateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCWA_QUERY;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
    }
}


VOS_UINT32 AT_CheckCcfcParaValid(VOS_VOID)
{
    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CCFC_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<number>过长，直接返回错误 */
    if (g_atParaList[AT_CCFC_NUMBER].paraLen > TAF_SS_MAX_FORWARDED_TO_NUM_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<subaddr>过长，直接返回错误 */
    if (g_atParaList[AT_CCFC_SUBADDR].paraLen > TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查NUM号码输入不正确 */
    if (g_atParaList[AT_CCFC_NUMBER].paraLen != 0) {
        if (At_CheckDialString(g_atParaList[AT_CCFC_NUMBER].para,
                               g_atParaList[AT_CCFC_NUMBER].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 检查SubAddress号码输入不正确 */
    if (g_atParaList[AT_CCFC_SUBADDR].paraLen != 0) {
        if (At_CheckDialString(g_atParaList[AT_CCFC_SUBADDR].para,
                               g_atParaList[AT_CCFC_SUBADDR].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_OK;
}


TAF_SS_CODE AT_GetSsCodeFromCfccPara(VOS_VOID)
{
    TAF_SS_CODE code;

    /* 设置SsCode */
    switch (g_atParaList[0].paraValue) {
        case AT_SET_SS_CODE_CFU:
            code = TAF_CFU_SS_CODE;
            break;

        case AT_SET_SS_CODE_CFB:
            code = TAF_CFB_SS_CODE;
            break;

        case AT_SET_SS_CODE_CFNRY:
            code = TAF_CFNRY_SS_CODE;
            break;

        case AT_SET_SS_CODE_CFNRC:
            code = TAF_CFNRC_SS_CODE;
            break;

        case AT_SET_SS_CODE_AF:
            code = TAF_ALL_FORWARDING_SS_CODE;
            break;

        default:
            code = TAF_ALL_COND_FORWARDING_SS_CODE;
            break;
    }

    return code;
}


VOS_VOID AT_SetNumAttribute(TAF_SS_NUMTYPE *numType, TAF_UINT8 *fwdToNum)
{
    errno_t memResult;
    /* +表示国际号码，在号码类型中已经指示，不需要拷贝到消息中 */
    if (g_atParaList[AT_CCFC_NUMBER].para[0] == '+') {
        if ((g_atParaList[AT_CCFC_NUMBER].paraLen - 1) > 0) {
            memResult = memcpy_s((TAF_CHAR *)fwdToNum, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                                 (TAF_CHAR *)(g_atParaList[AT_CCFC_NUMBER].para + 1),
                                 (VOS_SIZE_T)(g_atParaList[AT_CCFC_NUMBER].paraLen - 1));
            TAF_MEM_CHK_RTN_VAL(memResult, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                                (VOS_SIZE_T)(g_atParaList[AT_CCFC_NUMBER].paraLen - 1));
        }
    } else {
        if (g_atParaList[AT_CCFC_NUMBER].paraLen > 0) {
            memResult = memcpy_s((TAF_CHAR *)fwdToNum, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                                 (TAF_CHAR *)g_atParaList[AT_CCFC_NUMBER].para,
                                 g_atParaList[AT_CCFC_NUMBER].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, TAF_SS_MAX_FORWARDED_TO_NUM_LEN + 1,
                                g_atParaList[AT_CCFC_NUMBER].paraLen);
        }
    }

    if (g_atParaList[AT_CCFC_TYPE].paraLen) {
        *numType = (TAF_SS_NUMTYPE)g_atParaList[AT_CCFC_TYPE].paraValue;
    } else {
        *numType = At_GetCodeType(g_atParaList[AT_CCFC_NUMBER].para[0]);
    }
}


VOS_VOID AT_SetSubAddrAttribute(TAF_SS_SUBADDRTYPE *subAddrType, TAF_UINT8 *fwdToSubAddr)
{
    errno_t memResult;
    if (g_atParaList[AT_CCFC_SUBADDR].paraLen > 0) {
        memResult = memcpy_s((TAF_CHAR *)fwdToSubAddr, TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN + 1,
                             (TAF_CHAR *)g_atParaList[AT_CCFC_SUBADDR].para,
                             g_atParaList[AT_CCFC_SUBADDR].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_SS_MAX_FORWARDED_TO_SUBADDRESS_LEN + 1,
                            g_atParaList[AT_CCFC_SUBADDR].paraLen);
    }

    if (g_atParaList[AT_CCFC_SATTYPE].paraLen) {
        *subAddrType = (TAF_UINT8)g_atParaList[AT_CCFC_SATTYPE].paraValue;
    } else {
        *subAddrType = AT_CCFC_CLASS_DEDICATED_PAD_ACCESS;
    }
}


VOS_UINT32 AT_DeactivateSSReq(TAF_UINT8 indexNum, TAF_SS_ErasessReq *eraseReq)
{
    if (TAF_DeactivateSSReq(g_atClientTab[indexNum].clientId, 0, eraseReq) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCFC_DISABLE;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_ActivateSSReq(TAF_UINT8 indexNum, TAF_SS_ErasessReq *activateReq)
{
    if (TAF_ActivateSSReq(g_atClientTab[indexNum].clientId, 0, activateReq) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCFC_ENABLE;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_InterrogateSSReq(TAF_UINT8 indexNum, TAF_SS_ErasessReq *interrogateReq)
{
    g_atClientTab[indexNum].temp = g_atParaList[AT_CCFC_CLASS].paraValue;

    if (TAF_InterrogateSSReq(g_atClientTab[indexNum].clientId, 0, interrogateReq) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCFC_QUERY;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_RegisterSSReq(TAF_UINT8 indexNum, TAF_SS_RegisterssReq *registerReq)
{
    if (TAF_RegisterSSReq(g_atClientTab[indexNum].clientId, 0, registerReq) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCFC_REGISTRATION;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


VOS_UINT32 AT_EraseSSReq(TAF_UINT8 indexNum, TAF_SS_ErasessReq *eraseSSReq)
{
    if (TAF_EraseSSReq(g_atClientTab[indexNum].clientId, 0, eraseSSReq) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCFC_ERASURE;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetCcfcPara(TAF_UINT8 indexNum)
{
    TAF_SS_RegisterssReq para;
    TAF_SS_ErasessReq    sndpara;
    VOS_UINT32           ret;

    ret = AT_CheckCcfcParaValid();
    if (ret != AT_OK) {
        return ret;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
    (VOS_VOID)memset_s(&sndpara, sizeof(sndpara), 0x00, sizeof(sndpara));

    para.ssCode = AT_GetSsCodeFromCfccPara();

    /* 设置<number>,<type> */
    if (g_atParaList[AT_CCFC_NUMBER].paraLen != 0) {
        para.opFwdToNum = 1;
        para.opNumType  = 1;
        AT_SetNumAttribute(&para.numType, para.fwdToNum);
    } else {
        para.opFwdToNum = 0;
        para.opNumType  = 0;
    }

    /* 设置<subaddr>,<satype> */
    if (g_atParaList[AT_CCFC_SUBADDR].paraLen != 0) {
        para.opFwdToAddr   = 1;
        para.opSubAddrType = 1;
        AT_SetSubAddrAttribute(&(para.subAddrType), para.fwdToSubAddr);
    } else {
        para.opFwdToAddr   = 0;
        para.opSubAddrType = 0;
    }

    /* 设置<time> */
    AT_FillSsNoRepCondTime(para.ssCode, &g_atParaList[AT_CCFC_TIME], &para);

    /* 设置<class> */
    if (AT_FillSsBsService(&sndpara, &g_atParaList[AT_CCFC_CLASS]) != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    sndpara.ssCode = para.ssCode;

    if (sndpara.opBsService == VOS_TRUE) {
        para.opBsService             = sndpara.opBsService;
        para.bsService.bsType        = sndpara.bsService.bsType;
        para.bsService.bsServiceCode = sndpara.bsService.bsServiceCode;
    }

    /* 执行命令操作 */
    switch (g_atParaList[1].paraValue) {
        case 0: /* <mode>: disable */
            ret = AT_DeactivateSSReq(indexNum, &sndpara);
            break;

        case 1: /* <mode>: enable */
            ret = AT_ActivateSSReq(indexNum, &sndpara);
            break;

        case 2: /* <mode>: query status */
            ret = AT_InterrogateSSReq(indexNum, &sndpara);
            break;

        case 3: /* <mode>: registration */
            ret = AT_RegisterSSReq(indexNum, &para);
            break;

        default: /* <mode>: erasure */
            ret = AT_EraseSSReq(indexNum, &sndpara);
            break;
    }

    return ret;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
/*
 * Description: +CLCK=<fac>,<action>[,<passwd>[,<data>]]
 * History:
 *  1.Date: 2007-10-06
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCmlckPara(TAF_UINT8 indexNum)
{
    errno_t    memResult;
    TAF_UINT32 ulresult;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CMLCK_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* data长度大于15，直接返回参数错误 */
    if (g_atParaList[AT_CMLCK_DATA].paraLen > TAF_MAX_IMSI_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch (g_atParaList[0].paraValue) {
        case AT_CMLCK_PS_TYPE: {
            TAF_ME_PersonalisationData mePersonalisationData;

            if (g_atParaList[AT_CMLCK_PASSWD_INDEX].paraLen > TAF_PH_PINCODELENMAX) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00, sizeof(TAF_ME_PersonalisationData));

            /* 设置<passwd> */
            if (g_atParaList[AT_CMLCK_PASSWD_INDEX].paraLen != 0) {
                memResult = memcpy_s((TAF_CHAR *)mePersonalisationData.oldPwd, sizeof(mePersonalisationData.oldPwd),
                                     (VOS_CHAR *)g_atParaList[AT_CMLCK_PASSWD_INDEX].para,
                                     g_atParaList[AT_CMLCK_PASSWD_INDEX].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mePersonalisationData.oldPwd),
                                    g_atParaList[AT_CMLCK_PASSWD_INDEX].paraLen);
            }

            /* 设置PinType */
            mePersonalisationData.mePersonalType = TAF_SIM_PERSONALISATION;

            if (g_atParaList[AT_CMLCK_DATA].paraLen != 0) {
                ulresult = At_AsciiNum2Num(
                    mePersonalisationData.unMePersonalisationSet.SimPersionalisationStr.simPersonalisationStr,
                    g_atParaList[AT_CMLCK_DATA].para, g_atParaList[AT_CMLCK_DATA].paraLen);
                if (ulresult != AT_SUCCESS) {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                mePersonalisationData.unMePersonalisationSet.SimPersionalisationStr.dataLen =
                    (VOS_UINT8)g_atParaList[AT_CMLCK_DATA].paraLen;
            }

            /* 设置CmdType */
            switch (g_atParaList[1].paraValue) {
                case AT_CMD_TYPE_PERSONALISATION_SET:
                    if (g_atParaList[AT_CMLCK_DATA].paraLen == 0) {
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_SET;

                    break;

                case AT_CMD_TYPE_PERSONALISATION_RETRIEVE:
                    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_RETRIEVE;

                    break;

                default:
                    return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 执行命令操作 */
            if (Taf_MePersonalisationHandle(g_atClientTab[indexNum].clientId, 0, &mePersonalisationData) ==
                AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
        }

        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }
}
#endif

VOS_UINT32 AT_CheckPinLength(VOS_UINT16 len, VOS_UINT8 *pin)
{
    if (pin == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_CheckPinLength():PIN is NULL PTR");
        return VOS_ERR;
    }

    if ((len > TAF_PH_PINCODELENMAX) || (len < TAF_PH_PINCODELENMIN)) {
        AT_ERR_LOG("AT_CheckPinLength():PIN LENGTH is Error");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckPinValue(VOS_UINT16 len, VOS_UINT8 *pin)
{
    VOS_UINT8 i;

    if (pin == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_CheckPinValue(): PIN is NULL PTR");
        return VOS_ERR;
    }

    for (i = 0; i < len; i++) {
        if ((pin[i] > '9') || (pin[i] < '0')) {
            AT_ERR_LOG("AT_CheckPinValue(): PIN Value is Error");
            return VOS_ERR;
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckPinAvail(VOS_UINT16 len, VOS_UINT8 *pin)
{
    if (AT_CheckPinLength(len, pin) != VOS_OK) {
        AT_ERR_LOG("AT_CheckPinAvail(): PIN Length is Error");
        return VOS_ERR;
    } else {
        if (AT_CheckPinValue(len, pin) != VOS_OK) {
            AT_ERR_LOG("AT_CheckPinAvail():PIN Value is Error");
            return VOS_ERR;
        }
    }
    return VOS_OK;
}


AT_MTA_PersCategoryUint8 AT_GetSimlockUnlockCategoryFromClck(VOS_VOID)
{
    switch (g_atParaList[0].paraValue) {
        case AT_CLCK_PN_TYPE:
            return AT_MTA_PERS_CATEGORY_NETWORK;
        case AT_CLCK_PU_TYPE:
            return AT_MTA_PERS_CATEGORY_NETWORK_SUBSET;
        case AT_CLCK_PP_TYPE:
            return AT_MTA_PERS_CATEGORY_SERVICE_PROVIDER;
        default:
            return AT_MTA_PERS_CATEGORY_BUTT;
    }
}

#if (FEATURE_PHONE_SC == FEATURE_ON)

TAF_UINT32 AT_SetClckFacEqualPNPUPPPara(TAF_UINT8 indexNum)
{
    AT_MTA_SimlockunlockReq simlockUnlockSetReq;

    switch (g_atParaList[1].paraValue) {
        case AT_CLCK_MODE_UNLOCK: /* 设置<mode>为0，则进行锁网锁卡解锁操作 */
        {
            (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00, sizeof(AT_MTA_SimlockunlockReq));
            simlockUnlockSetReq.category = AT_GetSimlockUnlockCategoryFromClck();

            /* <password>参数检查 */
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen != AT_SIMLOCKUNLOCK_PWD_PARA_LEN) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 密码的合法性检查，密码为16个“0”-“9”ASCII字符,密码由ASCII码转换为十进制数字 */
            if (At_AsciiNum2Num(simlockUnlockSetReq.password, g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen) != AT_SUCCESS) {
                (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00,
                    sizeof(AT_MTA_SimlockunlockReq));
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 发送跨核消息到C核, 解锁锁网锁卡 */
            if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                       ID_AT_MTA_SIMLOCKUNLOCK_SET_REQ, (VOS_UINT8 *)&simlockUnlockSetReq,
                                       sizeof(AT_MTA_SimlockunlockReq), I0_UEPS_PID_MTA) != TAF_SUCCESS) {
                (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00,
                    sizeof(AT_MTA_SimlockunlockReq));
                return AT_ERROR;
            }

            /* 设置当前操作类型 */
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_SIMLOCKUNLOCK;
            (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00,
                sizeof(AT_MTA_SimlockunlockReq));
            return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
        }
        case AT_CLCK_MODE_LOCK: /* 设置<mode>为1，则直接返回错误信息 */
        {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        case AT_CLCK_MODE_QUERY_STATUS: /* 设置<mode>为2，则进行锁网锁卡功能查询操作 */
        {
            return AT_OK;
        }
        default: {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
}
#endif


TAF_UINT32 At_SetClckPara(TAF_UINT8 indexNum)
{
    VOS_UINT8  pin[TAF_PH_PINCODELENMAX];
    VOS_UINT32 cmdType;
    VOS_UINT32 result;
    errno_t    memResult;

    /* 参数检查 */
    if ((g_atParaList[AT_CLCK_FAC].paraLen == 0) || (g_atParaList[AT_CLCK_MODE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CLCK_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fac> */
    switch (g_atParaList[AT_CLCK_FAC].paraValue) {
        case AT_CLCK_P2_TYPE:
            return AT_CME_INCORRECT_PARAMETERS;

        case AT_CLCK_SC_TYPE: {
            TAF_PH_PinData pinData;

            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen > TAF_PH_PINCODELENMAX) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));

            /* 设置<passwd> */
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen != 0) {
                memResult = memcpy_s((TAF_CHAR *)pinData.oldPin, sizeof(pinData.oldPin),
                    (TAF_CHAR *)g_atParaList[AT_CLCK_PASSWD_INDEX].para, g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pinData.oldPin), g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
            }

            pinData.pinType = TAF_SIM_PIN;

            /* 设置CmdType */
            switch (g_atParaList[AT_CLCK_MODE].paraValue) {
                case 0: /* pin disable */
                    pinData.cmdType = TAF_PIN_DISABLE;
                    if (AT_CheckPinAvail(g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen,
                                         g_atParaList[AT_CLCK_PASSWD_INDEX].para) != VOS_OK) {
                        (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                            0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                    break;
                /* pin enable */
                case 1:
                    pinData.cmdType = TAF_PIN_ENABLE;
                    if (AT_CheckPinAvail(g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen,
                                         g_atParaList[AT_CLCK_PASSWD_INDEX].para) != VOS_OK) {
                        (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                             0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                    break;

                default:
                    pinData.cmdType = TAF_PIN_QUERY;
                    break;
            }

            /* 执行命令操作 */
            if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &pinData) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_ERROR;
            }
        }
        case AT_CLCK_FD_TYPE: {
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen > TAF_PH_PINCODELENMAX) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(pin, sizeof(pin), 0xFF, sizeof(pin));

            /* 设置<passwd> */
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen != 0) {
                memResult = memcpy_s((TAF_CHAR *)pin, sizeof(pin), (TAF_CHAR *)g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                    g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pin), g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
            }

            cmdType = g_atParaList[1].paraValue;

            /* 执行命令操作，当前只有FDN相关的操作，AT命令并不支持BDN功能 */
            if (cmdType == SI_PIH_FDN_BDN_ENABLE) {
                result = SI_PIH_FdnEnable(g_atClientTab[indexNum].clientId, 0, pin, TAF_PH_PINCODELENMAX);
            } else if (cmdType == SI_PIH_FDN_BDN_DISABLE) {
                result = SI_PIH_FdnDisable(g_atClientTab[indexNum].clientId, 0, pin, TAF_PH_PINCODELENMAX);
            } else {
                result = SI_PIH_FdnBdnQuery(g_atClientTab[indexNum].clientId, 0, SI_PIH_FDN_QUERY);
            }

            if (result == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                (VOS_VOID)memset_s(pin, sizeof(pin), 0xFF, sizeof(pin));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(pin, sizeof(pin), 0xFF, sizeof(pin));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0xff, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_ERROR;
            }
        }

        case AT_CLCK_PS_TYPE: {
            TAF_ME_PersonalisationData mePersonalisationData;

            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen > TAF_PH_PINCODELENMAX) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00, sizeof(TAF_ME_PersonalisationData));

            /* 设置<passwd> */
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen != 0) {
                memResult = memcpy_s((VOS_CHAR *)mePersonalisationData.oldPwd, sizeof(mePersonalisationData.oldPwd),
                    (VOS_CHAR *)g_atParaList[AT_CLCK_PASSWD_INDEX].para, g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mePersonalisationData.oldPwd),
                                    g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
            }

            /* 设置PinType */
            mePersonalisationData.mePersonalType = TAF_SIM_PERSONALISATION;

            /* 设置CmdType */
            switch (g_atParaList[1].paraValue) {
                case AT_ME_PS_DEACTIVE_TYPE:
                    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_DEACTIVE;
                    break;

                case AT_ME_PS_ACTIVE_TYPE:
                    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_ACTIVE;
                    break;

                default:
                    mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_QUERY;
                    break;
            }

            /* 执行命令操作 */
            if (Taf_MePersonalisationHandle(g_atClientTab[indexNum].clientId, 0, &mePersonalisationData) ==
                AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_PIN_HANDLE;
                (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData),
                         0x00, sizeof(TAF_ME_PersonalisationData));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                         sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0x00, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData),
                         0x00, sizeof(TAF_ME_PersonalisationData));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                         sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0x00, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_ERROR;
            }
        }

#if (FEATURE_PHONE_SC == FEATURE_ON)
        case AT_CLCK_PN_TYPE:
        case AT_CLCK_PU_TYPE:
        case AT_CLCK_PP_TYPE: {
            return AT_SetClckFacEqualPNPUPPPara(indexNum);
        }
#endif

        default: {
            TAF_SS_ErasessReq para;

            /* 初始化 */
            (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));

            /* 设置<password> */
            if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen > 0) {
                if (g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen != TAF_SS_MAX_PASSWORD_LEN) {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                para.opPassword = VOS_TRUE;
                memResult = memcpy_s((VOS_CHAR *)para.password, sizeof(para.password),
                                     (VOS_CHAR *)g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                     g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(para.password), g_atParaList[AT_CLCK_PASSWD_INDEX].paraLen);
            }

            /* 设置SsCode */
            At_SsPrint2Code(&para.ssCode, (TAF_UINT8)g_atParaList[0].paraValue);

            /* 设置<class> */
            if (AT_FillSsBsService(&para, &g_atParaList[AT_CLCK_CLASS]) != VOS_OK) {
                (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                         sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para),
                         0x00, sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 执行命令操作 */
            switch (g_atParaList[1].paraValue) {
                case 0: /* <mode>: unlock */
                    if (TAF_DeactivateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                        /* 设置当前操作类型 */
                        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_LOCK;
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
                    } else {
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_ERROR;
                    }
                    /* fall-through */

                case 1: /* <mode>: lock */
                    if (TAF_ActivateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                        /* 设置当前操作类型 */
                        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_UNLOCK;
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
                    } else {
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_ERROR;
                    }
                    /* fall-through */

                default: /* <mode>: query status */
                    para.opBsService             = 0;
                    g_atClientTab[indexNum].temp = g_atParaList[AT_CLCK_CLASS].paraValue;
                    if (TAF_InterrogateSSReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                        /* 设置当前操作类型 */
                        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLCK_QUERY;
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
                    } else {
                        (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                        (VOS_VOID)memset_s(g_atParaList[AT_CLCK_PASSWD_INDEX].para,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para), 0x00,
                                 sizeof(g_atParaList[AT_CLCK_PASSWD_INDEX].para));
                        return AT_ERROR;
                    }
            }
        }
    }
}


TAF_UINT32 At_SetCtfrPara(TAF_UINT8 indexNum)
{
    MN_CALL_SupsParam callSupsParam;
    VOS_UINT32        rst;
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl      ctrl;
    ModemIdUint16 modemId;

    /* 参数检查 */
    if (g_atParaList[AT_CTFR_NUMBER].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CTFR_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<number>过长，直接返回错误 */
    if (g_atParaList[AT_CTFR_NUMBER].paraLen > MN_CALL_MAX_ASCII_NUM_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<subaddr>过长，直接返回错误 */
    if (g_atParaList[AT_CTFR_SUBADDR].paraLen > MN_CALL_MAX_ASCII_NUM_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&callSupsParam, sizeof(callSupsParam), 0x00, sizeof(callSupsParam));

    g_atParaList[AT_CTFR_NUMBER].para[g_atParaList[AT_CTFR_NUMBER].paraLen] = '\0';

    rst = AT_AsciiNumberToBcd((VOS_CHAR *)g_atParaList[AT_CTFR_NUMBER].para, callSupsParam.redirectNum.bcdNum,
                              &callSupsParam.redirectNum.numLen);
    if (rst != MN_ERR_NO_ERROR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    callSupsParam.callId              = 0;
    callSupsParam.callSupsCmd         = MN_CALL_SUPS_CMD_DEFLECT_CALL;
    callSupsParam.redirectNum.numType = (TAF_UINT8)g_atParaList[1].paraValue;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&ctrl, &callSupsParam, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(callSupsParam), modemId) ==
        VOS_OK) {
        /* 停止自动接听 */
        ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);

        if (ccCtx->s0TimeInfo.timerStart == VOS_TRUE) {
            AT_StopRelTimer(ccCtx->s0TimeInfo.timerName, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CTFR_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetCusdPara(VOS_UINT8 indexNum)
{
    TAF_SS_ProcessUssReq     *para = VOS_NULL_PTR;
    VOS_UINT32                ret;
    TAF_SS_DATA_CODING_SCHEME datacodingScheme;
    VOS_UINT32                procRet;

    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    /* 获取SS上下文 */
    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    ret = AT_ERROR;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CUSD_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_CUSD_DCS].paraLen == 0) {
        /* 默认为7bit编码 */
        datacodingScheme = TAF_SS_7bit_LANGUAGE_UNSPECIFIED;
    } else {
        datacodingScheme = (TAF_SS_DATA_CODING_SCHEME)g_atParaList[AT_CUSD_DCS].paraValue;

        /* 产品线要求支持uss2的ussd */
    }

    /* 如果<str>号码过长，直接返回错误 */
    if (At_CheckUssdNumLen(indexNum, datacodingScheme, g_atParaList[AT_CUSD_STR].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /*lint -save -e516 */
    para = (TAF_SS_ProcessUssReq *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_SS_ProcessUssReq));
    /*lint -restore */
    if (para == TAF_NULL_PTR) {
        return AT_ERROR;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(para, sizeof(TAF_SS_ProcessUssReq), 0x00, sizeof(TAF_SS_ProcessUssReq));

    /* 设置<n> */
    if (g_atParaList[AT_CUSD_N].paraLen != 0) {
        if (g_atParaList[AT_CUSD_N].paraValue != AT_CUSD_N_EXIT_SESSION) {
            para->cusdType = (TAF_SS_CusdTypeUint8)g_atParaList[AT_CUSD_N].paraValue;
        }
    } else {
        para->cusdType = TAF_SS_CUSD_TYPE_DISABLE;
    }

    /* <n>: cancel session */
    if (g_atParaList[AT_CUSD_N].paraValue == AT_CUSD_N_CANCEL_SESSION_VALUE) {
        if (TAF_SsReleaseComplete(g_atClientTab[indexNum].clientId, 0) == AT_SUCCESS) {
            ret = AT_OK;

        } else {
            ret = AT_ERROR;
        }
    } else {
        /*  AT+CUSD=0时，也需要给C核发消息，但不用等C核回复 */
        if (g_atParaList[AT_CUSD_STR].paraLen == 0) {
            (VOS_VOID)memset_s(&(para->ussdStr), sizeof(para->ussdStr), 0x00, sizeof(para->ussdStr));
        } else {
            procRet = At_ConvUssdStrInCmd(&(para->ussdStr), datacodingScheme, indexNum);
            if (procRet != AT_OK) {
                /*lint -save -e516 */
                PS_MEM_FREE(WUEPS_PID_AT, para);
                /*lint -restore */
                return procRet;
            }
        }
        /* 设置<dcs> */
        para->datacodingScheme = datacodingScheme;

        para->ussdTransMode = ssCtx->ussdTransMode;
        /* 执行命令操作 */
        if (TAF_ProcessUnstructuredSSReq(g_atClientTab[indexNum].clientId, 0, para) == AT_SUCCESS) {
            /*  AT+CUSD=0时，也需要给C核发消息，但不用等C核回复 */
            if (g_atParaList[AT_CUSD_STR].paraLen == 0) {
                ret = AT_OK;
            } else {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CUSD_REQ;

                /* 返回命令处理挂起状态 */
                ret = AT_WAIT_ASYNC_RETURN;
            }
        } else {
            ret = AT_ERROR;
        }
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, para);
    /*lint -restore */
    return ret;
}

TAF_UINT32 At_SetCpwdPara(TAF_UINT8 indexNum)
{
    errno_t    memResult;
    VOS_UINT32 i;
    /* 参数检查 */
    if ((g_atParaList[AT_CPWD_FAC].paraLen    == 0) || (g_atParaList[1].paraLen == 0) ||
        (g_atParaList[AT_CPWD_NEWPWD].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CPWD_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<fac> */
    switch (g_atParaList[AT_CPWD_FAC].paraValue) {
        case AT_CLCK_P2_TYPE:
        case AT_CLCK_SC_TYPE: {
            TAF_PH_PinData pinData;

            if ((g_atParaList[AT_CPWD_OLDPWD].paraLen > TAF_PH_PINCODELENMAX) ||
                (g_atParaList[AT_CPWD_NEWPWD].paraLen > TAF_PH_PINCODELENMAX) ||
                (g_atParaList[AT_CPWD_OLDPWD].paraLen < TAF_PH_PINCODELENMIN) ||
                (g_atParaList[AT_CPWD_NEWPWD].paraLen < TAF_PH_PINCODELENMIN)) {
                return AT_ERROR;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));

            /* 设置<pin> */
            if (g_atParaList[AT_CPWD_OLDPWD].paraLen != 0) {
                for (i = 0; i < g_atParaList[AT_CPWD_OLDPWD].paraLen; i++) {
                    if ((g_atParaList[AT_CPWD_OLDPWD].para[i] > '9') || (g_atParaList[AT_CPWD_OLDPWD].para[i] < '0')) {
                        (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para,
                                 (VOS_SIZE_T)sizeof(g_atParaList[AT_CPWD_OLDPWD].para), 0xff,
                                 (VOS_SIZE_T)sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                }

                memResult = memcpy_s((TAF_VOID *)pinData.oldPin, sizeof(pinData.oldPin),
                                     (TAF_VOID *)g_atParaList[AT_CPWD_OLDPWD].para,
                                     g_atParaList[AT_CPWD_OLDPWD].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pinData.oldPin), g_atParaList[AT_CPWD_OLDPWD].paraLen);
            }

            /* 设置<newpin> */
            if (g_atParaList[AT_CPWD_NEWPWD].paraLen != 0) {
                for (i = 0; i < g_atParaList[AT_CPWD_NEWPWD].paraLen; i++) {
                    if ((g_atParaList[AT_CPWD_NEWPWD].para[i] > '9') || (g_atParaList[AT_CPWD_NEWPWD].para[i] < '0')) {
                        (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                                 0xff, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                        return AT_CME_INCORRECT_PARAMETERS;
                    }
                }

                memResult = memcpy_s(pinData.newPin, sizeof(pinData.newPin),
                                     g_atParaList[AT_CPWD_NEWPWD].para, g_atParaList[AT_CPWD_NEWPWD].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(pinData.newPin), g_atParaList[AT_CPWD_NEWPWD].paraLen);
            }
            /* 设置PinType */
            if (g_atParaList[0].paraValue == AT_CLCK_P2_TYPE) {
                pinData.pinType = TAF_SIM_PIN2;
            } else {
                pinData.pinType = TAF_SIM_PIN;
            }

            /* 设置CmdType */
            pinData.cmdType = TAF_PIN_CHANGE;

            /* 执行命令操作 */
            if (Taf_PhonePinHandle(g_atClientTab[indexNum].clientId, 0, &pinData) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPWD_CHANGE_PIN;
                (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(&pinData, sizeof(pinData), 0xFF, sizeof(pinData));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_ERROR;
            }
        }

        case AT_CLCK_PS_TYPE: {
            TAF_ME_PersonalisationData mePersonalisationData;

            if ((g_atParaList[AT_CPWD_OLDPWD].paraLen > TAF_PH_PINCODELENMAX) ||
                (g_atParaList[AT_CPWD_NEWPWD].paraLen > TAF_PH_PINCODELENMAX)) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData), 0x00,
                     sizeof(mePersonalisationData));

            /* 设置<oldpwd> */
            memResult = memcpy_s((VOS_UINT8 *)mePersonalisationData.oldPwd,
                                 sizeof(mePersonalisationData.oldPwd), g_atParaList[AT_CPWD_OLDPWD].para,
                                 g_atParaList[AT_CPWD_OLDPWD].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mePersonalisationData.oldPwd), g_atParaList[AT_CPWD_OLDPWD].paraLen);

            /* 设置<newpwd> */
            memResult = memcpy_s((VOS_CHAR *)mePersonalisationData.newPwd,
                                 sizeof(mePersonalisationData.newPwd), (VOS_CHAR *)g_atParaList[AT_CPWD_NEWPWD].para,
                                 g_atParaList[AT_CPWD_NEWPWD].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mePersonalisationData.newPwd), g_atParaList[AT_CPWD_NEWPWD].paraLen);

            /* 设置MePersonalType */
            mePersonalisationData.mePersonalType = TAF_SIM_PERSONALISATION;

            /* 设置CmdType */
            mePersonalisationData.cmdType = TAF_ME_PERSONALISATION_PWD_CHANGE;

            /* 执行命令操作 */
            if (Taf_MePersonalisationHandle(g_atClientTab[indexNum].clientId, 0, &mePersonalisationData) ==
                AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPWD_CHANGE_PIN;
                (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData),
                         0x00, sizeof(mePersonalisationData));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(&mePersonalisationData, sizeof(mePersonalisationData),
                         0x00,sizeof(mePersonalisationData));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_ERROR;
            }
        }

        default: {
            TAF_SS_RegpwdReq para;

            if ((g_atParaList[AT_CPWD_OLDPWD].paraLen > TAF_SS_MAX_PASSWORD_LEN) ||
                (g_atParaList[AT_CPWD_NEWPWD].paraLen > TAF_SS_MAX_PASSWORD_LEN)) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            /* 初始化 */
            (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));

            /* 设置<oldpwd> */
            memResult = memcpy_s((TAF_CHAR *)para.oldPwdStr, sizeof(para.oldPwdStr),
                                 (TAF_CHAR *)g_atParaList[AT_CPWD_OLDPWD].para, g_atParaList[AT_CPWD_OLDPWD].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(para.oldPwdStr), g_atParaList[AT_CPWD_OLDPWD].paraLen);

            /* 设置<newpwd> */
            memResult = memcpy_s((TAF_CHAR *)para.newPwdStr, sizeof(para.newPwdStr),
                                 (TAF_CHAR *)g_atParaList[AT_CPWD_NEWPWD].para, g_atParaList[AT_CPWD_NEWPWD].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(para.newPwdStr), g_atParaList[AT_CPWD_NEWPWD].paraLen);

            /* 设置<newpwd> */
            memResult = memcpy_s((TAF_CHAR *)para.newPwdStrCnf, sizeof(para.newPwdStrCnf),
                                 (TAF_CHAR *)g_atParaList[AT_CPWD_NEWPWD].para, g_atParaList[AT_CPWD_NEWPWD].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(para.newPwdStrCnf), g_atParaList[AT_CPWD_NEWPWD].paraLen);

            /* 设置SsCode */
            At_SsPrint2Code(&para.ssCode, (TAF_UINT8)g_atParaList[AT_CPWD_FAC].paraValue);

            /* 执行命令操作 */
            if (TAF_RegisterPasswordReq(g_atClientTab[indexNum].clientId, 0, &para) == AT_SUCCESS) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPWD_SET;
                (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                (VOS_VOID)memset_s(&para, sizeof(para), 0x00, sizeof(para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_OLDPWD].para, sizeof(g_atParaList[AT_CPWD_OLDPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_OLDPWD].para));
                (VOS_VOID)memset_s(g_atParaList[AT_CPWD_NEWPWD].para, sizeof(g_atParaList[AT_CPWD_NEWPWD].para),
                         0x00, sizeof(g_atParaList[AT_CPWD_NEWPWD].para));
                return AT_ERROR;
            }
        }
    }
}

TAF_VOID At_SetDialIGPara(TAF_UINT8 indexNum, TAF_UINT8 paraIndex, TAF_UINT8 *clir, MN_CALL_CugCfg *ccug)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* ->A32D08138 */
    /* 默认情况是使用CCA设置的默认值 */

    *clir = ssCtx->clirType;
    *ccug = ssCtx->ccugCfg;
    /* <-A32D08138 */

    switch (g_atParaList[paraIndex].para[0]) {
        case 'i':
            *clir = MN_CALL_CLIR_SUPPRESS;
            break;

        case 'I':
            *clir = MN_CALL_CLIR_INVOKE;
            break;

        case 'g':
        case 'G':
            ccug->enable = 1;
            break;

        default:
            break;
    }

    switch (g_atParaList[paraIndex + 1].para[0]) {
        case 'g':
        case 'G':
            ccug->enable = 1;
            break;

        default:
            break;
    }
}


TAF_UINT32 At_SetDialGprsPara(TAF_UINT8 indexNum, TAF_UINT8 cid, TAF_GPRS_ActiveTypeUint8 activeType)
{
    TAF_PPP_ReqConfigInfo pppReqConfigInfo;
    VOS_ULONG             userData;
    VOS_UINT16            pppId = 0;
    DMS_PortIdUint16      portId;
    VOS_UINT8             eventInfo[AT_EVENT_INFO_ARRAY_MAX_LEN];

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
    VOS_INT32             dlc;
    dlc = DMS_PORT_GetCmuxActivePppPstaskDlc();
#endif

    (VOS_VOID)memset_s(&pppReqConfigInfo, sizeof(pppReqConfigInfo), 0x00, sizeof(TAF_PPP_ReqConfigInfo));
    portId   = g_atClientTab[indexNum].portNo;
    userData = (VOS_ULONG)portId;

    /* 进行激活操作 */
    if (activeType == TAF_IP_ACTIVE_TE_PPP_MT_PPP_TYPE) { /* MT中启动PPP */
        g_atClientTab[indexNum].cid = cid;                /* 保存当前指定的cid */

        if (PPPA_CreatePppReq(&pppId, userData, DMS_PORT_SendPppPacket) == AT_SUCCESS) { /* TE中启动了PPP，MT中启动PPP */
            /* EVENT-At_SetDialGprsPara: usPppId/index */
            eventInfo[AT_EVENT_INFO_ARRAY_INDEX_0] = (TAF_UINT8)(pppId >> 8);
            eventInfo[AT_EVENT_INFO_ARRAY_INDEX_1] = (TAF_UINT8)pppId;
            eventInfo[AT_EVENT_INFO_ARRAY_INDEX_2] = indexNum;
            AT_EventReport(WUEPS_PID_AT, NAS_OM_EVENT_DCE_CREATE_PPP, eventInfo, sizeof(eventInfo));

            g_atPppIndexTab[pppId]        = indexNum; /* 记录PPP id和Index的对应关系 */
            g_atClientTab[indexNum].pppId = pppId;    /* 保存PPP id */

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
            if ((AT_CheckCmuxUser(indexNum) == VOS_TRUE) && (g_atClientTab[indexNum].dataId != indexNum)) {
                /* 保存PPP id */
                g_atClientTab[g_atClientTab[indexNum].dataId].pppId = pppId;
                /* 切换为PPP数传状态 */
                DMS_PORT_SwitchToPppDataMode(g_atClientTab[g_atClientTab[indexNum].dataId].portNo, DMS_PORT_DATA_PPP, PPP_PullPacketEvent, pppId);
                /*保存下发ATD的接口*/
                g_atClientTab[g_atClientTab[indexNum].dataId].ctrlId = indexNum;
            } else {
#endif
            DMS_PORT_SwitchToPppDataMode(portId, DMS_PORT_DATA_PPP, PPP_PullPacketEvent, pppId);
#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
            }
            /*设置拨号成功的标志位*/
            dlc++;
            DMS_PORT_SetCmuxActivePppPstaskDlc(dlc);
#endif
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_PPP_CALL_SET;

            return AT_CONNECT;
        } else {
            return AT_ERROR;
        }
    } else {
        pppReqConfigInfo.auth.authType = TAF_PDP_AUTH_TYPE_NONE;
        pppReqConfigInfo.ipcp.ipcpLen  = 0;

        /* 创建透传的PPP实体 */
        if (PPPA_CreateRawDataPppReq(&pppId, userData, DMS_PORT_SendPppPacket) != AT_SUCCESS) {
            return AT_ERROR;
        }

        if (TAF_PS_PPP_DIAL_UP(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, cid,
                               &pppReqConfigInfo) != VOS_OK) {
            AT_SendRelPppReq(pppId, PPP_AT_CTRL_REL_PPP_RAW_REQ);
            return AT_ERROR;
        }

        g_atPppIndexTab[pppId]        = indexNum; /* 记录PPP id和Index的对应关系 */
        g_atClientTab[indexNum].pppId = pppId;    /* 保存PPP id */

        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_IP_CALL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }
}


TAF_UINT32 At_SetDial98Para(TAF_UINT8 indexNum)
{
    TAF_ATD_Para atdPara;

    /* 初始化 */
    (VOS_VOID)memset_s(&atdPara, sizeof(atdPara), 0x00, sizeof(TAF_ATD_Para));

    /* CID存在 */
    /* 发送MMI字符串mmi_string。 */
    if (g_atParaList[AT_D_CID].paraLen != 0) {
        if (At_Auc2ul(g_atParaList[AT_D_CID].para, g_atParaList[AT_D_CID].paraLen,
                      &g_atParaList[AT_D_CID].paraValue) == AT_FAILURE) {
            return AT_ERROR;
        }

        if (g_atParaList[AT_D_CID].paraValue > 0xFF) { /* 需要检查，否则过界 */
            return AT_ERROR;
        }

        /* 获取当前用户输入的CID */
        atdPara.cid = (VOS_UINT8)g_atParaList[AT_D_CID].paraValue;
    } else {
        /* 设置默认CID */
        atdPara.cid = AT_DIAL_DEFAULT_CID;
    }

    /* 获取GPRS激活类型 */
    if (TAF_PS_GetGprsActiveType(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &atdPara) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetDial99Para(VOS_UINT8 indexNum)
{
    VOS_INT32    paraPPPFlg;
    VOS_INT32    paraNULLFlg;
    VOS_UINT8    tmp;
    VOS_UINT8    star;
    VOS_UINT8    l2pIndex;
    VOS_UINT8    cidIndex;
    TAF_ATD_Para atdPara;

    /* 初始化 */
    tmp      = 0;
    star     = 0;
    l2pIndex = 0;
    cidIndex = 0;
    (VOS_VOID)memset_s(&atdPara, sizeof(atdPara), 0x00, sizeof(TAF_ATD_Para));

    /* 解析参数列表 */
    for (tmp = 1; tmp < g_atParaIndex; tmp++) {
        if (g_atParaList[tmp].para[0] == '*') {
            star++;
        } else {
            switch (star) {
                case AT_STAR_NUM1:
                case AT_STAR_NUM2:
                    break;

                case AT_STAR_NUM3:
                    l2pIndex = tmp;
                    break;

                case AT_STAR_NUM4:
                    cidIndex = tmp;
                    break;

                default:
                    return AT_ERROR;
            }
        }
    }

    /* 获取CID: 不存在CID参数时, 取默认值1 */
    if (cidIndex != 0) {
        if (At_Auc2ul(g_atParaList[cidIndex].para, g_atParaList[cidIndex].paraLen, &g_atParaList[cidIndex].paraValue) ==
            AT_FAILURE) {
            return AT_ERROR;
        }

        /* 需要检查，否则过界 */
        if (g_atParaList[cidIndex].paraValue > 0xFF) {
            return AT_ERROR;
        }

        atdPara.cid = (VOS_UINT8)g_atParaList[cidIndex].paraValue;
    } else {
        atdPara.cid = AT_DIAL_DEFAULT_CID;
    }

    /* 获取L2P协议类型: 兼容不支持的协议类型 */
    if (l2pIndex != 0) {
        paraPPPFlg  = VOS_StrCmp((TAF_CHAR *)g_atParaList[l2pIndex].para, "1");
        paraNULLFlg = VOS_StrCmp((TAF_CHAR *)g_atParaList[l2pIndex].para, "0");

        if ((VOS_StrCmp((TAF_CHAR *)g_atParaList[l2pIndex].para, "PPP") == 0) || (paraPPPFlg == 0)) {
            atdPara.opL2p = VOS_TRUE;
            atdPara.l2p   = TAF_L2P_PPP;
        } else if ((VOS_StrCmp((TAF_CHAR *)g_atParaList[l2pIndex].para, "NULL") == 0) || (paraNULLFlg == 0)) {
            atdPara.opL2p = VOS_TRUE;
            atdPara.l2p   = TAF_L2P_NULL;
        } else {
            ;
        }
    } else {
        ;
    }

    /* 获取GPRS激活类型 */
    if (TAF_PS_GetGprsActiveType(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &atdPara) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetDial777Para(TAF_UINT8 indexNum)
{
    TAF_ATD_Para atdPara;

    /* 初始化 */
    (VOS_VOID)memset_s(&atdPara, sizeof(atdPara), 0x00, sizeof(TAF_ATD_Para));

    /* 设置默认CID */
    atdPara.cid = AT_DIAL_DEFAULT_CID;

    /* 获取GPRS激活类型 */
    if (TAF_PS_GetGprsActiveType(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, &atdPara) !=
        VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_GPRS_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_FillCalledNumPara(VOS_UINT8 *atPara, VOS_UINT16 len, MN_CALL_CalledNum *calledNum)
{
    VOS_UINT32 relt;

    /* 号码类型检查 */
    if (*atPara == '+') {
        /* 国际号码的第一个字符不需要编码,最多可以为81个字符 */
        if (len > (MN_CALL_MAX_CALLED_ASCII_NUM_LEN + 1)) {
            return VOS_ERR;
        }

        *(atPara + len) = '\0';
        atPara += 1;

        calledNum->numType = (MN_CALL_IS_EXIT | (MN_CALL_TON_INTERNATIONAL << 4) | MN_CALL_NPI_ISDN);
    } else {
        /* 国内号码或未知号码最多可以为80个字符 */
        if (len > MN_CALL_MAX_CALLED_ASCII_NUM_LEN) {
            return VOS_ERR;
        }

        *(atPara + len) = '\0';

        calledNum->numType = (MN_CALL_IS_EXIT | (MN_CALL_TON_UNKNOWN << 4) | MN_CALL_NPI_ISDN);
    }

    relt = AT_AsciiNumberToBcd((VOS_CHAR *)atPara, calledNum->bcdNum, &calledNum->numLen);

    if (relt != MN_ERR_NO_ERROR) {
        return VOS_ERR;
    }

    AT_JudgeIsPlusSignInDialString((VOS_CHAR *)atPara, len + 1, &calledNum->isExistPlusSign, &calledNum->plusSignLocation);

    return VOS_OK;
}


TAF_UINT32 At_SetDialNumPara(TAF_UINT8 indexNum, MN_CALL_TypeUint8 callType)
{
    MN_CALL_OrigParam origParam;
    AT_ModemSsCtx    *ssCtx = VOS_NULL_PTR;
    TAF_Ctrl          ctrl;
    ModemIdUint16     modemId;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 目前华为移动的AT命令的需求，应该只要满足一般的语音呼叫即可 */

    /* 初始化 */
    (VOS_VOID)memset_s(&origParam, sizeof(origParam), 0x00, sizeof(origParam));

    /* 设置<dial_string> */
    if (AT_FillCalledNumPara(g_atParaList[AT_D_BY_DIAL_STRING].para,
                             g_atParaList[AT_D_BY_DIAL_STRING].paraLen, &origParam.dialNumber) != VOS_OK) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    origParam.callType = callType;

    At_SetDialIGPara(indexNum, AT_D_PARA_INDEX_2, &origParam.clirCfg, &origParam.cugCfg);

    origParam.callMode = ssCtx->cModType;

    origParam.dataCfg = ssCtx->cbstDataCfg;

    /* 考虑数据卡的接口，这里的定义视频呼叫域为3GPP的 */
    if (callType == MN_CALL_TYPE_VIDEO) {
        origParam.voiceDomain = TAF_CALL_VOICE_DOMAIN_3GPP;
    } else {
        origParam.voiceDomain = TAF_CALL_VOICE_DOMAIN_AUTO;
    }

    /* 遗留问题6、呼叫接口，需要增加设置I、G的参数；需要修改D命令实现 */

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &origParam, ID_TAF_CCM_CALL_ORIG_REQ, sizeof(origParam), modemId) == VOS_OK) {
        if (callType == MN_CALL_TYPE_VOICE) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_CS_VOICE_CALL_SET;
        } else {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_CS_DATA_CALL_SET;
        }
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);

        return AT_ERROR;
    }
}

VOS_UINT32 At_DialNumByIndexFromPb(VOS_UINT8 indexNum, SI_PB_EventInfo *event)
{
    errno_t    memResult;
    VOS_UINT16 numberLength;

    numberLength = TAF_MIN(event->pbEvent.pbReadCnf.pbRecord.numberLength, SI_PB_PHONENUM_MAX_LEN);

    /* 将从电话本读到的号码写入g_atParaList[1].aucPara */
    if (event->pbEvent.pbReadCnf.pbRecord.numberLength > 0) {
        memResult = memcpy_s(&g_atParaList[1].para[0], AT_PARA_MAX_LEN + 1, event->pbEvent.pbReadCnf.pbRecord.number,
                             numberLength);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_PARA_MAX_LEN + 1, numberLength);
    }
    g_atParaList[1].para[numberLength] = '\0';
    g_atParaList[1].paraLen            = numberLength;
    /* D[<dial_string>][I][G][;] */
    return At_SetDialNumPara(indexNum, g_atClientTab[indexNum].atCallInfo.callType);
}

/*
 * Description: D><n>[I][G][;]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetDialVoiceIndexPara(TAF_UINT8 indexNum, MN_CALL_TypeUint8 callType)
{
    TAF_UINT32              uLIndex = 0;
    SI_PB_StorateTypeUint32 storage = SI_PB_STORAGE_UNSPECIFIED;
    /* 从当前存储器的存储位置<n>获取被叫号码，并用该号码发起呼叫。 */
    if (At_Auc2ul(g_atParaList[AT_D_BY_N].para, g_atParaList[AT_D_BY_N].paraLen, &uLIndex) == AT_FAILURE) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].atCallInfo.callType = callType;

    At_SetDialIGPara(indexNum, AT_D_PARA_INDEX_3, &g_atClientTab[indexNum].atCallInfo.clirInfo,
                     &g_atClientTab[indexNum].atCallInfo.cugMode);

    if (SI_PB_Read(g_atClientTab[indexNum].clientId, 0, storage, (TAF_UINT16)uLIndex, (TAF_UINT16)uLIndex) ==
        AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_GET_NUMBER_BEFORE_CALL;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
/*
 * Description: D><name>[I][G][;]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetDialVoiceNamePara(TAF_UINT8 indexNum, MN_CALL_TypeUint8 callType)
{
    /* 根据电话本中存储的姓名<name>获取被叫号码，并用该号码发起呼叫。 */
    if (At_CheckNumLen(SI_PB_ALPHATAG_MAX_LEN, g_atParaList[AT_D_BY_NAME].paraLen) == AT_FAILURE) {
        return AT_ERROR;
    }

    if (At_CheckStringPara(&g_atParaList[AT_D_BY_NAME]) == AT_FAILURE) {
        return AT_ERROR;
    }

    /* 设置ucAlphaTagType */
    if (g_atCscsType == AT_CSCS_UCS2_CODE) {
        if (At_UnicodePrint2Unicode(g_atParaList[AT_D_BY_NAME].para,
                                    &g_atParaList[AT_D_BY_NAME].paraLen) == AT_FAILURE) {
            return AT_ERROR;
        }
    }

    g_atClientTab[indexNum].atCallInfo.callType = callType;

    At_SetDialIGPara(indexNum, AT_D_PARA_INDEX_3, &g_atClientTab[indexNum].atCallInfo.clirInfo,
                     &g_atClientTab[indexNum].atCallInfo.cugMode);


    return AT_ERROR;
}

TAF_UINT32 At_SetDialVoiceMemPara(TAF_UINT8 indexNum, MN_CALL_TypeUint8 callType)
{
    TAF_UINT32              uLIndex = 0;
    SI_PB_StorateTypeUint32 storage = SI_PB_STORAGE_UNSPECIFIED;
    /* 从指定存储器mem的存储位置<n>获取被叫号码，并用该号码发起呼叫，存储器可以通过命令+CPBS=?查询。 */
    if (At_Auc2ul(g_atParaList[AT_D_MEM_N_NUM].para, g_atParaList[AT_D_MEM_N_NUM].paraLen, &uLIndex) == AT_FAILURE) {
        return AT_ERROR;
    }

    if (VOS_StrCmp((TAF_CHAR *)"SM", (TAF_CHAR *)g_atParaList[AT_D_MEM_TYPE].para) == 0) {
        storage = SI_PB_STORAGE_SM;
    } else {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].atCallInfo.callType = callType;

    At_SetDialIGPara(indexNum, AT_D_PARA_INDEX_4, &g_atClientTab[indexNum].atCallInfo.clirInfo,
                     &g_atClientTab[indexNum].atCallInfo.cugMode);

    if (SI_PB_Read(g_atClientTab[indexNum].clientId, 0, storage, (TAF_UINT16)uLIndex, (TAF_UINT16)uLIndex) ==
        AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_D_GET_NUMBER_BEFORE_CALL;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_CheckAtDPin(VOS_UINT8 indexNum)
{
    TAF_UINT32       rst;
    ModemIdUint16    modemId;
    VOS_UINT32       getModemIdRslt;
    AT_USIM_InfoCtx *usimInfoCtx = VOS_NULL_PTR;

    modemId = MODEM_ID_0;

    getModemIdRslt = AT_GetModemIdFromClient(indexNum, &modemId);

    if (getModemIdRslt != VOS_OK) {
        AT_ERR_LOG("At_CheckAtDPin:Get Modem Id fail!");
        return AT_ERROR;
    }

    usimInfoCtx = AT_GetUsimInfoCtxFromModemId(modemId);

    /* SIM卡状态判断 */
    switch (usimInfoCtx->cardStatus) {
        /* 仅替换消息类型 */
        case USIMM_CARDAPP_SERVIC_AVAILABLE:
            rst = AT_SUCCESS;
            break;
        case USIMM_CARDAPP_SERVIC_SIM_PIN:
            rst = AT_CME_SIM_PIN_REQUIRED;
            break;
        case USIMM_CARDAPP_SERVIC_SIM_PUK:
            rst = AT_CME_SIM_PUK_REQUIRED;
            break;
        case USIMM_CARDAPP_SERVIC_UNAVAILABLE:
        case USIMM_CARDAPP_SERVIC_NET_LCOK:
        case USIMM_CARDAPP_SERVICE_IMSI_LOCK:
            rst = AT_CME_SIM_FAILURE;
            break;
        case USIMM_CARDAPP_SERVIC_ABSENT:
            rst = AT_CME_SIM_NOT_INSERTED;
            break;
        default:
            rst = AT_ERROR;
            break;
    }

    return rst;
}


TAF_UINT32 At_PsDPara(TAF_UINT8 indexNum)
{
    TAF_UINT32 rst;

    rst = At_CheckAtDPin(indexNum);
    if (rst != AT_SUCCESS) {
        return rst;
    }

    /* 如果带分号,D*752#+436644101453; */
    if (At_CheckSemicolon(g_atParaList[0].para[g_atParaList[0].paraLen - 1]) == AT_SUCCESS) {
        /* D*752#+436644101453; */
        g_atParaList[0].para[g_atParaList[0].paraLen - 1] = 0;
        g_atParaList[0].paraLen--;
    } else if (g_atParaList[0].para[g_atParaList[0].paraLen - 1] == '#') {
        if (VOS_StrNiCmp((TAF_CHAR *)g_atParaList[AT_D_L2P].para, "98", g_atParaList[AT_D_L2P].paraLen) == 0) {
            /* D*<GPRS_SC_IP>[*<cid>[,<cid>]]# */
            return At_SetDial98Para(indexNum);
        } else if (VOS_StrNiCmp((TAF_CHAR *)g_atParaList[AT_D_L2P].para, "99", g_atParaList[AT_D_L2P].paraLen) == 0) {
            /* D*<GPRS_SC>[*[<called_address>][*[<L2P>][*[<cid>]]]]# */
            return At_SetDial99Para(indexNum);
        }
        else if (VOS_StrNiCmp((TAF_CHAR *)g_atParaList[AT_D_L2P].para, "777", g_atParaList[AT_D_L2P].paraLen) == 0) {
            return At_SetDial777Para(indexNum);
        }
        else {
        }
    } else {
    }
    return AT_ERROR;
}



VOS_UINT8 At_JudgeIfIsPsCall(VOS_VOID)
{
    VOS_UINT8 psCallFlg;

    if (g_atParaList[0].para[g_atParaList[0].paraLen - 1] != '#') {
        psCallFlg = VOS_FALSE;
    } else if (AT_CheckStrStartWith(&g_atParaList[0].para[1], g_atParaList[0].paraLen, (VOS_UINT8 *)"*98",
                                    AT_DATA_DIAL_LEN)) {
        psCallFlg = VOS_TRUE;
    } else if (AT_CheckStrStartWith(&g_atParaList[0].para[1], g_atParaList[0].paraLen, (VOS_UINT8 *)"*99",
                                    AT_DATA_DIAL_LEN)) {
        psCallFlg = VOS_TRUE;
    }
    else if (AT_CheckStrStartWith(&g_atParaList[1].para[0], g_atParaList[1].paraLen, (VOS_UINT8 *)"#777",
                                  AT_CDATA_DIAL_777_LEN)) {
        psCallFlg = VOS_TRUE;
    }
    else {
        psCallFlg = VOS_FALSE;
    }

    return psCallFlg;
}

TAF_UINT32 At_SetDPara(TAF_UINT8 indexNum)
{
    /* cS call */
    if (At_JudgeIfIsPsCall() != VOS_TRUE) {
        MN_CALL_TypeUint8 callType = MN_CALL_TYPE_VOICE;

#if (FEATURE_ECALL == FEATURE_ON)
        /* 当前有ecall正在通话或者发起 */
        if (AT_HaveEcallActive(indexNum, VOS_FALSE) == VOS_TRUE) {
            return AT_NO_CARRIER;
        }
#endif /* FEATURE_ECALL == FEATURE_ON */
        /* 如果命令末尾有分号，表示发起语音呼叫；如果没有分号，则表示发起数据呼叫。 */
        if (g_atParaList[AT_D_DIAL_STRING].para[g_atParaList[AT_D_DIAL_STRING].paraLen - 1] != ';') {
            callType = MN_CALL_TYPE_VIDEO;
        }
        /* 从指定存储器mem的存储位置<n>获取被叫号码，并用该号码发起呼叫，存储器可以通过命令+CPBS=?查询。 */
        if (g_atParaList[AT_D_BY_MEM_N_POSITION].para[0] == '>') {
            /* 根据电话本中存储的姓名<name>获取被叫号码，并用该号码发起呼叫。 */
            if ((g_atParaList[AT_D_BY_NAME].para[0] >= 'A') && (g_atParaList[AT_D_BY_NAME].para[0] <= 'Z')) {
                /* D>mem<n>[I][G][;] */
                return At_SetDialVoiceMemPara(indexNum, callType);
             /* 从当前存储器的存储位置<n>获取被叫号码，并用该号码发起呼叫。 */
            } else if ((g_atParaList[AT_D_BY_N].para[0] >= '0') && (g_atParaList[AT_D_BY_N].para[0] <= '9')) {
                /* D><n>[I][G][;] */
                return At_SetDialVoiceIndexPara(indexNum, callType);
            } else {
                /* D><name>[I][G][;] */
                return At_SetDialVoiceNamePara(indexNum, callType);
            }
        } else {
            /* D[<dial_string>][I][G][;] */
            return At_SetDialNumPara(indexNum, callType);
        }
    } else {
        return At_PsDPara(indexNum);
    }
}


TAF_UINT32 At_SetAPara(TAF_UINT8 indexNum)
{
    TAF_Ctrl          ctrl;
    MN_CALL_SupsParam supsCmdPara;
    VOS_UINT32        timerId;

    VOS_UINT8  numOfCalls;
    VOS_UINT8  tmp;
    VOS_UINT32 rlst;
    AT_ModemCcCtx          *ccCtx = VOS_NULL_PTR;
    TAFAGENT_CALL_InfoParam callInfos[MN_CALL_MAX_NUM];
    ModemIdUint16           modemId;

    ccCtx = AT_GetModemCcCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(callInfos, sizeof(callInfos), 0x00, sizeof(callInfos));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 从同步API获取通话信息 */
    rlst = TAF_AGENT_GetCallInfoReq(g_atClientTab[indexNum].clientId, &numOfCalls, callInfos);

    if (rlst != VOS_OK) {
        return AT_ERROR;
    }

    if (numOfCalls == 0) {
        return AT_NO_CARRIER;
    }

    numOfCalls = AT_MIN(numOfCalls, MN_CALL_MAX_NUM);
    for (tmp = 0; tmp < numOfCalls; tmp++) {
        /* 设置了自动接听的情况下如果呼叫已经处于incoming态，再触发ATA操作，返回ok */
        if ((callInfos[tmp].callState == MN_CALL_S_INCOMING) && (ccCtx->s0TimeInfo.s0TimerLen != 0) &&
            (ccCtx->s0TimeInfo.timerStart == TAF_FALSE)) {
            return AT_OK;
        }
        /* 设置了自动接听的情况下如果呼叫已经处于非incoming态，再触发ATA操作，返回error */
        else if ((ccCtx->s0TimeInfo.s0TimerLen != 0) && (ccCtx->s0TimeInfo.timerStart == TAF_FALSE)) {
            return AT_NO_CARRIER;
        }
        /* 呼叫已经是active状态再收到ata直接回复ok */
        else if (callInfos[tmp].callState == MN_CALL_S_ACTIVE) {
            return AT_OK;
        } else {
        }
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&supsCmdPara, sizeof(supsCmdPara), 0x00, sizeof(supsCmdPara));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    supsCmdPara.callSupsCmd = MN_CALL_SUPS_CMD_HOLD_ACT_ACPT_OTH;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&ctrl, &supsCmdPara, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(supsCmdPara), modemId) ==
        VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_A_SET;
        if (ccCtx->s0TimeInfo.timerStart == TAF_TRUE) {
            timerId = ccCtx->s0TimeInfo.timerName;

            AT_StopRelTimer(timerId, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_NO_CARRIER;
    }
}


LOCAL VOS_UINT32 At_HangupCall(VOS_UINT8 indexNum)
{
    AT_ModemCcCtx    *ccCtx = VOS_NULL_PTR;
    TAF_Ctrl          ctrl;
    MN_CALL_SupsParam supsCmdPara;
    ModemIdUint16     modemId;

    /* 获取ModemID */
    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        AT_LOG1("At_SetHPara AT_GetModemIdFromClient fail", indexNum);
        return AT_ERROR;
    }


    /* 获取CC上下文 */
    ccCtx = AT_GetModemCcCtxAddrFromModemId(modemId);

    /* 根据协议27007，如果CVHU设置为1时，不支持ATH挂断语音，所以在这里直接返回OK。如果CVHU为其他值，支持ATH挂断语音 */
    if (ccCtx->cvhuMode == CVHU_MODE_1) {
        AT_LOG1("At_SetHPara pstCcCtx->enCvhuMode", ccCtx->cvhuMode);
        return AT_OK;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&supsCmdPara, sizeof(supsCmdPara), 0x00, sizeof(supsCmdPara));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    supsCmdPara.callSupsCmd = MN_CALL_SUPS_CMD_REL_ALL_CALL;

    /* AT向CCM发送补充业务请求 */
    if (TAF_CCM_CallCommonReq(&ctrl, &supsCmdPara, ID_TAF_CCM_CALL_SUPS_CMD_REQ, sizeof(supsCmdPara), modemId) ==
        VOS_OK) {
        /* 停止自动接听 */
        if (ccCtx->s0TimeInfo.timerStart == VOS_TRUE) {
            AT_StopRelTimer(ccCtx->s0TimeInfo.timerName, &(ccCtx->s0TimeInfo.s0Timer));
            ccCtx->s0TimeInfo.timerStart = TAF_FALSE;
            ccCtx->s0TimeInfo.timerName  = 0;
        }

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_H_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)

VOS_UINT32 AT_CMUX_HangupCall(VOS_UINT8 indexNum)
{
    AT_ClientManage          *clientManage = VOS_NULL_PTR;
    VOS_UINT8                 dataId;
    DMS_PortModeUint8         mode;
    DMS_PortDataModeUint8     dataMode;

     if (AT_CheckCmuxUser(indexNum) == VOS_TRUE) {
        dataId       = g_atClientTab[indexNum].dataId;
        clientManage = AT_GetClientManage(dataId);
        mode         = DMS_PORT_GetMode(clientManage->portNo);
        dataMode     = DMS_PORT_GetDataMode(clientManage->portNo);

        if ((mode == DMS_PORT_MODE_ONLINE_CMD) || ((mode == DMS_PORT_MODE_ONLINE_DATA) &&
            (dataMode == DMS_PORT_DATA_PPP))) {
            (VOS_VOID)TAF_PS_CallEnd(WUEPS_PID_AT,
                                     g_atClientTab[dataId].clientId,
                                     0,
                                     g_atClientTab[dataId].cid);
            g_atClientTab[dataId].cmdCurrentOpt = AT_CMD_H_PS_SET;
            return  AT_WAIT_ASYNC_RETURN;
        }
    }

    return AT_OK;
}
#endif


VOS_UINT32 AT_ModemHangupCall(VOS_UINT8 indexNum)
{
    AT_ClientManage  *clientManage = VOS_NULL_PTR;

    VOS_UINT32        rslt;
    DMS_PortModeUint8 mode;

    clientManage = AT_GetClientManage(indexNum);
    mode         = DMS_PORT_GetMode(clientManage->portNo);

    /* ONLINE-COMMAND模式下, 需要断开PPP拨号连接 */
    if (mode == DMS_PORT_MODE_ONLINE_CMD) {
        /* 正在处理PPP断开请求, 直接继承, 设置命令操作类型为AT_CMD_H_PS_SET */
        if (clientManage->cmdCurrentOpt == AT_CMD_PS_DATA_CALL_END_SET) {
            AT_STOP_TIMER_CMD_READY(indexNum);
            clientManage->cmdCurrentOpt = AT_CMD_H_PS_SET;
            rslt                        = AT_WAIT_ASYNC_RETURN;
        }
        /* 正在等待PPP的释放响应, 直接释放, 返回OK */
        else if (clientManage->cmdCurrentOpt == AT_CMD_WAIT_PPP_PROTOCOL_REL_SET) {
            AT_STOP_TIMER_CMD_READY(indexNum);
            DMS_PORT_ResumeCmdMode(clientManage->portNo);
            At_FormatResultData(indexNum, AT_OK);

            if (DMS_PORT_IsDcdModeConnectOn() == VOS_TRUE) {
                DMS_PORT_DeassertDcd(clientManage->portNo);
            }

            rslt = AT_SUCCESS;
        } else {
            (VOS_VOID)TAF_PS_PPP_DIAL_DOWN(WUEPS_PID_AT, AT_PS_BuildExClientId(clientManage->clientId), 0,
                                     clientManage->cid);

            clientManage->cmdCurrentOpt = AT_CMD_H_PS_SET;
            rslt                        = AT_WAIT_ASYNC_RETURN;
        }
    } else if (mode == DMS_PORT_MODE_CMD) {
        return At_HangupCall(indexNum);
    } else {
#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
        return AT_CMUX_HangupCall(indexNum);
#endif
        rslt = AT_OK;
    }

    return rslt;
}


VOS_UINT32 At_SetHPara(VOS_UINT8 indexNum)
{
    /*
     * 对Modem口进行特殊处理: 收到ATH直接返回OK，
     * 即使Modem口发起过呼叫也不执行挂断操作
     */
    if ((g_atClientTab[indexNum].userType == AT_MODEM_USER) && (g_atClientTab[indexNum].used == AT_CLIENT_USED)) {
        return AT_OK;
    }

    /*
     * 增加通道模式判断:
     * (1) ONLINE-COMMAND模式 - 断开当前通道的PPP拨号连接
     * (2) COMMAND模式        - 直接返回OK
     */
    if (g_atClientTab[indexNum].userType == AT_HSUART_USER) {
        return AT_ModemHangupCall(indexNum);
    }

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
    if (AT_CheckCmuxUser(indexNum) == VOS_TRUE) {
        return AT_ModemHangupCall(indexNum);
    }
#endif

    return At_HangupCall(indexNum);
}
/*
 * Description: E[<value>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetEPara(TAF_UINT8 indexNum)
{
    if (g_atParaList[0].paraLen != 0) {
        g_atEType = (AT_CMD_ECHO_TYPE)g_atParaList[0].paraValue;
    } else {
        g_atEType = AT_E_ECHO_CMD;
    }
    return AT_OK;
}

TAF_UINT32 At_SetVPara(TAF_UINT8 indexNum)
{
    if (g_atParaList[0].paraLen != 0) {
        g_atVType = (AT_V_TYPE)g_atParaList[0].paraValue;
    } else {
        g_atVType = AT_V_ENTIRE_TYPE;
    }
    return AT_OK;
}
/*
 * Description: T
 * History:
 *  1.Date: 2009-05-27
 *    Modification: Created function
 */
TAF_UINT32 At_SetTPara(TAF_UINT8 indexNum)
{
    /* This commands will have no effect in our code */
    return AT_OK;
}
/*
 * Description: P
 * History:
 *  1.Date: 2009-05-27
 *    Modification: Created function
 */
TAF_UINT32 At_SetPPara(TAF_UINT8 indexNum)
{
    /* This commands will have no effect in our code */
    return AT_OK;
}

TAF_UINT32 At_SetXPara(TAF_UINT8 indexNum)
{
    if (g_atParaList[0].paraLen != 0) {
        g_atXType = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        g_atXType = 0;
    }
    return AT_OK;
}

TAF_UINT32 At_SetZPara(TAF_UINT8 indexNum)
{
    TAF_AT_Tz tz;
    VOS_CHAR  acTzStr[AT_SETZ_LEN + 1];

    VOS_UINT16 length;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
    errno_t    memResult;

    systemAppConfig = AT_GetSystemAppConfigAddr();

#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)
    /*if ATZ was sent from CMUX port, just return OK*/
    if (AT_CheckCmuxUser(indexNum) == VOS_TRUE) {
        return AT_OK;
    }
#endif

    (VOS_VOID)memset_s(&tz, sizeof(tz), 0x00, sizeof(tz));

    if (*systemAppConfig == SYSTEM_APP_WEBUI) {
        if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_ATSETZ_RET_VALUE, &tz, AT_SETZ_LEN) == NV_OK) {
            memResult = memcpy_s(acTzStr, sizeof(acTzStr), tz.tz, AT_SETZ_LEN);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(acTzStr), AT_SETZ_LEN);
            acTzStr[AT_SETZ_LEN] = 0;
            if (VOS_StrLen(acTzStr) > 0) {
                length = 0;
                length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                    (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);
                length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                    (VOS_CHAR *)g_atSndCodeAddress + length, "%s", acTzStr);
                length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                    (VOS_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);

                At_SendResultData((VOS_UINT8)indexNum, g_atSndCodeAddress, length);

                return AT_SUCCESS;
            }
        }
    }

    return AT_OK;
}
/*
 * Description: Q[value]
 * History:
 *  1.Date: 2009-08-06
 *    Modification: Created function
 */
TAF_UINT32 At_SetQPara(TAF_UINT8 indexNum)
{
    if (g_atParaList[0].paraLen != 0) {
        g_atQType = (AT_CMD_ECHO_TYPE)g_atParaList[0].paraValue;
    } else {
        g_atQType = 0;
    }
    return AT_OK;
}


VOS_UINT32 At_SetAmpCPara(VOS_UINT8 indexNum)
{
    DMS_PortIdUint16            portId;
    DMS_PortUartDcdModeUint8    dcdMode;
    DMS_PortModeUint8           portMode;

    portId   = AT_GetDmsPortIdByClientId((AT_ClientIdUint16)indexNum);
    portMode = DMS_PORT_GetMode(portId);

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(indexNum) != VOS_TRUE) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen != 0) {
        if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        dcdMode = (DMS_PortUartDcdModeUint8)g_atParaList[0].paraValue;
    } else {
        /* AT&C 等效于 AT&C1 */
        dcdMode = DMS_PORT_UART_DEFAULT_DCD_MODE;
    }

    /* 保存DCD Line Mode至上下文 */
    DMS_PORT_SetDcdMode(dcdMode);

    /* DCD管脚操作 */
    if (DMS_PORT_IsDcdModeConnectOn() == VOS_FALSE) {
        DMS_PORT_AssertDcd(portId);
    } else {
        if (portMode == DMS_PORT_MODE_CMD) {
            DMS_PORT_DeassertDcd(portId);
        }
    }

    return AT_OK;
}


VOS_UINT32 At_SetAmpDPara(VOS_UINT8 indexNum)
{
    DMS_PortUartDtrModeUint8    dtrMode;

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(indexNum) != VOS_TRUE) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen != 0) {
        dtrMode = (DMS_PortUartDtrModeUint8)g_atParaList[0].paraValue;
    } else {
        /* AT&D 等效于 AT&D2 */
        dtrMode = DMS_PORT_UART_DEFAULT_DTR_MODE;
    }

    /* 保存DTR Line Mode至上下文 */
    DMS_PORT_SetDtrMode(dtrMode);

    return AT_OK;
}

#if (FEATURE_AT_HSUART == FEATURE_ON)

VOS_UINT32 At_SetAmpSPara(VOS_UINT8 indexNum)
{
    DMS_PortUartDsrModeUint8    dsrMode;
    DMS_PortIdUint16            portId;

    portId   = AT_GetDmsPortIdByClientId((AT_ClientIdUint16)indexNum);

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(indexNum) != VOS_TRUE) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen != 0) {
        dsrMode = (DMS_PortUartDsrModeUint8)g_atParaList[0].paraValue;
    } else {
        /* AT&S 等效于 AT&S0 */
        dsrMode = DMS_PORT_UART_DEFAULT_DSR_MODE;
    }

    /* 保存DSR Line Mode至上下文 */
    DMS_PORT_SetDsrMode(dsrMode);

    /* 设置DSR 管脚信号 */
    if (DMS_PORT_IsDsrModeConnectOn() == VOS_FALSE) {
        DMS_PORT_AssertDsr(portId);
    } else {
        DMS_PORT_DeassertDsr(portId);
    }

    return AT_OK;
}
#endif


VOS_UINT32 AT_SetLPara(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_SetMPara(VOS_UINT8 indexNum)
{
    return AT_OK;
}


TAF_UINT32 At_SetS0Para(TAF_UINT8 indexNum)
{
    TAF_CCA_TelePara timeInfo;
    AT_ModemCcCtx   *ccCtx = VOS_NULL_PTR;
    ModemIdUint16    modemId;
    VOS_UINT32       rslt;

    modemId = MODEM_ID_0;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 删除通道数传模式标识存在直接返回OK的处理 */

    rslt = AT_GetModemIdFromClient(indexNum, &modemId);

    if (rslt != VOS_OK) {
        AT_ERR_LOG("At_SetS0Para: Get modem id fail.");
        return AT_ERROR;
    }

    ccCtx = AT_GetModemCcCtxAddrFromModemId(modemId);

    ccCtx->s0TimeInfo.s0TimerLen = (TAF_UINT8)g_atParaList[0].paraValue;
    ccCtx->s0TimeInfo.clientId   = g_atClientTab[indexNum].clientId;

    (VOS_VOID)memset_s(&timeInfo, sizeof(timeInfo), 0x00, sizeof(timeInfo));

    if (TAF_ACORE_NV_READ(modemId, NV_ITEM_CCA_TELE_PARA, &timeInfo, sizeof(TAF_CCA_TelePara)) == NV_OK) {
        if (timeInfo.s0TimerLen == ccCtx->s0TimeInfo.s0TimerLen) {
            AT_INFO_LOG("At_SetS0Para():The content to write is same as NV's");
            return AT_OK;
        }
    }
    timeInfo.s0TimerLen = ccCtx->s0TimeInfo.s0TimerLen;
    if (TAF_ACORE_NV_WRITE(modemId, NV_ITEM_CCA_TELE_PARA, (VOS_UINT8 *)&timeInfo, sizeof(TAF_CCA_TelePara)) != NV_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}
/*
 * Description: S3=[<value>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetS3Para(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        g_atS3 = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        g_atS3 = 13;  /* 命令行结束符，默认值为13 */
    }
    g_atCrLf[0] = g_atS3;
    return AT_OK;
}
/*
 * Description: S4=[<value>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetS4Para(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        g_atS4 = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        g_atS4 = 10;  /* 命令行换行符，默认值为10 */
    }
    g_atCrLf[1] = g_atS4;
    return AT_OK;
}
/*
 * Description: S5=[<value>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetS5Para(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        g_atS5 = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        g_atS5 = 8; /* 命令行退格符，默认值为8 */
    }
    return AT_OK;
}
/*
 * Description: S6=[<value>]
 * History:
 *  1.Date: 2009-05-27
 *    Modification: Created function
 */
TAF_UINT32 At_SetS6Para(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 0) {
        g_atS6 = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        /*
         * refer to V.250:
         * Recommended default setting
         * 2 Wait two seconds before blind dialling
         */
        g_atS6 = 2;
    }
    return AT_OK;
}
/*
 * Description: S7=[<value>]
 * History:
 *  1.Date: 2009-05-27
 *    Modification: Created function
 */
TAF_UINT32 At_SetS7Para(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * refer to V.250:
     * S7:Number of seconds in which connection must be established or call will be disconnected
     */
    if (g_atParaList[0].paraLen != 0) {
        g_atS7 = (TAF_UINT8)g_atParaList[0].paraValue;
    } else {
        /* 默认值填写为50 */
        g_atS7 = 50;
    }
    return AT_OK;
}


VOS_VOID AT_SetDefaultRatPrioList(ModemIdUint16 modemId, TAF_MMA_MultimodeRatCfg *sysCfgRatOrder,
                                  VOS_UINT8 userSptLteFlag, VOS_UINT8 userSptNrFlag)
{
    VOS_UINT8 userRatNum;

    userRatNum = 0;

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    /* 当前命令是否支持NR */
    if (userSptNrFlag == VOS_TRUE) {
        /* 平台支持NR */
        if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_NR) == VOS_TRUE) {
            sysCfgRatOrder->ratOrder[userRatNum] = TAF_MMA_RAT_NR;

            userRatNum++;
        }
    }
#endif

#if (FEATURE_LTE == FEATURE_ON)
    /* 当前命令是否支持LTE */
    if (userSptLteFlag == VOS_TRUE) {
        /* 平台支持LTE */
        if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_LTE) == VOS_TRUE) {
            sysCfgRatOrder->ratOrder[userRatNum] = TAF_MMA_RAT_LTE;

            userRatNum++;
        }
    }
#endif

    /* 平台支持WCDMA */
    if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_WCDMA) == VOS_TRUE) {
        sysCfgRatOrder->ratOrder[userRatNum] = TAF_MMA_RAT_WCDMA;

        userRatNum++;
    }

    /* 平台支持GSM */
    if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_GSM) == VOS_TRUE) {
        sysCfgRatOrder->ratOrder[userRatNum] = TAF_MMA_RAT_GSM;

        userRatNum++;
    }

    sysCfgRatOrder->ratNum = userRatNum;

    return;
}


AT_SYSCFG_RatPrioUint8 AT_GetGuAccessPrioNvim(ModemIdUint16 modemId)
{
    NAS_MMA_NvimAccessMode accessMode;
    AT_SYSCFG_RatPrioUint8 acqorder;

    (VOS_VOID)memset_s(&accessMode, sizeof(accessMode), 0x00, sizeof(NAS_MMA_NvimAccessMode));

    if (NV_OK != TAF_ACORE_NV_READ(modemId, NV_ITEM_MMA_ACCESS_MODE, &accessMode, sizeof(NAS_MMA_NvimAccessMode))) {
        return AT_SYSCFG_RAT_PRIO_AUTO;
    }

    acqorder = accessMode.accessMode[1];
    return acqorder;
}


VOS_UINT32 AT_IsSupportGMode(TAF_MMA_MultimodeRatCfg *ratOrder)
{
    VOS_UINT32 i;

    for (i = 0; i < ratOrder->ratNum; i++) {
        if (ratOrder->ratOrder[i] == TAF_MMA_RAT_GSM) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_IsSupport1XMode(TAF_MMA_MultimodeRatCfg *ratOrder)
{
    VOS_UINT32 i;
    for (i = 0; i < ratOrder->ratNum; i++) {
        if (ratOrder->ratOrder[i] == TAF_MMA_RAT_1X) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_IsSupportHrpdMode(TAF_MMA_MultimodeRatCfg *ratOrder)
{
    VOS_UINT32 i;

    for (i = 0; i < ratOrder->ratNum; i++) {
        if (ratOrder->ratOrder[i] == TAF_MMA_RAT_HRPD) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}
#endif


LOCAL VOS_UINT32 AT_IsSpecRatSupported(TAF_MMA_RatTypeUint8 ratMode, TAF_MMA_MultimodeRatCfg *ratOrder)
{
    VOS_UINT32 i;

    ratOrder->ratNum = AT_MIN(ratOrder->ratNum, TAF_MMA_RAT_BUTT);
    for (i = 0; i < ratOrder->ratNum; i++) {
        if (ratMode == ratOrder->ratOrder[i]) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_IsSupportWMode(TAF_MMA_MultimodeRatCfg *ratOrder)
{
    VOS_UINT32 i;

    for (i = 0; i < ratOrder->ratNum; i++) {
        if (ratOrder->ratOrder[i] == TAF_MMA_RAT_WCDMA) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_ConvertCpamRatOrderPara(VOS_UINT8 clientId, MN_MMA_CpamRatTypeUint8 mode,
                                      MN_MMA_CpamRatPrioUint8 acqorder, TAF_MMA_SysCfgPara *sysCfgSetPara,
                                      AT_SYSCFG_RatPrioUint8 *syscfgRatPrio)
{
    TAF_MMA_MultimodeRatCfg *ratOrder = VOS_NULL_PTR;
    AT_SYSCFG_RatPrioUint8   nvimRatPrio;
    ModemIdUint16            modemId;
    VOS_UINT32               rst;

    modemId  = MODEM_ID_0;
    ratOrder = &(sysCfgSetPara->multiModeRatCfg);

    rst = AT_GetModemIdFromClient(clientId, &modemId);
    if (rst != VOS_OK) {
        AT_ERR_LOG1("AT_ConvertCpamRatOrderPara:Get ModemID From ClientID fail,ClientID=%d", clientId);
        return AT_ERROR;
    }

    /* 如果接入优先级不改变则默认从NVIM中获取 */
    /* 由于NVIM中的接入优先级和CPAM的设置的不一样需要转化一下 */
    if (acqorder == MN_MMA_CPAM_RAT_PRIO_NO_CHANGE) {
        nvimRatPrio = AT_GetGuAccessPrioNvim(modemId);
        *syscfgRatPrio = nvimRatPrio;
    } else if (acqorder == MN_MMA_CPAM_RAT_PRIO_GSM) {
        *syscfgRatPrio = AT_SYSCFG_RAT_PRIO_GSM;
    } else {
        *syscfgRatPrio = AT_SYSCFG_RAT_PRIO_WCDMA;
    }

    switch (mode) {
        case MN_MMA_CPAM_RAT_TYPE_WCDMA_GSM:
            if (*syscfgRatPrio == AT_SYSCFG_RAT_PRIO_GSM) {
                /* GSM优先 */
                ratOrder->ratNum      = TAF_PH_MAX_GU_RAT_NUM;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_GSM;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_WCDMA;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;
            } else {
                /* WCDMA优先 */
                ratOrder->ratNum      = TAF_PH_MAX_GU_RAT_NUM;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_WCDMA;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_GSM;
                ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;
            }

            break;

        case MN_MMA_CPAM_RAT_TYPE_GSM:
            /* G单模 */
            ratOrder->ratNum      = 1;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_GSM;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;
            break;

        case MN_MMA_CPAM_RAT_TYPE_WCDMA:
            /* W单模 */
            ratOrder->ratNum      = 1;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_WCDMA;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            ratOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;
            break;

        case MN_MMA_CPAM_RAT_TYPE_NOCHANGE:
            ratOrder->ratNum                  = 0;
            sysCfgSetPara->ratCfgNoChangeType = TAF_MMA_RAT_NO_CHANGE_CMD_CPAM;

            break;

        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetCpamPara(VOS_UINT8 indexNum)
{
    TAF_MMA_SysCfgPara sysCfgSetPara;

    VOS_UINT32      rst;
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    (VOS_VOID)memset_s(&sysCfgSetPara, sizeof(sysCfgSetPara), 0x00, sizeof(TAF_MMA_SysCfgPara));

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    rst = AT_OK;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CPAM_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        g_atParaList[0].paraValue = MN_MMA_CPAM_RAT_TYPE_NOCHANGE;
    }

    if (g_atParaList[1].paraLen == 0) {
        g_atParaList[1].paraValue = MN_MMA_CPAM_RAT_PRIO_NO_CHANGE;
    }

    rst = AT_ConvertCpamRatOrderPara(indexNum, (VOS_UINT8)g_atParaList[0].paraValue,
                                     (VOS_UINT8)g_atParaList[1].paraValue, &sysCfgSetPara, &sysCfgSetPara.userPrio);

    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* stSysCfgSetPara其他参数赋值 */
    if (netCtx->roamFeature == AT_ROAM_FEATURE_ON) {
        sysCfgSetPara.roam = TAF_MMA_ROAM_UNCHANGE;
    } else {
        sysCfgSetPara.roam = AT_ROAM_FEATURE_OFF_NOCHANGE;
    }
    sysCfgSetPara.srvDomain       = TAF_MMA_SERVICE_DOMAIN_NOCHANGE;
    sysCfgSetPara.guBand.bandLow  = TAF_PH_BAND_NO_CHANGE;
    sysCfgSetPara.guBand.bandHigh = 0;
    (VOS_VOID)memset_s(&(sysCfgSetPara.lBand), sizeof(sysCfgSetPara.lBand), 0x00, sizeof(TAF_USER_SetLtePrefBandInfo));
    sysCfgSetPara.lBand.bandInfo[0] = TAF_PH_BAND_NO_CHANGE;

    /* 执行命令操作 */
    if (TAF_MMA_SetSysCfgReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &sysCfgSetPara) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPAM_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif


TAF_UINT32 At_SetStsfPara(TAF_UINT8 indexNum)
{
    USIMM_StkCfg  profileContent;
    TAF_UINT32    result;
    errno_t       memResult;
    TAF_UINT16    len = sizeof(USIMM_StkCfg);
    ModemIdUint16 modemId;

    if (g_atParaList[0].paraLen != 1) { /* check the para */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_STSF_PARA_MAX_NUM) { /* para too many */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    result = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_TERMINALPROFILE_SET, &profileContent, len);

    if (result != NV_OK) {
        return AT_ERROR;
    }

    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* change the string to Ascii value */
    profileContent.funcEnable = (TAF_UINT8)g_atParaList[0].para[0] - 0x30;

    if (g_atParaList[1].paraLen != 0x00) { /* have the <config> para */
        /* change the string formate */
        if (At_AsciiNum2HexString(g_atParaList[1].para, &g_atParaList[1].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* according the etsi102.223,the most len or Terminal Profile is 32 */
        if (g_atParaList[AT_STSF_CONFIG].paraLen > AT_STSF_CONFIG_LENGTH_MAX) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (AT_GetUsimInfoCtxFromModemId(modemId)->cardType == TAF_MMA_USIMM_CARD_USIM) {
            profileContent.usimProfile.profileLen = (TAF_UINT8)g_atParaList[1].paraLen;

            memResult = memcpy_s(profileContent.usimProfile.profile,
                                 (VOS_SIZE_T)sizeof(profileContent.usimProfile.profile), g_atParaList[1].para,
                                 profileContent.usimProfile.profileLen);
            TAF_MEM_CHK_RTN_VAL(memResult, (VOS_SIZE_T)sizeof(profileContent.usimProfile.profile),
                                profileContent.usimProfile.profileLen);
        } else {
            profileContent.simProfile.profileLen = (TAF_UINT8)g_atParaList[1].paraLen;

            memResult = memcpy_s(profileContent.simProfile.profile,
                                 (VOS_SIZE_T)sizeof(profileContent.simProfile.profile), g_atParaList[1].para,
                                 profileContent.simProfile.profileLen);
            TAF_MEM_CHK_RTN_VAL(memResult, (VOS_SIZE_T)sizeof(profileContent.simProfile.profile),
                                profileContent.simProfile.profileLen);
        }
    }

    if (g_atParaList[AT_STSF_TIMEOUT].paraLen != 0x00) { /* ave the <Timer>  para */
        result = At_Auc2ul(g_atParaList[AT_STSF_TIMEOUT].para, g_atParaList[AT_STSF_TIMEOUT].paraLen,
                           &g_atParaList[AT_STSF_TIMEOUT].paraValue);
        if (result != AT_SUCCESS) {
            AT_WARN_LOG("At_SetStsfPara():Warning: At_Auc2ul convert failed!");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        if ((g_atParaList[AT_STSF_TIMEOUT].paraValue > 0xFF) || (g_atParaList[AT_STSF_TIMEOUT].paraValue == 0)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        profileContent.timer = (TAF_UINT8)g_atParaList[AT_STSF_TIMEOUT].paraValue;
    }

    result = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_TERMINALPROFILE_SET, (VOS_UINT8 *)&profileContent, len);

    if (result != NV_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}

/*
 * Description: chang the cmdNo to cmdType
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_ChangeSATCmdType(TAF_UINT32 cmdNo, TAF_UINT32 *cmdType)
{
    TAF_UINT32 result = AT_SUCCESS;

    switch (cmdNo) {
        case SI_AT_CMD_DISPLAY_TEXT:
            *cmdType = SI_STK_DISPLAYTET;
            break;
        case SI_AT_CMD_GET_INKEY:
            *cmdType = SI_STK_GETINKEY;
            break;
        case SI_AT_CMD_GET_INPUT:
            *cmdType = SI_STK_GETINPUT;
            break;
        case SI_AT_CMD_SETUP_CALL:
            *cmdType = SI_STK_SETUPCALL;
            break;
        case SI_AT_CMD_PLAY_TONE:
            *cmdType = SI_STK_PLAYTONE;
            break;
        case SI_AT_CMD_SELECT_ITEM:
            *cmdType = SI_STK_SELECTITEM;
            break;
        case SI_AT_CMD_REFRESH:
            *cmdType = SI_STK_REFRESH;
            break;
        case SI_AT_CMD_SEND_SS:
            *cmdType = SI_STK_SENDSS;
            break;
        case SI_AT_CMD_SEND_SMS:
            *cmdType = SI_STK_SENDSMS;
            break;
        case SI_AT_CMD_SEND_USSD:
            *cmdType = SI_STK_SENDUSSD;
            break;
        case SI_AT_CMD_LAUNCH_BROWSER:
            *cmdType = SI_STK_LAUNCHBROWSER;
            break;
        case SI_AT_CMD_SETUP_IDLE_MODE_TEXT:
            *cmdType = SI_STK_SETUPIDLETEXT;
            break;
        case SI_AT_CMD_LANGUAGENOTIFICATION:
            *cmdType = SI_STK_LANGUAGENOTIFICATION;
            break;
        case SI_AT_CMD_SETFRAMES:
            *cmdType = SI_STK_SETFRAMES;
            break;
        case SI_AT_CMD_GETFRAMESSTATUS:
            *cmdType = SI_STK_GETFRAMESSTATUS;
            break;
        default:
            result = AT_ERROR;
            break;
    }

    return result;
}

#if ((FEATURE_PHONE_USIM == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))
/*
 * Description: ^STGI
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetStgiPara(TAF_UINT8 indexNum)
{
    TAF_UINT32 result;
    TAF_UINT32 cmdType;

    if (g_stkFunctionFlag == TAF_FALSE) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraLen == 0) { /* check the para */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex != 2) { /* the para number is must be 2 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue > 0x0C) { /* the <cmdType> is not more the 12 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 0x00) { /* get the main menu content */
        result = SI_STK_GetMainMenu(g_atClientTab[indexNum].clientId, 0);
    } else if (At_ChangeSATCmdType(g_atParaList[0].paraValue, &cmdType) == AT_ERROR) { /* get other SAT content */
        return AT_ERROR;
    } else {
        result = SI_STK_GetSTKCommand(g_atClientTab[indexNum].clientId, 0, cmdType);
    }

    if (result == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_STGI_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 At_SetClvlPara(VOS_UINT8 indexNum)
{
    const VOS_UINT8 intraVolume[] = {
        AT_CMD_CLVL_LEV_0, AT_CMD_CLVL_LEV_1, AT_CMD_CLVL_LEV_2, AT_CMD_CLVL_LEV_3, AT_CMD_CLVL_LEV_4, AT_CMD_CLVL_LEV_5
    };

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者错误 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * 这里做了一个转换，目前后台要求的范围是0~5，而我们对应的范围是0~92，
     * 根据和媒体的确认，设定范围是0~80，线性对应
     */

    /* 返回值为AT_SUCCESS改为VOS_OK，对应起来  */
    if (APP_VC_SetVoiceVolume(g_atClientTab[indexNum].clientId, 0, intraVolume[g_atParaList[0].paraValue]) == VOS_OK) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLVL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetVMSETPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 voiceMode;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    voiceMode = (VOS_UINT8)g_atParaList[0].paraValue;

#if (MULTI_MODEM_NUMBER >= 2)
    if (APP_VC_SetVoiceMode(g_atClientTab[indexNum].clientId, 0, voiceMode, I1_WUEPS_PID_VC) != VOS_OK) {
        return AT_ERROR;
    }

#if (MULTI_MODEM_NUMBER == 3)
    if (APP_VC_SetVoiceMode(g_atClientTab[indexNum].clientId, 0, voiceMode, I2_WUEPS_PID_VC) != VOS_OK) {
        return AT_ERROR;
    }
#endif
#endif

    if (APP_VC_SetVoiceMode(g_atClientTab[indexNum].clientId, 0, voiceMode, I0_WUEPS_PID_VC) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VMSET_SET;

    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
/*
 * Description: +TEST=[<n>]
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetTestPara(TAF_UINT8 indexNum)
{
    return AT_OK;
}

/* For WAS AutoTest */

TAF_UINT32 At_SetCwasPara(TAF_UINT8 indexNum)
{
    AT_MTA_WrrAutotestQryPara atCmd;
    VOS_UINT32                rst;

    /* 参数过多 */
    if ((g_atParaIndex > AT_CWAS_PARA_MAX_NUM) || (g_atParaIndex < AT_CWAS_PARA_MIN_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(AT_MTA_WrrAutotestQryPara));
    atCmd.cmd = (TAF_UINT8)g_atParaList[0].paraValue;

    for (atCmd.paraNum = 0; atCmd.paraNum < (g_atParaIndex - 1); atCmd.paraNum++) {
        atCmd.para[atCmd.paraNum] = g_atParaList[atCmd.paraNum + 1].paraValue;
    }

    /* 发送消息给C核处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_WRR_AUTOTEST_QRY_REQ,
                                 (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_WrrAutotestQryPara), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CWAS_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCGasPara(TAF_UINT8 indexNum)
{
    GAS_AT_CmdPara atCmd;
    VOS_UINT32     rst;

    /* 参数过多 */
    if ((g_atParaIndex > AT_CGAS_PARA_MAX_NUM) || (g_atParaIndex < AT_CGAS_PARA_MIN_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数长度等于0 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }


    (VOS_VOID)memset_s(&atCmd, sizeof(GAS_AT_CmdPara), 0x00, sizeof(GAS_AT_CmdPara));

    /* 获取命令参数 */
    atCmd.cmd = (TAF_UINT8)g_atParaList[0].paraValue;
    for (atCmd.paraNum = 0; atCmd.paraNum < (g_atParaIndex - 1); atCmd.paraNum++) {
        atCmd.para[atCmd.paraNum] = g_atParaList[atCmd.paraNum + 1].paraValue;
    }

    /* 发送消息给C核处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_GAS_AUTOTEST_QRY_REQ,
                                 (VOS_UINT8 *)&atCmd, sizeof(GAS_AT_CmdPara), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CGAS_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif

VOS_UINT32 At_SetAppDialModePara(VOS_UINT8 indexNum)
{
    VOS_UINT32 status;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;

    systemAppConfig = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (*systemAppConfig != SYSTEM_APP_WEBUI) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    } else {
        if (g_atParaList[0].paraValue == 1) {
            /* 调用底软接口通知应用进行拨号 */
            status = AT_USB_ENABLE_EVENT;
        } else if (g_atParaList[0].paraValue == 0) {
            /* 调用底软接口通知应用进行断开拨号 */
            status = AT_USB_SUSPEND_EVENT;
        } else {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    DRV_AT_SETAPPDAILMODE(status);

    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

TAF_UINT32 At_SetCmmPara(TAF_UINT8 indexNum)
{
    MM_TEST_AtCmdPara atCmd;

    /* 参数过多 */
    if (g_atParaIndex > AT_CMM_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(MM_TEST_AtCmdPara));

    atCmd.cmd = (TAF_UINT8)g_atParaList[0].paraValue;
    for (atCmd.paraNum = 0; atCmd.paraNum < (g_atParaIndex - 1); atCmd.paraNum++) {
        atCmd.para[atCmd.paraNum] = g_atParaList[atCmd.paraNum + 1].paraValue;
    }

    if (TAF_MMA_SetCmmReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &atCmd) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MM_TEST_CMD_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif

VOS_VOID AT_ShowCccRst(NAS_CC_StateInfo *ccState, VOS_UINT16 *length)
{
    VOS_UINT16 lengthTemp;

    lengthTemp = *length;

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%d,", ccState->callId);

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%d,", ccState->ti);

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%d,", ccState->callState);

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%d,", ccState->holdAuxState);

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%d", ccState->mptyAuxState);

    lengthTemp += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + lengthTemp, "%s", g_atCrLf);

    *length = lengthTemp;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetCccPara(TAF_UINT8 indexNum)
{
    VOS_UINT8  callId;
    VOS_UINT32 rst;

    if ((g_atParaIndex > AT_CCC_PARA_MAX_NUM) || (g_atParaIndex == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 0) {
        callId = 0; /* 0表示查询所有call Id */
    } else {
        /* g_atParaList[1].ulParaValue取值无则填取默认值,获取CallId = 1的呼叫状态 */
        if (g_atParaList[1].paraLen == 0) {
            callId = 1;
        } else {
            callId = (VOS_UINT8)g_atParaList[1].paraValue;
        }
    }

    /* 发送消息AT_CC_MSG_STATE_QRY_REQ给CC获取CC协议状态 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, AT_CC_MSG_STATE_QRY_REQ, &callId,
                                 sizeof(VOS_UINT8), I0_WUEPS_PID_CC);

    if (rst == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CC_STATE_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif


TAF_UINT32 At_SetSPNPara(TAF_UINT8 indexNum)
{
    VOS_UINT8       spnType;
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值错误 */
    spnType = (TAF_UINT8)g_atParaList[0].paraValue;
    if (spnType > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 记录AT^SPN查询的SPN类型 */
    netCtx->spnType = spnType;

    /* 给MMA发送消息，查询新参数类型TAF_PH_SPN_VALUE_PARA */
    if (TAF_MMA_QrySpnReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SPN_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCardModePara(TAF_UINT8 indexNum)
{
    TAF_UINT8        cardMode = 0; /* 0: card not exists, 1: SIM card, 2: USIM card */
    TAF_UINT16       length   = 0;
    ModemIdUint16    modemId;
    VOS_UINT32       getModemIdRslt;
    AT_USIM_InfoCtx *usimInfoCtx = VOS_NULL_PTR;

    modemId = MODEM_ID_0;

    /* 参数过多 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    getModemIdRslt = AT_GetModemIdFromClient(indexNum, &modemId);

    if (getModemIdRslt != VOS_OK) {
        AT_ERR_LOG("At_SetCardModePara:Get Modem Id fail!");
        return AT_ERROR;
    }

    usimInfoCtx = AT_GetUsimInfoCtxFromModemId(modemId);

    if (usimInfoCtx->cardStatus == USIMM_CARDAPP_SERVIC_BUTT) {
        AT_ERR_LOG("At_SetCardModePara:Sim card status butt!");
        return AT_CME_SIM_BUSY;
    }

    /* 获取卡模式 */
    if (usimInfoCtx->cardStatus != USIMM_CARDAPP_SERVIC_ABSENT) {
        if (usimInfoCtx->cardType == TAF_MMA_USIMM_CARD_SIM) {
            cardMode = AT_CARDMODE_SIM_TYPE_SIM;
        } else if (usimInfoCtx->cardType == TAF_MMA_USIMM_CARD_USIM) {
            cardMode = AT_CARDMODE_SIM_TYPE_USIM;
        } else {
            cardMode = AT_CARDMODE_SIM_TYPE_NULL_CARD;
        }
    } else {
        cardMode = AT_CARDMODE_SIM_TYPE_NULL_CARD;
    }

    /* 输出结果: ^CARDMODE:cardmode */
    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + length, "%s:", g_parseContext[indexNum].cmdElement->cmdName);

    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + length, "%d", cardMode);

    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


TAF_UINT32 At_SetDialModePara(TAF_UINT8 indexNum)
{
    /* 根据终端对该命令的要求，设置命令均返回ERROR */
    return AT_ERROR;
}


TAF_UINT32 At_SetCurcPara(TAF_UINT8 indexNum)
{
    AT_MTA_CurcSetNotify atCmd;
    VOS_UINT32           result;
    errno_t              memResult;

#if (FEATURE_LTE == FEATURE_ON)
    L4A_IND_Cfg   l4AIndCfgReq;
    ModemIdUint16 modemId;

    modemId = MODEM_ID_0;

    AT_PR_LOGI("Rcv Msg");
#endif

    /* 参数检查 */
    if ((g_atParaIndex > AT_CURC_PARA_MAX_NUM) || (g_atParaIndex < AT_CURC_PARA_MIN_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.curcRptType = (AT_MTA_RptGeneralCtrlTypeUint8 )g_atParaList[AT_CURC_MODE].paraValue;

    /* mode=0时，禁止所有的主动上报 */
    if (g_atParaList[AT_CURC_MODE].paraValue == 0) {
        (VOS_VOID)memset_s(g_atParaList[AT_CURC_REPORT_CFG].para, sizeof(g_atParaList[AT_CURC_REPORT_CFG].para), 0x00,
                 sizeof(g_atParaList[AT_CURC_REPORT_CFG].para));
    } else if (g_atParaList[AT_CURC_MODE].paraValue == 1) {
        /* mode=1时，打开所有的主动上报 */
        (VOS_VOID)memset_s(g_atParaList[AT_CURC_REPORT_CFG].para, sizeof(g_atParaList[AT_CURC_REPORT_CFG].para), 0xFF,
                 sizeof(g_atParaList[AT_CURC_REPORT_CFG].para));
    }
    else if (g_atParaList[AT_CURC_MODE].paraValue == AT_CURC_MODE_VAILD_VALUE) {
        /* mode=2时，按BIT位控制对应的主动上报,自定义配置主动上报命令需要<report_cfg>参数 */
        if ((g_atParaIndex != AT_CURC_PARA_MAX_NUM) ||
            (g_atParaList[AT_CURC_REPORT_CFG].paraLen != AT_CURC_RPT_CFG_PARA_LEN)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        result = At_AsciiNum2HexString(g_atParaList[AT_CURC_REPORT_CFG].para,
                                       &g_atParaList[AT_CURC_REPORT_CFG].paraLen);

        AT_PR_LOGI("Call interface success!");
        if (result != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memResult = memcpy_s(atCmd.rptCfg, sizeof(atCmd.rptCfg), g_atParaList[AT_CURC_REPORT_CFG].para,
                         (AT_CURC_RPT_CFG_MAX_SIZE));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(atCmd.rptCfg), (AT_CURC_RPT_CFG_MAX_SIZE));

    /* 通知MTA此次curc的设置 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_CURC_SET_NOTIFY, (VOS_UINT8 *)&atCmd,
                                    sizeof(AT_MTA_CurcSetNotify), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

#if (FEATURE_LTE == FEATURE_ON)
    result = AT_GetModemIdFromClient(indexNum, &modemId);

    if (result != VOS_OK) {
        AT_ERR_LOG1("At_SetCurcPara:Get ModemID From ClientID fail,ClientID=%d", indexNum);
        return AT_ERROR;
    }

    if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_LTE) == VOS_TRUE) {
        /* 平台能力支持LTE */
        (VOS_VOID)memset_s(&l4AIndCfgReq, sizeof(l4AIndCfgReq), 0x00, sizeof(l4AIndCfgReq));
        l4AIndCfgReq.curcBitValid = 1;
        memResult = memcpy_s(l4AIndCfgReq.curcCfgReq, sizeof(l4AIndCfgReq.curcCfgReq), g_atParaList[1].para,
                             sizeof(l4AIndCfgReq.curcCfgReq));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(l4AIndCfgReq.curcCfgReq), sizeof(l4AIndCfgReq.curcCfgReq));

        /* 通知L此次curc的设置 */
        return AT_SetLIndCfgReq(indexNum, &l4AIndCfgReq);
    } else {
        return AT_OK;
    }
#else
    return AT_OK;
#endif
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

TAF_UINT32 At_SetBOOTPara(TAF_UINT8 indexNum)
{
    /* 参数过多 */
    if (g_atParaIndex > AT_BOOT_PARA_NUM) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数过少 */
    if (g_atParaIndex < AT_BOOT_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数取值检查, para2必须为 0 */
    if ((g_atParaList[1].paraLen != 1) || (g_atParaList[1].para[0] != '0')) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 假命令，直接返回OK. */
    return AT_OK;
}
#endif


TAF_UINT32 At_SetCellInfoPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 atCmdCellInfo;
    VOS_UINT32 rst;

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    atCmdCellInfo = g_atParaList[0].paraValue;

    /* 发送消息ID_AT_MTA_WRR_CELLINFO_QRY_REQ到C核AT AGENT处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_WRR_CELLINFO_QRY_REQ,
                                 (VOS_UINT8 *)&atCmdCellInfo, sizeof(VOS_UINT32), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CELLINFO_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

TAF_UINT32 At_DelWCellEntity(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数过多 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_DEL_CELLENTITY_REQ, VOS_NULL_PTR, 0,
                                 I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DEL_CELLENTITY_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_GetMeanRpt(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    /* 参数过多 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息ID_AT_MTA_WRR_MEANRPT_QRY_REQ给AT AGENT处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_WRR_MEANRPT_QRY_REQ, VOS_NULL_PTR, 0,
                                 I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MEANRPT_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
/* For Was AutoTest */


TAF_UINT32 At_SetRRCVersion(TAF_UINT8 indexNum)
{
    VOS_UINT8  rRCVersion;
    VOS_UINT32 rst;

    /* 参数过多返回参数错误 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rRCVersion = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送消息DRV_AGENT_RRC_VERSION_SET_REQ给AT代理处理 */

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_WRR_RRC_VERSION_SET_REQ, &rRCVersion,
                                 sizeof(VOS_UINT8), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_RRC_VERSION_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif

TAF_UINT32 At_SetCSNR(TAF_UINT8 indexNum)
{
    /* 参数过多 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

TAF_UINT32 At_SetFreqLock(TAF_UINT8 indexNum)
{
    MTA_AT_WrrFreqlockCtrl freqLock;
    VOS_UINT32             rst;

    /* 参数个数不正确则返回参数错误 */
    if ((g_atParaIndex != AT_BOOT_VAILD_PARA_NUM1) && (g_atParaIndex != AT_BOOT_VAILD_PARA_NUM2)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * 如果第一个参数是锁频,但第二个参数频率值没有设置或
     * 设置的值无效则返回错误
     */
    if ((g_atParaList[0].paraValue == 1) && (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息赋值 */
    (VOS_VOID)memset_s(&freqLock, sizeof(freqLock), 0x00, sizeof(MTA_AT_WrrFreqlockCtrl));
    freqLock.freqLockEnable = (VOS_UINT8)g_atParaList[0].paraValue;
    freqLock.lockedFreq     = (VOS_UINT16)g_atParaList[1].paraValue;

    /* 发送消息 ID_AT_MTA_WRR_FREQLOCK_SET_REQ 给C核 AT 代理处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_WRR_FREQLOCK_SET_REQ,
                                 (VOS_UINT8 *)&freqLock, sizeof(MTA_AT_WrrFreqlockCtrl), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_FREQLOCK_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif
#if (FEATURE_PROBE_FREQLOCK == FEATURE_ON)

VOS_UINT32 AT_CheckM2MFreqLockPara(VOS_UINT8 clientId)
{
    /* <enable>参数为0时，参数个数应该为1 */
    if (g_atParaList[0].paraValue == 0) {
        if (g_atParaIndex == 1) {
            return AT_SUCCESS;
        } else {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* <enable>参数为1时，设置命令参数个数应该为6 */
    if ((g_atParaList[AT_FREQLOCK_ENABLE].paraValue == AT_FREQLOCK_ENABLE_VAILD_VALUE) &&
        (g_atParaIndex != AT_FREQLOCK_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 转换<MODE>参数为无符号整型 */
    if (At_Auc2ul(g_atParaList[1].para, g_atParaList[1].paraLen, &g_atParaList[1].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <mode>参数为字符串类型，取值为"01"--"04"，长度为2位 */
    if ((g_atParaList[AT_FREQLOCK_FREQ].paraLen != AT_FREQLOCK_FREQ_VAILD_LEN) ||
        ((g_atParaList[AT_FREQLOCK_FREQ].paraValue < AT_MTA_M2M_FREQLOCK_MODE_GSM) ||
         (g_atParaList[AT_FREQLOCK_FREQ].paraValue > AT_MTA_M2M_FREQLOCK_MODE_LTE))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <Band>参数仅在GSM制式下有效 */
    if (g_atParaList[1].paraValue == AT_MTA_M2M_FREQLOCK_MODE_GSM) {
        /* <band>参数为字符串类型，取值为"00"--"03"，长度为2位 */
        if (g_atParaList[AT_FREQLOCK_BAND].paraLen != AT_FREQLOCK_BAND_VAILD_LEN) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* <band>参数为字符串类型，带双引号,字符串长度为4 */
        if (At_Auc2ul(g_atParaList[AT_FREQLOCK_BAND].para, g_atParaList[AT_FREQLOCK_BAND].paraLen,
                      &g_atParaList[AT_FREQLOCK_BAND].paraValue) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_FREQLOCK_BAND].paraValue > AT_MTA_GSM_BAND_1900) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* GSM有效频点范围: 0-1023 */
        if (g_atParaList[AT_FREQLOCK_MODE].paraValue > AT_FREQLOCK_GSMMAX) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        /* 非GSM制式下，<Band>参数须为空 */
        if (g_atParaList[AT_FREQLOCK_BAND].paraLen != 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* <PSC>参数仅在WCDMA、TDS-CDMA制式下有效 */
    if ((g_atParaList[AT_FREQLOCK_PSC].paraLen != 0) &&
        ((g_atParaList[AT_FREQLOCK_FREQ].paraValue != AT_MTA_M2M_FREQLOCK_MODE_WCDMA) &&
         (g_atParaList[AT_FREQLOCK_FREQ].paraValue != AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PCI>参数仅在LTE制式下有效 */
    if ((g_atParaList[AT_FREQLOCK_PCI].paraLen != 0) &&
        (g_atParaList[AT_FREQLOCK_FREQ].paraValue != AT_MTA_M2M_FREQLOCK_MODE_LTE)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_GetM2MFreqLockPara(VOS_UINT8 clientId, AT_MTA_SetM2MFreqlockReq *freqLockInfo)
{
    if (g_atParaList[0].paraValue == 0) {
        /* 锁频功能关闭 */
        freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_OFF;
        return AT_SUCCESS;
    } else {
        /* GSM模式时，<band>参数为必选项，第5个参数无意义；WCDMA模式时，<band>参数无意义，根据<psc>是否为空，区分W锁频类型:锁频、锁频+扰码 */
        switch (g_atParaList[1].paraValue) {
            case AT_MTA_M2M_FREQLOCK_MODE_GSM:
                if (g_atParaList[AT_FREQLOCK_BAND].paraLen == 0) {
                    return AT_CME_INCORRECT_PARAMETERS;
                } else {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_GSM;
                    /* <freq>频点参数 */
                    freqLockInfo->gFreqPara.freq = (VOS_UINT16)g_atParaList[AT_FREQLOCK_MODE].paraValue;
                    /* <band>频段参数 */
                    freqLockInfo->gFreqPara.band = (VOS_UINT16)g_atParaList[AT_FREQLOCK_BAND].paraValue;
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_WCDMA:
                if (g_atParaList[AT_FREQLOCK_PSC].paraLen == 0) {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_WCDMA;
                    /* FREQ_ONLY类型 */
                    freqLockInfo->wFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;
                    /* <freq>频点参数 */
                    freqLockInfo->wFreqPara.freq = (VOS_UINT16)g_atParaList[AT_FREQLOCK_MODE].paraValue;
                } else {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_WCDMA;
                    /* FREQ + PSC类型 */
                    freqLockInfo->wFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;
                    /* <freq>频点参数 */
                    freqLockInfo->wFreqPara.freq = (VOS_UINT16)g_atParaList[AT_FREQLOCK_MODE].paraValue;
                    /* 主扰码参数 */
                    freqLockInfo->wFreqPara.psc = (VOS_UINT16)g_atParaList[AT_FREQLOCK_PSC].paraValue;
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA:
                if (g_atParaList[AT_FREQLOCK_PSC].paraLen == 0) {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA;
                    /* FREQ_ONLY类型 */
                    freqLockInfo->tdFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;
                    /* <freq>频点参数 */
                    freqLockInfo->tdFreqPara.freq = (VOS_UINT16)g_atParaList[AT_FREQLOCK_MODE].paraValue;
                } else {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_TDSCDMA;
                    /* FREQ + SC类型 */
                    freqLockInfo->tdFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;
                    /* <freq>频点参数 */
                    freqLockInfo->tdFreqPara.freq = (VOS_UINT16)g_atParaList[AT_FREQLOCK_MODE].paraValue;
                    /* 主扰码参数 */
                    freqLockInfo->tdFreqPara.sc = (VOS_UINT16)g_atParaList[AT_FREQLOCK_PSC].paraValue;
                }
                break;

            case AT_MTA_M2M_FREQLOCK_MODE_LTE:
                if (g_atParaList[AT_FREQLOCK_PCI].paraLen == 0) {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_LTE;
                    /* FREQ_ONLY类型 */
                    freqLockInfo->lFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_ONLY;
                    /* <freq>频点参数 */
                    freqLockInfo->lFreqPara.freq = g_atParaList[AT_FREQLOCK_MODE].paraValue;
                } else {
                    freqLockInfo->enableFlag = AT_MTA_M2M_FREQLOCK_FLAG_TYPE_ON;
                    freqLockInfo->mode       = AT_MTA_M2M_FREQLOCK_MODE_LTE;
                    /* FREQ + PCI类型 */
                    freqLockInfo->lFreqPara.freqType = AT_MTA_M2M_FREQLOCK_TYPE_ENUM_FREQ_COMBINED;
                    /* <freq>频点参数 */
                    freqLockInfo->lFreqPara.freq = g_atParaList[AT_FREQLOCK_MODE].paraValue;
                    /* 物理小区ID参数 */
                    freqLockInfo->lFreqPara.pci = (VOS_UINT16)g_atParaList[AT_FREQLOCK_PCI].paraValue;
                }
                break;

            default:
                return AT_CME_INCORRECT_PARAMETERS;
        }

        return AT_SUCCESS;
    }
}


TAF_UINT32 At_SetM2MFreqLock(TAF_UINT8 indexNum)
{
    AT_MTA_SetM2MFreqlockReq freqLockInfo;

    VOS_UINT32 rst;

    /* 初始化 */
    (VOS_VOID)memset_s(&freqLockInfo, sizeof(freqLockInfo), 0x00, sizeof(AT_MTA_SetM2MFreqlockReq));

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数有效性检查 */
    rst = AT_CheckM2MFreqLockPara(indexNum);

    if (rst != AT_SUCCESS) {
        return rst;
    }

    /* 获取用户锁频配置信息 */
    rst = AT_GetM2MFreqLockPara(indexNum, &freqLockInfo);

    if (rst != AT_SUCCESS) {
        return rst;
    }

    /* 发送消息 ID_AT_MTA_FREQLOCK_SET_REQ 给C核 AT 代理处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_SET_M2M_FREQLOCK_REQ,
                                 (VOS_UINT8 *)&freqLockInfo, sizeof(AT_MTA_SetM2MFreqlockReq), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_M2M_FREQLOCK_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif /* MBB_WPG_FREQLOCK == FEATURE_ON */


TAF_UINT32 At_SetParaCmd(TAF_UINT8 indexNum)
{
    AT_RreturnCodeUint32 result = AT_FAILURE;

    /*
     * vts这样的命令需要注意，它在参数表中的参数定义为TAF_NULL_PTR，而实际设置参数时，取出设置的参数
     * 而对于其它无参数命令，需要判断，如果有效参数个数不为0，则返回错误
     */

    if (g_parseContext[indexNum].cmdElement->setProc != TAF_NULL_PTR) {
        result = (AT_RreturnCodeUint32)g_parseContext[indexNum].cmdElement->setProc(indexNum);

        if (result == AT_WAIT_ASYNC_RETURN) {
            g_parseContext[indexNum].clientStatus = AT_FW_CLIENT_STATUS_PEND;

            /* 开定时器 */
            if (At_StartTimer(g_parseContext[indexNum].cmdElement->setTimeOut, indexNum) != AT_SUCCESS) {
                AT_ERR_LOG("At_SetParaCmd:ERROR:Start Timer");
                return AT_ERROR;
            }
        }
        return result;
    } else {
        return AT_ERROR;
    }
}

#if ((FEATURE_PHONE_USIM == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))
TAF_UINT32 At_StgrSelMenu(TAF_UINT8 indexNum)
{
    SI_STK_MenuSelection *menu = VOS_NULL_PTR;
    SI_STK_Envelope       eNStru;
    VOS_UINT32            rslt;

    /* 参数过多 */
    if (g_atParaIndex > AT_STGR_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    eNStru.envelopeType  = SI_STK_ENVELOPE_MENUSEL;
    eNStru.deviceId.sdId = SI_DEVICE_KEYPAD;
    eNStru.deviceId.ddId = SI_DEVICE_UICC;

    menu = &eNStru.envelope.menuSelect;
    (VOS_VOID)memset_s(menu, sizeof(SI_STK_MenuSelection), 0x00, sizeof(SI_STK_MenuSelection));

    if (g_atParaList[AT_STGR_RESULT].paraValue == SI_AT_RESULT_HELP_REQUIRED) {
        menu->opHelp      = 1;
        menu->help.rsv[0] = 1;
    }

    /* select item */
    if (g_atParaList[AT_STGR_DATA].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    } else {
        rslt = At_Auc2ul(g_atParaList[AT_STGR_DATA].para, g_atParaList[AT_STGR_DATA].paraLen,
                         &g_atParaList[AT_STGR_DATA].paraValue);
        if (rslt != AT_SUCCESS) {
            AT_WARN_LOG("At_StgiSelectItem():Warning: At_Auc2ul convert failed!");
            return AT_ERROR;
        }

        menu->opItemIp      = 1;
        menu->itemId.itemId = (TAF_UINT8)g_atParaList[AT_STGR_DATA].paraValue;
    }

    /* 执行命令操作 */
    if (SI_STK_MenuSelectionFunc(g_atClientTab[indexNum].clientId, 0, &eNStru) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_STGR_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR; /* 返回命令处理挂起状态 */
    }
}
#endif

/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_ChangeCmdResult(TAF_UINT32 resultNo, TAF_UINT8 *cmdResult)
{
    TAF_UINT32 result;

    result = AT_SUCCESS;

    switch (resultNo) {
        case SI_AT_RESULT_END_SESSION:
            *cmdResult = PROACTIVE_UICC_SESSION_TERMINATED_BY_THE_USER;
            break;
        case SI_AT_RESULT_PERFORM_SUCC:
            *cmdResult = COMMAND_PERFORMED_SUCCESSFULLY;
            break;
        case SI_AT_RESULT_HELP_REQUIRED:
            *cmdResult = HELP_INFORMATION_REQUIRED_BY_USER;
            break;
        case SI_AT_RESULT_BACKWARD_MOVE:
            *cmdResult = BACKWARD_MOVE_IN_THE_PROACTIVE_UICC_SESSION_REQUESTED_BY_USER;
            break;
        case SI_AT_RESULT_ME_NOT_SUPPORT:
            *cmdResult = COMMAND_BEYOND_TERMINALS_CAPABILITIES;
            break;
        case SI_AT_RESULT_ME_BROWSER_BUSY:
            *cmdResult = TERMINAL_CURRENTLY_UNABLE_TO_PROCESS_COMMAND;
            break;
        case SI_AT_RESULT_ME_SS_BUSY:
            *cmdResult = TERMINAL_CURRENTLY_UNABLE_TO_PROCESS_COMMAND;
            break;
        default:
            result = AT_ERROR;
    }

    return result;
}

/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
#if (FEATURE_IOT_ATNLPROXY == FEATURE_ON)
TAF_UINT32 At_StgiGetKey(TAF_UINT8 indexNum, SI_STK_TerminalRsp *rsp)
{
    TAF_UINT8  cmdResult;
    TAF_UINT8 *inputKey;
    errno_t    memResult;
    TAF_UINT8  atStkCmdQualify = AT_GetStkCmdQualify();

    inputKey = (TAF_UINT8 *)VOS_MemAlloc(WUEPS_PID_AT, DYNAMIC_MEM_PT, AT_PARA_MAX_LEN + 1);

    if (inputKey == NULL) {
        AT_NORM_LOG("At_StgiGetKey: Fail to malloc mem.");
        return AT_ERROR;
    }

    if (At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &cmdResult) == AT_ERROR) {
        VOS_MemFree(WUEPS_PID_AT, inputKey);
        return AT_ERROR;
    }

    rsp->result.result = cmdResult;

    if (cmdResult == COMMAND_PERFORMED_SUCCESSFULLY) {
        if ((g_atParaIndex != AT_STGR_PARA_MAX_NUM) ||
            (((AT_PARA_MAX_LEN + 1) <= g_atParaList[AT_STGR_DATA].paraLen) ||
            (g_atParaList[AT_STGR_DATA].paraLen < AT_STGR_DATA_VALID_LENGTH))) {
            AT_WARN_LOG("At_StgiGetKey: 4th para error!");
            VOS_MemFree(WUEPS_PID_AT, inputKey);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 专有参数 */
        rsp->uResp.getInkeyRsp.textStr.text = rsp->data;

        (VOS_VOID)memset_s(inputKey, AT_PARA_MAX_LEN + 1, 0x00, AT_PARA_MAX_LEN + 1);
        memResult = memcpy_s(inputKey, AT_PARA_MAX_LEN + 1, g_atParaList[AT_STGR_DATA].para,
                             g_atParaList[AT_STGR_DATA].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_PARA_MAX_LEN + 1, g_atParaList[AT_STGR_DATA].paraLen);

        /*
         * 由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，
         * 解析时需要将引号去除，长度减2
         */
        if (At_AsciiString2HexText(&rsp->uResp.getInkeyRsp.textStr, inputKey + 1,
                                   g_atParaList[AT_STGR_DATA].paraLen - AT_DOUBLE_QUOTATION_MARKS_LENGTH) ==
            AT_FAILURE) {
            VOS_MemFree(WUEPS_PID_AT, inputKey);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        rsp->uResp.getInkeyRsp.opTextStr = 1;

        if ((atStkCmdQualify & 0x02) == 0x00) {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x04;
        } else {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x08;
        }

        if ((atStkCmdQualify & 0x04) == 0x04) {
            *rsp->uResp.getInkeyRsp.textStr.text -= 0x30;
        }
    }

    VOS_MemFree(WUEPS_PID_AT, inputKey);
    return AT_SUCCESS;
}

TAF_UINT32 At_StgiGetInput(TAF_UINT8 indexNum, SI_STK_TerminalRsp *rsp)
{
    errno_t    memResult;
    TAF_UINT8  cmdResult;
    TAF_UINT8 *inputString;
    VOS_UINT32 length;
    TAF_UINT8  atStkCmdQualify = AT_GetStkCmdQualify();

    inputString = (TAF_UINT8 *)VOS_MemAlloc(WUEPS_PID_AT, DYNAMIC_MEM_PT, AT_PARA_MAX_LEN + 1);

    if (NULL == inputString) {
        AT_NORM_LOG("At_StgiGetInput: Fail to malloc mem.");
        return AT_ERROR;
    }
    (VOS_VOID)memset_s(inputString, AT_PARA_MAX_LEN + 1, 0x00, AT_PARA_MAX_LEN + 1);

    length = AT_PARA_MAX_LEN + 1;

    if (At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &cmdResult) == AT_ERROR) {
    VOS_MemFree(WUEPS_PID_AT, inputString);
        return AT_ERROR;
    }

    rsp->result.result = cmdResult;

    if (cmdResult == COMMAND_PERFORMED_SUCCESSFULLY) {
        /* 专有参数 */
        if (g_atParaList[AT_STGR_DATA].paraLen < 0x03) {
            rsp->uResp.getInkeyRsp.textStr.text = TAF_NULL_PTR;

            rsp->uResp.getInkeyRsp.textStr.len = 0;
        }
        else if (length > g_atParaList[AT_STGR_DATA].paraLen) {
            rsp->uResp.getInkeyRsp.textStr.text = rsp->data;

            (VOS_VOID)memset_s(inputString, AT_PARA_MAX_LEN + 1, 0x00, AT_PARA_MAX_LEN + 1);
            memResult = memcpy_s(inputString, AT_PARA_MAX_LEN + 1, g_atParaList[AT_STGR_DATA].para,
                                 g_atParaList[AT_STGR_DATA].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, AT_PARA_MAX_LEN + 1, g_atParaList[AT_STGR_DATA].paraLen);

            /* 由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，解析时需要将引号去除，长度减2 */
            if (At_AsciiString2HexText(&rsp->uResp.getInputRsp.textStr, inputString + 1,
                                       g_atParaList[AT_STGR_DATA].paraLen - AT_DOUBLE_QUOTATION_MARKS_LENGTH) ==
                                       AT_FAILURE) {
                VOS_MemFree(WUEPS_PID_AT, inputString);
                return AT_CME_INCORRECT_PARAMETERS;
            }
        } else {
            AT_WARN_LOG1("At_StgiGetInput: 4th para error!", g_atParaList[AT_STGR_DATA].paraLen);
            VOS_MemFree(WUEPS_PID_AT, inputString);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        rsp->uResp.getInputRsp.opTextStr = 1;

        if ((atStkCmdQualify & 0x02) == 0x00) {
            if ((atStkCmdQualify & 0x08) == 0x00) {
                rsp->uResp.getInkeyRsp.textStr.dcs = 0x04;
            } else {
                rsp->uResp.getInkeyRsp.textStr.dcs = 0x00;
            }
        } else {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x08;
        }
    }

    VOS_MemFree(WUEPS_PID_AT, inputString);
    return AT_SUCCESS;
}
#else
TAF_UINT32 At_StgiGetKey(TAF_UINT8 indexNum, SI_STK_TerminalRsp *rsp)
{
    TAF_UINT8 cmdResult;
    TAF_UINT8 inputKey[AT_PARA_MAX_LEN + 1];
    errno_t   memResult;
    TAF_UINT8 atStkCmdQualify = AT_GetStkCmdQualify();

    if (At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &cmdResult) == AT_ERROR) {
        return AT_ERROR;
    }

    rsp->result.result = cmdResult;

    if (cmdResult == COMMAND_PERFORMED_SUCCESSFULLY) {
        if ((g_atParaIndex != AT_STGR_PARA_MAX_NUM) ||
            (((VOS_SIZE_T)sizeof(inputKey) <= g_atParaList[AT_STGR_DATA].paraLen) ||
            (g_atParaList[AT_STGR_DATA].paraLen < AT_STGR_DATA_VALID_LENGTH))) {
            AT_WARN_LOG("At_StgiGetKey: 4th para error!");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 专有参数 */
        rsp->uResp.getInkeyRsp.textStr.text = rsp->data;

        (VOS_VOID)memset_s(inputKey, sizeof(inputKey), 0x00, sizeof(inputKey));
        memResult = memcpy_s(inputKey, sizeof(inputKey), g_atParaList[AT_STGR_DATA].para,
                             g_atParaList[AT_STGR_DATA].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(inputKey), g_atParaList[AT_STGR_DATA].paraLen);

        /*
         * 由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，
         * 解析时需要将引号去除，长度减2
         */
        if (At_AsciiString2HexText(&rsp->uResp.getInkeyRsp.textStr, inputKey + 1,
                                   g_atParaList[AT_STGR_DATA].paraLen - AT_DOUBLE_QUOTATION_MARKS_LENGTH) ==
            AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        rsp->uResp.getInkeyRsp.opTextStr = 1;

        if ((atStkCmdQualify & 0x02) == 0x00) {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x04;
        } else {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x08;
        }

        if ((atStkCmdQualify & 0x04) == 0x04) {
            *rsp->uResp.getInkeyRsp.textStr.text -= 0x30;
        }
    }

    return AT_SUCCESS;
}
/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_StgiGetInput(TAF_UINT8 indexNum, SI_STK_TerminalRsp *rsp)
{
    errno_t   memResult;
    TAF_UINT8 cmdResult;
    TAF_UINT8 inputString[AT_PARA_MAX_LEN + 1];
    VOS_UINT32 length;
    TAF_UINT8  atStkCmdQualify = AT_GetStkCmdQualify();

    length = (VOS_SIZE_T)sizeof(inputString);

    if (At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &cmdResult) == AT_ERROR) {
        return AT_ERROR;
    }

    rsp->result.result = cmdResult;

    if (cmdResult == COMMAND_PERFORMED_SUCCESSFULLY) {
        /* 专有参数 */
        if (g_atParaList[AT_STGR_DATA].paraLen < 0x03) {
            rsp->uResp.getInkeyRsp.textStr.text = TAF_NULL_PTR;

            rsp->uResp.getInkeyRsp.textStr.len = 0;
        }
        else if (length > g_atParaList[AT_STGR_DATA].paraLen) {
            rsp->uResp.getInkeyRsp.textStr.text = rsp->data;

            (VOS_VOID)memset_s(inputString, sizeof(inputString), 0x00, sizeof(inputString));
            memResult = memcpy_s(inputString, sizeof(inputString), g_atParaList[AT_STGR_DATA].para,
                                 g_atParaList[AT_STGR_DATA].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(inputString), g_atParaList[AT_STGR_DATA].paraLen);

            /* 由于第四个参数是变参的，AT词法解析器无法解析，必须在代码中自行解析处理，解析时需要将引号去除，长度减2 */
            if (At_AsciiString2HexText(&rsp->uResp.getInputRsp.textStr, inputString + 1,
                                       g_atParaList[AT_STGR_DATA].paraLen - AT_DOUBLE_QUOTATION_MARKS_LENGTH) ==
                                       AT_FAILURE) {
                return AT_CME_INCORRECT_PARAMETERS;
            }
        } else {
            AT_WARN_LOG1("At_StgiGetInput: 4th para error!", g_atParaList[AT_STGR_DATA].paraLen);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        rsp->uResp.getInputRsp.opTextStr = 1;

        if ((atStkCmdQualify & 0x02) == 0x00) {
            if ((atStkCmdQualify & 0x08) == 0x00) {
                rsp->uResp.getInkeyRsp.textStr.dcs = 0x04;
            } else {
                rsp->uResp.getInkeyRsp.textStr.dcs = 0x00;
            }
        } else {
            rsp->uResp.getInkeyRsp.textStr.dcs = 0x08;
        }
    }

    return AT_SUCCESS;
}
#endif


TAF_UINT32 At_StgiSelectItem(TAF_UINT8 indexNum, SI_STK_TerminalRsp *rsp)
{
    TAF_UINT8  cmdResult;
    VOS_UINT32 rslt;

    if (At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &cmdResult) == AT_ERROR) {
        return AT_ERROR;
    }

    rsp->result.result = cmdResult;

    if (cmdResult == COMMAND_PERFORMED_SUCCESSFULLY) {
        rslt = At_Auc2ul(g_atParaList[AT_STGR_DATA].para, g_atParaList[AT_STGR_DATA].paraLen,
                         &g_atParaList[AT_STGR_DATA].paraValue);
        if (rslt != AT_SUCCESS) {
            AT_WARN_LOG("At_StgiSelectItem():Warning: At_Auc2ul convert failed!");
            return AT_ERROR;
        }

        /* 专有参数 */
        rsp->uResp.selectItemRsp.itemId.itemId = (TAF_UINT8)g_atParaList[AT_STGR_DATA].paraValue;
        rsp->uResp.selectItemRsp.opItemID      = 1;
    }

    return AT_SUCCESS;
}

#if ((FEATURE_PHONE_USIM == FEATURE_OFF) || (defined(DMT)) || (defined(__PC_UT__)))
/*
 * Description: ^STGR=<cmdnum>,<cmdtype>,<result>,<data>
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetStgrPara(TAF_UINT8 indexNum)
{
    SI_STK_TerminalRsp rsponse;
    TAF_UINT32         result = 0;

#if (VOS_WIN32 != VOS_OS_VER)
    if (g_stkFunctionFlag == TAF_FALSE) {
        return AT_ERROR;
    }
#endif

    if ((g_atParaIndex > AT_STGR_MAX_VALID_NUM) || (g_atParaIndex < AT_STGR_MIN_VALID_NUM)) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the para1 and para2 is must be inputed */
    if ((g_atParaList[AT_STGR_CMD_TYPE].paraLen == 0) || (g_atParaList[AT_STGR_CMD_NUM].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rsponse.deviceId.sdId = SI_DEVICE_KEYPAD;
    rsponse.deviceId.ddId = SI_DEVICE_UICC;

    if (g_atParaList[AT_STGR_CMD_TYPE].paraValue == 0x00) {
        /* menu selection or need the help infomation */
        if ((g_atParaList[AT_STGR_RESULT].paraValue == AT_STGR_MENU_SELECTION) ||
            (g_atParaList[AT_STGR_RESULT].paraValue == AT_STGR_NEED_HELP_INFORMATION)) {
            return At_StgrSelMenu(indexNum);
        } else {
            return AT_OK;
        }
    }

    (VOS_VOID)memset_s(&rsponse, sizeof(rsponse), 0x00, sizeof(SI_STK_TerminalRsp));

    if (g_atParaList[AT_STGR_CMD_TYPE].paraValue == SI_AT_CMD_END_SESSION) {
        rsponse.result.result = PROACTIVE_UICC_SESSION_TERMINATED_BY_THE_USER;
    } else if (At_ChangeSATCmdType(g_atParaList[AT_STGR_CMD_TYPE].paraValue, &rsponse.cmdType) != AT_SUCCESS) {
        return AT_ERROR;
    } else {
    }

    switch (g_atParaList[0].paraValue) {
        case SI_AT_CMD_GET_INKEY:
            result = At_StgiGetKey(indexNum, &rsponse); /* change the GetInkey response content */
            break;
        case SI_AT_CMD_GET_INPUT:
            result = At_StgiGetInput(indexNum, &rsponse); /* change the GetInput response content */
            break;
        case SI_AT_CMD_SELECT_ITEM:
            result = At_StgiSelectItem(indexNum, &rsponse); /* change the SelectItem response content */
            break;
        default:
            result = At_ChangeCmdResult(g_atParaList[AT_STGR_RESULT].paraValue, &rsponse.result.result);
            break;
    }

    if (result != AT_SUCCESS) {
        return result; /* return the error */
    }

    if (SI_STK_TerminalResponse(g_atClientTab[indexNum].clientId, 0, &rsponse) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_STGR_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif

/*
 * Description: ^STGR=<Len>,<data>
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCstrPara(TAF_UINT8 indexNum)
{
    VOS_UINT8  data[AT_DATA_MAX_LEN];
    VOS_UINT8  dataLen;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    VOS_UINT8 tmpSystemAppConfig;
#endif

#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    AT_SetSystemAppConfig((VOS_UINT16)indexNum, &tmpSystemAppConfig);
    systemAppConfig = &tmpSystemAppConfig;
#else
    systemAppConfig = AT_GetSystemAppConfigAddr();
#endif

    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_ERROR;
    }
    if (g_atParaIndex != AT_STGR_VALID_NUM) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the para1 and para2 is must be inputed */
    if ((g_atParaList[AT_CSTR_LEN].paraLen == 0) || (g_atParaList[AT_CSTR_CMD_DATE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the value of para1 and the len of para2 must be equal */
    if (g_atParaList[AT_CSTR_LEN].paraValue != g_atParaList[AT_CSTR_CMD_DATE].paraLen) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiString2HexSimple(data, g_atParaList[AT_CSTR_CMD_DATE].para,
        (VOS_UINT16)g_atParaList[AT_CSTR_LEN].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    dataLen = (TAF_UINT8)(g_atParaList[AT_CSTR_LEN].paraValue / 2);

    if (SI_STK_DataSendSimple(g_atClientTab[indexNum].clientId, 0, SI_STK_TRSEND, dataLen, data) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSTR_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: ^CSIN命令处理函数
 * History:
 *  1.Date: 2012-05-17
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCsinPara(TAF_UINT8 indexNum)
{
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    VOS_UINT8 tmpSystemAppConfig;
#endif

#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    AT_SetSystemAppConfig((VOS_UINT16)indexNum, &tmpSystemAppConfig);
    systemAppConfig = &tmpSystemAppConfig;
#else
    systemAppConfig = AT_GetSystemAppConfigAddr();
#endif

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 非ANDROID系统不支持 */
    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_ERROR;
    }

    /* 获取最后一次收到的主动命令，不将命令类型传入 */
    if (SI_STK_GetSTKCommand(g_atClientTab[indexNum].clientId, 0, 0) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: ^STGR=<Len>,<data>
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCsenPara(TAF_UINT8 indexNum)
{
    VOS_UINT8  data[AT_DATA_MAX_LEN];
    VOS_UINT8  dataLen;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    VOS_UINT8 tmpSystemAppConfig;
#endif

#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    AT_SetSystemAppConfig((VOS_UINT16)indexNum, &tmpSystemAppConfig);
    systemAppConfig = &tmpSystemAppConfig;
#else
    systemAppConfig = AT_GetSystemAppConfigAddr();
#endif

    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_ERROR;
    }

    if (g_atParaIndex != AT_STGR_VALID_NUM) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the para1 and para2 is must be inputed */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* the value of para1 and the len of para2 must be equal */
    if (g_atParaList[0].paraValue != g_atParaList[1].paraLen) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiString2HexSimple(data, g_atParaList[1].para, (VOS_UINT16)g_atParaList[0].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    dataLen = (TAF_UINT8)(g_atParaList[AT_CSEN_LEN].paraValue / 2);

    if (SI_STK_DataSendSimple(g_atClientTab[indexNum].clientId, 0, SI_STK_ENVELOPESEND, dataLen, data) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

/*
 * Description: ^CSMN
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCsmnPara(TAF_UINT8 indexNum)
{
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    VOS_UINT8 tmpSystemAppConfig;
#endif

#if (FEATURE_MBB_CUST == FEATURE_ON) && (FEATURE_PHONE_USIM == FEATURE_OFF)
    AT_SetSystemAppConfig((VOS_UINT16)indexNum, &tmpSystemAppConfig);
    systemAppConfig = &tmpSystemAppConfig;
#else
    systemAppConfig = AT_GetSystemAppConfigAddr();
#endif

    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_ERROR;
    }

    if (g_atParaIndex != 0) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STK_GetMainMenu(g_atClientTab[indexNum].clientId, 0) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSEN_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCstcPara(TAF_UINT8 indexNum)
{
    if (g_atParaIndex != 1) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STK_SetUpCallConfirm(g_atClientTab[indexNum].clientId, g_atParaList[0].paraValue) == AT_SUCCESS) {
        return AT_OK;
    }

    return AT_ERROR;
}

/*
 * Description: ^STGR=<cmdnum>,<cmdtype>,<result>,<data>
 * History:
 *  1.Date: 2010-02-11
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetImsichgPara(TAF_UINT8 indexNum)
{
    if (SI_STKIsDualImsiSupport() == VOS_FALSE) {
        return AT_CMD_NOT_SUPPORT;
    }

    if (g_atParaIndex != 1) { /* the para munber is too many or too few */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) { /* the para1 must be inputed */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (SI_STKDualIMSIChangeReq(g_atClientTab[indexNum].clientId, 0) == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IMSICHG_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_PhyNumIsNull(ModemIdUint16 modemId, AT_PhynumTypeUint32 setType, VOS_BOOL *pbPhyNumIsNull)
{
    VOS_UINT32   ret;
    VOS_UINT32   loop;
    VOS_UINT32   totalNum;
    IMEI_STRU    imei;
    TAF_SVN_Data svnData;
    VOS_UINT8   *checkNum = VOS_NULL_PTR;
    VOS_UINT8    mac[AT_PHYNUM_MAC_LEN + 1]; /* MAC地址 */

    (VOS_VOID)memset_s(&svnData, sizeof(svnData), 0x00, sizeof(svnData));

    /* 从获取NV中IMEI或SVN物理号，获取操作失败，则返回AT_ERROR */
    if (setType == AT_PHYNUM_TYPE_IMEI) {
        ret = TAF_ACORE_NV_READ(modemId, en_NV_Item_IMEI, &imei, NV_ITEM_IMEI_SIZE);
        if (ret != NV_OK) {
            AT_WARN_LOG("AT_PhyNumIsNull: Fail to read en_NV_Item_IMEI");
            return AT_ERROR;
        }

        /* NV项en_NV_Item_IMEI中仅15位是UE的IMEI号，最后一位是无效位不作比较 */
        totalNum = TAF_IMEI_DATA_LENGTH;
        checkNum = imei.aucImei;
    }
    else if (setType == AT_PHYNUM_TYPE_SVN) {
        ret = TAF_ACORE_NV_READ(modemId, NV_ITEM_IMEI_SVN, &svnData, sizeof(svnData));
        if (ret != NV_OK) {
            AT_WARN_LOG("AT_PhyNumIsNull: Fail to read en_Nv_Item_Imei_Svn");
            return AT_ERROR;
        }

        /* SVN未激活按物理号为空处理 */
        if (svnData.activeFlag != NV_ITEM_ACTIVE) {
            *pbPhyNumIsNull = VOS_TRUE;
            return AT_OK;
        }

        totalNum = TAF_SVN_DATA_LENGTH;
        checkNum = svnData.svn;
    } else if (setType == AT_PHYNUM_TYPE_MAC) {
        /* 输出当前MAC地址是否为空状态 */
        AT_GetPhynumMac(mac, AT_PHYNUM_MAC_LEN + 1);
        totalNum = AT_PHYNUM_MAC_LEN;
        checkNum = mac;
    } else {
        AT_WARN_LOG("AT_PhyNumIsNull: the type of physical is error.");
        return AT_ERROR;
    }

    /* NV中IMEI或SVN物理号为全0认为物理号为空；否则，非空 */
    for (loop = 0; loop < totalNum; loop++) {
        if (*checkNum != 0) {
            *pbPhyNumIsNull = VOS_FALSE;
            return AT_OK;
        }

        checkNum++;
    }

    *pbPhyNumIsNull = VOS_TRUE;

    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_UpdateImei(ModemIdUint16 modemId, VOS_UINT8 aucImei[], VOS_UINT16 imeiLength)
{
    VOS_UINT8  bcdNum[TAF_PH_IMEI_LEN];
    VOS_UINT8  checkData;
    VOS_UINT32 i;

    /* IMEI 长度检查: 用户输入的IMEI长度应为14位的IMEI和1位的CHECK NUM，共15位 */
    if (imeiLength != (TAF_PH_IMEI_LEN - AT_IMEI_CHECK_NUM_LEN)) {
        AT_NORM_LOG1("AT_UpdateImei: the length of imei is error ", (VOS_INT32)imeiLength);
        return AT_PHYNUM_LENGTH_ERR;
    }

    /* IMEI 号码检查: 确认<imei>为数字字符串, 并将ASCII码转换成BCD码 */
    if (At_AsciiNum2Num(bcdNum, aucImei, imeiLength) != AT_SUCCESS) {
        AT_NORM_LOG("AT_UpdateImei: the number of imei is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }
    bcdNum[TAF_PH_IMEI_LEN - AT_IMEI_CHECK_NUM_LEN] = 0;

    /*
     * IMEI 校验检查: IMEI信息由IMEI(TAC8位,SNR6位)和校验位两部分组成
     * 参考协议: 3GPP 23003 B.2 Computation of CD for an IMEI和B.3 Example of computation
     */
    checkData = 0;
    /* 一次循环i和i+1，所以循环加2 */
    for (i = 0; i < (TAF_IMEI_DATA_LENGTH - AT_IMEI_CHECK_NUM_LEN); i += 2) {
        checkData += bcdNum[i] + ((bcdNum[i + 1UL] + bcdNum[i + 1UL]) / AT_DECIMAL_BASE_NUM) +
                     ((bcdNum[i + 1UL] + bcdNum[i + 1UL]) % AT_DECIMAL_BASE_NUM);
    }
    checkData = (AT_DECIMAL_BASE_NUM - (checkData % AT_DECIMAL_BASE_NUM)) % AT_DECIMAL_BASE_NUM;

    if (checkData != bcdNum[TAF_PH_IMEI_LEN - 2]) {
        AT_NORM_LOG("AT_UpdateImei: the checkdata of imei is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    if (TAF_ACORE_NV_WRITE(modemId, en_NV_Item_IMEI, bcdNum, TAF_PH_IMEI_LEN) != NV_OK) {
        AT_WARN_LOG("AT_UpdateImei: Fail to write NV.");
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetImeiPara(TAF_UINT8 indexNum)
{
    VOS_BOOL      bPhyNumIsNull;
    VOS_UINT32    ret;
    ModemIdUint16 modemId;

    modemId = MODEM_ID_0;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        AT_NORM_LOG1("At_SetImeiPara: the number of parameter is error ", (VOS_INT32)g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("At_SetImeiPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 物理号不为空，数据保护未解锁，直接返回错误，错误码为1物理号不合法。 */
    if (AT_PhyNumIsNull(modemId, AT_PHYNUM_TYPE_IMEI, &bPhyNumIsNull) != AT_OK) {
        return AT_ERROR;
    }

    if ((bPhyNumIsNull == VOS_FALSE) && (g_atDataLocked == VOS_TRUE)) {
        AT_NORM_LOG("At_SetImeiPara: physical number is not null and data locked.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* 更新数据到NV项en_NV_Item_IMEI并返回更新结果 */
    ret = AT_UpdateImei(modemId, g_atParaList[0].para, g_atParaList[0].paraLen);

    return ret;
}
#endif

TAF_UINT32 At_SetFPlmnPara(TAF_UINT8 indexNum)
{
    TAF_PH_FplmnOperate fplmnOperate;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_CFPLMN_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex == 1) {
        if (g_atParaList[0].paraValue != 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        } else {
            fplmnOperate.plmn.mcc = 0;
            fplmnOperate.plmn.mnc = 0;
            fplmnOperate.cmdType  = TAF_PH_FPLMN_DEL_ALL;
        }
    } else if (g_atParaIndex == AT_CFPLMN_PARA_MAX_NUM) {
        if ((g_atParaList[AT_CFPLMN_OPER].paraLen > AT_CFPLMN_OPER_MAX_VALID_LEN) ||
            (g_atParaList[AT_CFPLMN_OPER].paraLen < AT_CFPLMN_OPER_MIN_VALID_LEN)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mcc */
        if (At_String2Hex(g_atParaList[AT_CFPLMN_OPER].para, AT_MCC_LENGTH, &fplmnOperate.plmn.mcc) ==AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mnc */
        if (At_String2Hex(&g_atParaList[AT_CFPLMN_OPER].para[3], g_atParaList[AT_CFPLMN_OPER].paraLen - AT_MNC_LENGTH,
                          &fplmnOperate.plmn.mnc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        fplmnOperate.plmn.mcc &= 0x0FFF;

        if (g_atParaList[AT_CFPLMN_OPER].paraLen == AT_CFPLMN_OPER_MIN_VALID_LEN) {
            fplmnOperate.plmn.mnc |= 0x0F00;
        }

        fplmnOperate.plmn.mnc &= 0x0FFF;

        if (g_atParaList[0].paraValue == 0) {
            fplmnOperate.cmdType = TAF_PH_FPLMN_DEL_ONE;
        } else if (g_atParaList[0].paraValue == 1) {
            fplmnOperate.cmdType = TAF_PH_FPLMN_ADD_ONE;
        } else {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetFPlmnInfo(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &fplmnOperate) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CFPLMN_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetQuickStart(TAF_UINT8 indexNum)
{
    AT_PR_LOGI("Rcv Msg");
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraValue > 1) {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetQuickStartReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, g_atParaList[0].paraValue) ==
        VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CQST_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetAutoAttach(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) { /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_SetAutoAttachReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, g_atParaList[0].paraValue) ==
        VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CAATT_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetSystemInfo(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_QrySystemInfoReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, VOS_FALSE) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SYSINFO_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_VOID At_ConvertSysCfgExRat(VOS_UINT8 clientId, AT_SyscfgexRatOrder *sysCfgExRatOrder,
                               TAF_MMA_SysCfgPara *sysCfgExSetPara)
{
    VOS_UINT32               i;
    ModemIdUint16            modemId;
    VOS_UINT32               rst;
    TAF_MMA_MultimodeRatCfg *ratOrder = VOS_NULL_PTR;

    modemId  = MODEM_ID_0;
    ratOrder = &(sysCfgExSetPara->multiModeRatCfg);

    /* 获取ModemID */
    rst = AT_GetModemIdFromClient(clientId, &modemId);
    if (rst != VOS_OK) {
        AT_ERR_LOG1("At_ConvertSysCfgExRat:Get ModemID From ClientID fail,ClientID=%d", clientId);
        return;
    }

    /* 组合原因值00的接入技术转换 */
    if ((sysCfgExRatOrder->ratOrderNum == 1) && (sysCfgExRatOrder->ratOrder[0] == AT_SYSCFGEX_RAT_AUTO)) {
        AT_SetDefaultRatPrioList(modemId, ratOrder, VOS_TRUE, VOS_TRUE);
        return;
    }

    /* 组合原因值99的接入技术转换 */
    if ((sysCfgExRatOrder->ratOrderNum == 1) && (sysCfgExRatOrder->ratOrder[0] == AT_SYSCFGEX_RAT_NO_CHANGE)) {
        ratOrder->ratNum                    = 0;
        sysCfgExSetPara->ratCfgNoChangeType = TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFGEX;
        return;
    }

    /* 非组合原因值的接入技术转换 */
    ratOrder->ratNum = sysCfgExRatOrder->ratOrderNum;

    for (i = 0; i < sysCfgExRatOrder->ratOrderNum; i++) {
        switch (sysCfgExRatOrder->ratOrder[i]) {
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
            case AT_SYSCFGEX_RAT_NR:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_NR;
                break;
#endif

#if (FEATURE_LTE == FEATURE_ON)
            case AT_SYSCFGEX_RAT_LTE:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_LTE;
                break;
#endif

            case AT_SYSCFGEX_RAT_WCDMA:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_WCDMA;
                break;

            case AT_SYSCFGEX_RAT_GSM:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_GSM;
                break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
            case AT_SYSCFGEX_RAT_1X:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_1X;
                break;

            case AT_SYSCFGEX_RAT_DO:
                ratOrder->ratOrder[i] = TAF_MMA_RAT_HRPD;
                break;
#endif

            default:
                AT_ERR_LOG("At_ConvertSysCfgExRat");
                break;
        }
    }
}


TAF_MMA_ServiceDomainUint8 At_ConvertDetachTypeToServiceDomain(VOS_UINT32 cgcattMode)
{
    switch (cgcattMode) {
        case AT_CGCATT_MODE_PS:
            return TAF_MMA_SERVICE_DOMAIN_PS;

        case AT_CGCATT_MODE_CS:
            return TAF_MMA_SERVICE_DOMAIN_CS;

        case AT_CGCATT_MODE_CS_PS:
            return TAF_MMA_SERVICE_DOMAIN_CS_PS;

        default:
            AT_ERR_LOG("At_ConvertDetachTypeToServiceDomain Detach Type ERROR");
            return TAF_MMA_SERVICE_DOMAIN_CS_PS;
    }
}


TAF_MMA_AttachTypeUint8 At_ConvertCgcattModeToAttachType(VOS_UINT32 cgcattMode)
{
    switch (cgcattMode) {
        case AT_CGCATT_MODE_PS:
            return TAF_MMA_ATTACH_TYPE_GPRS;

        case AT_CGCATT_MODE_CS:
            return TAF_MMA_ATTACH_TYPE_IMSI;

        case AT_CGCATT_MODE_CS_PS:
            return TAF_MMA_ATTACH_TYPE_GPRS_IMSI;

        default:
            AT_ERR_LOG("At_ConvertCgcattModeToAttachType Attach Oper ERROR");
            return TAF_MMA_ATTACH_TYPE_GPRS_IMSI;
    }
}


VOS_VOID AT_ReadRoamCfgInfoNvim(VOS_UINT8 indexNum)
{
    NAS_NVIM_RoamCfgInfo roamFeature;
    ModemIdUint16        modemId;
    VOS_UINT32           rst;
    AT_ModemNetCtx      *netCtx = VOS_NULL_PTR;

    modemId = MODEM_ID_0;

    /* 获取ModemId */
    rst = AT_GetModemIdFromClient(indexNum, &modemId);
    if (rst != VOS_OK) {
        AT_ERR_LOG1("AT_ReadRoamCfgInfoNvim:Get ModemID From ClientID fail,ucIndex=%d", indexNum);
        return;
    }

    roamFeature.roamFeatureFlg = NV_ITEM_ACTIVE;
    roamFeature.roamCapability = 0;

    if (NV_OK != TAF_ACORE_NV_READ(modemId, NV_ITEM_ROAM_CAPA, &roamFeature, sizeof(NAS_NVIM_RoamCfgInfo))) {
        AT_WARN_LOG("AT_ReadRoamCfgInfoNvim():WARNING: NV_ITEM_ROAM_CAPA Error");

        return;
    }

    if ((roamFeature.roamFeatureFlg != NV_ITEM_ACTIVE) && (roamFeature.roamFeatureFlg != NV_ITEM_DEACTIVE)) {
        return;
    }

    netCtx              = AT_GetModemNetCtxAddrFromModemId(modemId);
    netCtx->roamFeature = roamFeature.roamFeatureFlg;
    return;
}


VOS_UINT32 AT_ConvertSysCfgExRatOrderPara(VOS_UINT8 clientId, TAF_MMA_SysCfgPara *sysCfgExSetPara)
{
    VOS_UINT32          rst;
    VOS_UINT32          i;
    VOS_UINT32          ratOrder;
    VOS_UINT8           indexNum;
    VOS_UINT32          ratAutoNoChangeExistFlag;
    AT_SyscfgexRatOrder syscfgExRatOrder;

    indexNum                 = 0;
    ratAutoNoChangeExistFlag = VOS_FALSE;

    /* acqorder字符串长度为奇数 */
    if ((g_atParaList[AT_SYSCFGEX_ACQORDER].paraLen % 2) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* acqorder字符串含非数字 */
    rst = At_CheckNumString(g_atParaList[AT_SYSCFGEX_ACQORDER].para, g_atParaList[AT_SYSCFGEX_ACQORDER].paraLen);
    if (rst != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* acqorder字符串长度是偶数但大于12也非法 */
    if ((g_atParaList[AT_SYSCFGEX_ACQORDER].paraLen / 2) > TAF_PH_MAX_SUPPORT_RAT_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < g_atParaList[AT_SYSCFGEX_ACQORDER].paraLen; i += AT_SYSCFGEX_RAT_MODE_STR_LEN) {
        rst = At_String2Hex(&g_atParaList[AT_SYSCFGEX_ACQORDER].para[i], AT_SYSCFGEX_RAT_MODE_STR_LEN, (VOS_UINT32 *)&ratOrder);
        if (rst != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果ulRatOrder是0x99十六进制数，需要转换为十进制的99 */
        if (ratOrder == AT_SYSCFGEX_RAT_NO_CHANGE_HEX_VALUE) {
            ratOrder = AT_SYSCFGEX_RAT_NO_CHANGE;
        }

        /* acqorder字符串含非00/01/02/03/04/07/08/99的组合 */
        if (At_CheckSysCfgExRatTypeValid((AT_SyscfgexRatTypeUint8)ratOrder) == VOS_FALSE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (((AT_SyscfgexRatTypeUint8)ratOrder == AT_SYSCFGEX_RAT_AUTO) ||
            ((AT_SyscfgexRatTypeUint8)ratOrder == AT_SYSCFGEX_RAT_NO_CHANGE)) {
            ratAutoNoChangeExistFlag = VOS_TRUE;
        }

        syscfgExRatOrder.ratOrder[indexNum] = (AT_SyscfgexRatTypeUint8)ratOrder;
        indexNum++;
    }

    syscfgExRatOrder.ratOrderNum = indexNum;

    /* acqorder字符串是00，99和其他值的组合 */
    if ((ratAutoNoChangeExistFlag == VOS_TRUE) && (syscfgExRatOrder.ratOrderNum > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    syscfgExRatOrder.ratOrderNum = AT_MIN(syscfgExRatOrder.ratOrderNum, TAF_PH_MAX_SUPPORT_RAT_NUM);
    /* acqorder字符串模式设置有重复 */
    if (At_CheckRepeatedRatOrder(&syscfgExRatOrder) == VOS_TRUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将SYSCFGEX的接入技术形式转换为TAF_MMA_RatOrder结构格式 */
    At_ConvertSysCfgExRat(clientId, &syscfgExRatOrder, sysCfgExSetPara);

    return AT_OK;
}


VOS_UINT32 At_CheckRepeatedRatOrder(AT_SyscfgexRatOrder *syscfgExRatOrder)
{
    VOS_UINT32 i;
    VOS_UINT32 j;

    for (i = 0; i < syscfgExRatOrder->ratOrderNum; i++) {
        for (j = i + 1; j < syscfgExRatOrder->ratOrderNum; j++) {
            if (syscfgExRatOrder->ratOrder[i] == syscfgExRatOrder->ratOrder[j]) {
                return VOS_TRUE;
            }
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 At_CheckSysCfgExRatTypeValid(VOS_UINT8 ratOrder)
{
    switch (ratOrder) {
        case AT_SYSCFGEX_RAT_AUTO:
        case AT_SYSCFGEX_RAT_NO_CHANGE:
        case AT_SYSCFGEX_RAT_LTE:
        case AT_SYSCFGEX_RAT_WCDMA:
        case AT_SYSCFGEX_RAT_GSM:
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case AT_SYSCFGEX_RAT_1X:
        case AT_SYSCFGEX_RAT_DO:
#endif
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        case AT_SYSCFGEX_RAT_NR:
#endif
            return VOS_TRUE;

        default:
            return VOS_FALSE;
    }
}


VOS_UINT32 AT_ConvertSysCfgExGuBandPara(VOS_UINT8 *para, VOS_UINT16 len, TAF_UserSetPrefBand64 *prefBandPara)
{
    VOS_UINT32 rslt;

    prefBandPara->bandHigh = 0;
    prefBandPara->bandLow  = 0;

    /* 如果频段为空，返回失败 */
    if (len == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 频段值小于32位时 */
    if (len <= AT_HEX_LEN_OF_ULONG_TYPE) {
        rslt = At_String2Hex(para, len, &(prefBandPara->bandLow));
    } else {
        /* 64位频段的高32位字符串转换为16进制数，转换失败返回 */
        rslt = At_String2Hex(para, (len - AT_HEX_LEN_OF_ULONG_TYPE), &(prefBandPara->bandHigh));
        if (rslt == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 64位频段的低32位字符串转换为16进制数，转换失败返回  */
        rslt = At_String2Hex(para + (len - AT_HEX_LEN_OF_ULONG_TYPE), AT_HEX_LEN_OF_ULONG_TYPE,
                             &(prefBandPara->bandLow));
    }

    if (rslt == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}


VOS_UINT32 AT_ConvertSysCfgExLteBandPara(VOS_UINT8 *para, VOS_UINT16 len, TAF_USER_SetLtePrefBandInfo *prefBandPara)
{
    TAF_USER_SetLtePrefBandInfo allBand;
    VOS_UINT32                  rslt;
    VOS_UINT32                  loop;
    VOS_UINT16                  convertCnt;

    rslt       = AT_SUCCESS;
    convertCnt = len / AT_HEX_LEN_OF_ULONG_TYPE;
    (VOS_VOID)memset_s(&allBand, sizeof(allBand), 0xFF, sizeof(TAF_USER_SetLtePrefBandInfo));
    (VOS_VOID)memset_s(prefBandPara, sizeof(TAF_USER_SetLtePrefBandInfo), 0x00, sizeof(TAF_USER_SetLtePrefBandInfo));

    /* 参数过长，返回错误 */
    if ((len > TAF_MMA_LTE_BAND_MAX_LENGTH * AT_HEX_LEN_OF_ULONG_TYPE)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AP侧新需求，如果频段为空，认为频段不变 */
    if (len == 0) {
        prefBandPara->bandInfo[0] = TAF_PH_BAND_NO_CHANGE;

        return AT_OK;
    }

    for (loop = 0; loop < convertCnt; loop++) {
        rslt |= At_String2Hex(para + (VOS_UINT16)((len - (loop + 1) * AT_HEX_LEN_OF_ULONG_TYPE)),
                              AT_HEX_LEN_OF_ULONG_TYPE, &(prefBandPara->bandInfo[loop]));
    }

    if ((len % AT_HEX_LEN_OF_ULONG_TYPE) != 0) {
        rslt |= At_String2Hex(para, len - (VOS_UINT16)(convertCnt * AT_HEX_LEN_OF_ULONG_TYPE),
                              &(prefBandPara->bandInfo[convertCnt]));
    }

    if (rslt != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* AP侧需求，全部设置为F时，认为是全频段 */
    if (VOS_MemCmp(prefBandPara, &allBand, sizeof(TAF_USER_SetLtePrefBandInfo)) == 0) {
        (VOS_VOID)memset_s(prefBandPara, sizeof(TAF_USER_SetLtePrefBandInfo), 0x00, sizeof(TAF_USER_SetLtePrefBandInfo));
        prefBandPara->bandInfo[0] = MN_MMA_LTE_LOW_BAND_ANY;
        prefBandPara->bandInfo[1] = MN_MMA_LTE_HIGH_BAND_ANY;
    }

    return AT_OK;
}


TAF_MMA_UserSetPrioRatUint8 AT_GetSysCfgPrioRat(TAF_MMA_SysCfgPara *sysCfgExSetPara)
{
    TAF_MMA_UserSetPrioRatUint8 userPrio;
    VOS_UINT8                   i;

    userPrio = TAF_MMA_USER_SET_PRIO_NOCHANGE;

    if (AT_IsSpecRatSupported(TAF_MMA_RAT_LTE, &sysCfgExSetPara->multiModeRatCfg) == VOS_TRUE) {
        return userPrio;
    }

#if (FEATURE_UE_MODE_NR == FEATURE_ON)
    if (AT_IsSpecRatSupported(TAF_MMA_RAT_NR, &sysCfgExSetPara->multiModeRatCfg) == VOS_TRUE) {
        return userPrio;
    }
#endif
    for (i = 0; i < AT_MIN(TAF_MMA_RAT_BUTT, sysCfgExSetPara->multiModeRatCfg.ratNum); i++) {
        if (sysCfgExSetPara->multiModeRatCfg.ratOrder[i] == TAF_MMA_RAT_GSM) {
            userPrio = TAF_MMA_USER_SET_PRIO_GSM_PREFER;
            break;
        }

        if (sysCfgExSetPara->multiModeRatCfg.ratOrder[i] == TAF_MMA_RAT_WCDMA) {
            userPrio = TAF_MMA_USER_SET_PRIO_WCDMA_PREFER;
            break;
        }
    }

    return userPrio;
}


LOCAL VOS_UINT32 AT_IsModeConflictingDomain(TAF_MMA_SysCfgPara *sysCfgExSetPara)
{
    /* 如果设置的模式里有L 或者 NR,且服务域是cs only，返回VOS_TRUE */
    if ((g_atParaList[AT_SYSCFGEX_SRVDOMAIN].paraValue == TAF_MMA_SERVICE_DOMAIN_CS) ||
        (g_atParaList[AT_SYSCFGEX_SRVDOMAIN].paraValue == TAF_MMA_SERVICE_DOMAIN_ANY)) {
        if (AT_IsSpecRatSupported(TAF_MMA_RAT_LTE, &sysCfgExSetPara->multiModeRatCfg) == VOS_TRUE) {
            return VOS_TRUE;
        }
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        if (AT_IsSpecRatSupported(TAF_MMA_RAT_NR, &sysCfgExSetPara->multiModeRatCfg) == VOS_TRUE) {
            return VOS_TRUE;
        }
#endif
    }
    return VOS_FALSE;
}


VOS_UINT32 AT_CheckSysCfgExPara(VOS_UINT8 clientId, TAF_MMA_SysCfgPara *sysCfgExSetPara)
{
    VOS_UINT32      rst;
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    netCtx = AT_GetModemNetCtxAddrFromClientId(clientId);

    /* 检查参数个数,如果不为7个，返回AT_CME_INCORRECT_PARAMETERS */
    if (g_atParaIndex != AT_SYSCFGEX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查acqorder参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败 */
    rst = AT_ConvertSysCfgExRatOrderPara(clientId, sysCfgExSetPara);

    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (sysCfgExSetPara->ratCfgNoChangeType != TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFGEX) {
        sysCfgExSetPara->userPrio = AT_GetSysCfgPrioRat(sysCfgExSetPara);
    }

    /* 如果设置的模式里有L,且服务域是cs only，返回失败 */

    if (AT_IsModeConflictingDomain(sysCfgExSetPara) == VOS_TRUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查band参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败 */
    rst = AT_ConvertSysCfgExGuBandPara(g_atParaList[AT_SYSCFGEX_BAND].para, g_atParaList[AT_SYSCFGEX_BAND].paraLen,
                                       &sysCfgExSetPara->guBand);

    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 漫游特性未激活,漫游能力取值范围0-2; 漫游特性激活,漫游能力取值范围0-3 */
    AT_ReadRoamCfgInfoNvim(clientId);
    if (((netCtx->roamFeature == AT_ROAM_FEATURE_OFF) &&
         (g_atParaList[AT_SYSCFGEX_ROAM].paraValue > AT_ROAM_FEATURE_OFF_NOCHANGE)) ||
        ((netCtx->roamFeature == AT_ROAM_FEATURE_ON) &&
         (g_atParaList[AT_SYSCFGEX_ROAM].paraValue > TAF_MMA_ROAM_NATIONAL_OFF_INTERNATIONAL_OFF))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    sysCfgExSetPara->roam = (VOS_UINT8)g_atParaList[AT_SYSCFGEX_ROAM].paraValue;

    /* 检查lteband参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败 */
    rst = AT_ConvertSysCfgExLteBandPara(g_atParaList[AT_SYSCFGEX_LTEBAND].para,
                                        g_atParaList[AT_SYSCFGEX_LTEBAND].paraLen, &sysCfgExSetPara->lBand);
    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    sysCfgExSetPara->srvDomain = (VOS_UINT8)g_atParaList[AT_SYSCFGEX_SRVDOMAIN].paraValue;

    return rst;
}


VOS_UINT32 AT_SetSysCfgExPara(VOS_UINT8 indexNum)
{
    TAF_MMA_SysCfgPara sysCfgExSetPara;

    VOS_UINT32 rst;

    AT_PR_LOGI("Rcv Msg");

    (VOS_VOID)memset_s(&sysCfgExSetPara, sizeof(sysCfgExSetPara), 0x00, sizeof(sysCfgExSetPara));

    /* 参数个数和合法性检查,不合法直接返回失败 */
    rst = AT_CheckSysCfgExPara(indexNum, &sysCfgExSetPara);

    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    rst = TAF_MMA_SetSysCfgReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &sysCfgExSetPara);
    AT_PR_LOGI("Call interface success!");

    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SYSCFG_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_GetValidNetScanPowerParam(VOS_INT16 *psCellPower)
{
    VOS_UINT32 cellPower;

    cellPower = 0;

    /* power长度大于4或小于3表示无效参数 */
    if ((g_atParaList[AT_NETSCAN_POWER].paraLen > AT_NETSCAN_POWER_PARA_MAX_LEN) ||
        (g_atParaList[AT_NETSCAN_POWER].paraLen < AT_NETSCAN_POWER_PARA_MIN_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 字符串第一个参数不为'-'，即为无效参数 */
    if (g_atParaList[AT_NETSCAN_POWER].para[0] != '-') {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* POWER首字符为'-',获取后面的值 */
    if (atAuc2ul(&g_atParaList[AT_NETSCAN_POWER].para[1],
                 g_atParaList[AT_NETSCAN_POWER].paraLen - 1, &cellPower) != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 由于POWER值为负，所以转换下 */
    *psCellPower = -(VOS_INT16)cellPower;

    /* GU Power取值判断[-110,-47]；LTE/NR Power取值判断[-125,-47] */
    if (*psCellPower > AT_NETSCAN_POWER_MAX_VALUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        || g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE_NRDC ||
        g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_NR
#endif
    ) {
        if (*psCellPower < AT_NETSCAN_LTE_POWER_MIN_VALUE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        if (*psCellPower < AT_NETSCAN_POWER_MIN_VALUE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_GetValidNetScanBandPara(TAF_MMA_BandSet *bandSet)
{
    VOS_UINT8 *para = VOS_NULL_PTR;
    VOS_UINT16 len;
    VOS_UINT16 tmpLen;
    VOS_UINT8  indexNum;
    VOS_UINT8  isNullBand;

    para       = g_atParaList[AT_NETSCAN_BAND].para;
    len        = g_atParaList[AT_NETSCAN_BAND].paraLen;
    isNullBand = VOS_TRUE;
    (VOS_VOID)memset_s(bandSet, sizeof(TAF_MMA_BandSet), 0, sizeof(TAF_MMA_BandSet));

    /* 如果频段为空，则认为是全频段搜索 */
    if (len == 0) {
        if ((g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_GSM) ||
            (g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_UMTS)) {
            bandSet->band[0] = AT_ALL_GU_BAND;
        } else if (g_atParaList[AT_NETSCAN_MODE].paraValue == TAF_MMA_NET_SCAN_RAT_MODE_LTE) {
            bandSet->band[0] = MN_MMA_LTE_LOW_BAND_ANY;
            bandSet->band[1] = MN_MMA_LTE_HIGH_BAND_ANY;
        } else {
            AT_NORM_LOG1("AT_GetValidNetScanBandPara: <mode>", g_atParaList[AT_NETSCAN_MODE].paraValue);
        }
        return AT_OK;
    }

    /* 转换频段 */
    for (indexNum = 0; indexNum < TAF_MMA_BAND_MAX_LEN; indexNum++) {
        tmpLen = (len < AT_HEX_LEN_OF_ULONG_TYPE) ? len : AT_HEX_LEN_OF_ULONG_TYPE;

        if (At_String2Hex(para + g_atParaList[AT_NETSCAN_BAND].paraLen - (indexNum * AT_HEX_LEN_OF_ULONG_TYPE) - tmpLen,
                          tmpLen, &(bandSet->band[indexNum])) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (bandSet->band[indexNum] != 0) {
            isNullBand = VOS_FALSE;
        }

        if (len <= AT_HEX_LEN_OF_ULONG_TYPE) {
            break;
        }

        len -= AT_HEX_LEN_OF_ULONG_TYPE;
    }

    /* 不允许扫描空BAND */
    if (isNullBand == VOS_TRUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}


VOS_UINT32 AT_GetValidNetScanPara(TAF_MMA_NetScanSetPara *netScanSetPara)
{
    /* 检查参数个数,如果超过4个，返回AT_CME_INCORRECT_PARAMETERS */
    if ((g_atParaIndex > AT_NETSCAN_PARA_MAX_NUM) || (g_atParaIndex < AT_NETSCAN_PARA_MIN_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数校验 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置CellNum */
    netScanSetPara->cellNum = (VOS_UINT16)g_atParaList[0].paraValue;

    /* 设置CellPow */
    if (AT_GetValidNetScanPowerParam(&(netScanSetPara->cellPow)) != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 缺省<mode>参数，但不缺省<band>参数，则认为参数错误 */
    if ((g_atParaIndex == AT_NETSCAN_PARA_MAX_NUM) && (g_atParaList[AT_NETSCAN_MODE].paraLen == 0) &&
        (g_atParaList[AT_NETSCAN_BAND].paraLen != 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果用户没输入接入技术，该g_atParaList[2].ulParaValue就是0 */
    if (g_atParaList[AT_NETSCAN_MODE].paraLen == 0) {
        netScanSetPara->rat = TAF_MMA_NET_SCAN_RAT_MODE_GSM;
    } else {
        netScanSetPara->rat = (TAF_MMA_NetScanRatModeUint8)g_atParaList[AT_NETSCAN_MODE].paraValue;
    }

    /* 检查band参数合法性,如果合法,进行转换并记录,如果不合法直接返回失败 */
    return AT_GetValidNetScanBandPara(&netScanSetPara->band);
}


VOS_UINT32 AT_SetNetScanPara(VOS_UINT8 indexNum)
{
    VOS_UINT32             rst;
    TAF_MMA_NetScanSetPara netScanSetPara;

    (VOS_VOID)memset_s(&netScanSetPara, sizeof(netScanSetPara), 0x00, sizeof(netScanSetPara));

    rst = AT_GetValidNetScanPara(&netScanSetPara);
    if (rst != AT_OK) {
        TAF_LOG(WUEPS_PID_AT, VOS_NULL, PS_LOG_LEVEL_ERROR,
                "AT_SetNetScanPara:ERROR: AT_GetValidNetScanPara returns FAILURE");
        return rst;
    }

    rst = TAF_MMA_NetScanReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &netScanSetPara);
    if (rst == VOS_TRUE) {
        /* 指示当前用户的命令操作类型为设置命令 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NETSCAN_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_AbortNetScanPara(VOS_UINT8 indexNum)
{
    /* 当前只能处理NETSCAN设置的打断, 其它命令则不进行打断操作 */
    if (g_atClientTab[indexNum].cmdCurrentOpt == AT_CMD_NETSCAN_SET) {
        /* AT向MMA发送打断NETSCAN的请求 */
        if (TAF_MMA_NetScanAbortReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0) == VOS_TRUE) {
            /* 停止NETSCANAT的保护定时器 */
            AT_StopRelTimer(indexNum, &g_atClientTab[indexNum].hTimer);

            /* 更新当前操作类型 */
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NETSCAN_ABORT;

            return AT_WAIT_ASYNC_RETURN;
        }

        /* AT向MMA发送打断NETSCAN的请求失败，返回失败 */
        return AT_FAILURE;
    }

    /* 当前非设置命令，返回失败 */
    return AT_FAILURE;
}


VOS_UINT32 AT_ConvertSysCfgRatOrderPara(VOS_UINT8 clientId, AT_SYSCFG_RatTypeUint8 ratMode,
                                        AT_SYSCFG_RatPrioUint8 acqorder, TAF_MMA_SysCfgPara *sysCfgPara)
{
    ModemIdUint16            modemId;
    VOS_UINT32               rst;
    TAF_MMA_MultimodeRatCfg *sysCfgRatOrder = VOS_NULL_PTR;

    modemId        = MODEM_ID_0;
    sysCfgRatOrder = &(sysCfgPara->multiModeRatCfg);
    /* 获取ModemId */
    rst = AT_GetModemIdFromClient(clientId, &modemId);

    if (rst != VOS_OK) {
        AT_ERR_LOG1("AT_ConvertSysCfgRatOrderPara:Get ModemID From ClientID fail,ClientID:", clientId);
        return AT_ERROR;
    }
    switch (ratMode) {
        case AT_SYSCFG_RAT_AUTO:
            /* 如果接入优先级不改变则默认从NVIM中获取 */
            if (acqorder == AT_SYSCFG_RAT_PRIO_NO_CHANGE) {
                acqorder = AT_GetGuAccessPrioNvim(modemId);
            }

            /* ucAcqorder为0自动或先WCDMA后GSM */

            if (acqorder == AT_SYSCFG_RAT_PRIO_AUTO) {
                AT_SetDefaultRatPrioList(modemId, sysCfgRatOrder, VOS_FALSE, VOS_FALSE);
            } else if (acqorder == AT_SYSCFG_RAT_PRIO_WCDMA) {
                sysCfgRatOrder->ratNum      = TAF_PH_MAX_GU_RAT_NUM;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_WCDMA;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_GSM;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            } else if (acqorder == AT_SYSCFG_RAT_PRIO_GSM) {
                sysCfgRatOrder->ratNum      = TAF_PH_MAX_GU_RAT_NUM;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_GSM;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_WCDMA;
                sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            } else {
            }

            break;

        case AT_SYSCFG_RAT_GSM:
            /* G单模 */
            sysCfgRatOrder->ratNum      = 1;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_GSM;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_WCDMA:
            /* W单模 */
            sysCfgRatOrder->ratNum      = 1;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_WCDMA;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            break;

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
        case AT_SYSCFG_RAT_1X:
            /* 1X单模 */
            sysCfgRatOrder->ratNum      = 1;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_1X;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_HRPD:
            /* HRPD单模 */
            sysCfgRatOrder->ratNum      = 1;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_HRPD;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_BUTT;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            break;

        case AT_SYSCFG_RAT_1X_AND_HRPD:
            /* 1X&HRPD混合模式 */
            sysCfgRatOrder->ratNum      = 2;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_0] = TAF_MMA_RAT_1X;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_1] = TAF_MMA_RAT_HRPD;
            sysCfgRatOrder->ratOrder[TAF_MMA_RAT_ORDER_INDEX_2] = TAF_MMA_RAT_BUTT;

            break;
#endif

        case AT_SYSCFG_RAT_NO_CHANGE:
            sysCfgRatOrder->ratNum         = 0;
            sysCfgPara->ratCfgNoChangeType = TAF_MMA_RAT_NO_CHANGE_CMD_SYSCFG;
            break;

        default:
            return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 返回成功 */
    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetSysCfgPara(VOS_UINT8 indexNum)
{
    TAF_MMA_SysCfgPara sysCfgPara;

    VOS_UINT32      rst;
    AT_ModemNetCtx *netCtx = VOS_NULL_PTR;

    AT_PR_LOGI("Rcv Msg");

    (VOS_VOID)memset_s(&sysCfgPara, sizeof(sysCfgPara), 0x00, sizeof(TAF_MMA_SysCfgPara));

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    if (g_atParaIndex != AT_SYSCFG_VALID_NUM) { /* 参数过多 */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0) ||
        (g_atParaList[AT_SYSCFG_BAND].paraLen == 0) || (g_atParaList[AT_SYSCFG_ROAM].paraLen == 0) ||
        (g_atParaList[AT_SYSCFG_SRVDOMAIN].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_ConvertSysCfgRatOrderPara(indexNum, (VOS_UINT8)g_atParaList[0].paraValue,
                                       (VOS_UINT8)g_atParaList[1].paraValue, &sysCfgPara);

    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_ConvertSysCfgExGuBandPara(g_atParaList[AT_SYSCFG_BAND].para, g_atParaList[AT_SYSCFG_BAND].paraLen,
                                       &sysCfgPara.guBand);
    if (rst != AT_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要将L的频段设置为不改变 */
    sysCfgPara.userPrio = (VOS_UINT8)g_atParaList[1].paraValue;
    (VOS_VOID)memset_s(&(sysCfgPara.lBand), sizeof(sysCfgPara.lBand), 0x00, sizeof(TAF_USER_SetLtePrefBandInfo));
    sysCfgPara.lBand.bandInfo[0] = TAF_PH_BAND_NO_CHANGE;

    AT_ReadRoamCfgInfoNvim(indexNum);

    if (((netCtx->roamFeature == AT_ROAM_FEATURE_OFF) &&
         (g_atParaList[AT_SYSCFG_ROAM].paraValue > AT_SYSCFG_ROAM_INACTIVE_STATUS_MAX_VALUE)) ||
        ((netCtx->roamFeature == AT_ROAM_FEATURE_ON) &&
         (g_atParaList[AT_SYSCFG_ROAM].paraValue > AT_SYSCFG_ROAM_ACTIVATE_STATUS_MAX_VALUE))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    sysCfgPara.roam      = (VOS_UINT8)g_atParaList[AT_SYSCFG_ROAM].paraValue;
    sysCfgPara.srvDomain = (VOS_UINT8)g_atParaList[AT_SYSCFG_SRVDOMAIN].paraValue;

    /* 执行命令操作 */
    if (TAF_MMA_SetSysCfgReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &sysCfgPara) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SYSCFG_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
#endif

/*
 * History:
 *  1.Date: 2005-04-19
 *    Author:
 *    Modification: Created function
 */
TAF_UINT32 At_SetCcinPara(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * 如果 参数是配置为启动主动上报模式；
     * 返回OK，并切换当前用户为主动上报模式；
     * 如果 参数是配置为停止主动上报模式；
     * 返回OK，并切换当前用户为普通命令模式；
     */

    g_atClientTab[indexNum].indMode = (TAF_UINT8)g_atParaList[0].paraValue;
    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
#if (FEATURE_UE_MODE_G == FEATURE_ON)

TAF_UINT32 At_SetTrigPara(TAF_UINT8 indexNum)
{
    TAF_UINT8     i;
    TAF_GPRS_Data gprsDataInfo;

    (VOS_VOID)memset_s(&gprsDataInfo, sizeof(gprsDataInfo), 0x00, sizeof(gprsDataInfo));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != AT_TRIG_PARA_VALID_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    for (i = 0; i < AT_TRIG_PARA_VALID_NUM; i++) {
        if (g_atParaList[i].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }
    gprsDataInfo.mode = (TAF_UINT8)g_atParaList[0].paraValue;
    if ((gprsDataInfo.mode != 0) && (gprsDataInfo.mode != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if ((g_atParaList[AT_TRIG_NSAPI].paraValue >= AT_TRIG_NSAPI_MIN_VALUE) &&
        (g_atParaList[AT_TRIG_NSAPI].paraValue <= AT_TRIG_NSAPI_MAX_VALUE)) {
        gprsDataInfo.nsapi = (TAF_UINT8)g_atParaList[AT_TRIG_NSAPI].paraValue;
    } else {
        return AT_ERROR;
    }

    gprsDataInfo.length      = (TAF_UINT32)g_atParaList[AT_TRIG_LENGTH].paraValue;
    gprsDataInfo.times       = (TAF_UINT8)g_atParaList[AT_TRIG_TIMES].paraValue;
    gprsDataInfo.millisecond = (TAF_UINT32)g_atParaList[AT_TRIG_MILLISECOND].paraValue;

    /* 执行命令操作 */
    if (TAF_PS_TrigGprsData(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId),
                            g_atClientTab[indexNum].opId, &gprsDataInfo)) {
        return AT_ERROR;
    }

    return AT_OK;
}
#endif

TAF_UINT32 At_SetGcfIndPara(TAF_UINT8 indexNum)
{
    VOS_UINT8  gctTestFlag;
    VOS_UINT32 rst;

    gctTestFlag = 0;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    gctTestFlag = (VOS_UINT8)g_atParaList[0].paraValue;
    if ((gctTestFlag != 0) && (gctTestFlag != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_GCF_IND, &gctTestFlag,
                                 sizeof(VOS_UINT8), I0_WUEPS_PID_DRV_AGENT);

    if (rst == TAF_SUCCESS) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 At_SetGcapPara(TAF_UINT8 indexNum)
{
    TAF_UINT16 length = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + length, "%s: %s",
        g_parseContext[indexNum].cmdElement->cmdName, "+CGSM,+DS,+ES");

    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 At_SetMsIdInfo(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_MSID_QRY_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MSID_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 AT_SetDsFlowClrPara(TAF_UINT8 indexNum)
{
    TAF_DSFLOW_ClearConfig clearConfigInfo;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&clearConfigInfo, sizeof(clearConfigInfo), 0x00, sizeof(TAF_DSFLOW_ClearConfig));

    /* 设置参数 */
    clearConfigInfo.clearMode = TAF_DSFLOW_CLEAR_TOTAL;

    /* 执行命令操作 */
    if (TAF_PS_ClearDsFlowInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                               &clearConfigInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DSFLOWCLR_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_MBB_CUST == FEATURE_ON)
/*
 * 功能说明: 流量查询函数扩展接口
 * 输入参数: index: AT命令输入端口
 * 返回结果: AT_ERROR: 失败
 *           AT_WAIT_ASYNC_RETURN: 异步挂起状态
 */
VOS_UINT32 AT_SetDsFlowQryParaExt(VOS_UINT8 indexNum)
{
    VOS_UINT8 usrCid;

    /* 如果是带CID参数的，则指定CID查询流量 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) {
        if (g_atParaList[0].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        usrCid = g_atParaList[0].para[0] - '0';
    } else if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        /* 不带参数表示查询所有的CID流量 */
        usrCid = TAF_MAX_CID;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_PS_GetDsFlowInfo(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, usrCid, 0) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DSFLOWQRY_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif


TAF_UINT32 AT_SetDsFlowQryPara(TAF_UINT8 indexNum)
{
#if (FEATURE_MBB_CUST == FEATURE_ON)
    return AT_SetDsFlowQryParaExt(indexNum);
#else
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_PS_GetDsFlowInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DSFLOWQRY_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
#endif
}


TAF_UINT32 AT_SetDsFlowRptPara(TAF_UINT8 indexNum)
{
    TAF_DSFLOW_ReportConfig reportConfigInfo;

    /* 初始化 */
    (VOS_VOID)memset_s(&reportConfigInfo, sizeof(reportConfigInfo), 0x00, sizeof(TAF_DSFLOW_ReportConfig));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    reportConfigInfo.rptEnabled = g_atParaList[0].paraValue;


    if (reportConfigInfo.rptEnabled == VOS_TRUE) {
        /* 设置流量上报周期时长 */
        reportConfigInfo.timerLength = 2000;
    }


    /* 执行命令操作 */
    if (TAF_PS_ConfigDsFlowRpt(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                               &reportConfigInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DSFLOWRPT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetVTFlowRptPara(TAF_UINT8 indexNum)
{
    TAF_VTFLOW_ReportConfig reportConfigInfo;

    /* 初始化 */
    (VOS_VOID)memset_s(&reportConfigInfo, sizeof(reportConfigInfo), 0x00, sizeof(TAF_VTFLOW_ReportConfig));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_VTFLOWRPT_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[AT_VTFLOWRPT_RPT_OPER].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    reportConfigInfo.rptEnabled = (VOS_UINT8)g_atParaList[AT_VTFLOWRPT_RPT_OPER].paraValue;

    /* 执行命令操作 */
    if (TAF_PS_ConfigVTFlowRpt(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                               &reportConfigInfo) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VTFLOWRPT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetSrvstPara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType       = AT_MTA_SET_SRVST_RPT_TYPE;
    atCmd.u.srvstRptFlg = 0;

    if (g_atParaList[0].paraLen != 0) {
        atCmd.u.srvstRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    /* 给MTA发送^srvst设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetRssiPara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType      = AT_MTA_SET_RSSI_RPT_TYPE;
    atCmd.u.rssiRptFlg = AT_RSSI_RESULT_CODE_NOT_REPORT_TYPE;

    if (g_atParaList[0].paraLen != 0) {
        atCmd.u.rssiRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    /* 给MTA发送^rssi设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    /* AT不需要发给L4A，由MMC发给LMM,再由LMM通知LRRC */

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetCerssiPara(VOS_UINT8 indexNum)
{
    TAF_START_InfoInd startInfoInd;
    AT_ModemNetCtx   *netCtx = VOS_NULL_PTR;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&startInfoInd, sizeof(startInfoInd), 0x00, sizeof(startInfoInd));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaIndex > AT_CERSSI_PARA_MAX_NUM) || (g_atParaList[AT_CERSSI_MODE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex == 1) {
        netCtx->cerssiReportType         = 0;
        netCtx->cerssiMinTimerInterval   = 0;
        startInfoInd.minRptTimerInterval = 0;
    }

    if (g_atParaIndex == AT_CERSSI_PARA_MAX_NUM) {
        netCtx->cerssiMinTimerInterval   = (VOS_UINT8)g_atParaList[1].paraValue;
        startInfoInd.minRptTimerInterval = (VOS_UINT8)g_atParaList[1].paraValue;
    }

    if (g_atParaList[0].paraValue != 0) {
        netCtx->cerssiReportType   = (VOS_UINT8)g_atParaList[0].paraValue;
        startInfoInd.actionType    = TAF_START_EVENT_INFO_FOREVER;
        startInfoInd.signThreshold = (VOS_UINT8)g_atParaList[0].paraValue;
        startInfoInd.rrcMsgType    = TAF_EVENT_INFO_CELL_SIGN;
    } else {
        /*
         * 由于+creg/+cgreg/+csq/^rssi都是通过RRMM_AT_MSG_REQ或GRRMM_AT_MSG_REQ通知接入层主动上报，
         * 所以不能通知接入层停止，设置成默认rssi 5db改变上报，AT_GetModemNetCtxAddrFromClientId(ucIndex)->ucCerssiReportType全局变量控制^cerssi是否上报
         */
        startInfoInd.actionType          = TAF_START_EVENT_INFO_FOREVER;
        startInfoInd.rrcMsgType          = TAF_EVENT_INFO_CELL_SIGN;
        startInfoInd.signThreshold       = 0;
        netCtx->cerssiReportType         = AT_CERSSI_REPORT_TYPE_NOT_REPORT;
        netCtx->cerssiMinTimerInterval   = 0;
        startInfoInd.minRptTimerInterval = 0;
    }

    if (TAF_MMA_SetCerssiReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &startInfoInd) == VOS_TRUE) {
        /* Set at cmd type */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CERSSI_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }

    /* AT不需要发给L4A，由MMC发给LMM,再由LMM通知LRRC */
}


VOS_UINT32 At_SetCnmrPara(VOS_UINT8 indexNum)
{
    VOS_UINT32       rst;
    AT_MTA_QryNmrReq qryNmrReq;

    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数长度过长 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 查询4g的nmr数据直接返回失败 */
    if (g_atParaList[0].paraValue == AT_CNMR_QRY_LTE_NMR_DATA) {
        return AT_ERROR;
    }

    /* 发送消息DRV_AGENT_AS_QRY_NMR_REQ给C核处理 */
    (VOS_VOID)memset_s(&qryNmrReq, sizeof(qryNmrReq), 0x00, sizeof(qryNmrReq));

    if (g_atParaList[0].paraValue == AT_CNMR_QRY_WAS_NMR_DATA) {
        qryNmrReq.ratType = 0;
    } else {
        qryNmrReq.ratType = 1;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, ID_AT_MTA_QRY_NMR_REQ,
                                 (VOS_UINT8 *)&qryNmrReq, sizeof(qryNmrReq), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CNMR_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


TAF_UINT32 At_SetTimePara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_TIME_PARA_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[AT_TIME_RPT_FLG].paraLen == 0) ||
        (g_atParaList[AT_TIME_RPT_FLG].paraValue > AT_TIME_RPT_FLG_MAX_VALID_VALUE)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType      = AT_MTA_SET_TIME_RPT_TYPE;
    atCmd.u.timeRptFlg = (VOS_UINT8)g_atParaList[AT_TIME_RPT_FLG].paraValue;

    /* 给MTA发送^time设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetCtzrPara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数范围扩展 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > AT_CTZR_VALUE_MAX_VALUE)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType      = AT_MTA_SET_CTZR_RPT_TYPE;
    atCmd.u.ctzrRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^ctzr设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetModePara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;
#if (FEATURE_LTE == FEATURE_ON)
    L4A_IND_Cfg   l4AIndCfgReq;
    ModemIdUint16 modemId;

    modemId = MODEM_ID_0;
#endif

    /* AT命令参数合法性检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType      = AT_MTA_SET_MODE_RPT_TYPE;
    atCmd.u.modeRptFlg = AT_MODE_RESULT_CODE_NOT_REPORT_TYPE;

    if (g_atParaList[0].paraLen != 0) {
        atCmd.u.modeRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    /* 给MTA发送^mode设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

#if (FEATURE_LTE == FEATURE_ON)
    result = AT_GetModemIdFromClient(indexNum, &modemId);

    if (result != VOS_OK) {
        AT_ERR_LOG1("At_SetModePara:Get ModemID From ClientID fail,ClientID=%d", indexNum);
        return AT_ERROR;
    }

    if (AT_IsModemSupportRat(modemId, TAF_MMA_RAT_LTE) == VOS_TRUE) {
        (VOS_VOID)memset_s(&l4AIndCfgReq, sizeof(l4AIndCfgReq), 0x00, sizeof(l4AIndCfgReq));
        l4AIndCfgReq.modeBitValid = 1;
        l4AIndCfgReq.modeBit      = g_atParaList[0].paraValue;

        /* 通知L此次mode的设置 */
        AT_SetLIndCfgReq(indexNum, &l4AIndCfgReq);
    }
#endif

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 At_SetSimstPara(TAF_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType       = AT_MTA_SET_SIMST_RPT_TYPE;
    atCmd.u.simstRptFlg = AT_SIMST_ENABLE_TYPE;

    if (g_atParaList[0].paraLen != 0) {
        atCmd.u.simstRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

TAF_UINT32 At_SetHSPara(TAF_UINT8 indexNum)
{
    TAF_UINT8 buf[AT_BUF_ARRAY_MAX_LEN];
    errno_t   memResult;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_HS_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_HS_ID].paraLen != 0) {
        memResult = memcpy_s(buf, sizeof(buf), &g_atParaList[AT_HS_ID].paraValue, sizeof(TAF_UINT32));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(buf), sizeof(TAF_UINT32));
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_HS_ACTION].paraLen != 0) {
        buf[AT_BUF_ARRAY_MAX_LEN - 1] = (TAF_UINT8)g_atParaList[AT_HS_ACTION].paraValue;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作，这些参数可以不用发送到MMA */
    if (TAF_MMA_QryHandShakeReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_HS_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_UpdateSvn(ModemIdUint16 modemId, VOS_UINT8 aucSvn[], VOS_UINT16 svnLength)
{
    TAF_SVN_Data svn;

    (VOS_VOID)memset_s(&svn, sizeof(svn), 0x00, sizeof(svn));

    /* SVN 长度检查: 用户输入的SVN固定长度应为2位 */
    if (svnLength != TAF_SVN_DATA_LENGTH) {
        AT_NORM_LOG("AT_UpdateSvn: the length of SVN is error.");
        return AT_PHYNUM_LENGTH_ERR;
    }

    /* SVN 字符串检查1: 确认<SVN>为数字字符串, 并将ASCII码转换成BCD码 */
    if (At_AsciiNum2Num(svn.svn, aucSvn, svnLength) != AT_SUCCESS) {
        AT_NORM_LOG("AT_UpdateSvn: the number of SVN is error.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    /*
     * SVN 字符串检查2: 99是SVN的保留数值，返回AT_PHYNUM_NUMBER_ERR物理号错误
     * 参考协议: 3GPP 23003 6.3 Allocation principles SVN value 99 is reserved for future use.
     */
    if ((svn.svn[0] == 9) && (svn.svn[1] == 9)) {
        AT_NORM_LOG("AT_UpdateSvn: the number of SVN is reserved.");
        return AT_PHYNUM_NUMBER_ERR;
    }

    /* 设置SVN的NV项激活标志为激活，此标志默认为未激活； */
    svn.activeFlag = NV_ITEM_ACTIVE;

    /* 清空无效的末位字节 */
    svn.reserve[0] = 0;

    if (TAF_ACORE_NV_WRITE(modemId, NV_ITEM_IMEI_SVN, (VOS_UINT8 *)&svn, sizeof(svn)) != NV_OK) {
        AT_WARN_LOG("AT_UpdateSvn: Fail to write NV.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_CheckPhyNumPara(AT_PhynumTypeUint32 *setType)
{
    VOS_UINT32 times;
    VOS_UINT32 ret;

    /*
     * <type>参数检查: BALONG仅支持输入物理号为IMEI或SVN，
     * 否则，直接返回错误，< err_code > 错误码为1物理号不合法
     */
    /* 全部格式化为大写字符 */
    if (At_UpString(g_atParaList[0].para, g_atParaList[0].paraLen) == AT_FAILURE) {
        return AT_ERROR;
    }

    if (VOS_StrCmp((VOS_CHAR *)g_atParaList[0].para, "IMEI") == 0) {
        *setType = AT_PHYNUM_TYPE_IMEI;
    } else if (VOS_StrCmp((VOS_CHAR *)g_atParaList[0].para, "SVN") == 0) {
        *setType = AT_PHYNUM_TYPE_SVN;
    } else if (VOS_StrCmp((VOS_CHAR *)g_atParaList[0].para, "MACWLAN") == 0) {
        *setType = AT_PHYNUM_TYPE_MAC;
    } else {
        AT_NORM_LOG("AT_CheckPhyNumPara: the type of physical is error.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* < times >参数检查: 输入< times >范围为0-1，否则返回AT_ERROR */
    if (g_atParaList[AT_PHYNUM_TIMES].paraLen != 0) {
        /* TIMES的取值范围是0－1 */
        ret = At_Auc2ul(g_atParaList[AT_PHYNUM_TIMES].para, g_atParaList[AT_PHYNUM_TIMES].paraLen, &times);
        if ((ret != AT_SUCCESS) || (times > 1)) {
            AT_NORM_LOG("AT_CheckPhyNumPara: times error.");
            return AT_ERROR;
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_SetPhyNumPara(VOS_UINT8 indexNum)
{
    VOS_UINT32          ret;
    AT_PhynumTypeUint32 setType;
    VOS_BOOL            bPhyNumIsNull;
    ModemIdUint16       modemId;

    modemId = MODEM_ID_0;

    /*
     * 参数个数有效性检查: 参数至少包括<type>,<number>两部分，
     * 最多可以再包含< times > ，参数个数错误，返回AT_ERROR
     */
    if ((g_atParaIndex != AT_PHYNUM_PARA_MIN_VALID_NUM) && (g_atParaIndex != AT_PHYNUM_PARA_MAX_VALID_NUM)) {
        AT_NORM_LOG("AT_SetPhyNumPara: the number of parameter is error.");
        return AT_ERROR;
    }

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("AT_SetPhyNumPara: Get modem id fail.");
        return AT_ERROR;
    }

    ret = AT_CheckPhyNumPara(&setType);
    if (ret != AT_OK) {
        return ret;
    }

    /* 物理号不为空，且数据保护未解锁，直接返回错误，< err_code > 错误码为1物理号不合法。 */
    if (AT_PhyNumIsNull(modemId, setType, &bPhyNumIsNull) != AT_OK) {
        return AT_ERROR;
    }

    if ((bPhyNumIsNull == VOS_FALSE) && (g_atDataLocked == VOS_TRUE)) {
        AT_NORM_LOG("AT_SetPhyNumPara: physical number is not null and data locked.");
        return AT_PHYNUM_TYPE_ERR;
    }

    /* 若当前用户设置的物理号为IMEI，则修改en_NV_Item_IMEI中的数据 */
    /* 若当前用户设置的物理号为SVN，则修改en_Nv_Item_Imei_Svn中的数据 */
    /* 若当前用户设置的物理号为MAC，则修改MAC地址对应的NV项(新增数据卡MAC地址的NV项)中的数据 */
    if (setType == AT_PHYNUM_TYPE_IMEI) {
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
        ret = AT_UpdateImei(modemId, g_atParaList[1].para, g_atParaList[1].paraLen);
#else
        ret = AT_OK;
#endif

    } else if (setType == AT_PHYNUM_TYPE_SVN) {
        ret = AT_UpdateSvn(modemId, g_atParaList[1].para, g_atParaList[1].paraLen);
    } else {
        /* 更新MAC地址到NV */
        ret = AT_UpdateMacPara(g_atParaList[1].para, g_atParaList[1].paraLen);
    }

    return ret;
}


VOS_UINT32 AT_SetGTimerPara(VOS_UINT8 indexNum)
{
    /* 参数个数错误，返回AT_DEVICE_OTHER_ERROR，上报CME ERROR:1 */
    if (g_atParaIndex != 1) {
        AT_NORM_LOG("AT_SetGTimerPara: the number of parameter is error.");
        return AT_ERROR;
    }

    /* 数据保护未解锁，返回AT_DATA_UNLOCK_ERROR，上报CME ERROR:0 */
    if (g_atDataLocked != VOS_FALSE) {
        AT_NORM_LOG("AT_SetGTimerPara: data locked.");
        return AT_ERROR;
    }

    if (NV_OK != TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_GPRS_ACTIVE_TIMER_LEN, (VOS_UINT8 *)&g_atParaList[0].paraValue,
                                    sizeof(g_atParaList[0].paraValue))) {
        AT_WARN_LOG("AT_SetGTimerPara: Fail to write NV_ITEM_GPRS_ACTIVE_TIMER_LEN.");
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetU2DiagPara(TAF_UINT8 indexNum)
{
    AT_USB_EnumStatus usbEnumStatus;

    NV_PID_EnableType pidEnableType;

    (VOS_VOID)memset_s(&usbEnumStatus, sizeof(usbEnumStatus), 0x00, sizeof(usbEnumStatus));

    pidEnableType.pidEnabled = VOS_FALSE;

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PID_ENABLE_TYPE, &pidEnableType, sizeof(NV_PID_EnableType))) {
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若使能，返回ERROR */
    if (pidEnableType.pidEnabled != VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 参数有效性检查 */
    if (DRV_U2DIAG_VALUE_CHECK(g_atParaList[0].paraValue) != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充stUsbEnumStatus结构体 */
    (VOS_VOID)memset_s(&usbEnumStatus, sizeof(usbEnumStatus), 0x00, sizeof(AT_USB_EnumStatus));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_USB_ENUM_STATUS, &usbEnumStatus, sizeof(AT_USB_EnumStatus)) == NV_OK) {
        if ((g_atParaList[0].paraValue == usbEnumStatus.value) && (usbEnumStatus.status == 1)) {
            AT_INFO_LOG("At_SetU2DiagPara():The content to write is same as NV's");
            return AT_OK;
        }
    }

    usbEnumStatus.status = 1;
    usbEnumStatus.value  = g_atParaList[0].paraValue;

    /* 写入NVIM */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_USB_ENUM_STATUS, (VOS_UINT8 *)&usbEnumStatus,
                           sizeof(AT_USB_EnumStatus)) != NV_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_BOOL At_FistScanSetPortPara(VOS_UINT16 *semiIndex, VOS_UINT8 *inputString, VOS_UINT16 inputLen)
{
    VOS_UINT32          i;
    VOS_UINT32          j;
    VOS_UINT8           semiCount;
    const VOS_UINT8     aAvailableChar[] = {
        '0', '1', '2', '3', '4', '5', '6', '7', 'A', 'B', 'D', 'E', 'F', ',', ';'
    };

    semiCount = 0;

    for (i = 0; i < inputLen; i++) {
        for (j = 0; j < (sizeof(aAvailableChar) / sizeof(VOS_UINT8)); j++) {
            if (*(inputString + i) == aAvailableChar[j]) {
                if (*(inputString + i) == ';') {
                    semiCount++;
                    *semiIndex = (VOS_UINT16)i;

                    /* 有且只能有一个分号 */
                    if (semiCount > 1) {
                        AT_ERR_LOG("At_FistScanSetPortPara:The num of semi can only be one!");
                        return VOS_FALSE;
                    }
                }
                break;
            }
        }

        /* 不是合法字符 */
        if ((sizeof(aAvailableChar) / sizeof(VOS_UINT8)) == j) {
            AT_ERR_LOG("At_FistScanSetPortPara:Invalid character!");
            return VOS_FALSE;
        }
    }

    /* 有且只能有一个分号并且不是第一个字符也不是最后一个字符 */
    if ((*semiIndex == 0) || ((inputLen - 1) == *semiIndex)) {
        AT_ERR_LOG("At_FistScanSetPortPara:The position of semi isn't suitable!");
        return VOS_FALSE;
    }

    /* 第一个和最后一个字符为逗号 */
    if ((*inputString == ',') || (inputString[inputLen - 1] == ',')) {
        return VOS_FALSE;
    }

    return VOS_TRUE;
}


VOS_BOOL At_SecScanSetPortFirstPara(VOS_UINT16 semiIndex, VOS_UINT8 *firstParaCount, VOS_UINT8 *inputString,
                                    VOS_UINT16 inputLen)
{
    VOS_UINT32 i;
    VOS_UINT8  charCount;

    charCount = 0;

    for (i = 0; i <= semiIndex; i++) {
        /* 逗号或者第一个参数的结尾 */
        if ((*(inputString + i) == ',') || (*(inputString + i) == ';')) {
            /* 参数之间多个逗号的情况A1,,,,A2;1,2 返回ERROR */
            /* 必须是两个字符A1,A2,FF */
            if (charCount != AT_SET_PORT_PORTTYPE_CHARCOUNT) {
                AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid first parameter!");
                return VOS_FALSE;
            }

            if ((i >= AT_SET_PORT_PORTTYPE_CHARCOUNT) &&
                !(((inputString[i - AT_SET_PORT_PORTTYPE_CHAR1] == 'A') &&
                   (inputString[i - AT_SET_PORT_PORTTYPE_CHAR2] == '1')) ||
                  ((inputString[i - AT_SET_PORT_PORTTYPE_CHAR1] == 'A') &&
                   (inputString[i - AT_SET_PORT_PORTTYPE_CHAR2] == '2')) ||
                  ((inputString[i - AT_SET_PORT_PORTTYPE_CHAR1] == 'F') &&
                   (inputString[i - AT_SET_PORT_PORTTYPE_CHAR2] == 'F')))) {

                AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid first parameter!");
                return VOS_FALSE;
            }

            (*firstParaCount)++;

            charCount = 0;
        } else {
            charCount++;
        }

        if (charCount > AT_SET_PORT_PORTTYPE_CHARCOUNT) {
            AT_ERR_LOG("At_SecScanSetPortFirstPara:Invalid character!");
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}


VOS_BOOL AT_SecParaTwoCharProc(VOS_UINT8 charCount, VOS_UINT32 loop, VOS_UINT8 *tmpInputString)
{
    VOS_BOOL bRet = VOS_TRUE;
    /* 如果是两个字符必须为A1,A2或16 */
    if (charCount == AT_SET_PORT_PORTTYPE_CHARCOUNT) {
        if ((loop >= AT_SET_PORT_PORTTYPE_CHARCOUNT) &&
            !(((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == 'A') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '1')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == 'A') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '2')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '6')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '0')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '1')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '2')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '3')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '4')) ||
              ((tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR1] == '1') &&
               (tmpInputString[loop - AT_SET_PORT_PORTTYPE_CHAR2] == '5')))) {
            AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
            bRet = VOS_FALSE;
        }
    }

    return bRet;
}


VOS_BOOL At_SecScanSetPortSecPara(VOS_UINT16 semiIndex, VOS_UINT8 *secParaCount,
                                    VOS_UINT8 aucSecPara[AT_SETPORT_PARA_MAX_LEN][AT_SETPORT_PORT_TYPE_NUM],
                                    VOS_UINT8 *inputString,
                                    VOS_UINT16 inputLen)
{
    errno_t    memResult;
    VOS_UINT32 i;
    VOS_UINT8  charCount;
    VOS_UINT8  tmpInputString[AT_SETPORT_PARA_MAX_CHAR_LEN];
    VOS_UINT16 tmpInputStringLen;

    charCount = 0;

    if (inputLen > AT_SETPORT_PARA_MAX_CHAR_LEN) {
        return VOS_FALSE;
    }

    /* 第二个参数结尾加上逗号便于以下参数检查 */
    tmpInputStringLen = inputLen - semiIndex;
    if (tmpInputStringLen > 1) {
        memResult = memcpy_s(tmpInputString, sizeof(tmpInputString), inputString + semiIndex + 1,
                             (VOS_SIZE_T)(tmpInputStringLen - 1));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(tmpInputString), (VOS_SIZE_T)(tmpInputStringLen - 1));
    }
    tmpInputString[tmpInputStringLen - 1] = ',';

    for (i = 0; i < tmpInputStringLen; i++) {
        if (*(tmpInputString + i) == ',') {
            /* 参数之间多个逗号的情况A1,A2;1,,,2返回eror */
            if (charCount == 0) {
                AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
                return VOS_FALSE;
            }

            if (AT_SecParaTwoCharProc(charCount, i, tmpInputString) == VOS_FALSE) {
                return VOS_FALSE;
            }

            /* 保存合法的参数 */
            if ((*secParaCount) >= AT_SETPORT_PARA_MAX_LEN) {
                return VOS_FALSE;
            }

            memResult = memcpy_s(aucSecPara[*secParaCount], charCount, (tmpInputString + i) - charCount, charCount);
            TAF_MEM_CHK_RTN_VAL(memResult, charCount, charCount);

            (*secParaCount)++;

            charCount = 0;
        } else {
            charCount++;
        }

        if (charCount > AT_VALID_CHAR_LEN) {
            AT_ERR_LOG("At_SecScanSetPortSecPara:Invalid second parameter!");
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}


VOS_BOOL At_SaveSetPortFirstPara(VOS_UINT8 firstParaCount, VOS_UINT8 *firstPort, VOS_UINT8 *inputString)
{
    /* 参数个数不符合要求 */
    if ((firstParaCount != AT_SETPORT_FIRST_PARA_MIN_NUM) && (firstParaCount != AT_SETPORT_FIRST_PARA_MAX_NUM)) {
        return VOS_FALSE;
    }

    /* 只有一个参数: FF或者A1 */
    if (firstParaCount == 1) {
        if ((*inputString == 'F') && (*(inputString + 1) == 'F')) {
            *firstPort = 0xFF;
        } else if ((*inputString == 'A') && (*(inputString + 1) == '1')) {
            *firstPort = 0xA1;
        } else {
            AT_ERR_LOG("At_SaveSetPortFirstPara:Invalid first parameter!");
            return VOS_FALSE;
        }
    }
    /* 两个参数: A1,A2 */
    else {
        if ((*inputString == 'A') && (inputString[1] == '1') && (inputString[3] == 'A') && (inputString[4] == '2')) {
            *firstPort       = 0xA1;
            *(firstPort + 1) = 0xA2;
        } else {
            AT_ERR_LOG("At_SaveSetPortFirstPara:Invalid first parameter!");
            return VOS_FALSE;
        }
    }
    return VOS_TRUE;
}


VOS_BOOL At_SaveSetPortSecPara(VOS_UINT8 secParaCount, VOS_UINT8 *secPort,
                               VOS_UINT8 aucSecPara[AT_SETPORT_PARA_MAX_LEN][AT_SETPORT_PORT_TYPE_NUM])
{
    VOS_UINT32 i;
    VOS_UINT32 j;

    /* 参数个数不符合要求 */
    if ((secParaCount == 0) || (secParaCount > AT_SETPORT_PARA_MAX_LEN)) {
        AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
        return VOS_FALSE;
    }

    /* 参数不能重复 */
    for (i = 0; i < (VOS_UINT8)(secParaCount - 1); i++) {
        for (j = i + 1; j < secParaCount; j++) {
            if (!VOS_MemCmp(aucSecPara[i], aucSecPara[j], AT_SETPORT_PORT_TYPE_NUM)) {
                AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
                return VOS_FALSE;
            }
        }
    }

    for (i = 0; i < secParaCount; i++) {
        for (j = 0; j < AT_SETPORT_DEV_LEN; j++) {
            if (!VOS_MemCmp(aucSecPara[i], g_setPortParaMap[j].atSetPara, AT_SETPORT_PORT_TYPE_NUM)) {
                secPort[i] = g_setPortParaMap[j].drvPara;
                break;
            }
        }

        /* 说明不是合法的设备形态，返回错误 */
        if (j >= AT_SETPORT_DEV_LEN) {
            AT_ERR_LOG("At_SaveSetPortSecPara:Invalid second parameter!");
            return VOS_FALSE;
        }
    }
    return VOS_TRUE;
}


VOS_UINT32 AT_CheckPortTypePara(VOS_UINT8 firstParaCount, VOS_UINT8 *firstPort, VOS_UINT8 secParaCount,
                                VOS_UINT8 *secPort)
{
    VOS_UINT32 ret;

    /*
     * 切换前端口有效性检查:
     * 端口配置第一位必须为A1(CDROM),否则返回ERROR；
     * 第二位如果有，仅允许有A2(SD),否则返回ERROR；
     * 如果是直接上报多端口状态，分号前就直接是FF,否则返回ERROR。
     */
    if (firstParaCount == AT_SETPORT_FIRST_PARA_MAX_NUM) {
        if ((*(firstPort) != AT_DEV_CDROM) || (*(firstPort + 1) != AT_DEV_SD)) {
            return VOS_FALSE;
        }

    } else if (firstParaCount == AT_SETPORT_FIRST_PARA_MIN_NUM) {
        if ((*(firstPort) != AT_DEV_CDROM) && (*(firstPort) != AT_DEV_NONE)) {
            return VOS_FALSE;
        }

    } else {
        return VOS_FALSE;
    }

    /*
     * 切换后端口有效性检查:
     * 1.端口形态中必须有2(PCUI),否则返回ERROR；
     * 2.切换后端口必须是测试命令中输出的支持的端口，否则返回ERROR；
     * 3.不能设置有重复的端口，否则返回ERROR；
     * 4.MASS 不能设置到其他端口的前面，否则返回ERROR
     * 5.端口个数不能超过规定的个数,否则返回ERROR；
     */
    ret = (VOS_UINT32)DRV_USB_PORT_TYPE_VALID_CHECK(secPort, secParaCount);
    if (ret != VOS_OK) {
        return VOS_FALSE;
    }

    return VOS_TRUE;
}


VOS_BOOL At_IsAvailableSetPortPara(VOS_UINT8 *inputString, VOS_UINT16 inputLen, VOS_UINT8 *firstPort,
                                   VOS_UINT8 *secPort)
{
    /* 分号的位置 */
    VOS_UINT16 semiIndex;
    VOS_UINT8  firstParaCount;
    VOS_UINT8  secParaCount;
    VOS_UINT8  secPara[AT_SETPORT_PARA_MAX_LEN][AT_SETPORT_PORT_TYPE_NUM];
    VOS_BOOL   bScanResult;
    VOS_UINT32 ret;
    semiIndex      = 0;
    firstParaCount = 0;
    secParaCount   = 0;

    (VOS_VOID)memset_s(secPara, sizeof(secPara), 0x00, sizeof(secPara));

    /* 第一轮扫描:是否有非法字符 */
    bScanResult = At_FistScanSetPortPara(&semiIndex, inputString, inputLen);

    if (bScanResult != VOS_TRUE) {
        AT_ERR_LOG("At_IsAvailableSetPortPara:First parameter is invalid!");
        return VOS_FALSE;
    }

    /* 第二轮扫描:每个参数必须是A1,A2,FF,A,B,D,E,1,2,3,4,5,6,7 */
    /* 第一个参数 */
    bScanResult = At_SecScanSetPortFirstPara(semiIndex, &firstParaCount, inputString, inputLen);

    if (bScanResult != VOS_TRUE) {
        AT_ERR_LOG("At_IsAvailableSetPortPara:First parameter is invalid!");
        return VOS_FALSE;
    }

    /* 第二个参数 */
    bScanResult = At_SecScanSetPortSecPara(semiIndex, &secParaCount, secPara, inputString, inputLen);

    if (bScanResult != VOS_TRUE) {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Second parameter is invalid!");
        return VOS_FALSE;
    }

    /* 保存第一个参数 */
    bScanResult = At_SaveSetPortFirstPara(firstParaCount, firstPort, inputString);

    if (bScanResult != VOS_TRUE) {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Save first parameter fail!");
        return VOS_FALSE;
    }

    /* 保存第二个参数 */
    bScanResult = At_SaveSetPortSecPara(secParaCount, secPort, secPara);

    if (bScanResult != VOS_TRUE) {
        AT_ERR_LOG("At_IsAvailableSetPortPara:Save second parameter fail!");
        return VOS_FALSE;
    }

    ret = AT_CheckPortTypePara(firstParaCount, firstPort, secParaCount, secPort);

    return ret;
}


VOS_UINT32 At_SetPort(VOS_UINT8 indexNum)
{
    errno_t           memResult;
    VOS_BOOL          bValidPara;
    VOS_UINT8         firstPort[AT_SETPORT_PARA_MAX_LEN];
    VOS_UINT8         secPort[AT_SETPORT_PARA_MAX_LEN];
    AT_DynamicPidType dynamicPidType;
    NV_PID_EnableType pidEnableType;

    pidEnableType.pidEnabled = VOS_FALSE;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(firstPort, sizeof(firstPort), 0x00, AT_SETPORT_PARA_MAX_LEN);
    (VOS_VOID)memset_s(secPort, sizeof(secPort), 0x00, AT_SETPORT_PARA_MAX_LEN);
    (VOS_VOID)memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(AT_DynamicPidType));

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PID_ENABLE_TYPE, &pidEnableType, sizeof(NV_PID_EnableType))) {
        AT_ERR_LOG("At_SetPort:Read NV failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回ERROR */
    if (pidEnableType.pidEnabled != VOS_TRUE) {
        AT_WARN_LOG("At_SetPort:PID is not enabled");
        return AT_ERROR;
    }

    /*
     * 1.参数为空
     * 2.参数超过最大长度
     * 参数最大长度: 两个参数的长度加一个分号
     */
    if ((g_atParaList[AT_SETPORT_PORT_TYPE].paraLen == 0) ||
        (g_atParaList[AT_SETPORT_PORT_TYPE].paraLen > ((AT_SETPORT_PARA_MAX_CHAR_LEN * AT_DOUBLE_LENGTH) + 1))) {
        return AT_ERROR;
    }

    /* 该AT命令支持用户输入大小写，先将小写转成大写，再进行字符串的解析 */
    At_UpString(g_atParaList[AT_SETPORT_PORT_TYPE].para, g_atParaList[AT_SETPORT_PORT_TYPE].paraLen);

    /* 参数解析 */
    bValidPara = At_IsAvailableSetPortPara(g_atParaList[AT_SETPORT_PORT_TYPE].para,
                                           g_atParaList[AT_SETPORT_PORT_TYPE].paraLen, firstPort, secPort);
    if (bValidPara == VOS_FALSE) {
        AT_WARN_LOG("At_SetPort:Parameter is invalid");
        return AT_ERROR;
    }

    /* 读NV失败，直接返回ERROR */
    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType))) {
        AT_ERR_LOG("At_SetPort:Read NV fail!");
        return AT_ERROR;
    }

    /* 读NV成功，判断该NV的使能状态，若不使能，直接返回ERROR */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 判断要写入内容是否与NV中内容相同，如果相同不再写操作，直接返回OK */
        if (!(VOS_MemCmp(dynamicPidType.firstPortStyle, firstPort, AT_SETPORT_PARA_MAX_LEN))) {
            if (!(VOS_MemCmp(dynamicPidType.rewindPortStyle, secPort, AT_SETPORT_PARA_MAX_LEN))) {
                AT_INFO_LOG("At_SetPort:Same, not need write");
                return AT_OK;
            }
        }
    } else {
        return AT_ERROR;
    }

    /* 此处增加DIAG口密码保护    */
    if (AT_CheckSetPortRight(dynamicPidType.rewindPortStyle, secPort) != AT_OK) {
        return AT_ERROR;
    }

    memResult = memcpy_s(dynamicPidType.firstPortStyle, sizeof(dynamicPidType.firstPortStyle), firstPort,
                         AT_SETPORT_PARA_MAX_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(dynamicPidType.firstPortStyle), AT_SETPORT_PARA_MAX_LEN);
    memResult = memcpy_s(dynamicPidType.rewindPortStyle, sizeof(dynamicPidType.rewindPortStyle), secPort,
                         AT_SETPORT_PARA_MAX_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(dynamicPidType.rewindPortStyle), AT_SETPORT_PARA_MAX_LEN);

    /* 写入NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, (VOS_UINT8 *)&dynamicPidType,
                           sizeof(AT_DynamicPidType)) != NV_OK) {
        AT_ERR_LOG("At_SetPort:Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_OpenSpecificPort(VOS_UINT8 port)
{
    AT_DynamicPidType dynamicPidType;
    VOS_UINT32        portPos;
    VOS_UINT32        portNum;

    (VOS_VOID)memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(dynamicPidType));

    portPos = AT_DEV_NONE;

    /* 读NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE获取当前的端口状态 */
    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType))) {
        AT_WARN_LOG("AT_OpenSpecificPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断端口是否已经打开: 已经打开则直接返回AT_OK */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 查询NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE中是否已经存在该端口 */
        AT_GetSpecificPort(port, dynamicPidType.rewindPortStyle, &portPos, &portNum);

        if (portPos != AT_DEV_NONE) {
            return AT_OK;
        }

    } else {
        AT_WARN_LOG("AT_OpenSpecificPort: NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE is inactive!");
        return AT_ERROR;
    }

    /* 当前不能再增加端口 */
    if (portNum >= AT_SETPORT_PARA_MAX_LEN) {
        return AT_ERROR;
    }

    dynamicPidType.rewindPortStyle[portNum] = port;

    /* 更新端口集合数据到NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, (VOS_UINT8 *)&dynamicPidType,
                           sizeof(AT_DynamicPidType)) != NV_OK) {
        AT_ERR_LOG("AT_OpenSpecificPort: Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_CloseSpecificPort(VOS_UINT8 port)
{
    AT_DynamicPidType dynamicPidType;
    VOS_UINT32        portPos;
    VOS_UINT32        portNum;
    VOS_UINT32        loop;

    (VOS_VOID)memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(dynamicPidType));

    portPos = AT_DEV_NONE;

    /* 读NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE获取当前的端口状态 */
    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, &dynamicPidType, sizeof(AT_DynamicPidType))) {
        AT_ERR_LOG("AT_CloseSpecificPort: Read NV fail!");
        return AT_ERROR;
    }

    /* 判断该端口是否已经关闭: 已经关闭则直接返回AT_OK */
    if (dynamicPidType.nvStatus == VOS_TRUE) {
        /* 查询NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE中是否已经存在该端口 */
        AT_GetSpecificPort(port, dynamicPidType.rewindPortStyle, &portPos, &portNum);

        if (portPos == AT_DEV_NONE) {
            return AT_OK;
        }
    } else {
        return AT_ERROR;
    }

    /* 删除NV项中的指定端口 */
    dynamicPidType.rewindPortStyle[portPos] = 0;
    portNum--;

    for (loop = portPos; loop < portNum; loop++) {
        dynamicPidType.rewindPortStyle[loop] = dynamicPidType.rewindPortStyle[loop + 1UL];
    }

    dynamicPidType.rewindPortStyle[portNum] = 0;

    /* 端口异常数据保护: 切换后的设备形态中，第一个设备不能为MASS设备(0xa1,0xa2) */
    if (portNum != 0) {
        if ((dynamicPidType.rewindPortStyle[0] == AT_DEV_CDROM) || (dynamicPidType.rewindPortStyle[0] == AT_DEV_SD)) {
            return AT_ERROR;
        }
    }

    /* 更新端口集合数据到NV项NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_HUAWEI_DYNAMIC_PID_TYPE, (VOS_UINT8 *)&dynamicPidType,
                           sizeof(AT_DynamicPidType)) != NV_OK) {
        AT_ERR_LOG("AT_CloseSpecificPort: Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


TAF_UINT32 At_SetPcscInfo(TAF_UINT8 indexNum)
{
    AT_DynamicPidType dynamicPidType;
    NV_PID_EnableType pidEnableType;

    pidEnableType.pidEnabled = VOS_FALSE;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&dynamicPidType, sizeof(dynamicPidType), 0x00, sizeof(AT_DynamicPidType));

    /* 读取PID使能NV项 */
    if (NV_OK != TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PID_ENABLE_TYPE, &pidEnableType, sizeof(NV_PID_EnableType))) {
        AT_ERR_LOG("At_SetPcscInfo:Read NV31 failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回ERROR */
    if (pidEnableType.pidEnabled != VOS_TRUE) {
        AT_WARN_LOG("At_SetPcscInfo:PID is not enabled!");
        return AT_ERROR;
    }

    /*  打开PCSC口 */
    if (g_atParaList[0].paraValue == VOS_TRUE) {
        return AT_OpenSpecificPort(AT_DEV_PCSC);
    }
    /* 关闭PCSC口 */
    else {
        return AT_CloseSpecificPort(AT_DEV_PCSC);
    }
}


VOS_UINT32 At_SetCellSearch(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;
    VOS_UINT8  cellSrh;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    cellSrh = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送消息 ID_AT_MTA_WRR_CELLSRH_SET_REQ 给 AT AGENT 处理，该消息带参数(VOS_UINT8)g_atParaList[0].ulParaValue */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), ID_AT_MTA_WRR_CELLSRH_SET_REQ,
                                 &cellSrh, sizeof(cellSrh), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_WAS_MNTN_SET_CELLSRH;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetGetportmodePara(TAF_UINT8 indexNum)
{
    TAF_PH_Port  portInfo;
    TAF_PH_FmrId fmrID;
    TAF_UINT16   dataLen;
    TAF_UINT32   rslt;
    TAF_UINT32   portInfoLen;
    errno_t      memResult;

    /* 参数检查 */
    if ((g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (g_atParaList[0].paraLen == 0)) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&portInfo, sizeof(portInfo), 0x00, sizeof(TAF_PH_Port));

    memResult = strncpy_s((VOS_CHAR *)portInfo.productName.productName, sizeof(portInfo.productName.productName),
                          PRODUCTION_CARD_TYPE, PRODUCTION_CARD_TYPE_MAX_LEN);
    TAF_STRCPY_CHK_RTN_VAL_CONTINUE(memResult, sizeof(portInfo.productName.productName), PRODUCTION_CARD_TYPE_MAX_LEN);

    (VOS_VOID)memset_s(&fmrID, sizeof(fmrID), 0x00, sizeof(TAF_PH_FmrId));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_FMRID, &fmrID, sizeof(TAF_PH_FmrId)) != NV_OK) {
        AT_WARN_LOG("At_SetMsIdInfo:WARNING:NVIM Read NV_ITEM_FMRID falied!");
        return AT_ERROR;
    } else {
        memResult = memcpy_s(portInfo.fmrId.mfrId, sizeof(portInfo.fmrId.mfrId), &fmrID, sizeof(TAF_PH_FmrId));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(portInfo.fmrId.mfrId), sizeof(TAF_PH_FmrId));
    }

    portInfoLen = TAF_MAX_PORT_INFO_LEN + 1;

    rslt = (VOS_UINT32)(DRV_GET_PORT_MODE((char *)portInfo.portId.portInfo, &portInfoLen));
    if (rslt != VOS_OK) {
        AT_WARN_LOG("At_SetGetportmodePara:DRV_GET_PORT_MODE Info fail.");
        return AT_ERROR;
    }

    dataLen = (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress, "%s: ", g_parseContext[indexNum].cmdElement->cmdName);
    dataLen += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + dataLen, "%s: %s", "TYPE", portInfo.productName.productName);
    dataLen += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + dataLen, ": %s,", portInfo.fmrId.mfrId);
    dataLen += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
        (TAF_CHAR *)g_atSndCodeAddress + dataLen, "%s", portInfo.portId.portInfo);

    g_atSendDataBuff.bufLen = dataLen;
    return AT_OK;
}


TAF_UINT32 At_SetCmsrPara(TAF_UINT8 indexNum)
{
    AT_ModemSmsCtx *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数设置 */
    smsCtx->paraCmsr = (VOS_UINT8)g_atParaList[0].paraValue;

    return AT_OK;
}


TAF_UINT32 At_SetCmgiPara(TAF_UINT8 indexNum)
{
    MN_MSG_StatusTypeUint8 msgStatus;
    MN_MSG_ListParm        listPara;
    AT_ModemSmsCtx        *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&listPara, sizeof(MN_MSG_ListParm), 0x00, sizeof(MN_MSG_ListParm));

    /* 参数检查 */
    if (g_atParaIndex > 1) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 设置<stat> */
    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    } else {
        msgStatus = (VOS_UINT8)g_atParaList[0].paraValue;
    }

    listPara.changeFlag = VOS_FALSE;
    listPara.memStore   = smsCtx->cpmsInfo.memReadorDelete;
    listPara.status     = msgStatus;
    (VOS_VOID)memset_s(listPara.reserve1, sizeof(listPara.reserve1), 0x00, sizeof(listPara.reserve1));

    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_Delete_Test(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &listPara) ==
        MN_ERR_NO_ERROR) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMGI_SET;
        g_parseContext[indexNum].clientStatus = AT_FW_CLIENT_STATUS_PEND;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


TAF_UINT32 At_SetCmmtPara(TAF_UINT8 indexNum)
{
    MN_MSG_ModifyStatusParm modifyParm;
    AT_ModemSmsCtx         *smsCtx = VOS_NULL_PTR;

    smsCtx = AT_GetModemSmsCtxAddrFromClientId(indexNum);

    /* 参数过多 */
    if (g_atParaIndex > AT_CMMT_PARA_MAX_NUM) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 参数检查 */
    if ((g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_PARA_CMD) && (g_atParaList[0].paraLen == 0)) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&modifyParm, sizeof(modifyParm), 0x00, sizeof(modifyParm));

    modifyParm.index = g_atParaList[0].paraValue;

    /* 设置<stat> */
    if (g_atParaList[1].paraValue == 0) {
        modifyParm.status = MN_MSG_STATUS_MT_NOT_READ;
    } else {
        modifyParm.status = MN_MSG_STATUS_MT_READ;
    }

    /* 设置读取存储器 */
    modifyParm.memStore = smsCtx->cpmsInfo.memReadorDelete;

    /* 执行命令操作 */
    g_atClientTab[indexNum].opId = At_GetOpId();
    if (MN_MSG_ModifyStatus(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &modifyParm) ==
        MN_ERR_NO_ERROR) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMMT_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

TAF_UINT32 At_SetUssdModePara(TAF_UINT8 indexNum)
{
    USSD_TRANS_Mode ussdTranMode;
    AT_ModemSsCtx  *ssCtx = VOS_NULL_PTR;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 1) && (g_atParaList[0].paraValue != 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新全局变量 */
    ssCtx                = AT_GetModemSsCtxAddrFromClientId(indexNum);
    ssCtx->ussdTransMode = (VOS_UINT16)g_atParaList[0].paraValue;

    ussdTranMode.status        = VOS_TRUE;
    ussdTranMode.ussdTransMode = (VOS_UINT8)ssCtx->ussdTransMode;

    /* 设置完拨号模式后，给C核发送消息 */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, TAF_MSG_SET_USSDMODE_MSG,
                               (VOS_UINT8 *)&ussdTranMode, sizeof(USSD_TRANS_Mode), I0_WUEPS_PID_TAF) != TAF_SUCCESS) {
        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetAdcTempPara(TAF_UINT8 indexNum)
{
    SPY_TempThresholdPara tempPara;
    VOS_UINT32            changeFlag = AT_SPY_TEMP_THRESHOLD_PARA_UNCHANGE;
    VOS_UINT32            ret;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_ADCTEMP_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    /* 全设为无效值 */
    (VOS_VOID)memset_s(&tempPara, sizeof(tempPara), 0xFF, sizeof(tempPara));

    if (g_atParaList[0].paraLen != 0) {
        tempPara.isEnable = g_atParaList[0].paraValue;
        changeFlag        = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if (g_atParaList[1].paraLen != 0) {
        tempPara.closeAdcThreshold = (VOS_INT)g_atParaList[1].paraValue;
        changeFlag                 = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if (g_atParaList[AT_ADCTEMP_VALUE3].paraLen != 0) {
        tempPara.alarmAdcThreshold  = (VOS_INT)g_atParaList[AT_ADCTEMP_VALUE3].paraValue;
        changeFlag                  = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if (g_atParaList[AT_ADCTEMP_VALUE4].paraLen != 0) {
        tempPara.resumeAdcThreshold  = (VOS_INT)g_atParaList[AT_ADCTEMP_VALUE4].paraValue;
        changeFlag                   = AT_SPY_TEMP_THRESHOLD_PARA_CHANGE;
    }

    if (changeFlag == AT_SPY_TEMP_THRESHOLD_PARA_CHANGE) {
        /* 调用接口设置门限值 */
        /* 发消息到C核设置 热保护温度状态  */
        ret = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                     DRV_AGENT_ADC_SET_REQ, (VOS_UINT8 *)&tempPara, sizeof(tempPara),
                                     I0_WUEPS_PID_DRV_AGENT);
        if (ret != TAF_SUCCESS) {
            AT_WARN_LOG("At_SetAdcTempPara: AT_FillAndSndAppReqMsg fail.");
            return AT_ERROR;
        }

        /* 设置AT模块实体的状态为等待异步返回 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ADC_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_OK;
}


TAF_UINT32 AT_SetDwinsPara(TAF_UINT8 indexNum)
{
    VOS_UINT32  enabled;
    WINS_Config wins;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    enabled = g_atParaList[0].paraValue;
    /* 填充stWins结构体 */
    (VOS_VOID)memset_s(&wins, sizeof(wins), 0x00, sizeof(WINS_Config));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_WINS_CONFIG, &wins, sizeof(WINS_Config)) == NV_OK) {
        if ((wins.ucStatus == 1) && (enabled == wins.ucWins)) {
            AT_INFO_LOG("AT_SetDwinsPara():The content to write is same as NV's");

            /* 更新PPP的WINS设置 */
            PPP_UpdateWinsConfig((VOS_UINT8)g_atParaList[0].paraValue);

            /* 更新APS的WINS设置 */
            TAF_PS_ConfigNbnsFunction(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                      enabled);

            return AT_OK;
        }
    }

    wins.ucStatus = 1;
    wins.ucWins   = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 写入NVIM */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WINS_CONFIG, (VOS_UINT8 *)&wins, sizeof(WINS_Config)) != NV_OK) {
        return AT_ERROR;
    } else {
        /* 更新PPP的WINS设置 */
        PPP_UpdateWinsConfig((VOS_UINT8)g_atParaList[0].paraValue);

        /* 更新APS的WINS设置 */
        TAF_PS_ConfigNbnsFunction(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, enabled);

        return AT_OK;
    }
}

#if (FEATURE_MBB_CUST == FEATURE_ON)
/*
 * 函数功能:  检查设置参数的有效性
 */
LOCAL VOS_UINT32 AT_CheckVoipKeySetCmdParameter(void)
{
    VOS_UINT16 maxLength;
    if (g_atDataLocked == VOS_TRUE) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : not unlock.");
        return AT_ERROR;
    }
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : not set cmd.");
        return AT_ERROR;
    }
    /* 第一个参数不存在 */
    if (g_atParaList[0].paraLen== 0) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : no first parameter.");
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 第二个参数不存在 */
    if (g_atParaList[1].paraLen== 0) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : no second parameter.");
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 参数过多 */
    if (g_atParaIndex != AT_APN_KEY_PARA_NUM) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : parameter number is not 2!");
        return AT_ERROR;
    }
    /* 检查首个参数的有效性 */
    if (g_atParaList[0].paraValue>= AT_MAX_APN_KEY_GROUP) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : first parameter too large!");
        return AT_ERROR;
    }
    /* 输入的字符不能超过95个 */
    maxLength = AT_MAX_APN_KEY_LENGTH - 1;
    if (g_atParaList[1].paraLen> maxLength) {
        AT_WARN_LOG("AT_CheckVoipKeySetCmdParameter : second parameter lenghth error!");
        return AT_ERROR;
    }
    return AT_OK;
}

/*
 * 函数功能: 用来加密保存装备协议的APN KEY使用C核提供的加密算法
 */
VOS_UINT32 AT_SetVoipApnKeyPara(VOS_UINT8 indexNum)
{
    TAF_NVIM_ApnKeyList encrptPwd;
    VOS_INT32 ret;

    /* 特性是否打开 */
    if (AT_GetModemMbbCustCtxAddrFromClientId(indexNum)->voipApnKey == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 检查参数的有效性 */
    if (AT_CheckVoipKeySetCmdParameter() != AT_OK) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&encrptPwd, sizeof(TAF_NVIM_ApnKeyList), 0, sizeof(TAF_NVIM_ApnKeyList));
    encrptPwd.useFlag = 1; /* 有效位置为1 */
    ret = memcpy_s(encrptPwd.apnKey, MAX_ENCRPT_APN_KEY_LENGTH, g_atParaList[1].para, g_atParaList[1].paraLen);
    if (ret != EOK) {
        AT_WARN_LOG("AT_SetVoipApnKeyPara : copy voip apn key err!");
        (VOS_VOID)memset_s(&encrptPwd, sizeof(TAF_NVIM_ApnKeyList), 0, sizeof(TAF_NVIM_ApnKeyList));
        return AT_ERROR;
    }
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_VOIP_APN_KEY, (VOS_UINT8 *)&encrptPwd, sizeof(TAF_NVIM_ApnKeyList)) != NV_OK) {
        AT_WARN_LOG("AT_SetVoipApnKeyPara : write NV voip apn key err!");
        (VOS_VOID)memset_s(&encrptPwd, sizeof(TAF_NVIM_ApnKeyList), 0, sizeof(TAF_NVIM_ApnKeyList));
        return AT_ERROR;
    }
    (VOS_VOID)memset_s(&encrptPwd, sizeof(TAF_NVIM_ApnKeyList), 0, sizeof(TAF_NVIM_ApnKeyList));

    return AT_OK;
}
#endif

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

LOCAL TAF_UINT32 At_ProcCommDebugParaActUsimCard(VOS_VOID)
{
    USIMM_ActiveCardReq *msg = VOS_NULL_PTR;
    errno_t              memResult;

    msg = (USIMM_ActiveCardReq *)VOS_AllocMsg(WUEPS_PID_AT, sizeof(USIMM_ActiveCardReq) - VOS_MSG_HEAD_LENGTH);

    if (msg == VOS_NULL_PTR) {
        LogPrint("At_ProcCommDebugParaActUsimCard:AllocMsg Failed.");

        return VOS_ERR;
    }

    /* 初始化消息 */
    memResult = memset_s((VOS_CHAR *)msg + VOS_MSG_HEAD_LENGTH,
                         (VOS_SIZE_T)(sizeof(USIMM_ActiveCardReq) - VOS_MSG_HEAD_LENGTH), 0x00,
                         (VOS_SIZE_T)(sizeof(USIMM_ActiveCardReq) - VOS_MSG_HEAD_LENGTH));
    TAF_MEM_CHK_RTN_VAL(memResult, (VOS_SIZE_T)(sizeof(USIMM_ActiveCardReq) - VOS_MSG_HEAD_LENGTH),
                        (VOS_SIZE_T)(sizeof(USIMM_ActiveCardReq) - VOS_MSG_HEAD_LENGTH));

    VOS_SET_RECEIVER_ID(msg, WUEPS_PID_USIM);
    msg->msgHeader.msgName = USIMM_ACTIVECARD_REQ;

    if (TAF_TraceAndSendMsg(WUEPS_PID_AT, msg) != VOS_OK) {
        LogPrint("At_ProcCommDebugParaActUsimCard:sndmsg Failed.");
    }

    return AT_OK;
}



TAF_UINT32 At_SetCommDebugPara(TAF_UINT8 indexNum)
{
    SPY_TempThresholdPara       tempPara;
    TAF_AT_NvimCommdegbugCfg    debugFlag;
    VOS_UINT16                  flag;

#if (VOS_WIN32 == VOS_OS_VER)
    const VOS_UINT8             filelist[] = { 0x6f, 0x43 };
#endif

    debugFlag.commDebugFlag = VOS_FALSE;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 全设为无效值 */
    (VOS_VOID)memset_s(&tempPara, sizeof(tempPara), 0xFF, sizeof(tempPara));

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch (g_atParaList[0].paraValue) {
        case 0x00:
            /* 去激活所有Debug功能 */
            if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, &(debugFlag.commDebugFlag),
                                  sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag0 Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if (debugFlag.commDebugFlag != 0x00) {
                debugFlag.commDebugFlag = 0x00;

                if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, (VOS_UINT8 *)&(debugFlag.commDebugFlag),
                                       sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag0 Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }
            }

            break;
        case 0x01:
            /* 使能DRX定位信息上报功能 */
            if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, &(debugFlag.commDebugFlag),
                                  sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if ((debugFlag.commDebugFlag & 0x01) != 0x01) {
                debugFlag.commDebugFlag |= 0x01;

                if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, (VOS_UINT8 *)&(debugFlag.commDebugFlag),
                                       sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }
            }

            break;
        case 0x03:
            /* 使能USIMM初始化信息记录功能 */
            if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, &(debugFlag.commDebugFlag),
                                  sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_READ Debug Flag2 Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            if ((debugFlag.commDebugFlag & 0x02) != 0x02) {
                debugFlag.commDebugFlag |= 0x02;

                if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_COMMDEGBUG_CFG, (VOS_UINT8 *)&(debugFlag.commDebugFlag),
                                       sizeof(TAF_AT_NvimCommdegbugCfg)) != NV_OK) {
                    LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Debug Flag2 Fail\r\n");

                    return AT_CME_OPERATION_NOT_ALLOWED;
                }
            }

            break;

        case 0x05:

            flag = 1;

            if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_USIM_DEBUG_MODE_SET, (VOS_UINT8 *)&flag, sizeof(VOS_UINT16)) !=
                NV_OK) {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Usim Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            break;

        case 0x06:

            flag = 0;

            if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_USIM_DEBUG_MODE_SET, (VOS_UINT8 *)&flag, sizeof(VOS_UINT16)) !=
                NV_OK) {
                LogPrint("At_SetOamDebugPara:TAF_ACORE_NV_WRITE Usim Debug Flag Fail\r\n");

                return AT_CME_OPERATION_NOT_ALLOWED;
            }

            break;

        case 0x07:
            /* 拆圈 */
            return At_ProcCommDebugParaActUsimCard();


        default:
            break;
    }

    return AT_OK;
}


TAF_UINT32 At_SetYjcxPara(TAF_UINT8 indexNum)
{
    VOS_UINT32 rst;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_YJCX_SET_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_YJCX_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetPhyInitPara(VOS_UINT8 indexNum)
{
    VOS_UINT32        rst;
    AT_MTA_PhyInitReq phyInit;

    /* 结构体重置 */
    (VOS_VOID)memset_s(&phyInit, sizeof(phyInit), 0x00, sizeof(AT_MTA_PhyInitReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 0) {
        return AT_TOO_MANY_PARA;
    }

    /* 向MTA发送消息通知物理层初始化 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), ID_AT_MTA_PHY_INIT_REQ,
                                 (VOS_UINT8 *)(&phyInit), sizeof(phyInit), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PHYINIT_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetDockPara(VOS_UINT8 indexNum)
{
    VOS_UINT8  clientIndex;
    VOS_UINT16 length;

    length = 0;

    if (g_atClientTab[indexNum].userType != AT_APP_USER) {
        return AT_FAILURE;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_FAILURE;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_FAILURE;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_FAILURE;
    }

    (VOS_VOID)memset_s(g_atParaList[0].para + g_atParaList[0].paraLen, AT_PARA_MAX_LEN - g_atParaList[0].paraLen,
             0x00, AT_PARA_MAX_LEN - g_atParaList[0].paraLen);

    for (clientIndex = 0; clientIndex < AT_MAX_CLIENT_NUM; clientIndex++) {
        if (g_atClientTab[clientIndex].userType == AT_USBCOM_USER) {
            length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress + length, "%s%s%s", g_atCrLf, g_atParaList[0].para, g_atCrLf);
            At_SendResultData(clientIndex, g_atSndCodeAddress, length);
            break;
        }
    }

    return AT_SUCCESS;
}
#endif


TAF_UINT32 At_SetAt2OmPara(TAF_UINT8 indexNum)
{
    CBTCPM_RCV_FUNC     cbtRcvFunc = VOS_NULL_PTR;
    DMS_PortIdUint16    portId;

    portId = AT_GetDmsPortIdByClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 该命令无输入参数 */
    if (g_atParaIndex != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* ucIndex所对应的AT通道不是AT/OM通道 */
    if (
#if (FEATURE_AT_HSUART == FEATURE_ON)
        (portId != DMS_PORT_HSUART) &&
#endif
        (portId != DMS_PORT_PCUI) && (portId != DMS_PORT_UART) &&
        (portId != DMS_PORT_CTRL) && (portId != DMS_PORT_PCUI2)) {
        return AT_ERROR;
    }

    /* 检查是否已有处于OM模式的AT通道 */
    if (DMS_PORT_IsExistCbtPort() == VOS_TRUE) {
        return AT_ERROR;
    }


    DMS_PORT_SwitchToOmDataMode(portId, cbtRcvFunc);


    return AT_OK;
}


VOS_UINT32 AT_GetOperatorNameFromParam(VOS_UINT16 *operNameLen, VOS_CHAR *operName, VOS_UINT16 bufSize,
                                       VOS_UINT32 formatType)
{
    errno_t memResult;
    if ((formatType == AT_COPS_LONG_ALPH_TYPE) && (bufSize > g_atParaList[AT_COPS_OPER].paraLen) &&
        (g_atParaList[AT_COPS_OPER].paraLen != 0) && (g_atParaList[AT_COPS_OPER].paraLen <= TAF_PH_OPER_NAME_LONG)) {
        memResult = memcpy_s((VOS_CHAR *)operName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR *)g_atParaList[AT_COPS_OPER].para,
                             g_atParaList[AT_COPS_OPER].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_PH_OPER_NAME_LONG, g_atParaList[AT_COPS_OPER].paraLen);
        operName[g_atParaList[AT_COPS_OPER].paraLen] = 0;
        *operNameLen                                 = g_atParaList[AT_COPS_OPER].paraLen;

        return AT_OK;
    } else if ((formatType == AT_COPS_SHORT_ALPH_TYPE) && (bufSize > g_atParaList[AT_COPS_OPER].paraLen) &&
               (g_atParaList[AT_COPS_OPER].paraLen != 0) &&
               (g_atParaList[AT_COPS_OPER].paraLen <= TAF_PH_OPER_NAME_LONG)) {
        memResult = memcpy_s((VOS_CHAR *)operName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR *)g_atParaList[AT_COPS_OPER].para,
                             g_atParaList[AT_COPS_OPER].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_PH_OPER_NAME_LONG, g_atParaList[AT_COPS_OPER].paraLen);
        operName[g_atParaList[AT_COPS_OPER].paraLen] = 0;
        *operNameLen                                 = g_atParaList[AT_COPS_OPER].paraLen;

        return AT_OK;
    } else if ((bufSize > g_atParaList[AT_COPS_OPER].paraLen) &&
               ((g_atParaList[AT_COPS_OPER].paraLen == AT_COPS_SHORT_OPER_LEN) ||
                (g_atParaList[AT_COPS_OPER].paraLen == AT_COPS_FULL_OPER_LEN)) &&
                (g_atParaList[AT_COPS_OPER].paraLen <= TAF_PH_OPER_NAME_LONG)) {
        memResult = memcpy_s((VOS_CHAR *)operName, TAF_PH_OPER_NAME_LONG, (VOS_CHAR *)g_atParaList[AT_COPS_OPER].para,
                             g_atParaList[AT_COPS_OPER].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_PH_OPER_NAME_LONG, g_atParaList[AT_COPS_OPER].paraLen);
        operName[g_atParaList[AT_COPS_OPER].paraLen] = 0;
        *operNameLen                                 = g_atParaList[AT_COPS_OPER].paraLen;

        return AT_OK;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }
}

VOS_UINT32 At_SetCpolPara(VOS_UINT8 indexNum)
{
    TAF_PH_SetPrefplmn prefPlmn;
    VOS_UINT32         rst;
    AT_ModemNetCtx    *netCtx = VOS_NULL_PTR;

    netCtx = AT_GetModemNetCtxAddrFromClientId(indexNum);

    (VOS_VOID)memset_s(&prefPlmn, sizeof(prefPlmn), 0x00, sizeof(prefPlmn));

    /* 参数过多 */
#if (FEATURE_UE_MODE_NR == FEATURE_ON) && (FEATURE_LTE == FEATURE_ON)
    if (g_atParaIndex > AT_UE_MODE_NR_AND_LTE_AT_CPOL_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#elif (FEATURE_LTE == FEATURE_ON) || (FEATURE_UE_MODE_NR == FEATURE_ON)
    if (g_atParaIndex > AT_UE_MODE_NR_OR_LTE_AT_CPOL_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#else
    if (g_atParaIndex > AT_OTHER_MODE_AT_CPOL_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    if ((g_atParaIndex == AT_CPOL_PARA_NUM) && (g_atParaList[AT_CPOL_INDEX].paraLen == 0) &&
        (g_atParaList[AT_CPOL_FORMAT].paraLen != 0)) {
        /*
         * 当前只存在<format>，如果当前对应的<oper>能够获取，则读取命令中<oper>
         * 的format需要改变
         */
        netCtx->cpolFormatType = (AT_COPS_FORMAT_TYPE)g_atParaList[AT_CPOL_FORMAT].paraValue;
        return AT_OK;
    }

    if (netCtx->prefPlmnType > MN_PH_PREF_PLMN_HPLMN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 保存参数到结构中，发送给MMA进行处理 */
    prefPlmn.prefPlmnType     = netCtx->prefPlmnType;
    prefPlmn.atParaIndex      = g_atParaIndex;
    prefPlmn.indexLen         = g_atParaList[AT_CPOL_INDEX].paraLen;
    prefPlmn.index            = g_atParaList[AT_CPOL_INDEX].paraValue;
    prefPlmn.formatLen        = g_atParaList[AT_CPOL_FORMAT].paraLen;
    prefPlmn.format           = g_atParaList[AT_CPOL_FORMAT].paraValue;
    prefPlmn.gsmRatLen        = g_atParaList[AT_CPOL_GSM_ACTN].paraLen;
    prefPlmn.gsmRat           = g_atParaList[AT_CPOL_GSM_ACTN].paraValue;
    prefPlmn.gsmCompactRatLen = g_atParaList[AT_CPOL_GSM_COMPACT_ACTN].paraLen;
    prefPlmn.gsmCompactRat    = g_atParaList[AT_CPOL_GSM_COMPACT_ACTN].paraValue;
    prefPlmn.utrnLen          = g_atParaList[AT_CPOL_UTRAN].paraLen;
    prefPlmn.utrn             = g_atParaList[AT_CPOL_UTRAN].paraValue;

#if (FEATURE_UE_MODE_NR == FEATURE_ON) && (FEATURE_LTE == FEATURE_ON)
    prefPlmn.eutrnLen = g_atParaList[AT_CPOL_E_UTRAN].paraLen;
    prefPlmn.eutrn    = g_atParaList[AT_CPOL_E_UTRAN].paraValue;
    prefPlmn.nrRatLen = g_atParaList[AT_CPOL_RAT].paraLen;
    prefPlmn.nrRat    = g_atParaList[AT_CPOL_RAT].paraValue;
#elif (FEATURE_LTE == FEATURE_ON)
    /* LTE的接入技术以及长度 */
    prefPlmn.eutrnLen = g_atParaList[AT_CPOL_E_UTRAN].paraLen;
    prefPlmn.eutrn    = g_atParaList[AT_CPOL_E_UTRAN].paraValue;
#elif (FEATURE_UE_MODE_NR == FEATURE_ON)
    prefPlmn.usNrRatLen = g_atParaList[AT_CPOL_E_UTRAN].paraLen;
    prefPlmn.ulNrRat    = g_atParaList[AT_CPOL_E_UTRAN].paraValue;
#else
#endif

    if (prefPlmn.formatLen == 0) {
        prefPlmn.formatLen = 1;
        prefPlmn.format    = AT_COPS_NUMERIC_TYPE;
    }

    netCtx->cpolFormatType = (AT_COPS_FORMAT_TYPE)prefPlmn.format;

    if (g_atParaList[AT_CPOL_OPER].paraLen != 0) {
        rst = AT_GetOperatorNameFromParam(&prefPlmn.operNameLen, prefPlmn.operName, sizeof(prefPlmn.operName),
                                          prefPlmn.format);
        if (rst != AT_OK) {
            return rst;
        }
    }

    if (TAF_MMA_SetCpolReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &prefPlmn) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPOL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

VOS_UINT32 At_SetCplsPara(VOS_UINT8 indexNum)
{
    VOS_UINT32              rst;
    MN_PH_PrefPlmnTypeUint8 prefPlmnType;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        prefPlmnType = (MN_PH_PrefPlmnTypeUint8)g_atParaList[0].paraValue;
    } else {
        prefPlmnType = MN_PH_PREF_PLMN_UPLMN;
    }

    if (prefPlmnType > MN_PH_PREF_PLMN_HPLMN) {
        return AT_CME_OPERATION_NOT_SUPPORTED;
    }

    /* 发送消息 ID_TAF_MMA_PREF_PLMN_TYPE_SET_REQ 给 MMA 处理 */
    rst = TAF_MMA_SetPrefPlmnTypeReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                     &prefPlmnType); /* 要求设置的优先网络类型 */

    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MMA_SET_PREF_PLMN_TYPE;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

TAF_UINT32 At_SetpidPara(TAF_UINT8 indexNum)
{
    TAF_UINT32 rslt;
    TAF_UINT8  diagValue;

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraValue != 1) && (g_atParaList[0].paraValue != 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    diagValue = (VOS_UINT8)g_atParaList[0].paraValue;

    rslt = (VOS_UINT32)(DRV_SET_PID(diagValue));
    if (rslt != VOS_OK) {
        AT_WARN_LOG("At_SetpidPara:Setpid fail.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetOpwordParaForApModem(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_SetOpwordPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 checkRlst       = VOS_FALSE;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;
    VOS_UINT32 result;

    /* 读取NV项中当前产品形态 */
    systemAppConfig = AT_GetSystemAppConfigAddr();

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    /* 已经具有权限  直接返回OK */
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_YES) {
        return AT_OK;
    }

    /* 若当前设备的形态为AP-MODEM */
    if (*systemAppConfig == SYSTEM_APP_ANDROID) {
        result = AT_SetOpwordParaForApModem(indexNum);
        return result;
    }

    /* 输入密码超长 */
    if (g_atParaList[0].paraLen > AT_DISLOG_PWD_LEN) {
        return AT_ERROR;
    }

    /* 密码比较 */
    if (VOS_StrLen((VOS_CHAR *)g_atOpwordPwd) == 0) {
        /* NV中密码为空则输入任何密码都能获取权限 */
        checkRlst = VOS_TRUE;
    } else {
        if (VOS_StrCmp((VOS_CHAR *)g_atOpwordPwd, (VOS_CHAR *)g_atParaList[0].para) == 0) {
            checkRlst = VOS_TRUE;
        }
    }

    if (checkRlst == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 密码比对成功  获取权限 */
    g_ate5RightFlag = AT_E5_RIGHT_FLAG_YES;

    /* 按D25的做法  不保存权限标志 */

    return AT_OK;
}


VOS_UINT32 AT_SetCpwordPara(VOS_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 已经不具有权限 */
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_NO) {
        return AT_OK;
    }

    /* 释放权限 */
    g_ate5RightFlag = AT_E5_RIGHT_FLAG_NO;

    /* 按D25的做法  不保存权限标志 */

    return AT_OK;
}


VOS_UINT32 AT_SetDislogPara(VOS_UINT8 indexNum)
{
    VOS_UINT32        ret;
    NV_PID_EnableType pidEnableType;

#if (FEATURE_LTE == FEATURE_ON)
    VOS_UINT32 retDiag;
    VOS_UINT32 ret3GDiag;
    VOS_UINT32 retGps;
#endif

    pidEnableType.pidEnabled = VOS_FALSE;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaIndex > 1)) {
        return AT_ERROR;
    }

    /* 读取PID使能NV项 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PID_ENABLE_TYPE, &pidEnableType, sizeof(NV_PID_EnableType)) != NV_OK) {
        AT_ERR_LOG("AT_SetDislogPara:Read NV failed!");
        return AT_ERROR;
    }

    /* NV读取成功，检查PID是否使能，若不使能，返回AT_OK */
    if (pidEnableType.pidEnabled != VOS_TRUE) {
        AT_WARN_LOG("AT_SetDislogPara:PID is not enabled");
        return AT_OK;
    }

    /*  打开DIAG口 */
    if (g_atParaList[0].paraValue == AT_DISLOG_DIAG_OPEN) {
#if (FEATURE_LTE == FEATURE_ON)
        ret3GDiag = AT_OpenSpecificPort(AT_DEV_DIAG);
        retDiag   = AT_OpenSpecificPort(AT_DEV_4G_DIAG);
        retGps    = AT_OpenSpecificPort(AT_DEV_4G_GPS);

        if ((retDiag == AT_OK) && (retGps == AT_OK) && (ret3GDiag == AT_OK)) {
            ret = AT_OK;
        } else {
            ret = AT_ERROR;
        }
#else
        ret = AT_OpenDiagPort();
#endif
        return ret;
    }

    /* 关闭DIAG口 */
    if (g_atParaList[0].paraValue == AT_DISLOG_DIAG_CLOSE) {
#if (FEATURE_LTE == FEATURE_ON)
        ret3GDiag = AT_CloseSpecificPort(AT_DEV_DIAG);
        retDiag   = AT_CloseSpecificPort(AT_DEV_4G_DIAG);
        retGps    = AT_CloseSpecificPort(AT_DEV_4G_GPS);

        if ((retDiag == AT_OK) && (retGps == AT_OK) && (ret3GDiag == AT_OK)) {
            ret = AT_OK;
        } else {
            ret = AT_ERROR;
        }

#else
        ret = AT_CloseDiagPort();
#endif
        return ret;
    }

    return AT_ERROR;
}
#if (FEATURE_SECURITY_SHELL == FEATURE_ON)

VOS_UINT32 AT_SetSpwordPara(VOS_UINT8 indexNum)
{
    errno_t memResult;
    VOS_UINT32 i;
    DRV_AGENT_SpwordSetReq spwordSetReq;

    /* 如果超过三次，则在系统重新启动前不再处理该命令，直接返回Error */
    if (g_spWordCtx.errTimes >= AT_SHELL_PWD_VERIFY_MAX_TIMES) {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Verify Max Times!");
        return AT_ERROR;
    }

    /* 一旦AT^SPWORD命令校验成功，系统不再对用户以后输入的AT^SPWORD命令进行处理，直接返回ERROR */
    if (g_spWordCtx.shellPwdCheckFlag == VOS_TRUE) {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Not need Verified!");
        return AT_ERROR;
    }

    /* 有且仅有一个参数，参数长度为8 */
    if ((g_atParaIndex > 1) || (g_atParaList[0].paraLen != AT_SHELL_PWD_LEN)) {
        AT_WARN_LOG("AT_SetSpwordPara:WARNING: Parameter error!");
        return AT_ERROR;
    }

    /* 参数只能为字符0-9 */
    for (i = 0; i < AT_SHELL_PWD_LEN; i++) {
        if ((g_atParaList[0].para[i] < '0') || (g_atParaList[0].para[i] > '9')) {
            AT_WARN_LOG("AT_SetSpwordPara:WARNING: PWD NOT 0-9!");
            return AT_ERROR;
        }
    }

    /* 密码校验需要在C核实现 */
    memResult = memcpy_s(spwordSetReq.shellPwd, (VOS_SIZE_T)sizeof(spwordSetReq.shellPwd),
                         (VOS_CHAR *)g_atParaList[0].para, AT_SHELL_PWD_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, (VOS_SIZE_T)sizeof(spwordSetReq.shellPwd), AT_SHELL_PWD_LEN);

    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, DRV_AGENT_SPWORD_SET_REQ,
                               (VOS_UINT8 *)&spwordSetReq, sizeof(spwordSetReq),
                               I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SPWORD_SET; /* 设置当前操作模式 */
        (VOS_VOID)memset_s(&spwordSetReq, sizeof(spwordSetReq), 0x00, sizeof(spwordSetReq));
        return AT_WAIT_ASYNC_RETURN; /* 等待异步事件返回 */
    } else {
        (VOS_VOID)memset_s(&spwordSetReq, sizeof(spwordSetReq), 0x00, sizeof(spwordSetReq));
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetShellPara(VOS_UINT8 indexNum)
{
    AT_ShellOpenFlagUint32 tmpOpenFlag;

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    /*  WIFI使用SHELL口 */
    if (g_atParaList[0].paraValue == AT_SHELL_WIFI_USE) {
        /* 保存WIFI使用SHELL结果到NV项 */
        tmpOpenFlag = AT_SHELL_OPEN_FLAG_WIFI;
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, (VOS_UINT8 *)&tmpOpenFlag,
                               sizeof(tmpOpenFlag)) != NV_OK) {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");
            return AT_ERROR;
        }

        return AT_OK;
    }

    /*  打开SHELL口 */
    if (g_atParaList[0].paraValue == AT_SHELL_OPEN) {
        /* 判断CK是否校验通过 */
        if (g_spWordCtx.shellPwdCheckFlag != VOS_TRUE) {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");

            return AT_ERROR;
        }

        /* 保存打开结果到NV项 */
        tmpOpenFlag = AT_SHELL_OPEN_FLAG_OPEN;
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, (VOS_UINT8 *)&tmpOpenFlag,
                               sizeof(tmpOpenFlag)) != NV_OK) {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");

            return AT_ERROR;
        }

        return AT_OK;
    }

    /* 关闭SHELL口 */
    if (g_atParaList[0].paraValue == AT_SHELL_CLOSE) {
        /* 保存当前SHELL口的关闭状态到NV项 */
        tmpOpenFlag = AT_SHELL_OPEN_FLAG_CLOSE;
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_AT_SHELL_OPEN_FLAG, (VOS_UINT8 *)&tmpOpenFlag,
                               sizeof(tmpOpenFlag)) != NV_OK) {
            AT_WARN_LOG("AT_SetShellPara:WARNING:TAF_ACORE_NV_WRITE SHELL_OPEN_FLAG faild!");
            return AT_ERROR;
        }

        return AT_OK;
    }

    return AT_ERROR;
}
#endif

#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetRsrpCfgPara(VOS_UINT8 indexNum)
{
    TAF_NVIM_LteRsrpCfg rsrpCfg;
    VOS_UINT32   rsrpLevel;

    (VOS_VOID)memset_s(&rsrpCfg, sizeof(rsrpCfg), 0x00, sizeof(rsrpCfg));

    /* 参数检查 */
    if ((g_atParaList[AT_RSRPCFG_LEVEL].paraLen == 0) || (g_atParaList[AT_RSRPCFG_VALUE].paraLen == 0) ||
        (g_atParaIndex != AT_RSRPCFG_PARA_VALID_NUM)) {
        return AT_ERROR;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_TAF_LTE_RSRP_CFG, &rsrpCfg, sizeof(rsrpCfg)) != NV_OK) {
        PS_PRINTF_WARNING("<AT_SetRsrpCfgPara> WARNING:TAF_ACORE_NV_READ RSRP faild!\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    rsrpLevel = g_atParaList[0].paraValue;
    rsrpCfg.level[rsrpLevel] = (VOS_INT16)(g_atParaList[AT_RSRPCFG_LEVEL].paraValue);
    rsrpCfg.value[rsrpLevel] = (VOS_INT16)(g_atParaList[AT_RSRPCFG_VALUE].paraValue);
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_YES) {
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_TAF_LTE_RSRP_CFG, (VOS_UINT8 *)&rsrpCfg, sizeof(rsrpCfg)) != NV_OK) {
            PS_PRINTF_WARNING("<AT_SetRsrpCfgPara> WARNING:TAF_ACORE_NV_WRITE RSRP faild!\n");
            return AT_ERROR;
        }
    } else {
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif

#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetRscpCfgPara(VOS_UINT8 indexNum)
{
    TAF_NVIM_LteRscpCfg rscpCfg;
    VOS_UINT32   rscpLevel;

    (VOS_VOID)memset_s(&rscpCfg, sizeof(rscpCfg), 0x00, sizeof(rscpCfg));

    /* 参数检查 */
    if ((g_atParaList[AT_RSCPCFG_LEVEL].paraLen == 0) || (g_atParaList[AT_RSCPCFG_VALUE].paraLen == 0) ||
        (g_atParaIndex != AT_RSCPCFG_PARA_VALID_NUM)) {
        PS_PRINTF_WARNING("RSCP para error\n");
        return AT_ERROR;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_TAF_LTE_RSCP_CFG, &rscpCfg, sizeof(rscpCfg)) != NV_OK) {
        PS_PRINTF_WARNING("RSCP read error!\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    rscpLevel = g_atParaList[AT_RSCPCFG_LEVEL].paraValue;
    rscpCfg.level[rscpLevel] = (VOS_INT16)(g_atParaList[AT_RSCPCFG_LEVEL].paraValue);
    rscpCfg.value[rscpLevel] = (VOS_INT16)(g_atParaList[AT_RSCPCFG_VALUE].paraValue);
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_YES) {
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_TAF_LTE_RSCP_CFG, (VOS_UINT8 *)&rscpCfg, sizeof(rscpCfg)) != NV_OK) {
            PS_PRINTF_WARNING("RSCP NV write error\n");
            return AT_ERROR;
        }
    } else {
        PS_PRINTF_WARNING("RSCP write limit\n");
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif
#if (FEATURE_LTE == FEATURE_ON)



VOS_UINT32 AT_SetEcioCfgPara(VOS_UINT8 indexNum)
{
    TAF_NVIM_LteEcioCfg ecioCfg;
    VOS_UINT32   ecioLevel;

    (VOS_VOID)memset_s(&ecioCfg, sizeof(ecioCfg), 0x00, sizeof(ecioCfg));

    /* 参数检查 */
    if ((g_atParaList[AT_ECIOCFG_LEVEL].paraLen == 0) || (g_atParaList[AT_ECIOCFG_VALUE].paraLen == 0) ||
        (g_atParaIndex != AT_ECIOCFG_PARA_VALID_NUM)) {
        PS_PRINTF_WARNING("ECIO para error\n");
        return AT_ERROR;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_TAF_LTE_ECIO_CFG, &ecioCfg, sizeof(ecioCfg)) != NV_OK) {
        PS_PRINTF_WARNING("ECIO read error\n");
        return AT_ERROR;
    }

    /* 根据输入值设置NV项 */
    ecioLevel = g_atParaList[AT_ECIOCFG_LEVEL].paraValue;
    ecioCfg.level[ecioLevel] = (VOS_INT16)(g_atParaList[AT_ECIOCFG_LEVEL].paraValue);
    ecioCfg.value[ecioLevel] = (VOS_INT16)(g_atParaList[AT_ECIOCFG_VALUE].paraValue);
    if (g_ate5RightFlag == AT_E5_RIGHT_FLAG_YES) {
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_TAF_LTE_ECIO_CFG, (VOS_UINT8 *)&ecioCfg, sizeof(ecioCfg)) != NV_OK) {
            PS_PRINTF_WARNING("ECIO write error\n");
            return AT_ERROR;
        }
    } else {
        PS_PRINTF_WARNING("ECIO write limit\n");
        return AT_ERROR; /* 如果权限未打开，返回ERROR */
    }

    return AT_OK;
}
#endif

#if (FEATURE_DSDS == FEATURE_ON)

VOS_UINT32 At_SetPsProtectModePara(VOS_UINT8 indexNum)
{
    VOS_UINT32             rst;
    AT_MTA_RrcProtectPsReq psProtectSetPara;

    /* 结构体重置 */
    (VOS_VOID)memset_s(&psProtectSetPara, sizeof(psProtectSetPara), 0x00, sizeof(AT_MTA_RrcProtectPsReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    psProtectSetPara.psProtectFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 向MTA发送消息通知PS PROTECT */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), ID_AT_MTA_RRC_PROTECT_PS_REQ,
                                 (VOS_UINT8 *)(&psProtectSetPara), sizeof(psProtectSetPara), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PSPROTECTMODE_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 AT_SetWifiGlobalMacPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;
    VOS_UINT8  e5GwMacAddr[AT_MAC_ADDR_LEN + 1]; /* MAC地址 */
    errno_t    stringRet;

    if (g_atParaIndex != 1) {
        AT_NORM_LOG("AT_SetApMacPara: the number of parameters is error.");
        return AT_ERROR;
    }

    if (g_atParaList[0].paraLen > AT_MAC_ADDR_LEN) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(e5GwMacAddr, sizeof(e5GwMacAddr), 0x00, sizeof(e5GwMacAddr));

    /* 写MAC地址参数到NV */
    stringRet = strncpy_s((VOS_CHAR *)e5GwMacAddr, sizeof(e5GwMacAddr), (VOS_CHAR *)g_atParaList[0].para,
                          g_atParaList[0].paraLen);
    TAF_STRCPY_CHK_RTN_VAL_CONTINUE(stringRet, sizeof(e5GwMacAddr), g_atParaList[0].paraLen);

    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WIFI_MAC_ADDR, e5GwMacAddr, AT_MAC_ADDR_LEN);

    if (ret != NV_OK) {
        AT_WARN_LOG("AT_SetApMacPara: Fail to write nv.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCsqlvlPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_CSQLVL_QRY_REQ, VOS_NULL_PTR, 0,
                                    I0_UEPS_PID_MTA);
    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSQLVL_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCsqlvlPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCsqlvlExtPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_CSQLVL_QRY_REQ, VOS_NULL_PTR, 0,
                                    I0_UEPS_PID_MTA);

    if (result == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSQLVLEXT_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCsqlvlExtPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetOpenportPara(VOS_UINT8 indexNum)
{
    /*
     * 能在这里处理OPENPORT, 要么是已经有权限了再输入OPENPORT,直接返回OK
     * 要么是没开启密码保护, 也直接返回OK
     */
    return AT_OK;
}
#endif


VOS_UINT32 AT_CheckIpv6Capability(VOS_UINT8 pdpType)
{
    switch (AT_GetIpv6Capability()) {
        case AT_IPV6_CAPABILITY_IPV4_ONLY:
            /* IPv4 only只能发起IPv4的PDP激活 */
            if (pdpType != TAF_PDP_IPV4) {
                AT_ERR_LOG("AT_CheckIpv6Capablity: Only IPv4 is supported!");
                return VOS_ERR;
            }
            break;

        case AT_IPV6_CAPABILITY_IPV6_ONLY:
            /* IPv6 only只能发起IPv6的PDP激活 */
            if (pdpType != TAF_PDP_IPV6) {
                AT_ERR_LOG("AT_CheckIpv6Capablity: Only IPv6 is supported!");
                return VOS_ERR;
            }
            break;

        default:
            break;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetNdisdupPara(VOS_UINT8 indexNum)
{
    VOS_UINT32              rslt;
    TAF_IFACE_UserTypeUint8 userType;

    userType = AT_PS_GetUserType(indexNum);

    if (userType == TAF_IFACE_USER_TYPE_BUTT) {
        /* 在V2版本中，其它端口下输入该命令，直接返回OK */
        AT_ERR_LOG("AT_SetNdisdupPara: User Type is Butt!");
        return AT_OK;
    }

    /* 检查参数有效性 */
    rslt = AT_PS_ValidateDialParam(indexNum, userType);

    if (rslt != AT_SUCCESS) {
        /* 记录PS域呼叫错误码 */
        AT_PS_SetPsCallErrCause(indexNum, TAF_PS_CAUSE_INVALID_PARAMETER);

        return rslt;
    }

    return AT_PS_ProcIfaceCmd(indexNum, userType);
}

/*
 * Description: ^AUTHDATA=<cid>[,<Auth_type>[<PLMN>[,<passwd>[,<username>]]]
 * History:
 *  1.Date: 2009-08-27
 *    Modification: Created function
 */
TAF_UINT32 At_SetAuthdataPara(TAF_UINT8 indexNum)
{
    TAF_AUTHDATA_Ext authDataInfo;
    errno_t          memResult;

    (VOS_VOID)memset_s(&authDataInfo, sizeof(authDataInfo), 0x00, sizeof(TAF_AUTHDATA_Ext));

    /* 若无参数，则直接返回OK */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_AUTHDATA_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    authDataInfo.cid = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 如果参数只有<CID>, 无需检查其它参数 */
    if (g_atParaIndex == 1) {
        authDataInfo.defined = VOS_FALSE;
    } else {
        authDataInfo.defined = VOS_TRUE;

        /* 设置<Auth_type> */
        if (g_atParaList[1].paraLen != 0) {
            authDataInfo.opAuthType = VOS_TRUE;
            authDataInfo.authType   = (VOS_UINT8)g_atParaList[1].paraValue;
        }

        /* 设置<PLMN> */
        if (g_atParaList[AT_AUTHDATA_PLMN].paraLen > TAF_MAX_AUTHDATA_PLMN_LEN) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_AUTHDATA_PLMN].paraLen != 0) {
            authDataInfo.opPlmn = VOS_TRUE;

            memResult = memcpy_s((VOS_CHAR *)authDataInfo.plmn, sizeof(authDataInfo.plmn),
                                 (VOS_CHAR *)g_atParaList[AT_AUTHDATA_PLMN].para,
                                 g_atParaList[AT_AUTHDATA_PLMN].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authDataInfo.plmn), g_atParaList[AT_AUTHDATA_PLMN].paraLen);
            authDataInfo.plmn[g_atParaList[AT_AUTHDATA_PLMN].paraLen] = 0;
        }

        /* 设置<username> */
        if (g_atParaList[AT_AUTHDATA_USERNAME_INDEX].paraLen > TAF_MAX_AUTHDATA_USERNAME_LEN) {
            (VOS_VOID)memset_s(&authDataInfo, sizeof(authDataInfo), 0x00, sizeof(TAF_AUTHDATA_Ext));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_AUTHDATA_USERNAME_INDEX].paraLen != 0) {
            authDataInfo.opUserName = VOS_TRUE;

            memResult = memcpy_s((VOS_CHAR *)authDataInfo.userName, sizeof(authDataInfo.userName),
                                 (VOS_CHAR *)g_atParaList[AT_AUTHDATA_USERNAME_INDEX].para,
                                 g_atParaList[AT_AUTHDATA_USERNAME_INDEX].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authDataInfo.userName),
                                g_atParaList[AT_AUTHDATA_USERNAME_INDEX].paraLen);
            authDataInfo.userName[g_atParaList[AT_AUTHDATA_USERNAME_INDEX].paraLen] = 0;
        }

        /* 设置<passwd> */
        if (g_atParaList[AT_AUTHDATA_PASSWD_INDEX].paraLen > TAF_MAX_AUTHDATA_PASSWORD_LEN) {
            (VOS_VOID)memset_s(&authDataInfo, sizeof(authDataInfo), 0x00, sizeof(TAF_AUTHDATA_Ext));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaList[AT_AUTHDATA_PASSWD_INDEX].paraLen != 0) {
            authDataInfo.opPassWord = VOS_TRUE;

            memResult = memcpy_s((VOS_CHAR *)authDataInfo.passWord, sizeof(authDataInfo.passWord),
                                 (VOS_CHAR *)g_atParaList[AT_AUTHDATA_PASSWD_INDEX].para,
                                 g_atParaList[AT_AUTHDATA_PASSWD_INDEX].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authDataInfo.passWord),
                                g_atParaList[AT_AUTHDATA_PASSWD_INDEX].paraLen);
            authDataInfo.passWord[g_atParaList[AT_AUTHDATA_PASSWD_INDEX].paraLen] = 0;
        }
    }

    /* 执行命令操作 */
    if (TAF_PS_SetAuthDataInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                               &authDataInfo) != VOS_OK) {
        (VOS_VOID)memset_s(&authDataInfo, sizeof(authDataInfo), 0x00, sizeof(TAF_AUTHDATA_Ext));
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_AUTHDATA_SET;
    (VOS_VOID)memset_s(&authDataInfo, sizeof(authDataInfo), 0x00, sizeof(TAF_AUTHDATA_Ext));
    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 At_SetCrpnPara(TAF_UINT8 indexNum)
{
    TAF_MMA_CrpnQryPara mnMmaCrpnQry;
    errno_t             memResult;

    /* 参数有效性检查 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_OK;
    }

    if (g_atParaIndex != AT_CRPN_PARA_VALID_NUM) {
        AT_WARN_LOG("At_SetCrpnPara: g_atParaIndex != 2.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 若<name_index>或<name>参数为空，则返回失败 */
    if ((g_atParaList[AT_CRPN_NAME_INDEX].paraLen == 0) || (g_atParaList[AT_CRPN_NAME].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查<name>参数长度有效性 */
    if (g_atParaList[AT_CRPN_NAME_INDEX].paraValue == 0) {
        if (g_atParaList[AT_CRPN_NAME].paraLen >= TAF_PH_OPER_NAME_LONG) {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    } else if (g_atParaList[AT_CRPN_NAME_INDEX].paraValue == 1) {
        if (g_atParaList[AT_CRPN_NAME].paraLen >= TAF_PH_OPER_NAME_SHORT) {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    } else {
        if ((g_atParaList[AT_CRPN_NAME].paraLen < AT_CRPN_NAME_MIN_LEN) ||
            (g_atParaList[AT_CRPN_NAME].paraLen > AT_CRPN_NAME_MAX_LEN)) {
            return AT_CME_TEXT_STRING_TOO_LONG;
        }
    }

    (VOS_VOID)memset_s(&mnMmaCrpnQry, sizeof(mnMmaCrpnQry), 0x00, sizeof(TAF_MMA_CrpnQryPara));

    /* 发送消息结构赋值 */
    mnMmaCrpnQry.currIndex   = 0;
    mnMmaCrpnQry.qryNum      = TAF_PH_CRPN_PLMN_MAX_NUM;
    mnMmaCrpnQry.plmnType    = (VOS_UINT8)g_atParaList[AT_CRPN_NAME_INDEX].paraValue;
    mnMmaCrpnQry.plmnNameLen = g_atParaList[AT_CRPN_NAME].paraLen;
    memResult = memcpy_s(mnMmaCrpnQry.plmnName, sizeof(mnMmaCrpnQry.plmnName), g_atParaList[AT_CRPN_NAME].para,
                         g_atParaList[AT_CRPN_NAME].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(mnMmaCrpnQry.plmnName), g_atParaList[AT_CRPN_NAME].paraLen);

    if (TAF_MMA_QryCrpnReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &mnMmaCrpnQry) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CRPN_QUERY;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetAlsPara(TAF_UINT8 indexNum)
{
    VOS_UINT32          ret;
    AT_ModemSsCtx      *ssCtx = VOS_NULL_PTR;
    TAF_Ctrl            ctrl;
    MN_CALL_SetAlsParam setAls;
    ModemIdUint16       modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&setAls, sizeof(setAls), 0x00, sizeof(setAls));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 参数过多 */
    if (g_atParaIndex > AT_ALS_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数不存在 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[1].paraLen != 0) {
        setAls.alsLine = (MN_CALL_AlsLineNoUint8)g_atParaList[1].paraValue;

        if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
            return AT_ERROR;
        }

        ret = TAF_CCM_CallCommonReq(&ctrl, &setAls, ID_TAF_CCM_SET_ALS_REQ, sizeof(setAls), modemId);
        if (ret != VOS_OK) {
            return AT_ERROR;
        }

        ssCtx->salsType = (TAF_UINT8)g_atParaList[0].paraValue;

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_APP_SET_ALS_REQ;

        return AT_WAIT_ASYNC_RETURN;
    }

    ssCtx->salsType = (TAF_UINT8)g_atParaList[0].paraValue;

    return AT_OK;
}


VOS_UINT32 At_SaveRxDivPara(VOS_UINT16 setDivBands, VOS_UINT8 rxDivCfg)
{
    TAF_AT_NvimRxdivConfig rxdivConfig;

    (VOS_VOID)memset_s(&rxdivConfig, sizeof(rxdivConfig), 0x00, sizeof(TAF_AT_NvimRxdivConfig));

    rxdivConfig.vaild = rxDivCfg;

    /*
     * NV项en_NV_Item_ANTENNA_CONFIG在V3R2B060后改成en_NV_Item_W_RF_DIV_BAND，
     * 两个NV项完全一样。
     */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_W_RF_DIV_BAND, (VOS_UINT8 *)&setDivBands, sizeof(VOS_UINT16)) !=
        NV_OK) {
        TAF_LOG(WUEPS_PID_AT, 0, PS_LOG_LEVEL_ERROR, "TAF_ACORE_NV_WRITE en_NV_Item_W_RF_DIV_BAND fail!\n");
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_RXDIV_CONFIG, (VOS_UINT8 *)&rxdivConfig,
                           sizeof(TAF_AT_NvimRxdivConfig)) != NV_OK) {
        TAF_LOG(WUEPS_PID_AT, 0, PS_LOG_LEVEL_ERROR, "TAF_ACORE_NV_WRITE en_NV_RXDIV_CONFIG fail!\n");
        return AT_CME_RX_DIV_OTHER_ERR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetTModePara(TAF_UINT8 indexNum)
{
    TAF_PH_TmodeUint8 *currentTMode = VOS_NULL_PTR;
#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    AT_DEVICE_CmdCtrl *atDevCmdCtrl = VOS_NULL_PTR;
#else
    AT_MT_Info *atMtInfoCtx = VOS_NULL_PTR;
#endif
    TAF_MMA_PhoneModePara phoneModePara;
    VOS_UINT8             updateFlag;

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
    atDevCmdCtrl = AT_GetDevCmdCtrl();
    currentTMode = &atDevCmdCtrl->currentTMode;
#else
    atMtInfoCtx = AT_GetMtInfoCtx();
    currentTMode = &atMtInfoCtx->currentTMode;
#endif

    (VOS_VOID)memset_s(&phoneModePara, sizeof(phoneModePara), 0x00, sizeof(phoneModePara));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置TMODE */
    if (g_atParaList[0].paraValue >= AT_TMODE_BUTT) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    switch (g_atParaList[0].paraValue) {
        case AT_TMODE_NORMAL:

            phoneModePara.phMode = TAF_PH_MODE_FULL;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) ==
                VOS_TRUE) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SET_TMODE;

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
                AT_InitDevCmdCtrl();
#else
                AT_InitMTInfo();
#endif

                *currentTMode = AT_TMODE_NORMAL;

                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

        case AT_TMODE_FTM:

            if (*currentTMode == AT_TMODE_UPGRADE) {
                return AT_ERROR;
            }

            phoneModePara.phMode = TAF_PH_MODE_FT;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) ==
                VOS_TRUE) {
                /* 设置当前操作类型 */
                *currentTMode                         = AT_TMODE_FTM;
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SET_TMODE;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

        case AT_TMODE_UPGRADE:

            if (*currentTMode == AT_TMODE_FTM) {
                return AT_ERROR;
            }
            /*
             * 发消息到 C 核设置升级标志位，不需要再启定时器，消息类型为DRV_AGENT_TMODE_SET_REQ
             * 直接返回AT_OK，不需要等待设置结果
             */
            updateFlag = VOS_TRUE;

            if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                       DRV_AGENT_TMODE_SET_REQ, &updateFlag, sizeof(updateFlag),
                                       I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
                AT_ERR_LOG("AT_SetPstandbyPara: AT_FillAndSndAppReqMsg fail.");
            }

            *currentTMode = AT_TMODE_UPGRADE;
            return AT_OK;
        case AT_TMODE_RESET:

            *currentTMode = AT_TMODE_RESET;

            /* 单板重启 */
            updateFlag = VOS_FALSE;

            if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                       DRV_AGENT_TMODE_SET_REQ, &updateFlag, sizeof(updateFlag),
                                       I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
                AT_ERR_LOG("AT_SetPstandbyPara: AT_FillAndSndAppReqMsg fail.");
            }

            return AT_OK;
        case AT_TMODE_POWEROFF:
            return AT_SetTmodeAutoPowerOff(indexNum);

            /* 按北京要求模式4->11和模式1做相同的处理 */
        case AT_TMODE_SIGNALING:
            if (*currentTMode == AT_TMODE_UPGRADE) {
                return AT_ERROR;
            }

            phoneModePara.phMode = TAF_PH_MODE_FT;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) ==
                VOS_TRUE) {
                /* 设置当前操作类型 */
                *currentTMode                         = AT_TMODE_SIGNALING;
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SET_TMODE;
                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

            /* 按北京要求模式5->12和模式0做相同的处理 */
        case AT_TMODE_OFFLINE:

            phoneModePara.phMode = TAF_PH_MODE_FULL;

            if (TAF_MMA_PhoneModeSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &phoneModePara) ==
                VOS_TRUE) {
                /* 设置当前操作类型 */
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SET_TMODE;

#if (FEATURE_UE_MODE_NR == FEATURE_OFF)
                AT_InitDevCmdCtrl();
#else
                AT_InitMTInfo();
#endif

                *currentTMode = AT_TMODE_OFFLINE;

                return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
            } else {
                return AT_ERROR;
            }
            /* fall-through */

#if ((FEATURE_LTE == FEATURE_ON) || (FEATURE_UE_MODE_TDS == FEATURE_ON))
        case AT_TMODE_F_NONESIGNAL:
        case AT_TMODE_SYN_NONESIGNAL:
        case AT_TMODE_SET_SECONDARY:
        case AT_TMODE_GU_BT:
        case AT_TMODE_TDS_FAST_CT:
        case AT_TMODE_TDS_BT:
        case AT_TMODE_COMM_CT:
            if (atSetTmodePara(indexNum, g_atParaList[0].paraValue) == AT_OK) {
                g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SET_TMODE;
                *currentTMode                         = (VOS_UINT8)g_atParaList[0].paraValue;
                return AT_WAIT_ASYNC_RETURN;
            } else {
                return AT_ERROR;
            }
            /* fall-through */
#endif

        default:
            break;
    }

    return AT_ERROR;
}

#if (FEATURE_LTEV == FEATURE_ON)

TAF_UINT32 At_SetVModePara(VOS_UINT8 indexNum)
{
    TAF_MTA_VModePwModeTypeUint8 mode;
    TAF_MTA_VModeRatTypeUint8    rat;
    TAF_MTA_Ctrl                 ctrl = {0};
    VOS_UINT32                   rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数必须为2 */
    if (g_atParaIndex != AT_VMODE_PARA_DEFAULT_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    rat = (TAF_MTA_VModeRatTypeUint8)g_atParaList[0].paraValue;

    if (g_atParaList[1].paraValue == 0) {
        mode = TAF_MTA_VMODE_POWEROFF;
    } else if (g_atParaList[1].paraValue == 1) {
        mode = TAF_MTA_VMODE_POWERON;
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 端口控制信息 */
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    rst = TAF_MTA_VModeSetReq(&ctrl, rat, mode);
    if (rst == TAF_MTA_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VMODE_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

TAF_UINT32 AT_SetSourceId(VOS_UINT8 indexNum)
{
    VNAS_LtevSourceIdSetReq sourceIdPara = {0};
    VOS_UINT32              rst;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为1或者2 */
    if (g_atParaIndex != AT_SRCID_PARA_MIN_NUM && g_atParaIndex != AT_SRCID_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    sourceIdPara.isAtSourceIdEffective = (VOS_UINT8)g_atParaList[0].paraValue;
    sourceIdPara.sourceId              = g_atParaList[1].paraValue;
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_VNAS_LTEV_SOURCE_ID_SET_REQ,
                                 (VOS_UINT8 *)&sourceIdPara, sizeof(VNAS_LtevSourceIdSetReq), I0_PS_PID_VNAS);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SRCID_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif
#endif


#if (FEATURE_LTE == FEATURE_ON)
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))
VOS_UINT32 At_SetSfm(VOS_UINT8 indexNum)
{
    OM_SW_VerFlag customVersion;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    /* AT命令与NV中存储的信息相反 */
    if (g_atParaList[0].paraValue == 0) {
        customVersion.nvSwVerFlag = 1;
    } else {
        customVersion.nvSwVerFlag = 0;
    }

    /* 判断是否为烧片版本 */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_SW_VERSION_FLAG, (VOS_UINT8 *)&customVersion.nvSwVerFlag,
                           sizeof(customVersion.nvSwVerFlag)) != VOS_OK) {
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}
#endif


VOS_UINT32 AT_SetFrStatus(VOS_UINT8 indexNum)
{
    VOS_UINT32         rst;
    AT_MTA_SetFrReq    atMtaSetFrReq;
    PS_BOOL_ENUM_UINT8 actFrFlag;

    /* 局部变量初始化 */
    rst       = TAF_FAILURE;
    actFrFlag = PS_BOOL_BUTT;
    (VOS_VOID)memset_s(&atMtaSetFrReq, sizeof(atMtaSetFrReq), 0x00, sizeof(AT_MTA_SetFrReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* enActFrFlag取值范围为'0'~'1' */
    if (((g_atParaList[0].paraValue) != 0) && ((g_atParaList[0].paraValue) != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    actFrFlag = (PS_BOOL_ENUM_UINT8)(g_atParaList[0].paraValue);

    /* 填充结构体 */
    atMtaSetFrReq.actFrFlag = actFrFlag;
    atMtaSetFrReq.rsv[0]    = 0;
    atMtaSetFrReq.rsv[1]    = 0;
    atMtaSetFrReq.rsv[2]    = 0;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, ID_AT_MTA_SET_FR_REQ,
                                 (VOS_UINT8 *)&atMtaSetFrReq, sizeof(AT_MTA_SetFrReq), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_FRSTATUS_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif



TAF_UINT32 At_SetBsn(TAF_UINT8 indexNum)
{
    TAF_PH_SerialNum serialNum;
    errno_t          memResult;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    /* 如果参数长度<imei>不等于16，直接返回错误 */
    if (g_atParaList[0].paraLen != TAF_SERIAL_NUM_LEN) {
        return AT_ERROR;
    }

    /* 检查<imei>是否为数字字符串,不是则直接返回错误 */
    if (At_CheckNumCharString(g_atParaList[0].para, g_atParaList[0].paraLen) == AT_FAILURE) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraLen > 0) {
        memResult = memcpy_s(serialNum.serialNum, sizeof(serialNum.serialNum), g_atParaList[0].para,
                             g_atParaList[0].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(serialNum.serialNum), g_atParaList[0].paraLen);
    }
    (VOS_VOID)memset_s(serialNum.serialNum + TAF_SERIAL_NUM_LEN,
                (VOS_SIZE_T)((TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN) * sizeof(serialNum.serialNum[0])),
                0x00,
                (VOS_SIZE_T)((TAF_SERIAL_NUM_NV_LEN - TAF_SERIAL_NUM_LEN) * sizeof(serialNum.serialNum[0])));

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_MANUFACTURE_INFO, serialNum.serialNum, TAF_SERIAL_NUM_NV_LEN) != NV_OK) {
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 At_SetQosPara(VOS_UINT8 indexNum)
{
    AT_TrafficClassCustomize aTTrafficClass;
    ModemIdUint16            modemId;
    VOS_UINT32               ret;
    VOS_UINT8                qosPara;

    modemId = MODEM_ID_0;

    /* 命令状态类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 数据保护未解除 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_DATA_UNLOCK_ERROR;
    }

    /* 参数个数不为1 */
    if (g_atParaIndex != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数长度不为1 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    qosPara = g_atParaList[0].para[0];

    /* ucQosPara取值范围为'0'~'4' */
    if ((qosPara >= '0') && (qosPara <= '4')) {
        qosPara = g_atParaList[0].para[0] - '0';
    } else {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 将NV项NV_ITEM_TRAFFIC_CLASS_TYPE的ucStatus单元置为激活态1 */
    aTTrafficClass.status = NV_ITEM_ACTIVE;

    /* 将数字参数值写入NV项的ucTrafficClass单元 */
    aTTrafficClass.trafficClass = qosPara;

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("At_SetQosPara: Get modem id fail.");
        return AT_ERROR;
    }

    if (TAF_ACORE_NV_WRITE(modemId, NV_ITEM_TRAFFIC_CLASS_TYPE, (VOS_UINT8 *)&aTTrafficClass,
                           sizeof(AT_TrafficClassCustomize)) != NV_OK) {
        AT_WARN_LOG("At_SetQosPara:WARNING:NVIM Write NV_ITEM_TRAFFIC_CLASS_TYPE failed!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 At_SetSDomainPara(VOS_UINT8 indexNum)
{
    TAF_MMA_ServiceDomainUint8 srvDomain;
    NAS_NVIM_MsClass msClass;
    ModemIdUint16    modemId;
    VOS_UINT32       ret;

    modemId = MODEM_ID_0;
    (VOS_VOID)memset_s(&msClass, sizeof(msClass), 0x00, sizeof(NAS_NVIM_MsClass));

    /* 命令状态类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 数据保护未解除 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_DATA_UNLOCK_ERROR;
    }

    /* 参数个数不为1 */
    if (g_atParaIndex != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数长度不为1 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    srvDomain = g_atParaList[0].para[0];

    /* ucSrvDomain取值范围为'0'~'3' */
    if ((srvDomain >= '0') && (srvDomain <= '3')) {
        /* 将字符参数转换为数字,范围为0~3 */
        srvDomain = g_atParaList[0].para[0] - '0';
    } else {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 将数字参数转换为MsClass类型，即将3转换为0 */
    if (srvDomain == TAF_MMA_SERVICE_DOMAIN_ANY) {
        srvDomain = TAF_MMA_SERVICE_DOMAIN_CS;
    }

    msClass.msClass = srvDomain;
    /* 将转换后的参数值写入NV项NV_ITEM_MMA_MS_CLASS的MsClass单元 */
    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("At_SetSDomainPara: Get modem id fail.");
        return AT_ERROR;
    }
    if (TAF_ACORE_NV_WRITE(modemId, NV_ITEM_MMA_MS_CLASS, (VOS_UINT8 *)&msClass, sizeof(NAS_NVIM_MsClass)) != NV_OK) {
        AT_WARN_LOG("At_SetSDomainPara:WARNING:NVIM Write NV_ITEM_MMA_MS_CLASS failed!");
        return AT_DEVICE_OTHER_ERROR;
    }
    return AT_OK;
}


VOS_UINT32 At_WriteDpaCatToNV(VOS_UINT8 dpaRate)
{
    AT_NvimUeCapa uECapa;
    AT_DpacatPara dhpaCategory[AT_DPACAT_CATEGORY_TYPE_BUTT] = {
        /* 支持速率等级3.6M  */
        { PS_TRUE, AT_HSDSCH_PHY_CATEGORY_6, PS_FALSE, 0, PS_FALSE },
        /* 支持速率等级7.2M  */
        { PS_TRUE, AT_HSDSCH_PHY_CATEGORY_8, PS_FALSE, 0, PS_FALSE },
        /* 支持速率等级1.8M  */
        { PS_TRUE, AT_HSDSCH_PHY_CATEGORY_11, PS_FALSE, 0, PS_FALSE },
        /*  支持速率等级14.4M */
        { PS_TRUE, AT_HSDSCH_PHY_CATEGORY_10, PS_FALSE, 0, PS_FALSE },
        /*  支持速率等级21M */
        { PS_TRUE, AT_HSDSCH_PHY_CATEGORY_10, PS_TRUE, AT_HSDSCH_PHY_CATEGORY_14, PS_FALSE }
    };

    (VOS_VOID)memset_s(&uECapa, sizeof(uECapa), 0x00, sizeof(uECapa));

    if (dpaRate >= AT_DPACAT_CATEGORY_TYPE_BUTT) {
        AT_WARN_LOG("At_WriteDpaCatToNV: WARNING:Input DPA rate index invalid!");
        return VOS_ERR;
    }

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW, &uECapa, sizeof(AT_NvimUeCapa)) != NV_OK) {
        AT_WARN_LOG("At_WriteDpaCatToNV: en_NV_Item_WAS_RadioAccess_Capa NV Read Fail!");
        return VOS_ERR;
    }

    /* 是否支持enHSDSCHSupport的标志                */
    uECapa.hsdschSupport = dhpaCategory[dpaRate].hsdschSupport;

    /* 支持HS-DSCH物理层的类型标志                  */
    uECapa.hsdschPhyCategory    = dhpaCategory[dpaRate].hsdschPhyCategory;
    uECapa.macEhsSupport        = dhpaCategory[dpaRate].macEhsSupport;
    uECapa.hsdschPhyCategoryExt = dhpaCategory[dpaRate].hsdschPhyCategoryExt;

    /* 是否支持 Multi cell support,如果支持MultiCell,Ex2存在 */
    uECapa.multiCellSupport = dhpaCategory[dpaRate].multiCellSupport;

    /* 将新的能力写到内部的全局变量，并更新到NV项中 */
    uECapa.hspaStatus = NV_ITEM_ACTIVE; /* 此项成为激活项 */

    /* 已经设置好NV结构体中的对应值，将这些值写入NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW, (VOS_UINT8 *)&uECapa,
                           sizeof(AT_NvimUeCapa)) != NV_OK) {
        AT_WARN_LOG("At_WriteDpaCatToNV: en_NV_Item_WAS_RadioAccess_Capa NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))


VOS_UINT32 At_SetDpaCat(VOS_UINT8 indexNum)
{
    /*
     * 0     支持速率为3.6M
     * *1     支持速率为7.2M
     * *2     支持速率为1.8M
     * *3     支持速率为14.4M
     * *4     支持速率为21M
     */
    VOS_UINT8 dpaRate;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数不为1 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    /* 参数内容只能为1个 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_ERROR;
    }

    dpaRate = g_atParaList[0].para[0];
    /* ucDpaRate取值范围为'0'~'4' */
    if ((dpaRate >= '0') && (dpaRate <= '4')) {
        dpaRate = g_atParaList[0].para[0] - '0';
    } else {
        return AT_ERROR;
    }

    if (g_atDataLocked == VOS_TRUE) {
        return AT_ERROR;
    }

    /* 调用写NV接口函数: At_WriteDpaCatToNV,返回操作结果 */
    if (At_WriteDpaCatToNV(dpaRate) == VOS_OK) {
        return AT_OK;
    } else {
        AT_WARN_LOG("At_SetDpaCat:WARNING:WAS_MNTN_SetDpaCat failed!");
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 AT_WriteRrcVerToNV(VOS_UINT8 srcWcdmaRRC)
{
    AT_NvimUeCapa uECapa;

    /* 从NV项中读取en_NV_Item_WAS_RadioAccess_Capa值 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW, &uECapa, sizeof(AT_NvimUeCapa)) != NV_OK) {
        AT_WARN_LOG("AT_WriteRrcVerToNV():NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW NV Read Fail!");
        return VOS_ERR;
    }

    switch (srcWcdmaRRC) {
        case AT_RRC_VERSION_WCDMA:
            uECapa.edchSupport   = VOS_FALSE;
            uECapa.hsdschSupport = VOS_FALSE;
            break;

        case AT_RRC_VERSION_DPA:
            uECapa.edchSupport   = VOS_FALSE;
            uECapa.hsdschSupport = VOS_TRUE;
            break;

        case AT_RRC_VERSION_DPA_AND_UPA:
            uECapa.asRelIndicator = AT_PTL_VER_ENUM_R6;
            uECapa.edchSupport    = VOS_TRUE;
            uECapa.hsdschSupport  = VOS_TRUE;
            break;

        case AT_RRC_VERSION_HSPA_PLUNS:
            uECapa.asRelIndicator = AT_PTL_VER_ENUM_R7;
            uECapa.edchSupport    = VOS_TRUE;
            uECapa.hsdschSupport  = VOS_TRUE;
            break;

        default:
            break;
    }

    /* 将要设置的值写入Balong NV 结构体 */
    uECapa.hspaStatus = NV_ITEM_ACTIVE;

    /* 已经设置好NV结构体中的对应值，将这些值写入NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW, (VOS_UINT8 *)&uECapa,
                           sizeof(AT_NvimUeCapa)) != NV_OK) {
        AT_WARN_LOG("AT_WriteRrcVerToNV():NV_ITEM_WAS_RADIO_ACCESS_CAPA_NEW NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 At_SetDataLock(VOS_UINT8 indexNum)
{
    DRV_AGENT_DatalockSetReq datalockInfo;
    errno_t                  memResult;

    /* 设置命令无参数 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    /* <unlock_code>必须为长度为8的数字字符串 */
    if (g_atParaList[0].paraLen != TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) {
        return AT_ERROR;
    }

    if (At_CheckNumString(g_atParaList[0].para, TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX) == AT_FAILURE) {
        return AT_ERROR;
    }

    if (g_atDataLocked == VOS_TRUE) {
        /* 复制用户解锁码 */
        datalockInfo.pwd[TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX] = '\0';
        memResult = memcpy_s(datalockInfo.pwd, sizeof(datalockInfo.pwd), g_atParaList[0].para,
                             TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(datalockInfo.pwd), TAF_PH_ME_PERSONALISATION_PWD_LEN_MAX);

        /* 发消息到 C 核 获取 DATALOCK 校验信息 */
        if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                   DRV_AGENT_DATALOCK_SET_REQ, (VOS_UINT8 *)&datalockInfo, sizeof(datalockInfo),
                                   I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DATALOCK_SET; /* 设置当前操作模式 */
            (VOS_VOID)memset_s(&datalockInfo, sizeof(datalockInfo), 0x00, sizeof(datalockInfo));
            return AT_WAIT_ASYNC_RETURN; /* 等待异步事件返回 */
        } else {
            (VOS_VOID)memset_s(&datalockInfo, sizeof(datalockInfo), 0x00, sizeof(datalockInfo));
            return AT_ERROR;
        }
    }

    return AT_OK;
}

#if (FEATURE_LTE == FEATURE_ON)
/* 生产NV恢复 */
VOS_UINT32 At_SetInfoRRS(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 参数个数过多 */
    if (g_atParaIndex != 0) {
        return AT_ERROR;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_INFORRS_SET_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);
    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_INFORRS_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 At_SetGPIOPL(VOS_UINT8 indexNum)
{
    DRV_AGENT_GpioplSetReq gpioplSet;
    errno_t                memResult;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    /* 如果参数长度GPIOPL大于20个字节,即:BCD数 > 20*2个，直接返回错误 */
    if (g_atParaList[AT_GPIOPL_PL].paraLen > (AT_GPIOPL_MAX_LEN * AT_DOUBLE_BCD_NUM)) {
        return AT_ERROR;
    }

    /* 检查GPIO值是否为16进制字符串,不是则直接返回错误;是则转换为16进制数字 */
    if (At_AsciiNum2HexString(g_atParaList[AT_GPIOPL_PL].para, &g_atParaList[AT_GPIOPL_PL].paraLen) == AT_FAILURE) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(gpioplSet.gpiopl, sizeof(gpioplSet.gpiopl), 0x00, DRVAGENT_GPIOPL_MAX_LEN);

    if (g_atParaList[AT_GPIOPL_PL].paraLen > 0) {
        memResult = memcpy_s(gpioplSet.gpiopl, sizeof(gpioplSet.gpiopl), g_atParaList[AT_GPIOPL_PL].para,
                             g_atParaList[AT_GPIOPL_PL].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(gpioplSet.gpiopl), g_atParaList[AT_GPIOPL_PL].paraLen);
    }

    /* 调用AT_FillAndSndAppReqMsg发消息到C核I0_WUEPS_PID_DRV_AGENT */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, DRV_AGENT_GPIOPL_SET_REQ,
                               (VOS_UINT8 *)&gpioplSet, sizeof(gpioplSet), I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_GPIOPL_SET; /* 设置当前操作模式 */
        return AT_WAIT_ASYNC_RETURN;                               /* 等待异步事件返回 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_ProcUus1WithParm(VOS_UINT8 indexNum, MN_CALL_Uus1Param *uus1Group)
{
    VOS_UINT32 ret;
    VOS_UINT32 msgNum;
    VOS_UINT32 i;
    VOS_UINT32 rst;
    VOS_UINT32 strLength;
    errno_t    memResult;

    TAF_Ctrl          ctrl;
    MN_CALL_Uus1Param uus1Info;
    ModemIdUint16     modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&uus1Info, sizeof(uus1Info), 0x00, sizeof(uus1Info));

    /* 去处<n>和<m>后,实际的消息个数 */
    msgNum = g_atParaIndex;

    if (g_atParaList[AT_CUUS1_MESSAGE].paraLen == 0) {
        uus1Group->actNum = 0;
    } else {
        /* 设置message */
        for (i = AT_CUUS1_FIRST_AND_SECOND_PARA_COUNT; (i < msgNum && i < (AT_MAX_PARA_NUMBER - 1)); i++) {
            /*
             * 先需要转换,由于该命令可设置多次参数,AT格式中仅对前4个参数进行转换,
             * 后面的参数未进行转换,因此需要将数组中的值进行所转换
             */
            if (At_Auc2ul(g_atParaList[i].para, g_atParaList[i].paraLen, &g_atParaList[i].paraValue) != AT_SUCCESS) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            uus1Group->uus1Info[uus1Group->actNum].msgType = g_atParaList[i].paraValue;
            i++;

            /* <UUIE>不存在,表明是去激活 */
            if (g_atParaList[i].paraLen == 0) {
                uus1Group->setType[uus1Group->actNum] = MN_CALL_SET_UUS1_DEACT;
            } else {
                uus1Group->setType[uus1Group->actNum] = MN_CALL_SET_UUS1_ACT;
                /* 需将ASCII转换为HEX */
                if (At_AsciiNum2HexString(g_atParaList[i].para, &g_atParaList[i].paraLen) == AT_FAILURE) {
                    return AT_CME_INCORRECT_PARAMETERS;
                }

                strLength = sizeof(uus1Group->uus1Info[uus1Group->actNum].uuie);
                if (strLength < g_atParaList[i].paraLen) {
                    return AT_CME_INCORRECT_PARAMETERS;
                }
                memResult = memcpy_s(uus1Group->uus1Info[uus1Group->actNum].uuie,
                                     sizeof(uus1Group->uus1Info[uus1Group->actNum].uuie), g_atParaList[i].para,
                                     g_atParaList[i].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, sizeof(uus1Group->uus1Info[uus1Group->actNum].uuie),
                                    g_atParaList[i].paraLen);
            }

            ret = MN_CALL_CheckUus1ParmValid(uus1Group->setType[uus1Group->actNum],
                                             &(uus1Group->uus1Info[uus1Group->actNum]));
            if (ret != MN_ERR_NO_ERROR) {
                return AT_CME_INCORRECT_PARAMETERS;
            }

            uus1Group->actNum++;

            /* 如果未携带UUIE,则默认表示结束不关心后面参数 */
            if (uus1Group->setType[uus1Group->actNum] == MN_CALL_SET_UUS1_DEACT) {
                break;
            }
        }
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    memResult = memcpy_s(&uus1Info, sizeof(uus1Info), uus1Group, sizeof(MN_CALL_Uus1Param));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(uus1Info), sizeof(MN_CALL_Uus1Param));

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /*
     * 1.对要设置的各个Uus1Info进行设定，然后通过MN_CALL_APP_SET_UUSINFO消息带参数结构
     * MN_CALL_Uus1Param通知CS进行参数设置
     */
    rst = TAF_CCM_CallCommonReq(&ctrl, &uus1Info, ID_TAF_CCM_SET_UUSINFO_REQ, sizeof(uus1Info), modemId);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_APP_SET_UUSINFO_REQ;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetCuus1Para(VOS_UINT8 indexNum)
{
    VOS_UINT32        ret;
    MN_CALL_Uus1Param uus1Info; /* 设置UUS1信息结构 */

    /*
     * 27007中该命令格式,该命令可以不携带任何参数,如果不携带参数直接返回OK
     * + CUUS1 =[<n>[,<m>[,<message>[,<UUIE> [,<message>[,<UUIE>[,...]]]]]]]
     */

    /* 不携带参数直接返回OK */
    if (g_atParaIndex == 0) {
        return AT_OK;
    }

    (VOS_VOID)memset_s(&uus1Info, sizeof(uus1Info), 0x00, sizeof(uus1Info));

    /* 设置<n> */
    if (g_atParaList[0].paraLen != 0) {
        uus1Info.cuus1IFlg = (MN_CALL_Cuus1FlgUint32)g_atParaList[0].paraValue;
    } else {
        /* <n>不存在同时参数个数不为0返回ERROR */
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<m> */
    if (g_atParaList[1].paraLen != 0) {
        uus1Info.cuus1UFlg = (MN_CALL_Cuus1FlgUint32)g_atParaList[1].paraValue;
    }

    /* 设置message */
    /* 只带n和m参数时，也要给MN发消息 */
    ret = AT_ProcUus1WithParm(indexNum, &uus1Info);

    return ret;
}

VOS_UINT32 At_SetGlastErrPara(VOS_UINT8 indexNum)
{
    VOS_UINT16         length;
    TAF_PS_CauseUint32 psCause;
    TAF_UINT32         atErrType;
    length = 0;

    /* 检查拨号错误码是否使能 */
    if (g_pppDialErrCodeRpt == PPP_DIAL_ERR_CODE_DISABLE) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 没有参数 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数值错误 */
    if (g_atParaList[0].paraValue != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    AT_SetErrType(g_atParaList[0].paraValue);

    /* 获取错误码 */
    psCause = AT_PS_GetPsCallErrCause(indexNum);
    if (psCause == TAF_PS_CAUSE_SUCCESS) {
        return AT_ERROR;
    }

    atErrType = AT_GetErrType();
    /* 将错误码上报给后台 */
    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s: %d,%d", g_parseContext[indexNum].cmdElement->cmdName, atErrType,
        AT_Get3gppSmCauseByPsCause(psCause));

    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 AT_SetMDatePara(VOS_UINT8 indexNum)
{
    errno_t memResult;
    VOS_UINT32                 ret;
    AT_DATE                    date;
    TAF_AT_NvimManufactureDate manufactrueDate;

    if (g_atParaIndex != 1) {
        AT_NORM_LOG("AT_SetMDatePara: the number of parameters is error.");
        return AT_ERROR;
    }

    /* 参数检查1:日期格式检查； */
    ret = AT_CheckDateFormat(g_atParaList[0].para, g_atParaList[0].paraLen);
    if (ret != AT_OK) {
        AT_NORM_LOG("AT_SetMDatePara: the format of parameters is error.");
        return AT_ERROR;
    }

    /* 参数检查2:获取生产日期并对日期作有效性检查； */
    ret = AT_GetDate(g_atParaList[0].para, g_atParaList[0].paraLen, &date);
    if (ret != AT_OK) {
        AT_NORM_LOG("AT_SetMDatePara: Fail to get the date.");
        return AT_ERROR;
    }

    ret = AT_CheckDate(&date);
    if (ret != AT_OK) {
        AT_NORM_LOG("AT_SetMDatePara: the value of parameters is error.");
        return AT_ERROR;
    }

    /* 写日期参数到NV */
    memResult = memcpy_s(manufactrueDate.mDate, sizeof(manufactrueDate.mDate), g_atParaList[0].para,
                         (AT_MDATE_STRING_LENGTH - 1));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(manufactrueDate.mDate), (AT_MDATE_STRING_LENGTH - 1));
    manufactrueDate.mDate[AT_MDATE_STRING_LENGTH - 1] = '\0';
    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_AT_MANUFACTURE_DATE, manufactrueDate.mDate, AT_MDATE_STRING_LENGTH);
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_SetMDatePara: Fail to write nv.");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetFacInfoPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;
    VOS_UINT8 *facInfo = TAF_NULL_PTR;
    VOS_UINT32 offSet;
    errno_t    memResult;

    if ((g_atParaIndex != AT_FACINFO_PARA_VALID_NUM) || ((g_atParaList[AT_FACINFO_VALUE_INFO].paraLen == 0))) {
        AT_WARN_LOG("AT_SetFacInfoPara: the number of parameters is error.");
        return AT_ERROR;
    }

    /* 长度超过制造信息有效字段长度则参数检查失败 */
    if (g_atParaList[0].paraValue == 0) {
        if (g_atParaList[AT_FACINFO_VALUE_INFO].paraLen != AT_FACINFO_INFO1_LENGTH) {
            AT_NORM_LOG("AT_SetFacInfoPara: Length of info1 is failure.");
            return AT_ERROR;
        }

        if (At_CheckNumString(g_atParaList[AT_FACINFO_VALUE_INFO].para, AT_FACINFO_INFO1_LENGTH) == AT_FAILURE) {
            return AT_ERROR;
        }
    } else {
        if (g_atParaList[AT_FACINFO_VALUE_INFO].paraLen != AT_FACINFO_INFO2_LENGTH) {
            AT_NORM_LOG("AT_SetFacInfoPara: Length of info2 is failure.");
            return AT_ERROR;
        }

        if (At_CheckNumString(g_atParaList[AT_FACINFO_VALUE_INFO].para, AT_FACINFO_INFO2_LENGTH) == AT_FAILURE) {
            return AT_ERROR;
        }
    }

    /* 获取NV中已经存储的制造信息 */
    facInfo = (TAF_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_FACINFO_STRING_LENGTH);
    if (facInfo == TAF_NULL_PTR) {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to alloc memory.");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(facInfo, AT_FACINFO_STRING_LENGTH, 0x00, AT_FACINFO_STRING_LENGTH);

    ret = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_AT_FACTORY_INFO, facInfo, AT_FACINFO_STRING_LENGTH);
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to read NVIM . ");
        PS_MEM_FREE(WUEPS_PID_AT, facInfo);
        return AT_ERROR;
    }

    /*
     * 组装待写入NV项NV_ITEM_AT_FACTORY_INFO的局部变量:
     * 根据用户输入参数<INDEX>刷新制造信息,
     * <INDEX>为0则刷新前129字节，其中第129字节为结束符；
     * <INDEX>为1则刷新后129字节，其中第129字节为结束符；
     */
    offSet = (AT_FACINFO_INFO1_LENGTH + 1) * g_atParaList[0].paraValue;
    if ((offSet + g_atParaList[AT_FACINFO_VALUE_INFO].paraLen) >
        ((AT_FACINFO_INFO1_LENGTH + 1) + AT_FACINFO_INFO2_LENGTH)) {
        AT_WARN_LOG("AT_SetFacInfoPara: offset is error. ");
        PS_MEM_FREE(WUEPS_PID_AT, facInfo);
        return AT_ERROR;
    }

    *((facInfo + offSet) + g_atParaList[AT_FACINFO_VALUE_INFO].paraLen) = '\0';

    memResult = memcpy_s((facInfo + offSet), AT_FACINFO_STRING_LENGTH - offSet,
                         g_atParaList[AT_FACINFO_VALUE_INFO].para,
                         g_atParaList[AT_FACINFO_VALUE_INFO].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, AT_FACINFO_STRING_LENGTH - offSet, g_atParaList[AT_FACINFO_VALUE_INFO].paraLen);

    /* 刷新用户修改后的制造信息到NV项NV_ITEM_AT_FACTORY_INFO */
    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_AT_FACTORY_INFO, facInfo, AT_FACINFO_STRING_LENGTH);
    if (ret != NV_OK) {
        AT_WARN_LOG("AT_SetFacInfoPara: fail to write NVIM . ");
        PS_MEM_FREE(WUEPS_PID_AT, facInfo);
        return AT_ERROR;
    }

    PS_MEM_FREE(WUEPS_PID_AT, facInfo);
    return AT_OK;
}


VOS_UINT32 At_SetCallSrvPara(VOS_UINT8 indexNum)
{
    NAS_NVIM_CustomizeService custSrv;

    /* 命令状态检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数个数过多 */
    if (g_atParaIndex != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_DATA_UNLOCK_ERROR;
    }

    custSrv.customizeService = g_atParaList[0].paraValue;
    custSrv.status           = NV_ITEM_ACTIVE; /* NV项设置为激活 */

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CUSTOMIZE_SERVICE, (VOS_UINT8 *)&custSrv, sizeof(custSrv)) != NV_OK) {
        AT_WARN_LOG("At_SetCallSrvPara():NV_ITEM_CUSTOMIZE_SERVICE NV Write Fail!");
        return AT_DEVICE_OTHER_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 At_WriteWifiNVToDefault(AT_CustomizeItemDfltUint8 customizeItem)
{
    TAF_AT_MultiWifiSec  wifiKey;
    TAF_AT_MultiWifiSsid wifiSsid;

    if (AT_IsMiscSupport(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_UNSUPPORT) {
        return VOS_OK;
    }

    (VOS_VOID)memset_s(&wifiKey, sizeof(wifiKey), 0x00, sizeof(wifiKey));
    (VOS_VOID)memset_s(&wifiSsid, sizeof(wifiSsid), 0x00, sizeof(wifiSsid));

    /* 读取WIFI KEY对应的NV项 */
    if (TAF_ACORE_NV_READ_IN_CCORE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_KEY, (VOS_UINT8 *)&wifiKey,
                                   sizeof(TAF_AT_MultiWifiSec)) != NV_OK) {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:READ NV ERROR");
        return VOS_ERR;
    }

    /* 设置WIKEY为默认值 */
    (VOS_VOID)memset_s(wifiKey.wifiWpapsk, sizeof(wifiKey.wifiWpapsk), 0x00, sizeof(wifiKey.wifiWpapsk));

    /* 设置WIWEP为默认值 */
    (VOS_VOID)memset_s(wifiKey.wifiWepKey1, sizeof(wifiKey.wifiWepKey1), 0x00, sizeof(wifiKey.wifiWepKey1));
    (VOS_VOID)memset_s(wifiKey.wifiWepKey2, sizeof(wifiKey.wifiWepKey2), 0x00, sizeof(wifiKey.wifiWepKey2));
    (VOS_VOID)memset_s(wifiKey.wifiWepKey3, sizeof(wifiKey.wifiWepKey3), 0x00, sizeof(wifiKey.wifiWepKey3));
    (VOS_VOID)memset_s(wifiKey.wifiWepKey4, sizeof(wifiKey.wifiWepKey4), 0x00, sizeof(wifiKey.wifiWepKey4));

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_KEY, (VOS_UINT8 *)&wifiKey, sizeof(TAF_AT_MultiWifiSec)) !=
        NV_OK) {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:WRITE NV ERROR");
        return VOS_ERR;
    }

    /* 读取SSID对应的NV项 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_MULTI_WIFI_STATUS_SSID, &wifiSsid, sizeof(TAF_AT_MultiWifiSsid)) !=
        VOS_OK) {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:READ NV ERROR");
        return VOS_ERR;
    }

    /* 设置SSID为默认值 */
    (VOS_VOID)memset_s(wifiSsid.wifiSsid, sizeof(wifiSsid.wifiSsid), 0x00, sizeof(wifiSsid.wifiSsid));

    /* 写入WIFI SSID对应的NV项 */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_MULTI_WIFI_STATUS_SSID, (VOS_UINT8 *)&wifiSsid,
                           sizeof(TAF_AT_MultiWifiSsid)) != VOS_OK) {
        AT_WARN_LOG("At_WriteCustomizeSrvNVToDefault:WRITE NV ERROR");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 At_WriteSimLockNVToDefault(VOS_UINT8 indexNum, AT_CustomizeItemDfltUint8 customizeItem)
{
    TAF_CUSTOM_SimLockPlmnInfo simLockPlmnInfo;
    TAF_CUSTOM_CardlockStatus  cardLockStatus;
    TAF_CUSTOM_SimLockMaxTimes simLockMaxTimes;
    VOS_UINT32                 i;
    errno_t                    memResult;

    VOS_UINT8 range[TAF_PH_SIMLOCK_PLMN_STR_LEN] = {
        AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
        AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL,
        AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL
    };

    /*
     * 该定制项在可配置需求文档中默认值和单板自定义的默认值相同
     * NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO的ulStatus:默认未激活;
     * mnc_num:默认为2; range_begin和rang_end默认全为0xAA
     */
    simLockPlmnInfo.status = NV_ITEM_DEACTIVE;
    for (i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++) {
        simLockPlmnInfo.simLockPlmnRange[i].mncNum = AT_SIM_LOCK_MNC_NUM_DEFAULT_VAL;
        memResult = memcpy_s(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin,
                             sizeof(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin), range, sizeof(range));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin), sizeof(range));
        memResult = memcpy_s(simLockPlmnInfo.simLockPlmnRange[i].rangeEnd,
                             sizeof(simLockPlmnInfo.simLockPlmnRange[i].rangeEnd), range, sizeof(range));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(simLockPlmnInfo.simLockPlmnRange[i].rangeEnd), sizeof(range));
    }

    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO, (VOS_UINT8 *)&simLockPlmnInfo,
                           sizeof(simLockPlmnInfo)) != NV_OK) {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO NV Write Fail!");
        return VOS_ERR;
    }

    /*
     * 该定制项在可配置需求文档中默认值和单板自定义的默认值相同,
     * NV_ITEM_CARDLOCK_STATUS的ulStatus:默认为未激活; CardlockStatus:默认值为2;
     * RemainUnlockTimes:默认值为0
     */
    cardLockStatus.status            = NV_ITEM_DEACTIVE;
    cardLockStatus.cardlockStatus    = TAF_OPERATOR_LOCK_NONEED_UNLOCK_CODE;
    cardLockStatus.remainUnlockTimes = TAF_PH_CARDLOCK_DEFAULT_MAXTIME;
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CARDLOCK_STATUS, (VOS_UINT8 *)&cardLockStatus, sizeof(cardLockStatus)) !=
        NV_OK) {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():NV_ITEM_CARDLOCK_STATUS NV Write Fail!");
        return VOS_ERR;
    }

    /* 向C核发送消息备份simlockNV */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_SIMLOCK_NV_SET_REQ,
                               (VOS_UINT8 *)&cardLockStatus, sizeof(cardLockStatus),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        return VOS_ERR;
    }

    /*
     * 该定制项在可配置需求文档中默认值和单板自定义的默认值相同,
     * NV_ITEM_CUSTOMIZE_SIM_LOCK_MAX_TIMES的ulStatus:默认为未激活；
     * LockMaxTimes:默认最大解锁次数为10次
     */
    simLockMaxTimes.status       = NV_ITEM_DEACTIVE;
    simLockMaxTimes.lockMaxTimes = TAF_PH_CARDLOCK_DEFAULT_MAXTIME;
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CUSTOMIZE_SIM_LOCK_MAX_TIMES, (VOS_UINT8 *)&simLockMaxTimes,
                           sizeof(simLockMaxTimes)) != NV_OK) {
        AT_WARN_LOG("At_WriteSimLockNVToDefault():NV_ITEM_CUSTOMIZE_SIM_LOCK_MAX_TIMES NV Write Fail!");
        return VOS_ERR;
    }

    return VOS_OK;
}

static VOS_UINT32 At_WriteVoipApnKeyNvToDefault(AT_CustomizeItemDfltUint8 customizeItem)
{
    TAF_NVIM_ApnKeyList voipApnKey;
    VOS_UINT32 ret;

    (VOS_VOID)memset_s(&voipApnKey, sizeof(voipApnKey), 0x00, sizeof(voipApnKey));
    ret = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_VOIP_APN_KEY, (VOS_UINT8 *)&voipApnKey, sizeof(voipApnKey));
    if (ret != NV_OK) {
        AT_WARN_LOG("At_WriteVoipApnKeyNvToDefault : WRITE VOIP APN key NV ERROR.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 At_SetCustomizeItemToDefaultVal(VOS_UINT8 indexNum, AT_CustomizeItemDfltUint8 customizeItem)
{
    /*
     * 设置WIFI定制项对应的en_NV_Item_WIFI_KEY、
     * en_NV_Item_WIFI_STATUS_SSID 2个NV项
     */
    if (At_WriteWifiNVToDefault(customizeItem) != VOS_OK) {
        return VOS_ERR;
    }

    /*
     * 设置SimLock定制项对应的NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO、
     * NV_ITEM_CARDLOCK_STATUS、NV_ITEM_CUSTOMIZE_SIM_LOCK_MAX_TIMES 3个NV项
     */
    if (At_WriteSimLockNVToDefault(indexNum, customizeItem) != VOS_OK) {
        return VOS_ERR;
    }

    if (At_WriteVoipApnKeyNvToDefault(customizeItem) != VOS_OK) {
        AT_WARN_LOG("At_WriteVoipApnKeyNvToDefault : WRITE VOIP APN key to default error.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 At_SetCsdfltPara(VOS_UINT8 indexNum)
{
    /* 命令状态检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 参数个数过多 */
    if (g_atParaIndex != 0) {
        return AT_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_ERROR;
    }

    /* 默认值为0 */
    if (At_SetCustomizeItemToDefaultVal(indexNum, AT_CUSTOMIZE_ITEM_DEFAULT_VALUE_FROM_CFGFILE) != VOS_OK) {
        return AT_ERROR;
    }

    /*  恢复出厂设置后通知应用保存wifi定制信息 */
    if (AT_IsMiscSupport(BSP_MODULE_TYPE_WIFI) == BSP_MODULE_SUPPORT) {
        AT_PhSendRestoreFactParmNoReset();
    }

    return AT_OK;
}

VOS_UINT32 At_GetParaCnt(VOS_UINT8 *data, VOS_UINT16 len)
{
    VOS_UINT32 i;
    VOS_UINT32 cnt;

    cnt = 0;
    for (i = 0; i < len; i++) {
        if (data[i] == ',') {
            ++cnt;
        }
    }

    /* 参数个数 = ','个数+1 */
    return (cnt + 1);
}

VOS_UINT32 At_AsciiNum2SimLockImsiStr(VOS_UINT8 *dst, VOS_UINT8 *src, VOS_UINT16 srcLen)
{
    VOS_UINT16 chkLen;
    VOS_UINT8  tmp;
    VOS_UINT8  bcdCode;

    /* 字符串长度最大为16 */
    if (srcLen > (TAF_PH_SIMLOCK_PLMN_STR_LEN * 2)) {
        return AT_FAILURE;
    }

    for (chkLen = 0; chkLen < srcLen; chkLen++) {
        /* the number is 0-9 */
        if ((src[chkLen] >= 0x30) && (src[chkLen] <= 0x39)) {
            bcdCode = src[chkLen] - 0x30;
        } else {
            return AT_FAILURE;
        }

        tmp = chkLen % 2; /* 判断高低位 */
        if (tmp == 0) {
            dst[chkLen / 2] = (VOS_UINT8)((bcdCode << 4) & 0xF0); /* 高位 */
        } else {
            dst[chkLen / 2] |= (VOS_UINT8)(bcdCode); /* 低位 */
        }
    }
    /* 判定srcLen参数是否是2n+1 */
    if ((srcLen % 2) == 1) {
        dst[srcLen / 2] |= 0x0F; /* 低位 */
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_CovertAtParaToSimlockPlmnInfo(VOS_UINT32 paraCnt, AT_ParseParaType *paralist,
                                            TAF_CUSTOM_SimLockPlmnInfo *simLockPlmnInfo)
{
    VOS_UINT8  mncNum;
    VOS_UINT8  imsiStr[TAF_PH_SIMLOCK_PLMN_STR_LEN];
    VOS_UINT8 *plmnRange = VOS_NULL_PTR;
    VOS_UINT32 i;
    VOS_UINT32 plmnParaIdx;
    VOS_UINT32 imsiStrLen;
    errno_t    memResult;
    VOS_UINT32 mncParaInvalidFlg;

    plmnParaIdx = 0;
    mncNum      = AT_MNC_MIN_LEN;

    (VOS_VOID)memset_s(imsiStr, sizeof(imsiStr), 0x00, sizeof(imsiStr));

    /* Plmn号段信息，从第2个参数开始，每3个为一组，对应(MNClen,PlmnRangeBegin,PlmnRangeEnd) */
    for (i = 1; i < paraCnt; i++) {
        /* 当Plmninfo参数index是3n+1时,对应MNC的长度 */
        if ((i % 3) == 1) {
            mncParaInvalidFlg = (paralist[i].paraLen != 1) ||
                                ((paralist[i].para[0] != '2') && (paralist[i].para[0] != '3'));

            if (mncParaInvalidFlg == VOS_TRUE) {
                return AT_SIMLOCK_PLMN_MNC_LEN_ERR;
            } else {
                mncNum                                                = paralist[i].para[0] - '0';
                simLockPlmnInfo->simLockPlmnRange[plmnParaIdx].mncNum = mncNum;
            }

        } else if ((i % 3) == 2) {
            /* 当Plmninfo参数index是3n+2 时,对应PlmnRangeBegin */
            if (At_AsciiNum2SimLockImsiStr(imsiStr, paralist[i].para, paralist[i].paraLen) == AT_FAILURE) {
                return AT_ERROR;
            } else {
                imsiStrLen = (((VOS_UINT32)paralist[i].paraLen + 1) / 2);
                plmnRange  = simLockPlmnInfo->simLockPlmnRange[plmnParaIdx].rangeBegin;
                if (imsiStrLen > 0) {
                    memResult = memcpy_s(plmnRange, TAF_PH_SIMLOCK_PLMN_STR_LEN, imsiStr, (VOS_UINT16)imsiStrLen);
                    TAF_MEM_CHK_RTN_VAL(memResult, TAF_PH_SIMLOCK_PLMN_STR_LEN, (VOS_UINT16)imsiStrLen);
                }
                (VOS_VOID)memset_s(plmnRange + imsiStrLen, TAF_PH_SIMLOCK_PLMN_STR_LEN - imsiStrLen, 0xFF,
                         (TAF_PH_SIMLOCK_PLMN_STR_LEN - imsiStrLen));
            }
        } else {
            /* 当Plmninfo参数index是3n+2 时,对应PlmnRangeEnd */
            if (At_AsciiNum2SimLockImsiStr(imsiStr, paralist[i].para, paralist[i].paraLen) == AT_FAILURE) {
                return AT_ERROR;
            }
            /* 起始和结束号段长度不一致 或起始号段大于结束号段 直接返回失败 */
            else if ((paralist[i - 1].paraLen != paralist[i].paraLen) ||
                     (AT_AtoI((VOS_CHAR *)paralist[i - 1].para) > AT_AtoI((VOS_CHAR *)paralist[i].para))) {
                AT_ERR_LOG("At_CovertAtParaToSimlockPlmnInfo: AT_CME_INCORRECT_PARAMETERS!");
                return AT_CME_INCORRECT_PARAMETERS;
            } else {
                imsiStrLen = (((VOS_UINT32)paralist[i].paraLen + 1) / 2);
                plmnRange  = simLockPlmnInfo->simLockPlmnRange[plmnParaIdx].rangeEnd;
                if (imsiStrLen > 0) {
                    memResult = memcpy_s(plmnRange, TAF_PH_SIMLOCK_PLMN_STR_LEN, imsiStr, (VOS_UINT16)imsiStrLen);
                    TAF_MEM_CHK_RTN_VAL(memResult, TAF_PH_SIMLOCK_PLMN_STR_LEN, (VOS_UINT16)imsiStrLen);
                }
                (VOS_VOID)memset_s(plmnRange + imsiStrLen, TAF_PH_SIMLOCK_PLMN_STR_LEN - imsiStrLen, 0xFF,
                         (TAF_PH_SIMLOCK_PLMN_STR_LEN - imsiStrLen));
            }
            ++plmnParaIdx;
        }
    }

    return AT_OK;
}


VOS_UINT32 At_SetSimLockPlmnInfo(VOS_UINT8 indexNum, VOS_UINT32 paraCnt, AT_ParseParaType *paralist)
{
    VOS_UINT32                 rslt;
    TAF_CUSTOM_SimLockPlmnInfo simLockPlmnInfo;
    TAF_CUSTOM_CardlockStatus  cardLockStatus;
    VOS_UINT32                 i;
    VOS_UINT32                 plmnInfoNum;
    /* TAF_CUSTOM_SimLockPlmnRange stDftPlmnInfoVal; */

    if (g_atDataLocked == VOS_TRUE) {
        rslt = AT_DATA_UNLOCK_ERROR;
    } else if (paraCnt > ((TAF_MAX_SIM_LOCK_RANGE_NUM * 3) + 1)) {
        rslt = AT_SIMLOCK_PLMN_NUM_ERR;
        /* 判定ulParaCnt参数是否是3n+1 */
    } else if (((paraCnt - 1) % 3) != 0) {
        rslt = AT_ERROR;
    } else {
        rslt = At_CovertAtParaToSimlockPlmnInfo(paraCnt, paralist, &simLockPlmnInfo);
    }

    if (rslt != AT_OK) {
        At_FormatResultData(indexNum, rslt);
        return AT_ERROR;
    }

    /* 获得PLMN 号段(MNClen,PlmnRangeBegin,PlmnRangeEnd)的个数 ，第2个参数开始是Plmn 信息 */
    plmnInfoNum = (paraCnt - 1) / 3;

    /* 将剩余的PLMN号段设置为默认值 */
    for (i = plmnInfoNum; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++) {
        (VOS_VOID)memset_s(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin, TAF_PH_SIMLOCK_PLMN_STR_LEN,
                 AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, TAF_PH_SIMLOCK_PLMN_STR_LEN);
        (VOS_VOID)memset_s(simLockPlmnInfo.simLockPlmnRange[i].rangeEnd, TAF_PH_SIMLOCK_PLMN_STR_LEN,
                 AT_SIM_LOCK_PLMN_RANGE_DEFAULT_VAL, TAF_PH_SIMLOCK_PLMN_STR_LEN);
        simLockPlmnInfo.simLockPlmnRange[i].mncNum = AT_SIM_LOCK_MNC_NUM_DEFAULT_VAL;
    }

    simLockPlmnInfo.status = NV_ITEM_ACTIVE;

    (VOS_VOID)memset_s(&cardLockStatus, sizeof(cardLockStatus), 0x00, sizeof(cardLockStatus));

    /* 获取当前解锁状态 */
    rslt = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_CARDLOCK_STATUS, &cardLockStatus, sizeof(cardLockStatus));

    if (rslt != NV_OK) {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:read NV_ITEM_CARDLOCK_STATUS Fail.");
        At_FormatResultData(indexNum, AT_ERROR);
        return AT_ERROR;
    }

    /* 如果当前已经处于锁定状态，直接返回ERROR */
    if ((cardLockStatus.status == NV_ITEM_ACTIVE) &&
        (cardLockStatus.remainUnlockTimes == TAF_OPERATOR_UNLOCK_TIMES_MIN) &&
        (cardLockStatus.cardlockStatus == TAF_OPERATOR_LOCK_LOCKED)) {
        AT_WARN_LOG("At_SetSimLockPlmnInfo: is locked, operation is not allowed.");
        At_FormatResultData(indexNum, AT_ERROR);
        return AT_ERROR;
    }

    /* 将NV_ITEM_CARDLOCK_STATUS的状态置为激活，CardStatus 的内容设置为1,Remain Times保持不变 */
    cardLockStatus.status         = NV_ITEM_ACTIVE;
    cardLockStatus.cardlockStatus = TAF_OPERATOR_LOCK_NEED_UNLOCK_CODE;

    rslt = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CARDLOCK_STATUS, (VOS_UINT8 *)&cardLockStatus,
                              sizeof(cardLockStatus));
    if (rslt != NV_OK) {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:write NV_ITEM_CARDLOCK_STATUS Fail.");
        At_FormatResultData(indexNum, AT_ERROR);
        return AT_ERROR;
    }

    /* 向C核发送消息备份simlockNV */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_SIMLOCK_NV_SET_REQ,
                               (VOS_UINT8 *)&cardLockStatus, sizeof(cardLockStatus),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetSimLockPlmnInfo():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        At_FormatResultData(indexNum, AT_ERROR);
        return VOS_ERR;
    }

    /* 将PLMN信息写入到NV项NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO */
    rslt = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO, (VOS_UINT8 *)&simLockPlmnInfo,
                              sizeof(simLockPlmnInfo));
    if (rslt != NV_OK) {
        AT_WARN_LOG("At_SetSimLockPlmnInfo:write NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO Fail.");
        At_FormatResultData(indexNum, AT_ERROR);
        return AT_ERROR;
    }

    At_FormatResultData(indexNum, AT_OK);
    return AT_OK;
}


VOS_UINT32 At_SetMaxLockTimes(VOS_UINT8 indexNum)
{
    TAF_CUSTOM_SimLockMaxTimes simLockMaxTimes;

    /* 设置参数为空 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 参数个数过多 */
    if (g_atParaIndex != 1) {
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 检查是否解除数据保护,未解除时返回出错信息 */
    if (g_atDataLocked == VOS_TRUE) {
        return AT_DATA_UNLOCK_ERROR;
    }

    simLockMaxTimes.status       = NV_ITEM_ACTIVE;
    simLockMaxTimes.lockMaxTimes = g_atParaList[0].paraValue;

    /* 向C核发送消息设置SIMLOCK的最大次数 */
    if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_MAX_LOCK_TIMES_SET_REQ,
                               (VOS_UINT8 *)&simLockMaxTimes, sizeof(simLockMaxTimes),
                               I0_WUEPS_PID_DRV_AGENT) != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetMaxLockTimes():DRV_AGENT_SIMLOCK_NV_SET_REQ NV Write Fail!");
        return AT_DEVICE_OTHER_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MAXLCKTMS_SET;
    return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
}


VOS_UINT32 AT_SetVertime(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 发送消息DRV_AGENT_VERTIME_QRY_REQ给AT代理处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, DRV_AGENT_VERTIME_QRY_REQ, VOS_NULL_PTR, 0,
                                 I0_WUEPS_PID_DRV_AGENT);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VERSIONTIME_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

#if (VOS_WIN32 == VOS_OS_VER)


VOS_UINT32 AT_ResetNplmn(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_SetNplmn(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 At_SetReadUsimStub(VOS_UINT8 indexNum)
{

    return AT_OK;
}


VOS_UINT32 AT_SetNvimPara(VOS_UINT8 indexNum)
{
    NV_IdU16      eNvimTempId;
    VOS_UINT32    tempLen;
    VOS_UINT32    rst;
    VOS_UINT8    *nvTemp = VOS_NULL_PTR;
    VOS_UINT16    length;
    ModemIdUint16 modemId;
    VOS_UINT32    ret;

    modemId = MODEM_ID_0;
    tempLen = 0;

    ret = AT_GetModemIdFromClient(indexNum, &modemId);
    if (ret != VOS_OK) {
        AT_ERR_LOG("At_SetCgsnPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 参数不正确 */
    /* 第一个参数为0表示读NV项值，为1表示写NV项 */
    if (!(((g_atParaList[AT_NVSTUB_READ_OR_WRITE].paraValue == 0) && (g_atParaIndex == AT_NVSTUB_MIN_PARA_NUM)) ||
          ((g_atParaList[AT_NVSTUB_READ_OR_WRITE].paraValue == 1) && (g_atParaIndex == AT_NVSTUB_MAX_PARA_NUM)))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第二个参数为NV项ID */
    eNvimTempId = (NV_IdU16)g_atParaList[AT_NVSTUB_NVIM_ID].paraValue;

    /* 第一个参数为0表示读NV项值，为1表示写NV项 */
    if (g_atParaList[AT_NVSTUB_READ_OR_WRITE].paraValue == 0) {
        (VOS_VOID)TAF_ACORE_NV_GET_LENGTH(eNvimTempId, &tempLen);

         if (tempLen == 0) {
            return AT_ERROR;
        }

        nvTemp = (VOS_UINT8 *)PS_MEM_ALLOC(I0_WUEPS_PID_TAF, tempLen);

        if (nvTemp == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_SetNvimPara:ERROR:ALLOC MEMORY FAIL.");
            return AT_ERROR;
        }

        (VOS_VOID)memset_s(nvTemp, tempLen, 0x00, tempLen);

        rst = AT_ReadValueFromNvim(eNvimTempId, nvTemp, tempLen, modemId);
        if (rst == AT_OK) {
            length = 0;
            length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
                (TAF_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);
            length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
                (TAF_CHAR *)g_atSndCodeAddress + length, "^NVSTUB:");
            length += (TAF_UINT16)At_HexString2AsciiNumPrint(AT_CMD_MAX_LEN, (TAF_INT8 *)g_atSndCodeAddress,
                                                             g_atSndCodeAddress + length, nvTemp, (VOS_UINT16)tempLen);

            length += (TAF_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
                (TAF_CHAR *)g_atSndCodeAddress + length, "%s", g_atCrLf);
            At_SendResultData(indexNum, g_atSndCodeAddress, length);
            rst = AT_SUCCESS;
        }

        /* 增加内存释放 */
        PS_MEM_FREE(I0_WUEPS_PID_TAF, nvTemp);
        nvTemp = VOS_NULL_PTR;
        return rst;
    } else {
        if (At_AsciiNum2HexString(g_atParaList[AT_NVSTUB_WRITE].para,
                                  &g_atParaList[AT_NVSTUB_WRITE].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (TAF_ACORE_NV_WRITE_OLD(modemId, eNvimTempId, g_atParaList[AT_NVSTUB_WRITE].para,
                                   g_atParaList[AT_NVSTUB_WRITE].paraLen) != NV_OK) {
            AT_WARN_LOG("AT_SetNvimPara():WARNING:Invoke NVIM Write function falied");
            return AT_ERROR;
        }

        return AT_OK;
    }
}


VOS_UINT32 AT_SetPidReinitPara(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_CheckUSIMPara(VOS_VOID)
{
    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[AT_USIMWRITESTUB_MSG].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_USIMWRITESTUB_MAX_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_USIMWRITESTUB_MSG].para,
                              &g_atParaList[AT_USIMWRITESTUB_MSG].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_VOID AT_SetRecordNumAndAppType(VOS_UINT8 *recordNum, USIMM_CardAppUint32 *appType)
{
    if (g_atParaIndex == AT_USIMWRITESTUB_MIN_PARA_NUM) {
        *recordNum = g_atParaList[AT_USIMWRITESTUB_RECORDNUM].paraValue;
    }

    if (g_atParaIndex == AT_USIMWRITESTUB_MAX_PARA_NUM) {
        *recordNum = g_atParaList[AT_USIMWRITESTUB_RECORDNUM].paraValue;

        *appType = (USIMM_CardAppUint32)g_atParaList[AT_USIMWRITESTUB_APPTYPE].paraValue;
    }

    return;
}

TAF_UINT32 AT_SetUSIMPara(TAF_UINT8 indexNum)
{
    USIMM_StkCommandDetails cMDDetail;
    VOS_UINT8               recordNum;
    USIMM_ResetInfo         rstInfo;
    USIMM_UpdateFileReq    *msg        = VOS_NULL_PTR;
    USIMM_StkrefreshReq    *refreshMsg = VOS_NULL_PTR;
    VOS_UINT32              pathLength;
    VOS_UINT32              msgLength;
    VOS_CHAR               *filePathStr = VOS_NULL_PTR;
    USIMM_DefFileidUint32   fileId;
    VOS_UINT32              i;
    VOS_UINT8               foundFlag;
    USIMM_CardAppUint32     appType;
    VOS_UINT16              modemId;
    VOS_UINT32              result;
    errno_t                 memResult;

    pathLength = 0;
    msgLength  = 0;

    recordNum = 0;
    appType   = USIMM_GUTL_APP;
    modemId   = MODEM_ID_0;
    AT_GetModemIdFromClient(indexNum, &modemId);

    result = AT_CheckUSIMPara();
    if (result != AT_SUCCESS) {
        return result;
    }

    AT_SetRecordNumAndAppType(&recordNum, &appType);

    /* 当读到定制需求更新0x4F36和0x4F34文件时，要设置enAppType */
    /* 文件Id转文件路径 */
    foundFlag = VOS_FALSE;

    if (appType == USIMM_GUTL_APP) {
        for (i = 0; i < g_atUsimFileNumToIdTabLen; i++) {
            if (g_atParaList[0].paraValue == g_atUsimFileNumToIdTab[i].fileNum) {
                fileId = g_atUsimFileNumToIdTab[i].fileId;

                foundFlag = VOS_TRUE;
                break;
            }
        }
    }

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    if (appType == USIMM_CDMA_APP) {
        for (i = 0; i < g_atCsimFileNumToIdTabLen; i++) {
            if (g_atParaList[0].paraValue == g_atCsimFileNumToIdTab[i].fileNum) {
                fileId = g_atCsimFileNumToIdTab[i].fileId;

                foundFlag = VOS_TRUE;
                break;
            }
        }
    }
#endif

    if (foundFlag == VOS_FALSE) {
        return AT_ERROR;
    }

    if (USIMM_ChangeDefFileToPath(fileId, &filePathStr) != VOS_OK) {
        return AT_ERROR;
    }

    /* 文件路径长度保护 */
    pathLength = VOS_StrLen(filePathStr);
    if (pathLength == 0) {
        return AT_ERROR;
    }

    msgLength = (sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH) +
                 ((VOS_UINT32)g_atParaList[AT_USIMWRITESTUB_MSG].paraLen - AT_THREE_TIMES_LENGTH * sizeof(VOS_UINT8));

    if (msgLength < (sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH)) {
        msgLength = sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH;
    }

    msg = (USIMM_UpdateFileReq *)PS_ALLOC_MSG(WUEPS_PID_AT, msgLength);
    if (msg == VOS_NULL_PTR) {
        return AT_ERROR;
    }

    TAF_CfgMsgHdr((MsgBlock *)msg, WUEPS_PID_AT, WUEPS_PID_USIM, msgLength);
    if (modemId == MODEM_ID_1) {
        TAF_CfgMsgHdr((MsgBlock *)msg, WUEPS_PID_AT, I1_WUEPS_PID_USIM, msgLength);
    }

    msg->msgHeader.msgName  = USIMM_UPDATEFILE_REQ;
    msg->msgHeader.appType  = appType;
    msg->msgHeader.sendPara = 0;
    msg->filePath.pathLen   = pathLength;
    memResult = memcpy_s(msg->filePath.path, sizeof(msg->filePath.path), filePathStr, msg->filePath.pathLen + 1);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(msg->filePath.path), msg->filePath.pathLen + 1);
    msg->dataLen   = g_atParaList[AT_USIMWRITESTUB_MSG].paraLen;
    msg->recordNum = recordNum;
    if (g_atParaList[AT_USIMWRITESTUB_MSG].paraLen > 0) {
        memResult = memcpy_s(msg->content, g_atParaList[AT_USIMWRITESTUB_MSG].paraLen,
                             g_atParaList[AT_USIMWRITESTUB_MSG].para,
                             g_atParaList[AT_USIMWRITESTUB_MSG].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, g_atParaList[AT_USIMWRITESTUB_MSG].paraLen,
                            g_atParaList[AT_USIMWRITESTUB_MSG].paraLen);
    }

    /* 调用VOS发送原语 */
    if (TAF_TraceAndSendMsg(WUEPS_PID_AT, msg) != VOS_OK) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraValue == 0x6F07) {
        (VOS_VOID)memset_s(&cMDDetail, sizeof(cMDDetail), 0x00, sizeof(USIMM_StkCommandDetails));

        cMDDetail.commandQua  = USIMM_RESET;
        cMDDetail.commandNum  = 1;
        cMDDetail.commandType = 1;

        (VOS_VOID)memset_s(&rstInfo, sizeof(rstInfo), 0x00, sizeof(rstInfo));

        /* 分配消息内存并初始化 */
        msgLength  = sizeof(USIMM_StkrefreshReq) - VOS_MSG_HEAD_LENGTH;
        refreshMsg = (USIMM_StkrefreshReq *)PS_ALLOC_MSG(WUEPS_PID_AT, msgLength);
        if (refreshMsg == VOS_NULL_PTR) {
            return AT_ERROR;
        }

        /* 填写消息头 */
        TAF_CfgMsgHdr((MsgBlock *)refreshMsg, WUEPS_PID_AT, WUEPS_PID_USIM, msgLength);
        if (modemId == MODEM_ID_1) {
            TAF_CfgMsgHdr((MsgBlock *)refreshMsg, WUEPS_PID_AT, I1_WUEPS_PID_USIM, msgLength);
        }

        refreshMsg->msgHeader.msgName  = USIMM_STKREFRESH_REQ;
        refreshMsg->msgHeader.sendPara = 0;
        refreshMsg->msgHeader.appType  = USIMM_GUTL_APP;

        /* 填写消息体 */
        refreshMsg->commandNum  = cMDDetail.commandNum;
        refreshMsg->commandType = cMDDetail.commandType;
        refreshMsg->refreshType = cMDDetail.commandQua;

        /* 调用VOS发送原语 */
        if (TAF_TraceAndSendMsg(WUEPS_PID_AT, refreshMsg) != VOS_OK) {
            return AT_ERROR;
        }
    }

    return AT_OK;
}

TAF_UINT32 AT_SetSIMPara(TAF_UINT8 indexNum)
{
    errno_t                 memResult;
    USIMM_StkCommandDetails cMDDetail;
    VOS_UINT8               recordNum;
    USIMM_ResetInfo         rstInfo;
    USIMM_UpdateFileReq    *msg        = VOS_NULL_PTR;
    USIMM_StkrefreshReq    *refreshMsg = VOS_NULL_PTR;
    VOS_UINT32              pathLength;
    VOS_UINT32              msgLength;
    VOS_CHAR               *filePathStr = VOS_NULL_PTR;
    USIMM_DefFileidUint32   fileId;
    VOS_UINT32              i;
    VOS_UINT8               foundFlag;

    pathLength = 0;
    msgLength  = 0;

    recordNum = 0;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_SIMWRITESTUB_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].para,
                              &g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex == AT_SIMWRITESTUB_PARA_MAX_NUM) {
        recordNum = g_atParaList[AT_SIMWRITESTUB_RECORDNUM].paraValue;
    }

    /* 当读到定制需求更新0x4F36和0x4F34文件时，要设置enAppType */
    /* 文件Id转文件路径 */
    foundFlag = VOS_FALSE;
    for (i = 0; i < g_atSimFileNumToIdTabLen; i++) {
        if (g_atParaList[0].paraValue == g_atSimFileNumToIdTab[i].fileNum) {
            fileId    = g_atSimFileNumToIdTab[i].fileId;
            foundFlag = VOS_TRUE;
            break;
        }
    }

    if (foundFlag == VOS_FALSE) {
        return AT_ERROR;
    }

    if (USIMM_ChangeDefFileToPath(fileId, &filePathStr) != VOS_OK) {
        return AT_ERROR;
    }

    /* 文件路径长度保护 */
    pathLength = VOS_StrLen(filePathStr);
    if (pathLength == 0) {
        return AT_ERROR;
    }

    msgLength = (sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH) +
        ((VOS_UINT32)g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen - AT_THREE_TIMES_LENGTH * sizeof(VOS_UINT8));

    if (msgLength < (sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH)) {
        msgLength = (sizeof(USIMM_UpdateFileReq) - VOS_MSG_HEAD_LENGTH);
    }

    msg = (USIMM_UpdateFileReq *)PS_ALLOC_MSG(WUEPS_PID_AT, msgLength);
    if (msg == VOS_NULL_PTR) {
        return AT_ERROR;
    }

    TAF_CfgMsgHdr((MsgBlock *)msg, WUEPS_PID_AT, WUEPS_PID_USIM, msgLength);

    msg->msgHeader.msgName  = USIMM_UPDATEFILE_REQ;
    msg->msgHeader.appType  = USIMM_GUTL_APP;
    msg->msgHeader.sendPara = 0;
    msg->filePath.pathLen   = pathLength;
    memResult = memcpy_s(msg->filePath.path, sizeof(msg->filePath.path), filePathStr, msg->filePath.pathLen + 1);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(msg->filePath.path), msg->filePath.pathLen + 1);
    msg->dataLen   = g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen;
    msg->recordNum = recordNum;
    memResult      = memcpy_s(msg->content, g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen,
                              g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].para,
                              g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen,
                        g_atParaList[AT_SIMWRITESTUB_MSGLENGTH].paraLen);

    /* 调用VOS发送原语 */
    if (TAF_TraceAndSendMsg(WUEPS_PID_AT, msg) != VOS_OK) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraValue == 0x6F07) {
        (VOS_VOID)memset_s(&cMDDetail, sizeof(cMDDetail), 0x00, sizeof(USIMM_StkCommandDetails));

        cMDDetail.commandQua  = USIMM_RESET;
        cMDDetail.commandNum  = 1;
        cMDDetail.commandType = 1;

        (VOS_VOID)memset_s(&rstInfo, sizeof(rstInfo), 0x00, sizeof(rstInfo));

        /* 分配消息内存并初始化 */
        msgLength  = sizeof(USIMM_StkrefreshReq) - VOS_MSG_HEAD_LENGTH;
        refreshMsg = (USIMM_StkrefreshReq *)PS_ALLOC_MSG(WUEPS_PID_AT, msgLength);
        if (refreshMsg == VOS_NULL_PTR) {
            return AT_ERROR;
        }

        /* 填写消息头 */
        TAF_CfgMsgHdr((MsgBlock *)refreshMsg, WUEPS_PID_AT, WUEPS_PID_USIM, msgLength);

        refreshMsg->msgHeader.msgName  = USIMM_STKREFRESH_REQ;
        refreshMsg->msgHeader.sendPara = 0;
        refreshMsg->msgHeader.appType  = USIMM_GUTL_APP;

        /* 填写消息体 */
        refreshMsg->commandNum  = cMDDetail.commandNum;
        refreshMsg->commandType = cMDDetail.commandType;
        refreshMsg->refreshType = cMDDetail.commandQua;

        /* 调用VOS发送原语 */
        if (TAF_TraceAndSendMsg(WUEPS_PID_AT, refreshMsg) != VOS_OK) {
            return AT_ERROR;
        }
    }

    return AT_OK;
}

/* AT_SetSTKParaStub无调用点，删除 */


VOS_UINT32 AT_RefreshUSIMPara(VOS_UINT8 indexNum)
{
    USIMM_STKRefreshInd *mmcUsimRefreshMsg = VOS_NULL_PTR;
    USIMM_STKRefreshInd *mmaUsimRefreshMsg = VOS_NULL_PTR;
    VOS_UINT32           rslt;

    /* 参数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_USIM_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[1].para, &g_atParaList[1].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 申请内存  */
    mmcUsimRefreshMsg = (USIMM_STKRefreshInd *)PS_ALLOC_MSG(WUEPS_PID_AT,
                                                            sizeof(USIMM_STKRefreshInd) - VOS_MSG_HEAD_LENGTH);

    if (mmcUsimRefreshMsg == VOS_NULL_PTR) {
        /* 内存申请失败 */
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR: Memory Alloc Error for pstMsg");
        return VOS_ERR;
    }

    TAF_CfgMsgHdr((MsgBlock *)mmcUsimRefreshMsg, MAPS_PIH_PID, AT_GetDestPid(indexNum, I0_WUEPS_PID_MMC),
                  sizeof(USIMM_STKRefreshInd) - VOS_MSG_HEAD_LENGTH);

    /* 模拟USIM给MMC模块发送消息 */
    mmcUsimRefreshMsg->indHdr.msgName = USIMM_STKREFRESH_IND;
    mmcUsimRefreshMsg->efId[0].fileId = g_atParaList[0].paraValue;
    mmcUsimRefreshMsg->efNum          = 1;
    mmcUsimRefreshMsg->refreshType    = USIMM_REFRESH_FILE_LIST;

    /* 调用VOS发送原语 */
    rslt = TAF_TraceAndSendMsg(WUEPS_PID_AT, mmcUsimRefreshMsg);

    if (rslt != VOS_OK) {
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR:TAF_TraceAndSendMsg ");
        return VOS_ERR;
    }

    /* 申请内存  */
    mmaUsimRefreshMsg = (USIMM_STKRefreshInd *)PS_ALLOC_MSG(WUEPS_PID_AT,
                                                            sizeof(USIMM_STKRefreshInd) - VOS_MSG_HEAD_LENGTH);

    if (mmaUsimRefreshMsg == VOS_NULL_PTR) {
        /* 内存申请失败 */
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR: Memory Alloc Error for pstMsg");
        return VOS_ERR;
    }

    TAF_CfgMsgHdr((MsgBlock *)mmaUsimRefreshMsg, MAPS_PIH_PID, AT_GetDestPid(indexNum, I0_WUEPS_PID_MMA),
                  sizeof(USIMM_STKRefreshInd) - VOS_MSG_HEAD_LENGTH);

    /* 模拟USIM给MMA模块发送消息 */
    mmaUsimRefreshMsg->indHdr.msgName = USIMM_STKREFRESH_IND;
    mmaUsimRefreshMsg->efId[0].fileId = g_atParaList[0].paraValue;
    mmaUsimRefreshMsg->efNum          = 1;
    mmaUsimRefreshMsg->refreshType    = USIMM_REFRESH_FILE_LIST;

    /* 调用VOS发送原语 */
    rslt = TAF_TraceAndSendMsg(WUEPS_PID_AT, mmaUsimRefreshMsg);

    if (rslt != VOS_OK) {
        AT_ERR_LOG("AT_RefreshUSIMPara:ERROR:TAF_TraceAndSendMsg ");
        return VOS_ERR;
    }

    return AT_OK;
}
#endif

/* begin V7R1 PhaseI Modify */

VOS_UINT32 At_SetSystemInfoEx(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_QrySystemInfoReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, VOS_TRUE) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SYSINFOEX_READ;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}
/* end V7R1 PhaseI Modify */

#if (FEATURE_UE_MODE_NR == FEATURE_ON)

VOS_UINT32 At_Set5gOptionPara(TAF_UINT8 indexNum)
{
    AT_MTA_Set5GOptionReq option5G;
    VOS_UINT32            rst;

    (VOS_VOID)memset_s(&option5G, sizeof(option5G), 0x00, sizeof(option5G));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != AT_C5GOPTION_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_C5GOPTION_SA_SUPPORT_FLAG].paraLen == 0) ||
        (g_atParaList[AT_C5GOPTION_DC_MODE].paraLen == 0) ||
        (g_atParaList[AT_C5GOPTION_5GCACCESSMODE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    option5G.nrSaSupportFlag = (VOS_UINT8)g_atParaList[AT_C5GOPTION_SA_SUPPORT_FLAG].paraValue;
    option5G.nrDcMode        = (AT_MTA_NrDcModeUint8 )g_atParaList[AT_C5GOPTION_DC_MODE].paraValue;
    option5G.en5gcAccessMode = (AT_MTA_5GcAccessModeUint8 )g_atParaList[AT_C5GOPTION_5GCACCESSMODE].paraValue;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_5G_OPTION_CFG_REQ,
                                 (VOS_UINT8 *)&option5G, sizeof(AT_MTA_Set5GOptionReq), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_5G_OPTION_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_Qry5gOptionPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送消息 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_5G_OPTION_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("At_Qry5gOptionPara: WARNINT: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_5G_OPTION_QRY;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_QryNrSsbIdPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_ERROR;
    }

    /* 发送消息 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_NR_SSB_ID_QRY_REQ, VOS_NULL_PTR, 0, I0_UEPS_PID_MTA);
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("At_QryNrSsbIdPara: WARNING: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NR_SSB_ID_QRY;

    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 AT_SetTmmiPara(VOS_UINT8 indexNum)
{
    errno_t    memResult;
    VOS_UINT32 result;
    VOS_UINT8  facInfo[AT_FACTORY_INFO_LEN];

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数长度过长 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    (VOS_VOID)memset_s(facInfo, sizeof(facInfo), 0x00, AT_FACTORY_INFO_LEN);

    /* 写入en_NV_Item_Factory_Info，需偏移24个字节，长度4为四个字节，因此需要先读 */
    result = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_Factory_Info, facInfo, AT_FACTORY_INFO_LEN);

    if (result != NV_OK) {
        AT_ERR_LOG("AT_SetTmmiPara: NV Read Fail!");
        return AT_ERROR;
    }

    /* 成功 写入"ST P" */
    if (g_atParaList[0].paraValue == 1) {
        memResult = memcpy_s(&facInfo[AT_MMI_TEST_FLAG_OFFSET], AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET,
                             AT_MMI_TEST_FLAG_SUCC, AT_MMI_TEST_FLAG_LEN);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET, AT_MMI_TEST_FLAG_LEN);
    }
    /* 失败 清空 */
    else {
        memResult = memcpy_s(&facInfo[AT_MMI_TEST_FLAG_OFFSET], AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET, "0000",
                             AT_MMI_TEST_FLAG_LEN);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_FACTORY_INFO_LEN - AT_MMI_TEST_FLAG_OFFSET, AT_MMI_TEST_FLAG_LEN);
    }

    result = TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_Factory_Info, facInfo, AT_FACTORY_INFO_LEN);

    if (result != NV_OK) {
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}

VOS_UINT32 AT_SetTestScreenPara(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_SetCdurPara(VOS_UINT8 indexNum)
{
    VOS_UINT32           ret;
    TAF_Ctrl             ctrl;
    TAF_CALL_GetCdurPara getCdurPara;
    ModemIdUint16        modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&getCdurPara, sizeof(getCdurPara), 0x00, sizeof(getCdurPara));

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > AT_CALL_MAX_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    getCdurPara.callId = (VOS_UINT8)g_atParaList[0].paraValue;

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发消息到C核获取通话时长 */
    ret = TAF_CCM_CallCommonReq(&ctrl, &getCdurPara, ID_TAF_CCM_GET_CDUR_REQ, sizeof(getCdurPara), modemId);

    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetCdurPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CDUR_READ;
    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 AT_SetWebPwdPara(VOS_UINT8 indexNum)
{
    VOS_CHAR                    webPwdTmp[AT_WEBUI_PWD_MAX + 1];
    TAF_AT_NvimWebAdminPassword webPwd;
    errno_t                     memResult;

    (VOS_VOID)memset_s(&webPwd, sizeof(webPwd), 0x00, sizeof(webPwd));

    /* 参数检查 */
    if (g_atParaIndex > AT_WUPWD_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数长度过长 */
    if (g_atParaList[1].paraLen > AT_WEBUI_PWD_MAX) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 校验WEBUI PWD */
    if (g_atParaList[0].paraValue == AT_WEBUI_PWD_VERIFY) {
        if (TAF_ACORE_NV_READ_IN_CCORE(MODEM_ID_0, NV_ITEM_WEB_ADMIN_PASSWORD, (VOS_UINT8 *)&webPwd, sizeof(webPwd)) !=
            VOS_OK) {
            AT_WARN_LOG("AT_SetWebPwdPara:READ NV ERROR");
            return AT_ERROR;
        }

        memResult = memcpy_s(webPwdTmp, sizeof(webPwdTmp), &webPwd, sizeof(webPwd));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(webPwdTmp), sizeof(webPwd));

        webPwdTmp[AT_WEBUI_PWD_MAX] = '\0';

        /* 密码不匹配 */
        if (VOS_StrCmp(webPwdTmp, (VOS_CHAR *)g_atParaList[1].para) != 0) {
            (VOS_VOID)memset_s(webPwdTmp, sizeof(webPwdTmp), 0x00, sizeof(webPwdTmp));
            (VOS_VOID)memset_s(&webPwd, sizeof(webPwd), 0x00, sizeof(webPwd));
            (VOS_VOID)memset_s(g_atParaList[1].para, sizeof(g_atParaList[1].para), 0x00, sizeof(g_atParaList[1].para));
            return AT_ERROR;
        }
    } else {
        /* 读取WEBPWD对应的NV项 */
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_WEB_ADMIN_PASSWORD, g_atParaList[1].para, AT_WEBUI_PWD_MAX) !=
            VOS_OK) {
            AT_WARN_LOG("AT_SetWebPwdPara:WRITE NV ERROR");
            (VOS_VOID)memset_s(g_atParaList[1].para, sizeof(g_atParaList[1].para), 0x00, sizeof(g_atParaList[1].para));
            return AT_ERROR;
        }
    }

    (VOS_VOID)memset_s(webPwdTmp, sizeof(webPwdTmp), 0x00, sizeof(webPwdTmp));
    (VOS_VOID)memset_s(&webPwd, sizeof(webPwd), 0x00, sizeof(webPwd));
    (VOS_VOID)memset_s(g_atParaList[1].para, sizeof(g_atParaList[1].para), 0x00, sizeof(g_atParaList[1].para));
    return AT_OK;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetSdloadPara(VOS_UINT8 indexNum)
{
#if (FEATURE_LTE == FEATURE_ON)
    return AT_SetLteSdloadPara(indexNum);
#else
    VOS_UINT32 ret;

    ret = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 DRV_AGENT_SDLOAD_SET_REQ, VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT);
    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetSdloadPara: MN_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SDLOAD_SET;
    return AT_WAIT_ASYNC_RETURN;

#endif
}
#endif


VOS_UINT32 AT_SetProdNamePara(VOS_UINT8 indexNum)
{
    TAF_AT_ProductId productId;
    VOS_UINT32       productIdLen;
    VOS_UINT32       ret;
    errno_t          memResult;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(&productId, sizeof(productId), 0x00, sizeof(TAF_AT_ProductId));

    /* 从NV50048中读取产品名称 */
    /* 读取NV项NV_ITEM_PRODUCT_ID */
    ret = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PRODUCT_ID, &productId,
                            sizeof(productId.nvStatus) + sizeof(productId.productId));

    if (ret != NV_OK) {
        AT_WARN_LOG("AT_SetProdNamePara: Fail to read NV_ITEM_PRODUCT_ID");
        return AT_ERROR;
    }

    /* 产品名称写到NV项中，长度最长AT_PRODUCT_NAME_MAX_NUM 30，超过截断 */
    productIdLen = (g_atParaList[0].paraLen > AT_PRODUCT_NAME_MAX_NUM) ? AT_PRODUCT_NAME_MAX_NUM :
                                                                         g_atParaList[0].paraLen;

    (VOS_VOID)memset_s(productId.productId, sizeof(productId.productId), 0x00, sizeof(productId.productId));
    if (productIdLen > 0) {
        memResult = memcpy_s(productId.productId, sizeof(productId.productId), g_atParaList[0].para,
                             (VOS_UINT16)productIdLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(productId.productId), (VOS_UINT16)productIdLen);
    }

    productId.nvStatus = VOS_TRUE;

    /* 写入NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_PRODUCT_ID, (VOS_UINT8 *)&productId,
                           sizeof(productId.nvStatus) + sizeof(productId.productId)) != NV_OK) {
        AT_ERR_LOG("AT_SetProdNamePara:Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_SetApRptSrvUrlPara(VOS_UINT8 indexNum)
{
    errno_t   memResult;
    VOS_UINT8 apRptSrvUrl[AT_AP_XML_RPT_SRV_URL_LEN + 1];
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    /* URL为空或者长度超过127 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraLen > AT_AP_XML_RPT_SRV_URL_LEN)) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(apRptSrvUrl, sizeof(apRptSrvUrl), 0x00, sizeof(apRptSrvUrl));
    memResult = memcpy_s(apRptSrvUrl, sizeof(apRptSrvUrl), g_atParaList[0].para, g_atParaList[0].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(apRptSrvUrl), g_atParaList[0].paraLen);

    /* 写NV:NV_ITEM_AP_RPT_SRV_URL */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_AP_RPT_SRV_URL, apRptSrvUrl, AT_AP_XML_RPT_SRV_URL_LEN + 1) != NV_OK) {
        AT_ERR_LOG("AT_SetApRptSrvUrlPara:Write NV fail");
        return AT_ERROR;
    } else {
        g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (TAF_CHAR *)g_atSndCodeAddress, "^APRPTSRVURLNTY");

        return AT_OK;
    }
}


VOS_UINT32 AT_SetApXmlInfoTypePara(VOS_UINT8 indexNum)
{
    VOS_UINT8 apXmlInfoType[AT_AP_XML_RPT_INFO_TYPE_LEN + 1];
    errno_t   memResult;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    /* INFO TYPE为空或者长度超过127 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraLen > AT_AP_XML_RPT_INFO_TYPE_LEN)) {
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(apXmlInfoType, sizeof(apXmlInfoType), 0x00, sizeof(apXmlInfoType));
    memResult = memcpy_s(apXmlInfoType, sizeof(apXmlInfoType), g_atParaList[0].para, g_atParaList[0].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(apXmlInfoType), g_atParaList[0].paraLen);

    /* 写NV:NV_ITEM_AP_XML_INFO_TYPE */
    if (NV_OK !=
        TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_AP_XML_INFO_TYPE, apXmlInfoType, AT_AP_XML_RPT_INFO_TYPE_LEN + 1)) {
        AT_ERR_LOG("AT_SetApXmlInfoTypePara:Write NV fail");
        return AT_ERROR;
    } else {
        g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (TAF_CHAR *)g_atSndCodeAddress,
            (TAF_CHAR *)g_atSndCodeAddress, "^APXMLINFOTYPENTY");

        return AT_OK;
    }
}


VOS_UINT32 AT_SetApXmlRptFlagPara(VOS_UINT8 indexNum)
{
    TAF_AT_NvimApXmlRptFlg apXmlRptFlg;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    apXmlRptFlg.apXmlRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 写NV:NV_ITEM_AP_XML_RPT_FLAG */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_AP_XML_RPT_FLAG, (VOS_UINT8 *)&apXmlRptFlg,
                           sizeof(TAF_AT_NvimApXmlRptFlg)) != NV_OK) {
        AT_ERR_LOG("AT_SetApXmlRptFlagPara:Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}


VOS_UINT32 AT_SetFastDormPara(VOS_UINT8 indexNum)
{
    AT_RABM_FastdormPara fastDormPara;
    VOS_UINT32           rslt;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_FASTDORM_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第二个参数为空，则填写默认值 */
    if (g_atParaList[1].paraLen == 0) {
        /* 填写默认值5S */
        g_atParaList[1].paraValue = AT_FASTDORM_DEFAULT_TIME_LEN;
    }

    fastDormPara.fastDormOperationType = g_atParaList[0].paraValue;
    fastDormPara.timeLen               = g_atParaList[1].paraValue;

#if (FEATURE_LTE == FEATURE_ON)
    AT_SetLFastDormPara(indexNum);
#endif

    /* 在AT融合版本上，新增的接口为直接发消息，因此这里直接发送消息给RABM */
    rslt = AT_SndSetFastDorm(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &fastDormPara);
    if (rslt == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_FASTDORM_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetMemInfoPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;

    /* 参数检查 */
    if ((g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) || (g_atParaIndex > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发消息到C核获取 MEMINFO 信息, g_atParaList[0].ulParaValue 中为查询的类型 */
    ret = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 DRV_AGENT_MEMINFO_QRY_REQ, (VOS_UINT8 *)&(g_atParaList[0].paraValue),
                                 sizeof(g_atParaList[0].paraValue), I0_WUEPS_PID_DRV_AGENT);
    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("AT_QryMemInfoPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MEMINFO_READ;
    return AT_WAIT_ASYNC_RETURN;
}
#endif

#if (VOS_WIN32 == VOS_OS_VER)

VOS_UINT32 AT_SetRplmnStub(VOS_UINT8 indexNum)
{
    TAF_PLMN_Id plmnId;
    VOS_UINT32  lai;
    VOS_UINT32  rac;

    /*
     * 参数不正确,
     * 0:表示需要设置L的RPLMN
     * 1:表示需要设置GU的RPLMN
     */
    if ((g_atParaList[AT_RPLMNSTUB_L_RPLMN].paraValue != 0) && (g_atParaList[AT_RPLMNSTUB_L_RPLMN].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要设置PLMN ID的值 其长度只能为5 或者6 */
    if ((g_atParaList[AT_RPLMNSTUB_PLMN_ID].paraLen != AT_PLMN_STR_MIN_LEN) &&
        (g_atParaList[AT_RPLMNSTUB_PLMN_ID].paraLen != AT_PLMN_STR_MAX_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* Mcc */
    if (At_String2Hex(g_atParaList[AT_RPLMNSTUB_PLMN_ID].para, AT_MCC_LENGTH, &plmnId.mcc) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* Mnc */
    if (At_String2Hex(&g_atParaList[AT_RPLMNSTUB_PLMN_ID].para[3],
                      g_atParaList[AT_RPLMNSTUB_PLMN_ID].paraLen - AT_MNC_LENGTH,
                      &plmnId.mnc) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    plmnId.mcc |= 0xFFFFF000U;
    /* mnc一个数字只占半个字节，也就是4bit */
    plmnId.mnc |= (0xFFFFFFFFU << ((g_atParaList[AT_RPLMNSTUB_PLMN_ID].paraLen - AT_MNC_LENGTH) * 4));

    /* lai */
    lai = 0x0001;
    if (g_atParaList[AT_RPLMNSTUB_LAI].paraLen == AT_RPLMNSTUB_LAI_VALID_LEN) {
        if (At_String2Hex(g_atParaList[AT_RPLMNSTUB_LAI].para, AT_RPLMNSTUB_LAI_VALID_LEN, &lai) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* rac  */
    rac = 0x01;
    if (g_atParaList[AT_RPLMNSTUB_RAC].paraLen == AT_RPLMNSTUB_RAC_VALID_LEN) {
        if (At_String2Hex(g_atParaList[AT_RPLMNSTUB_RAC].para, AT_RPLMNSTUB_RAC_VALID_LEN, &rac) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 需要设置L的RPLMN */
    if (g_atParaList[AT_RPLMNSTUB_L_RPLMN].paraValue == 0) {
        NAS_SetLteRplmnId(&plmnId, lai, rac);
    } else {
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCsgStub(VOS_UINT8 indexNum)
{
    /* 第一个参数为设置UE是否支持CSG功能，0:不支持csg功能；1:支持csg功能 */
    if (At_String2Hex(g_atParaList[AT_CSGSTUB_UECSG].para, g_atParaList[AT_CSGSTUB_UECSG].paraLen,
                      &g_atParaList[AT_CSGSTUB_UECSG].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CSGSTUB_UECSG].paraValue != 0) && (g_atParaList[AT_CSGSTUB_UECSG].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第二个参数设置EFAD文件中csg display indicator的值，0:都上报；1:只上报operator csg list中csg id */
    if (At_String2Hex(g_atParaList[AT_CSGSTUB_EFAD].para, g_atParaList[AT_CSGSTUB_EFAD].paraLen,
                      &g_atParaList[AT_CSGSTUB_EFAD].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CSGSTUB_EFAD].paraValue != 0) && (g_atParaList[AT_CSGSTUB_EFAD].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数csg list搜网是否仅上报operator csg list中的网络，0:都上报；1:只上报operator csg list中csg id */
    if (At_String2Hex(g_atParaList[AT_CSGSTUB_CSGLIST].para, g_atParaList[AT_CSGSTUB_CSGLIST].paraLen,
                      &g_atParaList[AT_CSGSTUB_CSGLIST].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CSGSTUB_CSGLIST].paraValue != 0) && (g_atParaList[AT_CSGSTUB_CSGLIST].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    NAS_SetCsgCfg(g_atParaList[AT_CSGSTUB_UECSG].paraValue, g_atParaList[AT_CSGSTUB_EFAD].paraValue,
                  g_atParaList[AT_CSGSTUB_CSGLIST].paraValue);

    return AT_OK;
}


VOS_UINT32 AT_SetDamParaStub(VOS_UINT8 indexNum)
{
    TAF_PLMN_Id imsiPlmnList[AT_IMSI_PLMN_LIST_ARRAY_MAX_LEN];
    VOS_UINT8   imsiPlmnNum;
    TAF_PLMN_Id damPlmnList[AT_DAM_PLMN_LIST_ARRAY_MAX_LEN];
    VOS_UINT8   damPlmnNum;
    VOS_UINT8   enableLteTrigPlmnSearchFlag;
    VOS_UINT8   addDamPlmnInDisabledPlmnList;
    VOS_UINT8   i;
    VOS_UINT8   paraIndex;
    VOS_UINT32  mcc;
    VOS_UINT32  mnc;
    VOS_UINT8 damActiveFlg;

    (VOS_VOID)memset_s(&imsiPlmnList, sizeof(imsiPlmnList), 0x00, sizeof(imsiPlmnList));
    (VOS_VOID)memset_s(&damPlmnList, sizeof(damPlmnList), 0x00, sizeof(damPlmnList));

    /*
     * 第一个参数为enable lte是否需要搜网，0为不需要；1为需要；
     * 第二个参数为DAM网络disable lte后是否加入禁止接入技术网络列表中，0为不需要；1为需要；
     * 第三个参数为imsi plmn list个数，如果个数为2，第四个参数和第五个参数为 imsi plmn id。
     * 第六个参数为DAM plmn list 个数，如果个数为2，第七个参数和第8个参数为dam plmn id
     */

    /* 获取ucDamActiveFlg */
    if (At_String2Hex(g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].para,
                      g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].paraLen,
                      &g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].paraValue != 0) &&
        (g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    damActiveFlg = g_atParaList[AT_DAMCFGSTUB_DAM_ACTIVE_FLG].paraValue;

    /* 获取ucEnableLteTrigPlmnSearchFlag */
    if (At_String2Hex(g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].para, g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].paraLen,
                      &g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].paraValue != 0) &&
        (g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    enableLteTrigPlmnSearchFlag = g_atParaList[AT_DAMCFGSTUB_ENABLE_LTE].paraValue;

    /* 获取ucAddDamPlmnInDisabledPlmnList */
    if (At_String2Hex(g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].para,
                      g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].paraLen,
                      &g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].paraValue != 0) &&
        (g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    addDamPlmnInDisabledPlmnList = g_atParaList[AT_DAMCFGSTUB_DAM_DISABLE_LTE].paraValue;

    /* 获取ucImsiPlmnNum */
    if (At_String2Hex(g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM].para, g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM].paraLen,
                      &g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM].paraValue > AT_DAMCFGSTUB_IMSI_PLMN_MAX_VALUE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    imsiPlmnNum = g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM].paraValue;
    for (i = 1; i <= imsiPlmnNum; i++) {
        /* Mcc */
        if (At_String2Hex(g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM + i].para, AT_MCC_LENGTH, &mcc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        imsiPlmnList[i - 1].mcc = mcc;

        /* Mnc */
        if (At_String2Hex(&g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM + i].para[AT_COMMAND_PARA_INDEX_3],
                          g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM + i].paraLen - AT_MCC_LENGTH, &mnc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        imsiPlmnList[i - 1].mnc = mnc;

        imsiPlmnList[i - 1].mcc |= 0xFFFFF000U;
        imsiPlmnList[i - 1].mnc |= (0xFFFFFFFFU <<
            ((g_atParaList[AT_DAMCFGSTUB_IMSI_PLMN_NUM + i].paraLen - AT_MCC_LENGTH) * AT_HALF_BYTE_BIT_LEN));
    }

    /* 第三个参数为imsi plmn list个数，加3为第六个参数为DAM plmn list个数，再加1为第七个参数dam plmn id */
    paraIndex = 3 + imsiPlmnNum + 1;
    if (At_String2Hex(g_atParaList[paraIndex].para, g_atParaList[paraIndex].paraLen,
                      &g_atParaList[paraIndex].paraValue) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    damPlmnNum = g_atParaList[paraIndex].paraValue;

    for (i = 1; i <= damPlmnNum; i++) {
        /* Mcc */
        if (At_String2Hex(g_atParaList[paraIndex + i].para, AT_MCC_LENGTH, &damPlmnList[i - 1].mcc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* Mnc */
        if (At_String2Hex(&g_atParaList[paraIndex + i].para[AT_COMMAND_PARA_INDEX_3],
            g_atParaList[paraIndex + i].paraLen - AT_MCC_LENGTH, &damPlmnList[i - 1].mnc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        damPlmnList[i - 1].mcc |= 0xFFFFF000U;
        damPlmnList[i - 1].mnc |= (0xFFFFFFFFU <<
            ((g_atParaList[paraIndex + i].paraLen - AT_MCC_LENGTH) * AT_HALF_BYTE_BIT_LEN));
    }

    NAS_SetDamCfg(damActiveFlg, enableLteTrigPlmnSearchFlag, addDamPlmnInDisabledPlmnList, imsiPlmnNum, imsiPlmnList,
                  damPlmnNum, damPlmnList);
    return AT_OK;
}


VOS_UINT32 AT_SetEonsParaStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 num;
    VOS_UINT8 eonsPrioType[AT_EONS_PRIO_TYPE_ARRAY_MAX_LEN];
    VOS_UINT8 refreshAllFileRestartFlag;

    (VOS_VOID)memset_s(&eonsPrioType, sizeof(eonsPrioType), 0x00, sizeof(eonsPrioType));

    num                                           = (VOS_UINT8)g_atParaList[AT_EONSSTUB_NCNUM].paraValue;
    eonsPrioType[AT_EONS_PRIO_TYPE_ARRAY_INDEX_0] = (VOS_UINT8)g_atParaList[AT_EONSSTUB_TYPE1].paraValue;
    eonsPrioType[AT_EONS_PRIO_TYPE_ARRAY_INDEX_1] = (VOS_UINT8)g_atParaList[AT_EONSSTUB_TYPE2].paraValue;
    eonsPrioType[AT_EONS_PRIO_TYPE_ARRAY_INDEX_2] = (VOS_UINT8)g_atParaList[AT_EONSSTUB_TYPE3].paraValue;
    eonsPrioType[AT_EONS_PRIO_TYPE_ARRAY_INDEX_3] = (VOS_UINT8)g_atParaList[AT_EONSSTUB_TYPE4].paraValue;
    refreshAllFileRestartFlag                     = (VOS_UINT8)g_atParaList[AT_EONSSTUB_RESTART_FLAG].paraValue;

    NAS_SetEonsPara(num, eonsPrioType, refreshAllFileRestartFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetWildCardParaStub(VOS_UINT8 indexNum)
{
    NAS_SetWildCardPara(g_atParaList[0].para[0]);

    return AT_OK;
}


VOS_UINT32 AT_SetCsUnAvailPlmnStub(VOS_UINT8 indexNum)
{
    TAF_PLMN_Id plmnId;

    /*
     * 参数不正确,
     * 0:表示需要删除CS不可用网络
     * 1:表示需要新增CS不可用网络
     */
    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue != 0) {
        /* 需要设置PLMN ID的值 其参数长度只能为5 或者6  */
        if ((g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].paraLen != AT_PLMN_STR_MIN_LEN) &&
            (g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].paraLen != AT_PLMN_STR_MAX_LEN)) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* Mcc */
        if (At_String2Hex(g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].para, AT_MCC_LENGTH, &plmnId.mcc) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        /* Mnc */
        if (At_String2Hex(&g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].para[3],
                          g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].paraLen - AT_MNC_LENGTH, &plmnId.mnc) ==
                          AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        plmnId.mcc |= 0xFFFFF000U;
        /* mnc一个数字只占半个字节，也就是4bit */
        plmnId.mnc |= (0xFFFFFFFFU << ((g_atParaList[AT_CSUNAVAILPLMNSTUB_PLMNID].paraLen - AT_MNC_LENGTH) * 4));
    }

    /* 需要设置L的CS不可用网络 */
    if (NAS_SetCsUnAvailPlmnId(g_atParaList[0].paraValue, &plmnId) == VOS_OK) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetDisableRatPlmnStub(VOS_UINT8 indexNum)
{
    /*
     * 参数不正确,
     * 0:表示需要删除禁止接入技术网络列表
     */
    if (g_atParaList[0].paraValue != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (NAS_SetDisableRatPlmn(g_atParaList[0].paraValue) == VOS_OK) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetForbRoamTaStub(VOS_UINT8 indexNum)
{
    /*
     * 参数不正确,
     * 0:表示需要删除禁止漫游TA
     * 1:表示需要新增禁止漫游TA
     */
    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 需要设置L的禁止漫游TA */
    if (NAS_SetForbRoamTa(g_atParaList[0].paraValue) == VOS_OK) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetTinTypeStub(VOS_UINT8 indexNum)
{
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置TIN类型 */
    NAS_SetTinType(g_atParaList[0].paraValue);

    return AT_OK;
}


VOS_UINT32 AT_SetPsBearIsrFlgStub(VOS_UINT8 indexNum)
{
    if (g_atParaIndex > AT_PDPISRSTUB_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

#if (FEATURE_LTE == FEATURE_ON)

    /* 设置usapi 对应的pdp是在ISR激活前激活的还是在ISR激活后激活的 */
    NAS_SetPsBearerIsrFlg(g_atParaList[AT_COMMAND_PARA_INDEX_0].paraValue,
                          g_atParaList[AT_COMMAND_PARA_INDEX_1].paraValue,
                          g_atParaList[AT_COMMAND_PARA_INDEX_2].paraValue);
#endif

    return AT_OK;
}


VOS_UINT32 AT_SetImsRatStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 lteImsSupportFlg;
    VOS_UINT8 lteEmsSupportFlg;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_IMSRATSTUB_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数 LTE IMS是否支持 */
    lteImsSupportFlg = g_atParaList[0].paraValue;

    /* 第二个参数 LTE EMS是否支持 */
    lteEmsSupportFlg = g_atParaList[1].paraValue;

    NAS_SetLteImsSupportFlag(lteImsSupportFlg, lteEmsSupportFlg);

    return AT_OK;
}


VOS_UINT32 AT_SetImsCapabilityStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 voiceCallOnImsSupportFlg;
    VOS_UINT8 videoCallOnImsSupportFlg;
    VOS_UINT8 smsOnImsSupportFlg;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_IMSCAPSTUB_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数表示voice call是否支持 0:不支持;1:支持 */
    voiceCallOnImsSupportFlg = g_atParaList[0].paraValue;

    /* 第二个参数表示video call是否支持 0:不支持;1:支持 */
    videoCallOnImsSupportFlg = g_atParaList[1].paraValue;

    /* 第三个参数表示sms是否支持 0:不支持;1:支持 */
    smsOnImsSupportFlg = g_atParaList[AT_IMSCAPSTUB_SMS].paraValue;

    NAS_SetImsLteCapabilitySupportFlag(voiceCallOnImsSupportFlg, videoCallOnImsSupportFlg, smsOnImsSupportFlg);

    return AT_OK;
}


VOS_UINT32 AT_SetDomainStub(VOS_UINT8 indexNum)
{
    VOS_UINT8  voiceDomain;
    VOS_UINT8  smsDomain;
    VOS_UINT32 updateMmlVoiceDomainFlag;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_DOMAINSTUB_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数 voice domain时，0:CS ONLY; 1:IMS PS ONLY; 2:CS PREFERRED; 3:IMS PS PREFERRED */
    voiceDomain = g_atParaList[0].paraValue;

    /* 第二个参数 sms domain时，  0:NOT USE SMS OVER IP;    1:PREFERR TO USE SMS OVER IP */
    smsDomain = g_atParaList[1].paraValue;

    updateMmlVoiceDomainFlag = g_atParaList[AT_DOMAINSTUB_MMLVOICEDOMAINFLAG].paraValue;

    NAS_SetPreferDomain(voiceDomain, smsDomain, updateMmlVoiceDomainFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetCmdImsRoamingStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 imsRoamingFlag;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    imsRoamingFlag = g_atParaList[0].paraValue;

    NAS_SetImsRoaming(imsRoamingFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetCmdRedailStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 callRedialImsToCs;
    VOS_UINT8 smsRedialImsToCs;
    VOS_UINT8 ssRedialImsToCs;
    VOS_UINT8 callRedialCsToIms;
    VOS_UINT8 smsRedialCsToIms;
    VOS_UINT8 ssRedialCsToIms;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > AT_CREDIALSTUB_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* IMS到CS呼叫换域重拨配置 */
    callRedialImsToCs = g_atParaList[0].paraValue;

    /* IMS到CS短信换域重拨配置 */
    smsRedialImsToCs = g_atParaList[1].paraValue;

    /* IMS到CS补充换域重拨配置 */
    ssRedialImsToCs = g_atParaList[AT_CREDIALSTUB_SSREDIALIMSTOCS].paraValue;

    /* CS到IMS呼叫换域重拨配置 */
    callRedialCsToIms = g_atParaList[AT_CREDIALSTUB_CALLREDIALCSTOIMS].paraValue;

    /* CS到IMS短信换域重拨配置 */
    smsRedialCsToIms = g_atParaList[AT_CREDIALSTUB_SMSREDIALCSTOTMS].paraValue;

    /* CS到IMS补充换域重拨配置 */
    ssRedialCsToIms = g_atParaList[AT_CREDIALSTUB_SSREDIALCSTOIMS].paraValue;

    NAS_SetRedialCfg(callRedialImsToCs, smsRedialImsToCs, ssRedialImsToCs, callRedialCsToIms, smsRedialCsToIms,
                     ssRedialCsToIms);

    return AT_OK;
}


VOS_UINT32 AT_SetImsVoiceInterSysLauEnableStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 forceLauFlag;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    forceLauFlag = g_atParaList[0].paraValue;

    NAS_SetImsVoiceInterSysLauEnable(forceLauFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetImsVoiceMMEnableStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 imsVoiceMMEnableFlag;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    imsVoiceMMEnableFlag = g_atParaList[0].paraValue;

    NAS_SetImsVoiceMMEnableFlg(imsVoiceMMEnableFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetCmdImsUssdStub(VOS_UINT8 indexNum)
{
    VOS_UINT8 imsUssdFlag;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取漫游支持参数 */
    imsUssdFlag = g_atParaList[0].paraValue;

    NAS_SetImsUssd(imsUssdFlag);

    return AT_OK;
}

#endif


VOS_UINT32 AT_SetDnsQueryPara(VOS_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 给APS模块发送执行命令操作消息 */
    if (TAF_PS_GetDynamicDnsInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId),
                                 g_atClientTab[indexNum].opId, (VOS_UINT8)g_atParaList[0].paraValue) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DNSQUERY_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetMemStatusPara(VOS_UINT8 indexNum)
{
    MN_MSG_SetMemstatusParm memStatus;

    /* 初始化 */
    (VOS_VOID)memset_s(&memStatus, sizeof(memStatus), 0x00, sizeof(MN_MSG_SetMemstatusParm));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    if (g_atParaList[0].paraValue == 0) {
        memStatus.memFlag = MN_MSG_MEM_FULL_SET;
    } else {
        memStatus.memFlag = MN_MSG_MEM_FULL_UNSET;
    }

    /* 调用MN消息API发送设置请求给MSG模块 */
    if (MN_MSG_SetMemStatus(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, &memStatus) !=
        MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSASM_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCdmaMemStatusPara(VOS_UINT8 indexNum)
{
    TAF_XSMS_ApMemFullUint8 aPMemFullFlag = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置参数 */
    if (g_atParaList[0].paraValue == 0) {
        aPMemFullFlag = TAF_XSMS_AP_MEM_FULL;
    } else {
        aPMemFullFlag = TAF_XSMS_AP_MEM_NOT_FULL;
    }

    /* 调用MN消息API发送设置请求给MSG模块 */
    if (TAF_XSMS_SetXsmsApMemFullReq(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, aPMemFullFlag) !=
        AT_SUCCESS) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCSASM_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 AT_SetApRptPortSelectTwoPara(void)
{
    VOS_UINT32                    result0;
    VOS_UINT32                    result1;
    AT_PortRptCfg                 rptCfg;
    VOS_UINT32                    clientCfgTabLen;
    const AT_ClientCfgMapTab     *cfgMapTbl = VOS_NULL_PTR;
    AT_ClientConfiguration       *clientCfg = VOS_NULL_PTR;
    VOS_UINT8                     i;

    (VOS_VOID)memset_s(&rptCfg, sizeof(rptCfg), 0x00, sizeof(rptCfg));
    /* AT的端口个数大于32个，所以用两个32bit的参数表示对应的端口是否允许主动上报 */
    result0 = AT_String2Hex(g_atParaList[0].para, g_atParaList[0].paraLen, &rptCfg.rptCfgBit32[0]);
    result1 = AT_String2Hex(g_atParaList[1].para, g_atParaList[1].paraLen, &rptCfg.rptCfgBit32[1]);

    if ((result0 == VOS_ERR) || (result1 == VOS_ERR)) {
        AT_ERR_LOG1("AT_SetApRptPortSelectTwoPara: ulResult0 is d%", result0);
        AT_ERR_LOG1("AT_SetApRptPortSelectTwoPara: ulResult1 is d%", result1);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    clientCfgTabLen = AT_GET_CLIENT_CFG_TAB_LEN();
    /*  FEATURE_VCOM_EXT宏关闭的时候，ulClientCfgTabLen 总长度为2，不需要减 */
#if (FEATURE_VCOM_EXT == FEATURE_ON)
    /* 两个参数的时候，需要总长度需要减去一个参数所代表的长度32，另外加上预留了6个端口，所以是26 */
    clientCfgTabLen = clientCfgTabLen - 26;
#endif

    for (i = 0; i < clientCfgTabLen; i++) {
        cfgMapTbl = AT_GetClientCfgMapTbl(i);
        clientCfg = AT_GetClientConfig(cfgMapTbl->clientId);

        clientCfg->reportFlg = ((rptCfg.rptCfgBit32[0] & cfgMapTbl->rptCfgBit32[0]) ||
                                (rptCfg.rptCfgBit32[1] & cfgMapTbl->rptCfgBit32[1])) ?
                                   VOS_TRUE :
                                   VOS_FALSE;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetApRptPortSelectThreePara(void)
{
    VOS_UINT32                    result0;
    VOS_UINT32                    result1;
    VOS_UINT32                    result2;
    AT_PortRptCfg                 rptCfg;
    const AT_ClientCfgMapTab     *cfgMapTbl = VOS_NULL_PTR;
    AT_ClientConfiguration       *clientCfg = VOS_NULL_PTR;
    VOS_UINT8                     i;

    (VOS_VOID)memset_s(&rptCfg, sizeof(rptCfg), 0x00, sizeof(rptCfg));
    /* 获取用户设置的参数 */
    /* AT的端口个数大于64个，所以用三个32bit的参数表示对应的端口是否允许主动上报 */
    result0 = AT_String2Hex(g_atParaList[AT_APRPTPORTSEL_PORTSEL1].para, g_atParaList[AT_APRPTPORTSEL_PORTSEL1].paraLen,
                            &rptCfg.rptCfgBit32[AT_RPT_CFG_BIT32_INDEX_0]);
    result1 = AT_String2Hex(g_atParaList[AT_APRPTPORTSEL_PORTSEL2].para, g_atParaList[AT_APRPTPORTSEL_PORTSEL2].paraLen,
                            &rptCfg.rptCfgBit32[AT_RPT_CFG_BIT32_INDEX_1]);
    result2 = AT_String2Hex(g_atParaList[AT_APRPTPORTSEL_PORTSELTHREE].para,
                            g_atParaList[AT_APRPTPORTSEL_PORTSELTHREE].paraLen,
                            &rptCfg.rptCfgBit32[AT_RPT_CFG_BIT32_INDEX_2]);

    if ((result0 == VOS_ERR) || (result1 == VOS_ERR) || (result2 == VOS_ERR)) {
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult0 is d%", result0);
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult1 is d%", result1);
        AT_ERR_LOG1("AT_SetApRptPortSelectThreePara: ulResult2 is d%", result2);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    for (i = 0; i < AT_GET_CLIENT_CFG_TAB_LEN(); i++) {
        cfgMapTbl = AT_GetClientCfgMapTbl(i);
        clientCfg = AT_GetClientConfig(cfgMapTbl->clientId);

        clientCfg->reportFlg = ((rptCfg.rptCfgBit32[0] & cfgMapTbl->rptCfgBit32[0]) ||
                                (rptCfg.rptCfgBit32[1] & cfgMapTbl->rptCfgBit32[1]) ||
                                (rptCfg.rptCfgBit32[AT_APRPTPORTSEL_PORTSELTHREE] &
                                 cfgMapTbl->rptCfgBit32[AT_APRPTPORTSEL_PORTSELTHREE])) ?
                                    VOS_TRUE :
                                    VOS_FALSE;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetApRptPortSelectPara(VOS_UINT8 indexNum)
{
    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_APRPTPORTSEL_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 为了兼容扩容以前的两个参数的AT命令 总长度要减去32 */
    if (g_atParaList[AT_APRPTPORTSEL_PORTSELTHREE].paraLen == 0) {
        return AT_SetApRptPortSelectTwoPara();
    }

    return AT_SetApRptPortSelectThreePara();
}


VOS_UINT32 At_SetUsbSwitchPara(VOS_UINT8 indexNum)
{
    VOS_INT   iResult;
    VOS_UINT8 usbStatus;

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* para too many */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    usbStatus = USB_SWITCH_OFF;

    if (DRV_USB_PHY_SWITCH_GET(&usbStatus) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置Modem的USB启动 */
    if (g_atParaList[0].paraValue == AT_USB_SWITCH_SET_VBUS_VALID) {
        if (usbStatus != USB_SWITCH_ON) {
            iResult = DRV_USB_PHY_SWITCH_SET(USB_SWITCH_ON);
        } else {
            return AT_OK;
        }
    } else if (g_atParaList[0].paraValue == AT_USB_SWITCH_SET_VBUS_INVALID) {
        if (usbStatus != USB_SWITCH_OFF) {
            iResult = DRV_USB_PHY_SWITCH_SET(USB_SWITCH_OFF);
        } else {
            return AT_OK;
        }
    } else {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (iResult == VOS_OK) {
        return AT_OK;
    } else {
        return AT_ERROR;
    }
}



VOS_UINT32 AT_SetSARReduction(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;
    VOS_UINT16 uETestMode;

    AT_ModemMtInfoCtx *mtInfoCtx = VOS_NULL_PTR;
    ModemIdUint16      modemId;
    VOS_UINT16         antState;

    uETestMode = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_ERR_LOG("AT_SetSARReduction: Cmd Opt Type is wrong.");
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 读取NV项判定是否为测试模式，该NV项只有一份 */
    result = TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_RF_SAR_BACKOFF_TESTMODE, &uETestMode, sizeof(uETestMode));

    if (result != NV_OK) {
        AT_ERR_LOG("AT_SetSARReduction:Read NV fail");
        return AT_ERROR;
    }

    modemId = MODEM_ID_0;

    result = AT_GetModemIdFromClient(indexNum, &modemId);

    if (result != VOS_OK) {
        AT_ERR_LOG("AT_SetSARReduction:Get modem id fail");

        return AT_ERROR;
    }

    mtInfoCtx = AT_GetModemMtInfoCtxAddrFromModemId(modemId);

    result = TAF_AGENT_GetAntState(indexNum, &antState);
    if (result != VOS_OK) {
        AT_ERR_LOG("AT_QrySARReduction:Get modem id fail");
        return AT_ERROR;
    }

#ifndef FEATURE_ANTEN_DETECT
    if ((antState == AT_ANT_CONDUCTION_MODE) && (uETestMode != VOS_TRUE))
#else
    if ((antState != AT_ANT_AIRWIRE_MODE) && (uETestMode != VOS_TRUE))
#endif
    {
        AT_ERR_LOG("AT_SetSARReduction: Test mode wrong");
        return AT_ERROR;
    }

    mtInfoCtx->sarReduction = g_atParaList[0].paraValue;

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_SARREDUCTION_NTF,
                                    (VOS_UINT8 *)&mtInfoCtx->sarReduction, sizeof(VOS_UINT32), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_ERR_LOG("AT_SetSARReduction: Send Msg Fail");

        return AT_ERROR;
    }

    return AT_OK;
}


TAF_UINT32 At_SetScidPara(TAF_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if (Taf_ParaQuery(g_atClientTab[indexNum].clientId, 0, TAF_PH_ICC_ID, TAF_NULL_PTR) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ICCID_READ;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UCHAR ToBase64Char(const VOS_UCHAR code6bit)
{
    VOS_UCHAR value;

    /* [ 0..25] => ['A'..'Z'] */
    if (code6bit < 26) {
        value = (VOS_UCHAR)(code6bit + 'A');
        return value;
    }

    /* [26..51] => ['a'..'z'] */
    else if (code6bit < 52) {
        value = (VOS_UCHAR)(code6bit + ('a' - 26));
        return value;
    }

    /* [52..61] => ['0'..'9'] */
    else if (code6bit < 62) {
        value = (VOS_UCHAR)(code6bit - 52 + '0');
        return value;
    }

    /* 62 => '+' */
    else if (code6bit == 62) {
        value = '+';
        return value;
    }

    /* 63 => */
    else {
        value = '/';
        return value;
    }
}


VOS_VOID AtBase64Encode(const VOS_UINT8 *pdata, const VOS_UINT32 dataSize, VOS_UINT8 *outPcode)
{
    const VOS_UCHAR *input     = (const unsigned char *)pdata;
    const VOS_UCHAR *inputEnd  = &input[dataSize];
    VOS_UCHAR       *output    = (unsigned char *)outPcode;
    VOS_UINT32       bordWidth = 0;
    /* input一次循环三个，output一次循环4个 */
    for (; input + AT_BORD_MAX_WIDTH < inputEnd; input += 3, output += 4) {
        output[AT_OUTPUT_INDEX_0] = ToBase64Char(input[AT_INPUT_INDEX_0] >> 2);
        output[AT_OUTPUT_INDEX_1] = ToBase64Char(((input[AT_INPUT_INDEX_0] << 4) | (input[AT_INPUT_INDEX_1] >> 4)) &
                                                 0x3F);
        output[AT_OUTPUT_INDEX_2] = ToBase64Char(((input[AT_INPUT_INDEX_1] << 2) | (input[AT_INPUT_INDEX_2] >> 6)) &
                                                 0x3F);
        output[AT_OUTPUT_INDEX_3] = ToBase64Char(input[AT_INPUT_INDEX_2] & 0x3F);
    }

    if (inputEnd > input) {
        bordWidth = (VOS_UINT32)(inputEnd - input);
        if (bordWidth == AT_BORD_MIN_WIDTH) {
            output[AT_OUTPUT_INDEX_0] = ToBase64Char(input[AT_INPUT_INDEX_0] >> 2);
            output[AT_OUTPUT_INDEX_1] = ToBase64Char((input[AT_INPUT_INDEX_0] << 4) & 0x3F);
            output[AT_OUTPUT_INDEX_2] = AT_BASE64_PADDING;
            output[AT_OUTPUT_INDEX_3] = AT_BASE64_PADDING;
        } else if (bordWidth == AT_BORD_MAX_WIDTH) {
            output[AT_OUTPUT_INDEX_0] = ToBase64Char(input[AT_INPUT_INDEX_0] >> 2);
            output[AT_OUTPUT_INDEX_1] =
                ToBase64Char(((input[AT_INPUT_INDEX_0] << 4) | (input[AT_INPUT_INDEX_1] >> 4)) & 0x3F);
            output[AT_OUTPUT_INDEX_2] = ToBase64Char((input[AT_INPUT_INDEX_1] << 2) & 0x3F);
            output[AT_OUTPUT_INDEX_3] = AT_BASE64_PADDING;
        } else {
        }
    }
}


unsigned int AtBase64Decode(const VOS_UINT8 *pcode, const unsigned int codeSize, VOS_UINT8 *outPdata,
                            const unsigned int dataSize, unsigned int *outPwritedDataSize)
{
    const unsigned char *inputLastFastNode = VOS_NULL_PTR;
    unsigned char       *output            = VOS_NULL_PTR;
    const unsigned char *input             = VOS_NULL_PTR;
    const unsigned char  decodeDataMax     =  AT_BASE_64_CODING_CHAR_MAX_NUM - 1;
    const unsigned char  decodePadding     = decodeDataMax + 2; /* 不能被整除，在后面填充2个"=" */
    const unsigned char  decodeError       = decodeDataMax + 3; /* 最多填充2个"="， 不能为3个 */
    static unsigned char base64Decode[AT_BASE64_DECODE_ARRAY_MAX_LEN];
    static VOS_BOOL      initialized = VOS_FALSE;
    unsigned int         code0;
    unsigned int         code1;
    unsigned int         code2;
    unsigned int         code3;
    unsigned int         bordWidth;
    unsigned int         outputSize;
    unsigned int         codeNode;
    unsigned int         i;

    if (!initialized) {
        for (i = 0; i < AT_BASE64_DECODE_ARRAY_MAX_LEN; ++i) {
            base64Decode[i] = decodeError;
        }
        for (i = 'A'; i <= 'Z'; ++i) {
            base64Decode[i] = (unsigned char)(i - 'A');
        }
        for (i = 'a'; i <= 'z'; ++i) {
            base64Decode[i] = (unsigned char)(i - 'a' + AT_LETTERS_NUM);
        }
        for (i = '0'; i <= '9'; ++i) {
            base64Decode[i] = (unsigned char)(i - '0' + AT_LETTERS_NUM * AT_DOUBLE_LENGTH);
        }
        base64Decode['+'] = AT_LETTERS_NUM * AT_DOUBLE_LENGTH + AT_DECIMAL_BASE_NUM;
        base64Decode['/'] = AT_LETTERS_NUM * AT_DOUBLE_LENGTH + AT_DECIMAL_BASE_NUM + 1;
        base64Decode['='] = decodePadding;
        initialized       = VOS_TRUE;
    }
    *outPwritedDataSize = 0;
    /* 进行base64编码的数据应该是被4整除的，否则编码出错 */
    codeNode            = codeSize / 4;
    if ((codeNode * 4) != codeSize) {
        return b64Result_CODE_SIZE_ERROR;
    } else if (codeNode == 0) {
        return b64Result_OK;
    } else {
    }

    /* code_node>0 */
    input      = (const unsigned char *)pcode;
    output     = (unsigned char *)outPdata;
    /* 进行base64编码后将3个字节为一组 */
    outputSize = codeNode * 3;

   /* 判断倒数第二位和第三位是否为填充的"=" */
    if (input[codeSize - 2] == AT_BASE64_PADDING) {
        if (input[codeSize - 1] != AT_BASE64_PADDING) {
            return b64Result_CODE_ERROR;
        }
        /* 减去后面填充的两位数据 */
        outputSize -= 2;
    } else if (input[codeSize - 1] == AT_BASE64_PADDING) {
        --outputSize;
    } else {
    }

    if (outputSize > dataSize) {
        return b64Result_DATA_SIZE_SMALLNESS;
    }
    inputLastFastNode = &input[outputSize / 3UL * 4UL];

    /* input一次循环三个，output一次循环4个 */
    for (; input < inputLastFastNode; input += 4, output += 3) {
        code0 = base64Decode[input[AT_INPUT_INDEX_0]];
        code1 = base64Decode[input[AT_INPUT_INDEX_1]];
        code2 = base64Decode[input[AT_INPUT_INDEX_2]];
        code3 = base64Decode[input[AT_INPUT_INDEX_3]];
        if (((code0 | code1) | (code2 | code3)) <= decodeDataMax) {
            output[AT_OUTPUT_INDEX_0] = (unsigned char)((code0 << 2) + (code1 >> 4));
            output[AT_OUTPUT_INDEX_1] = (unsigned char)((code1 << 4) + (code2 >> 2));
            output[AT_OUTPUT_INDEX_2] = (unsigned char)((code2 << 6) + code3);
        } else {
            return b64Result_CODE_ERROR;
        }
    }
    /* 进行base64编码后将3个字节为一组 */
    bordWidth = outputSize % 3;
    if (bordWidth == AT_BORD_MIN_WIDTH) {
        code0 = base64Decode[input[AT_INPUT_INDEX_0]];
        code1 = base64Decode[input[AT_INPUT_INDEX_1]];
        if ((code0 | code1) <= decodeDataMax) {
            output[AT_OUTPUT_INDEX_0] = (unsigned char)((code0 << 2) + (code1 >> 4));
        } else {
            return b64Result_CODE_ERROR;
        }
    } else if (bordWidth == AT_BORD_MAX_WIDTH) {
        code0 = base64Decode[input[AT_INPUT_INDEX_0]];
        code1 = base64Decode[input[AT_INPUT_INDEX_1]];
        code2 = base64Decode[input[AT_INPUT_INDEX_2]];
        if ((code0 | code1 | code2) <= decodeDataMax) {
            output[AT_OUTPUT_INDEX_0] = (unsigned char)((code0 << 2) + (code1 >> 4));
            output[AT_OUTPUT_INDEX_1] = (unsigned char)((code1 << 4) + (code2 >> 2));
        } else {
            return b64Result_CODE_ERROR;
        }
    } else {
    }
    *outPwritedDataSize = outputSize;
    return b64Result_OK;
}


VOS_UINT32 AT_RsfrSimLockProc(VOS_UINT8 *pgcSrcData, VOS_UINT16 *len)
{
    TAF_CUSTOM_SimLockPlmnInfo simLockPlmnInfo;
    VOS_UINT32                 i;
    VOS_UINT16                 length;
    VOS_UINT8                  mncLen;
    VOS_UINT32                 plmnIdx;
    VOS_UINT32                 rsltChkPlmnBegin;
    VOS_UINT32                 rsltChkPlmnEnd;
    VOS_UINT32                 totalPlmnNum;
    VOS_BOOL                   abPlmnValidFlg[TAF_MAX_SIM_LOCK_RANGE_NUM] = {VOS_FALSE};
    VOS_UINT8                  asciiNumBegin[(TAF_PH_SIMLOCK_PLMN_STR_LEN * 2) + 1];
    VOS_UINT8                  asciiNumEnd[(TAF_PH_SIMLOCK_PLMN_STR_LEN * 2) + 1];

    (VOS_VOID)memset_s(&simLockPlmnInfo, sizeof(simLockPlmnInfo), 0x00, sizeof(simLockPlmnInfo));

    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_CUSTOMIZE_SIM_LOCKPLMN_INFO, &simLockPlmnInfo, sizeof(simLockPlmnInfo))) {
        return AT_ERROR;
    }

    totalPlmnNum = 0;

    if (simLockPlmnInfo.status == NV_ITEM_DEACTIVE) {
        /* 状态非激活时，显示Plmn个数为0 */
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData, (VOS_CHAR *)pgcSrcData,
            "%s%s:%d%s", g_atCrLf, "^SIMLOCK", totalPlmnNum, g_atCrLf);

        *len = length;
        return AT_OK;
    }

    /*  判断Plmn号段是否有效 */
    for (i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++) {
        mncLen = simLockPlmnInfo.simLockPlmnRange[i].mncNum;

        rsltChkPlmnBegin = At_SimlockPlmnNumToAscii(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin,
                                                    TAF_PH_SIMLOCK_PLMN_STR_LEN, asciiNumBegin);

        rsltChkPlmnEnd = At_SimlockPlmnNumToAscii(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin,
                                                  TAF_PH_SIMLOCK_PLMN_STR_LEN, asciiNumEnd);

        if ((rsltChkPlmnBegin == AT_SUCCESS) && (rsltChkPlmnEnd == AT_SUCCESS) &&
            ((mncLen <= AT_MNC_MAX_LEN) && (mncLen >= AT_MNC_MIN_LEN))) {
            abPlmnValidFlg[i] = VOS_TRUE;
            ++totalPlmnNum;
        }
    }

    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData, (VOS_CHAR *)pgcSrcData,
        "%s%s:%d%s", g_atCrLf, "^SIMLOCK", totalPlmnNum, g_atCrLf);

    if (totalPlmnNum == 0) {
        *len = length;
        return AT_OK;
    }

    /* CustomInfoSetting 工具软件要求的格式 */
    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
        (VOS_CHAR *)pgcSrcData + length, "^SIMLOCK:");

    plmnIdx = 0;
    for (i = 0; i < TAF_MAX_SIM_LOCK_RANGE_NUM; i++) {
        if (abPlmnValidFlg[i] == VOS_FALSE) {
            continue;
        }

        ++plmnIdx;

        At_SimlockPlmnNumToAscii(simLockPlmnInfo.simLockPlmnRange[i].rangeBegin, TAF_PH_SIMLOCK_PLMN_STR_LEN,
                                 asciiNumBegin);

        At_SimlockPlmnNumToAscii(simLockPlmnInfo.simLockPlmnRange[i].rangeEnd, TAF_PH_SIMLOCK_PLMN_STR_LEN,
                                 asciiNumEnd);

        length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)pgcSrcData,
            (VOS_CHAR *)pgcSrcData + length, "%d,%d,%s,%s%s", plmnIdx, simLockPlmnInfo.simLockPlmnRange[i].mncNum,
            asciiNumBegin, asciiNumEnd, g_atCrLf);
    }

    *len = length;

    return AT_OK;
}


VOS_UINT32 AT_SetRsfrPara(VOS_UINT8 indexNum)
{
    errno_t    memResult;
    VOS_UINT32 ret;
    VOS_UINT16 length                                = 0;
    VOS_CHAR   name[AT_RSFR_RSFW_NAME_LEN + 1]       = {0};
    VOS_CHAR   subName[AT_RSFR_RSFW_SUBNAME_LEN + 1] = {0};
    VOS_UINT8 *pcRsfrSrcItem                         = VOS_NULL_PTR;
    VOS_CHAR  *pcRsfrDstItem                         = VOS_NULL_PTR;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数个数不为两个 */
    if (g_atParaIndex != AT_RSFR_PARA_VALID_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraLen > AT_RSFR_RSFW_NAME_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memResult = memcpy_s(name, sizeof(name), g_atParaList[0].para, g_atParaList[0].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(name), g_atParaList[0].paraLen);

    At_UpString((VOS_UINT8 *)name, g_atParaList[0].paraLen);

    if (g_atParaList[1].paraLen > AT_RSFR_RSFW_SUBNAME_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[1].paraLen > 0) {
        memResult = memcpy_s(subName, sizeof(subName), g_atParaList[1].para, g_atParaList[1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(subName), g_atParaList[1].paraLen);
    }

    if (AT_STRCMP(name, "VERSION") == ERR_MSP_SUCCESS) {
        if (AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                   DRV_AGENT_VERSION_QRY_REQ, VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT) == TAF_SUCCESS) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_RSFR_VERSION_QRY;
            return AT_WAIT_ASYNC_RETURN;
        } else {
            return AT_ERROR;
        }
    } else if (AT_STRCMP(name, "SIMLOCK") == ERR_MSP_SUCCESS) {
        pcRsfrSrcItem = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (pcRsfrSrcItem == VOS_NULL_PTR) {
            return AT_ERROR;
        }

        (VOS_VOID)memset_s(pcRsfrSrcItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        ret = AT_RsfrSimLockProc(pcRsfrSrcItem, &length);
        if (ret != AT_OK) {
            PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
            return ret;
        }

        pcRsfrDstItem = (VOS_CHAR *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (pcRsfrDstItem == VOS_NULL_PTR) {
            PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
            return AT_ERROR;
        }

        (VOS_VOID)memset_s(pcRsfrDstItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        /* 把从SIMLOCK命令中读出来的结果字符串作为编码源 */
        AtBase64Encode(pcRsfrSrcItem, length, (VOS_UINT8 *)pcRsfrDstItem);

        g_atSendDataBuff.bufLen = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "^RSFR:\"%s\",\"%s\",123,1,1,%s", name, subName, g_atCrLf);

        g_atSendDataBuff.bufLen += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + g_atSendDataBuff.bufLen, "\"%s\"", pcRsfrDstItem);
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, pcRsfrSrcItem);
        PS_MEM_FREE(WUEPS_PID_AT, pcRsfrDstItem);
        /*lint -restore */

        return AT_OK;
    } else {
        return AT_ERROR;
    }
}


VOS_VOID AT_SetRsfrVersionCnf(VOS_UINT8 indexNum, VOS_UINT8 *data, VOS_UINT32 len)
{
    VOS_UINT16 length;
    VOS_CHAR  *pcRsfrItem = NULL;

    pcRsfrItem = (VOS_CHAR *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
    if (pcRsfrItem == VOS_NULL_PTR) {
        return;
    }

    (VOS_VOID)memset_s(pcRsfrItem, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

    /* 把从SIMLOCK命令中读出来的结果字符串作为编码源 */
    AtBase64Encode(data, len, (VOS_UINT8 *)pcRsfrItem);

    length = 0;
    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "^RSFR:\"VERSION\",\"111\",125,1,1,%s", g_atCrLf);

    length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress + length, "\"%s\"", pcRsfrItem);

    g_atSendDataBuff.bufLen = length;

    At_FormatResultData(indexNum, AT_OK);
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, pcRsfrItem);
    /*lint -restore */
    return;
}


VOS_VOID AT_RsfwSimLockProc(VOS_UINT8 *data, VOS_UINT16 len)
{
    VOS_UINT16 i   = 0;
    VOS_UINT32 num = 0;

    /* 补充AT两个字符 */
    data[AT_SIMLOCK_INDEX_A]  = 'A';
    data[AT_SIMLOCK_INDEX_T]  = 'T';
    data[AT_SIMLOCK_INDEX_EQUAL_SIGN] = '='; /* 把冒号改为等号 */

    if (len < AT_SIMLOCK_MIN_LEN) {
        return;
    }

    if ((data[AT_SIMLOCK_INDEX_1] == '1') && (data[AT_SIMLOCK_INDEX_COMMA] == ',')) {
        /* 工具下发的字符串里MNC长度添的是0，需要改为2或3 */
        for (i = AT_SIMLOCK_INDEX_1; i < len; i++) {
            if (data[i] == ',') {
                num++;
                if (i + AT_SIMLOCK_UNLOCK_PASSWORD_LEN >= len) {
                    return;
                }

                /* 通过判断PLMN的位数来确定是2还是3 */
                if (((num % 3) == 1) && (data[i + 1] == '0') && (data[i + 2] == ',')) {
                    if (data[i + AT_SIMLOCK_UNLOCK_PASSWORD_LEN] == ',') {
                        data[i + 1] = '2';
                    } else {
                        data[i + 1] = '3';
                    }
                }
            }
        }
    }

    return;
}


VOS_UINT32 AT_SetRsfwPara(VOS_UINT8 indexNum)
{
    errno_t    memResult;
    VOS_UINT32 ret;
    VOS_UINT32 length                          = 0;
    VOS_CHAR   name[AT_RSFR_RSFW_NAME_LEN + 1] = {0};
    VOS_UINT8 *rsfw                            = NULL;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数个数不为六个 */
    if (g_atParaIndex != AT_RSFW_PARA_MAX_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if ((g_atParaList[AT_RSFW_ITEM_NAME].paraLen == 0) ||
        (g_atParaList[AT_RSFW_ITEM_NAME].paraLen > AT_RSFR_RSFW_NAME_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memResult = memcpy_s(name, sizeof(name), g_atParaList[AT_RSFW_ITEM_NAME].para,
                         g_atParaList[AT_RSFW_ITEM_NAME].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(name), g_atParaList[AT_RSFW_ITEM_NAME].paraLen);

    At_UpString((VOS_UINT8 *)name, g_atParaList[AT_RSFW_ITEM_NAME].paraLen);

    /* CustomInfoSetting 工具软件只检查参数<name>，其余参数不检查 */

    if (AT_STRCMP(name, "SIMLOCK") == ERR_MSP_SUCCESS) {
        if (g_atParaList[AT_RSFW_ITME].paraLen > AT_PARA_MAX_LEN) {
            PS_PRINTF_WARNING("<AT_SetRsfwPara> param 5 is too long : %d.\n", g_atParaList[AT_RSFW_ITME].paraLen);

            return AT_ERROR;
        }

        rsfw = (TAF_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_RSFR_RSFW_MAX_LEN);
        if (rsfw == VOS_NULL_PTR) {
            return AT_ERROR;
        }

        (VOS_VOID)memset_s(rsfw, AT_RSFR_RSFW_MAX_LEN, 0x00, AT_RSFR_RSFW_MAX_LEN);

        /* 前两个字符用来补充AT，然后送给^SIMLOCK命令的处理函数处理 */
        ret = AtBase64Decode(g_atParaList[AT_RSFW_ITME].para, g_atParaList[AT_RSFW_ITME].paraLen,
                             &(rsfw[AT_CHAR_AT_LEN]), (AT_RSFR_RSFW_MAX_LEN - AT_CHAR_AT_LEN), &length);
        if (b64Result_OK != ret) {
            PS_MEM_FREE(WUEPS_PID_AT, rsfw);
            return AT_ERROR;
        }

        /* 整理从CustomInfoSetting接收到的字符串 */
        AT_RsfwSimLockProc(rsfw, (VOS_UINT16)(length + AT_CHAR_AT_LEN)); /* 补充AT两个字符,所以长度加2 */

        ret = At_ProcSimLockPara(indexNum, rsfw, (VOS_UINT16)(length + AT_CHAR_AT_LEN));

        if (ret != AT_SUCCESS) {
            PS_PRINTF_WARNING("<AT_SetRsfwPara> At_ProcSimLockPara failed %d.\n", ret);
        }

        PS_MEM_FREE(WUEPS_PID_AT, rsfw);

        /* AT_ERROR AT_OK在At_ProcSimLockPara中返回 */
        return AT_SUCCESS;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetHukPara(VOS_UINT8 indexNum)
{
    errno_t             memResult;
    VOS_UINT32          result;
    VOS_UINT16          length;
    DRV_AGENT_HukSetReq hukSetReq;

    AT_PR_LOGI("Rcv Msg");

    /* 局部变量初始化 */
    result = VOS_NULL;
    length = g_atParaList[0].paraLen;
    (VOS_VOID)memset_s(&hukSetReq, sizeof(hukSetReq), 0x00, sizeof(DRV_AGENT_HukSetReq));

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 检查码流参数长度 */
    if (length != AT_HUK_PARA_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将字符串参数转换为码流 */
    result = At_AsciiNum2HexString(g_atParaList[0].para, &length);
    if ((result != AT_SUCCESS) || (length != DRV_AGENT_HUK_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    memResult = memcpy_s(hukSetReq.huk, sizeof(hukSetReq.huk), g_atParaList[0].para, DRV_AGENT_HUK_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(hukSetReq.huk), DRV_AGENT_HUK_LEN);

    /* 转换成功, 发送跨核消息到C核, 设置HUK */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    DRV_AGENT_HUK_SET_REQ, (VOS_UINT8 *)&hukSetReq, sizeof(DRV_AGENT_HukSetReq),
                                    I0_WUEPS_PID_DRV_AGENT);
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetHukPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_HUK_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_ProcAuthPubkeyExData(VOS_UINT32 paraLen, VOS_UINT8 *pubKeyData)
{
    AT_AUTH_PUBKEYEX_CMD_PROC_CTX *authPubKeyCtx = VOS_NULL_PTR;
    VOS_UINT8                     *tempData      = VOS_NULL_PTR;
    errno_t                        memResult;
    VOS_UINT16                     totalLen;

    if ((pubKeyData == VOS_NULL_PTR) || (paraLen == 0)) {
        AT_ERR_LOG("AT_ProcAuthPubkeyExData: NULL Pointer");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    authPubKeyCtx = AT_GetAuthPubkeyExCmdCtxAddr();

    /* 当前是一次新的设置过程，收到的是第一条AT命令 */
    if (authPubKeyCtx->data == VOS_NULL_PTR) {
        authPubKeyCtx->data = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, paraLen);

        /* 分配内存失败，直接返回 */
        if (authPubKeyCtx->data == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_ProcAuthPubkeyExData: first data, Alloc mem fail");

            return AT_ERROR;
        }

        (VOS_VOID)memset_s(authPubKeyCtx->data, paraLen, 0x00, paraLen);

        memResult = memcpy_s(authPubKeyCtx->data, paraLen, pubKeyData, paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, paraLen, paraLen);

        authPubKeyCtx->paraLen = (VOS_UINT16)paraLen;
    } else {
        /* 当前不是收到第一条AT命令，需要拼接码流 */
        totalLen = (VOS_UINT16)paraLen + authPubKeyCtx->paraLen;
        if (totalLen < paraLen) {
            return AT_ERROR;
        }
        /*lint -save -e516 */
        tempData = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, totalLen);
        /*lint -restore */
        /* 分配内存失败，直接返回 */
        if (tempData == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_ProcAuthPubkeyExData: Non-first data, Alloc mem fail");

            return AT_ERROR;
        }

        (VOS_VOID)memset_s(tempData, totalLen, 0x00, totalLen);

        if (authPubKeyCtx->paraLen > 0) {
            memResult = memcpy_s(tempData, totalLen, authPubKeyCtx->data, authPubKeyCtx->paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, totalLen, authPubKeyCtx->paraLen);
        }
        memResult = memcpy_s((tempData + authPubKeyCtx->paraLen), paraLen, pubKeyData, paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, paraLen, paraLen);
        PS_MEM_FREE(WUEPS_PID_AT, authPubKeyCtx->data);
        authPubKeyCtx->data = VOS_NULL_PTR;

        authPubKeyCtx->paraLen = totalLen;
        authPubKeyCtx->data    = tempData;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetFacAuthPubkeyExPara(VOS_UINT8 indexNum, VOS_UINT32 currIndex, VOS_UINT32 total, VOS_UINT32 paraLen,
                                     VOS_UINT8 *pubKeyData)
{
    AT_AUTH_PUBKEYEX_CMD_PROC_CTX *authPubKeyCtx       = VOS_NULL_PTR;
    DRV_AGENT_FacauthpubkeySetReq *facAuthPubkeySetReq = VOS_NULL_PTR;
    VOS_UINT32                     result;
    VOS_UINT32                     tempIndex;
    VOS_UINT32                     timerName;
    errno_t                        memResult;

    tempIndex = (VOS_UINT32)indexNum;
    timerName = AT_AUTH_PUBKEY_TIMER;
    timerName |= AT_INTERNAL_PROCESS_TYPE;
    timerName |= (tempIndex << 12);

    authPubKeyCtx = AT_GetAuthPubkeyExCmdCtxAddr();

    /* Index要小于total */
    if (currIndex > total) {
        AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: Index bigger then total", currIndex, total);

        AT_ClearAuthPubkeyCtx();
        (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当前不再设置过程中，第一次收到此命令 */
    if (authPubKeyCtx->settingFlag == VOS_FALSE) {
        if (currIndex != 1) {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: Invalid ulCurrIndex", currIndex);

            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 将字符串参数转换为码流 */
        result = AT_ProcAuthPubkeyExData(paraLen, pubKeyData);
        if (result != AT_SUCCESS) {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: AT_ProcAuthPubkeyExData fail %d", result);

            return result;
        }

        authPubKeyCtx->clientId    = indexNum;
        authPubKeyCtx->totalNum    = (VOS_UINT8)total;
        authPubKeyCtx->curIdx      = (VOS_UINT8)currIndex;
        authPubKeyCtx->settingFlag = VOS_TRUE;
    } else {
        /* 必须在同一个通道下发命令 */
        if (indexNum != authPubKeyCtx->clientId) {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: port error, ucIndex %d ucClientId, %d", indexNum,
                         authPubKeyCtx->clientId);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 当前已经在设置中，当前下发的total与之前之前下发的total不同 */
        if ((VOS_UINT8)total != authPubKeyCtx->totalNum) {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: total %d wrong, %d", total, authPubKeyCtx->totalNum);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 当前下发的Index不是之前下发Index+1 */
        if ((VOS_UINT8)currIndex != (authPubKeyCtx->curIdx + 1)) {
            AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: CurrIndex %d wrong, %d", currIndex, authPubKeyCtx->curIdx);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 将字符串参数转换为码流 */
        result = AT_ProcAuthPubkeyExData(paraLen, pubKeyData);
        if (result != AT_SUCCESS) {
            AT_WARN_LOG1("AT_SetFacAuthPubkeyExPara: AT_ProcAuthPubkeyExData fail %d", result);

            AT_ClearAuthPubkeyCtx();
            (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
            return result;
        }

        /* 更新CurrIndex */
        authPubKeyCtx->curIdx = (VOS_UINT8)currIndex;
    }

    /* 如果还未收齐数据，则启动定时器，回复OK */
    if (authPubKeyCtx->curIdx < authPubKeyCtx->totalNum) {
        (VOS_VOID)AT_StartRelTimer(&(authPubKeyCtx->hAuthPubkeyProtectTimer), AT_AUTH_PUBKEY_PROTECT_TIMER_LEN,
                                   timerName, 0, VOS_RELTIMER_NOLOOP);
        return AT_OK;
    }

    /* 已经收齐了数据，转换码流后发给C核 */
    result = At_AsciiNum2HexString(authPubKeyCtx->data, &authPubKeyCtx->paraLen);
    if ((result != AT_SUCCESS) || (authPubKeyCtx->paraLen != (DRV_AGENT_PUBKEY_LEN + DRV_AGENT_PUBKEY_SIGNATURE_LEN))) {
        AT_WARN_LOG2("AT_SetFacAuthPubkeyExPara: At_AsciiNum2HexString fail ulResult: %d ulParaLen: %d", result,
                     authPubKeyCtx->paraLen);

        AT_ClearAuthPubkeyCtx();
        (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /*lint -save -e516 */
    facAuthPubkeySetReq = (DRV_AGENT_FacauthpubkeySetReq *)PS_MEM_ALLOC(WUEPS_PID_AT,
                                                                        sizeof(DRV_AGENT_FacauthpubkeySetReq));
    /*lint -restore */
    if (facAuthPubkeySetReq == VOS_NULL_PTR) {
        AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: alloc mem fail.");

        AT_ClearAuthPubkeyCtx();
        (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
        return AT_ERROR;
    }

    memResult = memcpy_s(facAuthPubkeySetReq, sizeof(DRV_AGENT_FacauthpubkeySetReq), authPubKeyCtx->data,
                         authPubKeyCtx->paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(DRV_AGENT_FacauthpubkeySetReq), authPubKeyCtx->paraLen);

    AT_ClearAuthPubkeyCtx();
    (VOS_VOID)AT_StopRelTimer(timerName, &(authPubKeyCtx->hAuthPubkeyProtectTimer));
    /* 转换成功, 发送跨核消息到C核, 设置产线公钥 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    DRV_AGENT_FACAUTHPUBKEY_SET_REQ, (VOS_UINT8 *)facAuthPubkeySetReq,
                                    sizeof(DRV_AGENT_FacauthpubkeySetReq), I0_WUEPS_PID_DRV_AGENT);
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, facAuthPubkeySetReq);
    /*lint -restore */
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    /* 由于FACAUTHPUBKEYEX特殊处理，需要手动启动定时器 */
    if (At_StartTimer(AT_SET_PARA_TIME, indexNum) != AT_SUCCESS) {
        AT_WARN_LOG("AT_SetFacAuthPubkeyExPara: At_StartTimer fail.");

        return AT_ERROR;
    }

    g_parseContext[indexNum].clientStatus = AT_FW_CLIENT_STATUS_PEND;

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_FACAUTHPUBKEYEX_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetIdentifyStartPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;
    VOS_UINT8  otaFlag = VOS_FALSE;

    AT_PR_LOGI("Rcv Msg");

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    if (VOS_StrCmp((VOS_CHAR *)g_atParseCmd.cmdName.cmdName, "^IDENTIFYOTASTART") == 0) {
        otaFlag = VOS_TRUE;
    }

    /* 发送跨核消息到C核, 发起鉴权握手 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    DRV_AGENT_IDENTIFYSTART_SET_REQ, &otaFlag, sizeof(VOS_UINT8),
                                    I0_WUEPS_PID_DRV_AGENT);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetIdentifyStartPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IDENTIFYSTART_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetIdentifyEndPara(VOS_UINT8 indexNum, VOS_UINT8 *rsaData, VOS_UINT32 rsaLen, VOS_UINT8 otaRsaFlag)
{
    DRV_AGENT_IdentifyendOtaSetReq identifyEndSetReq;
    errno_t                        memResult;
    VOS_UINT32                     result;
    VOS_UINT16                     length;

    AT_PR_LOGI("Rcv Msg");

    /* 局部变量初始化 */
    result = VOS_NULL;
    length = (VOS_UINT16)rsaLen;
    (VOS_VOID)memset_s(&identifyEndSetReq, sizeof(identifyEndSetReq), 0x00, sizeof(DRV_AGENT_IdentifyendOtaSetReq));

#if (FEATURE_SC_RSA_PADDING_UPDATE == FEATURE_ON)
    length = (VOS_UINT16)AT_MIN(rsaLen, AT_RSA_TLV_CIPHERTEXT_PARA_LEN);
#else
    /* 检查码流参数长度 */
    if (length != AT_RSA_CIPHERTEXT_PARA_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    /* 将字符串参数转换为码流 */
    result = At_AsciiNum2HexString(rsaData, &length);
    if ((result != AT_SUCCESS) ||
#if (FEATURE_SC_RSA_PADDING_UPDATE == FEATURE_ON)
        (length < DRV_AGENT_RSA_CIPHERTEXT_LEN) || (length > DRV_AGENT_RSA_TLV_CIPHERTEXT_LEN)
#else
        (length != DRV_AGENT_RSA_CIPHERTEXT_LEN)
#endif
    ) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    memResult = memcpy_s(identifyEndSetReq.rsa.rsaText, sizeof(identifyEndSetReq.rsa.rsaText), rsaData, length);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(identifyEndSetReq.rsa.rsaText), length);
    identifyEndSetReq.rsa.rsaTextlen = length;
    identifyEndSetReq.otaFlag        = otaRsaFlag;

    /* 发送跨核消息到C核, 完成产线鉴权 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
        DRV_AGENT_IDENTIFYEND_SET_REQ, (VOS_UINT8 *)&identifyEndSetReq, sizeof(DRV_AGENT_IdentifyendOtaSetReq),
        I0_WUEPS_PID_DRV_AGENT);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetIdentifyEndPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IDENTIFYEND_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetSimlockDataWritePara(VOS_UINT8 indexNum, AT_SIMLOCKDATAWRITE_SetReq *simlockDataWrite)
{
    return AT_OK;
}


VOS_UINT32 AT_CheckPhonePhynumPara(AT_PhonePhynumCmdProcCtx *phonePhynumCtx, DRV_AGENT_PhPhynumTypeUint8 *setType)
{
    /* <type>参数检查: 支持设置物理号IMEI或SN，否则, 直接返回物理号类型错误 */
    /* 全部格式化为大写字符 */
    if (At_UpString(phonePhynumCtx->typeValue, phonePhynumCtx->typeValueLen) == AT_FAILURE) {
        return AT_PERSONALIZATION_PH_PHYNUM_TYPE_ERROR;
    }

    if (VOS_StrNiCmp((VOS_VOID *)phonePhynumCtx->typeValue, (VOS_VOID *)"IMEI",
                     (VOS_UINT32)phonePhynumCtx->typeValueLen) == 0) {
        *setType = DRV_AGENT_PH_PHYNUM_IMEI;
    }
    else if (VOS_StrNiCmp((VOS_VOID *)phonePhynumCtx->typeValue, (VOS_VOID *)"SN",
                          (VOS_UINT32)phonePhynumCtx->typeValueLen) == 0) {
        *setType = DRV_AGENT_PH_PHYNUM_SN;
    } else {
        AT_NORM_LOG("AT_CheckPhonePhyNumPara: the type of physical is error.");
        return AT_PERSONALIZATION_PH_PHYNUM_TYPE_ERROR;
    }

#if (FEATURE_SC_RSA_PADDING_UPDATE == FEATURE_OFF)
    /* 参数长度检查 */
    if (phonePhynumCtx->phynumValueLen != AT_RSA_CIPHERTEXT_PARA_LEN) {
        AT_NORM_LOG1("AT_CheckPhonePhyNumPara: rsa para len error.", phonePhynumCtx->phynumValueLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }
#endif

    if (phonePhynumCtx->hmacValueLen!= AT_SET_SIMLOCK_DATA_HMAC_LEN) {
        AT_NORM_LOG1("AT_CheckPhonePhyNumPara: hmac len error.", phonePhynumCtx->hmacValueLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetPhonePhynumPara(VOS_UINT8 indexNum)
{
    AT_PhonePhynumCmdProcCtx    *phonePhynumCtx = VOS_NULL_PTR;
    DRV_AGENT_PhonephynumSetReq  phonePhynumSetReq;
    errno_t                      memResult;
    VOS_UINT32                   result;
    VOS_UINT32                   checkParaRst;
    VOS_UINT16                   length;

    /* 局部变量初始化 */
    phonePhynumCtx = AT_GetPhonePhynumCmdCtxAddr();
#if (FEATURE_SC_RSA_PADDING_UPDATE == FEATURE_ON)
    length = AT_MIN(phonePhynumCtx->phynumValueLen, AT_RSA_TLV_CIPHERTEXT_PARA_LEN);
#else
    length = phonePhynumCtx->phynumValueLen;
#endif
    (VOS_VOID)memset_s(&phonePhynumSetReq, sizeof(phonePhynumSetReq), 0x00, sizeof(DRV_AGENT_PhonephynumSetReq));

    AT_PR_LOGI("Rcv Msg");

    checkParaRst = AT_CheckPhonePhynumPara(phonePhynumCtx,&(phonePhynumSetReq.phynumType));
    if (checkParaRst != AT_SUCCESS) {
        return checkParaRst;
    }

    /* 将RSA字符串参数转换为码流 */
    result = At_AsciiNum2HexString(phonePhynumCtx->phynumValue, &length);
    if ((result != AT_SUCCESS) ||
#if (FEATURE_SC_RSA_PADDING_UPDATE == FEATURE_ON)
        (length < DRV_AGENT_RSA_CIPHERTEXT_LEN) || (length > DRV_AGENT_RSA_TLV_CIPHERTEXT_LEN)
#else
        (length != DRV_AGENT_RSA_CIPHERTEXT_LEN)
#endif
    ) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    memResult = memcpy_s(phonePhynumSetReq.phynumValue, sizeof(phonePhynumSetReq.phynumValue),
        phonePhynumCtx->phynumValue, length);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(phonePhynumSetReq.phynumValue), length);
    phonePhynumSetReq.rsaIMEILen = length;

    /* 将HMAC字符串参数转换为码流 */
    length = phonePhynumCtx->hmacValueLen;
    result = At_AsciiNum2HexString(phonePhynumCtx->hmacValue, &length);
    if ((result != AT_SUCCESS) || (length != DRV_AGENT_HMAC_DATA_LEN)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    memResult = memcpy_s(phonePhynumSetReq.hmacData, sizeof(phonePhynumSetReq.hmacData),
        phonePhynumCtx->hmacValue, DRV_AGENT_HMAC_DATA_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(phonePhynumSetReq.hmacData), DRV_AGENT_HMAC_DATA_LEN);
    phonePhynumSetReq.hmacLen = DRV_AGENT_HMAC_DATA_LEN;

    /* 发送跨核消息到C核, 完成产线鉴权 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    DRV_AGENT_PHONEPHYNUM_SET_REQ, (VOS_UINT8 *)&phonePhynumSetReq,
                                    sizeof(DRV_AGENT_PhonephynumSetReq), I0_WUEPS_PID_DRV_AGENT);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetPhonePhynumPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PHONEPHYNUM_SET;
    return AT_WAIT_ASYNC_RETURN;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetApSimStPara(VOS_UINT8 indexNum)
{
    VOS_UINT32              result;
    DRV_AGENT_ApSimstSetReq apSimStSetReq;

    /* 局部变量初始化 */
    (VOS_VOID)memset_s(&apSimStSetReq, sizeof(apSimStSetReq), 0x00, sizeof(DRV_AGENT_ApSimstSetReq));

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    /* 参数设置为1时，目前不支持，直接返回OK */
    if (g_atParaList[0].paraValue == 1) {
        apSimStSetReq.usimState = DRV_AGENT_USIM_OPERATE_ACT;
    } else {
        apSimStSetReq.usimState = DRV_AGENT_USIM_OPERATE_DEACT;
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    DRV_AGENT_AP_SIMST_SET_REQ, (VOS_UINT8 *)&apSimStSetReq,
                                    sizeof(DRV_AGENT_ApSimstSetReq), I0_WUEPS_PID_DRV_AGENT);
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetApSimStPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_APSIMST_SET;

    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_VOID AT_ConvertMncToNasType(VOS_UINT32 mnc, VOS_UINT32 mncLen, VOS_UINT32 *nasMnc)
{
    VOS_UINT32 tmp[AT_MNC_LENGTH];
    VOS_UINT32 loop;

    *nasMnc = 0;

    for (loop = 0; loop < AT_MNC_LENGTH; loop++) {
        tmp[loop] = mnc & 0x0f;
        mnc >>= 4;
    }

    /* tmp[0],tmp[1],tmp[2]中的0 1 2分别表示tmp[AT_MNC_LENGTH]中的第0个元素，第1个元素，和第2个元素 */
    if (tmp[2] == 0x0000000F) {
        *nasMnc = 0x000F0000 | ((VOS_UINT32)tmp[0] << 8) | ((VOS_UINT32)tmp[1]);
    } else {
        *nasMnc = tmp[2] | ((VOS_UINT32)tmp[1] << 8) | ((VOS_UINT32)tmp[0] << 16);
    }

    return;
}

/*
 * 功能描述: 将原MCCd转化为NAS内部使用格式记录
 *           例如:MCC为460
 *           pstPlmnId->Mcc = 0x000604      pstPlmnId->Mcc = 0x00000460
 *
 */
VOS_VOID AT_ConvertMccToNasType(VOS_UINT32 mcc, VOS_UINT32 *nasMcc)
{
    VOS_UINT32 tmp[AT_MCC_LENGTH];
    VOS_UINT32 i;

    *nasMcc = 0;

    for (i = 0; i < AT_MCC_LENGTH; i++) {
        tmp[i] = mcc & 0x0f;
        mcc >>= 4;
    }

    /* tmp[0],tmp[1],tmp[2]中的0 1 2分别表示tmp[AT_MCC_LENGTH]中的第0个元素，第1个元素，和第2个元素 */
    *nasMcc = tmp[2] | ((VOS_UINT32)tmp[1] << 8) | ((VOS_UINT32)tmp[0] << 16);
}


VOS_UINT32 AT_SetNvmEccNumPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                 rst;
    VOS_UINT32                 temp;
    VOS_UINT32                 mcc;
    TAF_Ctrl                   ctrl;
    MN_CALL_AppCustomEccNumReq eccNumReq;
    ModemIdUint16              modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&eccNumReq, sizeof(eccNumReq), 0x00, sizeof(eccNumReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_ERR_LOG("AT_SetNvmEccNumSetPara: Cmd Opt Type is wrong.");
        return AT_ERROR;
    }

    /* 参数过多 */
    if ((g_atParaIndex < AT_NVM_MIN_PARA_NUM) || (g_atParaIndex > AT_NVM_MAX_PARA_NUM)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数合法性检查, index > total认为设置无效 */
    if (g_atParaList[AT_NVM_INDEX].paraValue > g_atParaList[AT_NVM_TOTAL].paraValue) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果<ecc_num>过长，直接返回错误 */
    if (g_atParaList[AT_NVM_ECC_NUM].paraLen > (MN_CALL_MAX_BCD_NUM_LEN * 2)) {
        AT_ERR_LOG("AT_SetNvmEccNumSetPara: ecc_num too long.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将ECC NUM转换为BCD码 */
    if (AT_AsciiNumberToBcd((TAF_CHAR *)&g_atParaList[AT_NVM_ECC_NUM].para[0], eccNumReq.eccNum.bcdNum,
                            &eccNumReq.eccNum.numLen) != MN_ERR_NO_ERROR) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    temp = 0;
    /* 计算出国家码个位数 */
    temp |= (g_atParaList[AT_NVM_MCC].paraValue % 10);
    /* 计算出国家码的十位数再左移4位 */
    temp |= (((g_atParaList[AT_NVM_MCC].paraValue / 10) % 10) << 4);
    /* 计算出国家码的百位数再左移8位 */
    temp |= (((g_atParaList[AT_NVM_MCC].paraValue / 100) % 10) << 8);

    /* 将MCC转化为NAS结构 */
    AT_ConvertMccToNasType(temp, &mcc);

    eccNumReq.index      = (VOS_UINT8)g_atParaList[AT_NVM_INDEX].paraValue;
    eccNumReq.total      = (VOS_UINT8)g_atParaList[AT_NVM_TOTAL].paraValue;
    eccNumReq.category   = (VOS_UINT8)g_atParaList[AT_NVM_CATEGORY].paraValue;
    eccNumReq.simPresent = (VOS_UINT8)g_atParaList[AT_NVM_SIMPRESENT].paraValue;
    eccNumReq.mcc        = mcc;

    if (g_atParaIndex == AT_NVM_MAX_PARA_NUM) {
        eccNumReq.abnormalServiceFlg = (VOS_UINT8)g_atParaList[AT_NVM_ABNORMAL_SERVICE].paraValue;
    } else {
        /* 默认有卡非正常服务状态时紧急呼号码标示默认值为FALSE */
        eccNumReq.abnormalServiceFlg = VOS_FALSE;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送消息 */
    rst = TAF_CCM_CallCommonReq(&ctrl, &eccNumReq, ID_TAF_CCM_CUSTOM_ECC_NUM_REQ, sizeof(eccNumReq), modemId);

    if (rst != MN_ERR_NO_ERROR) {
        AT_WARN_LOG("AT_SetNvmEccNumPara: TAF_CCM_CallCommonReq fail.");
        return AT_ERROR;
    }

    /* 设置结束直接返回OK */
    return AT_OK;
}


VOS_UINT32 AT_SetCposPara(VOS_UINT8 indexNum)
{
    AT_ModemAgpsCtx *agpsCtx = VOS_NULL_PTR;

    agpsCtx = AT_GetModemAgpsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 为准备输入的XML码流申请内存 */
    agpsCtx->xml.xmlTextHead = (VOS_CHAR *)PS_MEM_ALLOC(WUEPS_PID_AT, AT_XML_MAX_LEN);
    if (agpsCtx->xml.xmlTextHead == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetCposPara: Memory malloc failed!");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(agpsCtx->xml.xmlTextHead, AT_XML_MAX_LEN, 0x00, AT_XML_MAX_LEN);

    agpsCtx->xml.xmlTextCur = agpsCtx->xml.xmlTextHead;

    /* 切换为AGPS XML码流输入模式 */
    At_SetCmdSubMode(indexNum, AT_XML_MODE);

    /* 返回提示XML码流输入状态 */
    return AT_WAIT_XML_INPUT;
}


VOS_UINT32 AT_SetCposrPara(VOS_UINT8 indexNum)
{
    AT_ModemAgpsCtx *agpsCtx = VOS_NULL_PTR;

    TAF_NVIM_XcposrrptCfg xcposrRptCfg;
    (VOS_VOID)memset_s(&xcposrRptCfg, sizeof(xcposrRptCfg), 0x00, sizeof(xcposrRptCfg));

    agpsCtx = AT_GetModemAgpsCtxAddrFromClientId(indexNum);

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    agpsCtx->cposrReport = (AT_CposrFlgUnit8)g_atParaList[0].paraValue;

    /* 读取NV项 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_XCPOSRRPT_CFG, &xcposrRptCfg, (VOS_SIZE_T)sizeof(xcposrRptCfg)) ==
        NV_OK) {
        xcposrRptCfg.cposrDefault = agpsCtx->cposrReport;
        if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_XCPOSRRPT_CFG, (VOS_UINT8 *)&xcposrRptCfg,
                               (VOS_SIZE_T)sizeof(xcposrRptCfg)) != NV_OK) {
            AT_ERR_LOG("AT_SetCposrPara: write NV_ITEM_XCPOSRRPT_CFG Error");
        }
    } else {
        AT_ERR_LOG("AT_SetCposrPara: read NV_ITEM_XCPOSRRPT_CFG Error");
    }

    return AT_OK;
}


VOS_UINT32 AT_SetXcposrPara(VOS_UINT8 indexNum)
{
    VOS_UINT32          result;
    AT_MTA_SetXcposrReq setXcposr;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&setXcposr, sizeof(setXcposr), 0x00, sizeof(setXcposr));

    setXcposr.xcposrEnableCfg = (AT_MTA_XcposrCfgUnit8)g_atParaList[0].paraValue;

    /* 发送跨核消息到C核, 设置保存模式 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_XCPOSR_SET_REQ, (VOS_UINT8 *)&setXcposr, sizeof(setXcposr),
                                    I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetXcposrPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_XCPOSR_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetXcposrRptPara(VOS_UINT8 indexNum)
{
    VOS_UINT32             result;
    AT_MTA_SetXcposrrptReq setXcposrRpt;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&setXcposrRpt, sizeof(setXcposrRpt), 0x00, sizeof(setXcposrRpt));

    setXcposrRpt.xcposrRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送跨核消息到C核, 设置保存模式 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_XCPOSRRPT_SET_REQ, (VOS_UINT8 *)&setXcposrRpt, sizeof(setXcposrRpt),
                                    I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetXcposrRptPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_XCPOSRRPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetGpsInfoPara(VOS_UINT8 indexNum)
{
    return AT_OK;
}
/*
 * 功能描述: (AT^CFG)AP设置CFG信息
 */
VOS_UINT32 AT_SetLogCfgParaEx(VOS_UINT32 paraValue)
{
    VOS_UINT32 ret;
    if (paraValue == 0) {
        ret = (VOS_UINT32)AT_SetSocpCfgIndMode(SOCP_IND_MODE_DIRECT);
        if (ret != VOS_OK) {
            PS_PRINTF_WARNING("[socp]at^logcfg=0 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }
    } else if (paraValue == 1) {
        ret = (VOS_UINT32)AT_SetSocpCfgIndMode(SOCP_IND_MODE_DELAY);
        if (ret != VOS_OK) {
            PS_PRINTF_WARNING("[socp]at^logcfg=1 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }

    } else {
        ret = (VOS_UINT32)AT_SetSocpCfgIndMode(SOCP_IND_MODE_CYCLE);
        if (ret != VOS_OK) {
            PS_PRINTF_WARNING("[socp]at^logcfg=2 can not config!\n");
            return AT_DIAG_VCOM_SET_CFG_ERROR;
        }
    }
    return AT_OK;
}

VOS_UINT32 AT_SetLogCfgPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 logPort = CBP_OM_PORT_TYPE_BUTT;
    VOS_UINT32 rslt;
    VOS_UINT32 ret;
    /* add print by cuijunqiang, for socp timer set, 2016.01.21 */

    PS_PRINTF_INFO("at^logcfg= %d, param %d.\n", g_atParaList[0].paraValue, indexNum);

    if ((g_atParaList[0].paraValue != SOCP_IND_MODE_DIRECT) && (g_atParaList[0].paraValue != SOCP_IND_MODE_DELAY) &&
        (g_atParaList[0].paraValue != SOCP_IND_MODE_CYCLE)) {
        PS_PRINTF_WARNING("<AT_SetLogCfgPara> input param error:%d!\n", g_atParaList[0].paraValue);
        return AT_DIAG_CFG_SET_ERROR;
    }
    rslt = AT_QueryPpmLogPort(&logPort);
    if (rslt != VOS_OK) {
        PS_PRINTF_WARNING("get port fail!\n");
        return AT_DIAG_GET_PORT_ERROR;
    }
    if (logPort == CPM_OM_PORT_TYPE_USB) {
        if (g_atParaList[0].paraValue == SOCP_IND_MODE_DIRECT) {
            PS_PRINTF_WARNING("[socp]usb at^logcfg=0!\n");
            return AT_OK;
        } else {
            PS_PRINTF_WARNING("[socp]usb not support at^logcps=%d!\n", g_atParaList[0].paraValue);
            return AT_DIAG_USB_NOT_SUPPORT_CFG;
        }
    } else if (logPort == CPM_OM_PORT_TYPE_VCOM) {
        ret = AT_SetLogCfgParaEx(g_atParaList[0].paraValue);
        return ret;

    } else {
        PS_PRINTF_WARNING("at^logcfg get port error!\n");
        return AT_DIAG_GET_PORT_NOT_USB_OR_VCOM;
    }
}
/*
 * 功能描述: enLogPort-端口，ulParaValue-模式
 */
VOS_UINT32 AT_SetLogCpsParaEx(VOS_UINT32 logPort, VOS_UINT32 paraValue)
{
    VOS_UINT32 ret;
    if (logPort == CPM_OM_PORT_TYPE_USB) {
        if (paraValue == 0) {
            PS_PRINTF_WARNING("[deflate]usb at^logcps=0!\n");
            return AT_OK;
        } else {
            PS_PRINTF_WARNING("[deflate]usb not support at^logcps=%d!\n", paraValue);
            return AT_DIAG_USB_NOT_SUPPORT_CPS;
        }
    } else if (logPort == CPM_OM_PORT_TYPE_VCOM) {
        if (paraValue == 0) {
            ret = (VOS_UINT32)AT_SetSocpCpsIndMode(DEFLATE_IND_NO_COMPRESS);
            if (ret != VOS_OK) {
                PS_PRINTF_WARNING("[deflate]vcom at^logcps=0 can not config!\n");
                return AT_DIAG_VCOM_SET_CPS_ERROR;
            }
            return AT_OK;
        } else {
            ret = (VOS_UINT32)AT_SetSocpCpsIndMode(DEFLATE_IND_COMPRESS);
            if (ret != VOS_OK) {
                PS_PRINTF_WARNING("[deflate]vcom at^logcps=1 can not config!\n");
                return AT_DIAG_VCOM_SET_NOCPS_ERROR;
            }
            return AT_OK;
        }
    } else {
        PS_PRINTF_WARNING("[deflate]vcom at^logcps=1 can not config!\n");
        return AT_ERROR;
    }
}
/*
 * 功能描述: (AT^LOGCPS)设置压缩模式
 */
VOS_UINT32 AT_SetLogCpsPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rslt;
    VOS_UINT32 logPort = CBP_OM_PORT_TYPE_BUTT;
    VOS_UINT32 ret;

    PS_PRINTF_INFO("at^logcps=%d!\n", g_atParaList[0].paraValue);
    if ((g_atParaList[0].paraValue != DEFLATE_IND_NO_COMPRESS) && (g_atParaList[0].paraValue != DEFLATE_IND_COMPRESS)) {
        PS_PRINTF_WARNING("<AT_SetLogCpsPara> input param error:%d!\n", g_atParaList[0].paraValue);
        return AT_DIAG_CPS_SET_ERROR;
    }
    rslt = AT_QueryPpmLogPort(&logPort);
    if (rslt != VOS_OK) {
        PS_PRINTF_WARNING("[deflate]get port fail!\n");
        return AT_DIAG_GET_PORT_ERROR;
    }
    ret = AT_SetLogCpsParaEx(logPort, g_atParaList[0].paraValue);
    return ret;
}


VOS_UINT32 AT_SetLogNvePara(VOS_UINT8 indexNum)
{
    return AT_OK;
}


VOS_UINT32 AT_SetLogSavePara(VOS_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCISAPara(VOS_UINT8 indexNum, VOS_UINT32 lengthValue, VOS_UINT8 *command, VOS_UINT16 commandLength)
{
    SI_PIH_IsdbAccessCommand commandInfo;
    errno_t                  memResult;
    VOS_UINT16               commandHexLen;

    /* 初始化 */
    (VOS_VOID)memset_s(&commandInfo, sizeof(commandInfo), 0x00, sizeof(commandInfo));

    /* 参数检查 */
    if ((lengthValue > (SI_APDU_MAX_LEN * 2)) || (lengthValue != commandLength)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <command>是ASCII码，做输入参数到HEX的转换 */
    commandHexLen = commandLength;
    if (At_AsciiNum2HexString(command, &commandHexLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 设置<length> */
    commandInfo.len = commandHexLen;

    /* 设置<command> */
    if ((VOS_UINT16)commandInfo.len > 0) {
        memResult = memcpy_s((TAF_VOID *)commandInfo.command, sizeof(commandInfo.command), (TAF_VOID *)command,
                             (VOS_UINT16)commandInfo.len);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(commandInfo.command), (VOS_UINT16)commandInfo.len);
    }

    /* 执行命令操作 */
    if (SI_PIH_IsdbAccessReq(g_atClientTab[indexNum].clientId, 0, &commandInfo) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CISA_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCISAPara: SI_PIH_IsdbAccessReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCmutPara(VOS_UINT8 indexNum)
{
    APP_VC_MuteStatusUint8 muteStatus;

    /* 无参数 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者错误 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取命令参数, 提取要设置的静音状态 */
    if (g_atParaList[0].paraValue == 0) {
        muteStatus = APP_VC_MUTE_STATUS_UNMUTED;
    } else {
        muteStatus = APP_VC_MUTE_STATUS_MUTED;
    }

    /* 执行命令操作 */
    if (APP_VC_SetMuteStatus(g_atClientTab[indexNum].clientId, 0, muteStatus) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CMUT_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_PHONE_SC == FEATURE_ON)

VOS_UINT32 AT_SetSimlockUnlockPara(VOS_UINT8 indexNum)
{
    VOS_UINT32              result;
    AT_MTA_SimlockunlockReq simlockUnlockSetReq;

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParaIndex != AT_SIMLOCKUNLOCK_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析锁网锁卡解锁参数 */
    if ((g_atParaList[AT_SIMLOCKUNLOCK_CAT].paraLen == 0) ||
        (g_atParaList[AT_SIMLOCKUNLOCK_PWD].paraLen != AT_SIMLOCKUNLOCK_PWD_PARA_LEN) ||
        (g_atParaList[AT_SIMLOCKUNLOCK_CAT].paraValue > AT_MTA_PERS_CATEGORY_SERVICE_PROVIDER)) {
        (VOS_VOID)memset_s(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para),
            0x00, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para));
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00, sizeof(AT_MTA_SimlockunlockReq));
    simlockUnlockSetReq.category = (AT_MTA_PersCategoryUint8)g_atParaList[AT_SIMLOCKUNLOCK_CAT].paraValue;

    /* 密码的合法性检查，密码为16个“0”-“9”ASCII字符,密码由ASCII码转换为十进制数字 */
    result = At_AsciiNum2Num(simlockUnlockSetReq.password, g_atParaList[AT_SIMLOCKUNLOCK_PWD].para,
                             g_atParaList[AT_SIMLOCKUNLOCK_PWD].paraLen);
    if (result != AT_SUCCESS) {
        (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00, sizeof(AT_MTA_SimlockunlockReq));
        (VOS_VOID)memset_s(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para),
            0x00, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para));
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送跨核消息到C核, 解锁锁网锁卡 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_SIMLOCKUNLOCK_SET_REQ, (VOS_UINT8 *)&simlockUnlockSetReq,
                                    sizeof(AT_MTA_SimlockunlockReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00, sizeof(AT_MTA_SimlockunlockReq));
        (VOS_VOID)memset_s(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para),
            0x00, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para));
        AT_WARN_LOG("AT_SetSimlockUnlockPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SIMLOCKUNLOCK_SET;
    (VOS_VOID)memset_s(&simlockUnlockSetReq, sizeof(simlockUnlockSetReq), 0x00, sizeof(AT_MTA_SimlockunlockReq));
    (VOS_VOID)memset_s(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para, sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para), 0x00,
             sizeof(g_atParaList[AT_SIMLOCKUNLOCK_PWD].para));
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 AT_FillApdsPara(VOS_UINT8 indexNum, MN_CALL_OrigParam *origParam)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;
    errno_t        memResult;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 默认情况是使用CCA设置的默认值 */
    origParam->callMode = ssCtx->cModType;
    origParam->dataCfg  = ssCtx->cbstDataCfg;
    origParam->clirCfg  = ssCtx->clirType;
    origParam->cugCfg   = ssCtx->ccugCfg;

    /* 设置<dial_string> */
    if (g_atParaList[AT_APDS_DIAL_STRING].paraLen == 0) {
        return VOS_ERR;
    } else {
        if (AT_FillCalledNumPara(g_atParaList[AT_APDS_DIAL_STRING].para, g_atParaList[AT_APDS_DIAL_STRING].paraLen,
                                 &origParam->dialNumber) != VOS_OK) {
            return VOS_ERR;
        }
    }

    /* 检查被叫号码子地址的长度 */
    if (g_atParaList[AT_APDS_SUB_STRING].paraLen > MN_CALL_MAX_SUBADDR_INFO_LEN) {
        return VOS_ERR;
    }

    /* 设置<sub_string> */
    if (g_atParaList[AT_APDS_SUB_STRING].paraLen != 0) {
        origParam->subaddr.isExist = VOS_TRUE;

        /* 偏移量 = 子地址编码的长度 + Octet3的长度 */
        origParam->subaddr.lastOctOffset = (VOS_UINT8)g_atParaList[AT_APDS_SUB_STRING].paraLen +
                                           sizeof(origParam->subaddr.octet3);
        origParam->subaddr.octet3        = (0x80 | (MN_CALL_SUBADDR_NSAP << 4));
        memResult = memcpy_s(origParam->subaddr.subAddrInfo, MN_CALL_MAX_SUBADDR_INFO_LEN,
                             g_atParaList[AT_APDS_SUB_STRING].para, g_atParaList[AT_APDS_SUB_STRING].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, MN_CALL_MAX_SUBADDR_INFO_LEN, g_atParaList[AT_APDS_SUB_STRING].paraLen);
    }

    /* 设置<I><G><call_type><voice_domain>参数 */
    if (g_atParaList[AT_APDS_I].paraLen != 0) {
        if (g_atParaList[AT_APDS_I].paraValue == 0) {
            origParam->clirCfg = AT_CLIR_INVOKE;
        } else if (g_atParaList[AT_APDS_I].paraValue == 1) {
            origParam->clirCfg = AT_CLIR_SUPPRESS;
        } else {
            return VOS_ERR;
        }
    }

    if (g_atParaList[AT_APDS_G].paraLen != 0) {
        origParam->cugCfg.enable = g_atParaList[AT_APDS_G].paraValue;
    }

    if (g_atParaList[AT_APDS_CALL_TYPE].paraLen != 0) {
        origParam->callType = (VOS_UINT8)g_atParaList[AT_APDS_CALL_TYPE].paraValue;
    }

    if (g_atParaList[AT_APDS_CALLDOMAIN].paraLen != 0) {
        origParam->voiceDomain = (VOS_UINT8)g_atParaList[AT_APDS_CALLDOMAIN].paraValue;
    }

    if (g_atParaList[AT_APDS_SRV_TYPE].paraLen != 0) {
        if (g_atParaList[AT_APDS_SRV_TYPE].paraValue == 1) {
            return VOS_ERR;
        }
        origParam->serviceType = (VOS_UINT8)g_atParaList[AT_APDS_SRV_TYPE].paraValue;
    }

    return VOS_OK;
}


VOS_UINT32 AT_FillApdsPara_Part2(VOS_UINT8 indexNum, MN_CALL_OrigParam *origParam)
{
    if (g_atParaList[AT_APDS_RTTFLG].paraLen != 0) {
        origParam->rttFlg = (VOS_UINT8)g_atParaList[AT_APDS_RTTFLG].paraValue;
    }

    if (g_atParaList[AT_APDS_CALLPULLDIALOGID].paraLen != 0) {
        origParam->callPullDialogId = (VOS_UINT8)g_atParaList[AT_APDS_CALLPULLDIALOGID].paraValue;
        if (origParam->callPullDialogId == TAF_APDS_CALL_PULL_DIALOG_ID) {
            origParam->callPullFlg = VOS_FALSE;
        } else {
            origParam->callPullFlg = VOS_TRUE;
        }
    }

    if (g_atParaList[AT_APDS_ENCRYPTFLAG].paraLen != 0) {
        origParam->encryptFlag = (VOS_UINT8)g_atParaList[AT_APDS_ENCRYPTFLAG].paraValue;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetApdsPara(VOS_UINT8 indexNum)
{
    MN_CALL_OrigParam origParam;
    TAF_Ctrl          ctrl;
    VOS_UINT32        relt;
    ModemIdUint16     modemId;

    /* 初始化 */
    (VOS_VOID)memset_s(&origParam, sizeof(origParam), 0x00, sizeof(MN_CALL_OrigParam));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 参数过多 */
    if (g_atParaIndex > AT_APDS_MAX_PARA_NUM) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查并填写输入的参数 */
    relt = AT_FillApdsPara(indexNum, &origParam);
    if (relt == VOS_OK) {
        relt = AT_FillApdsPara_Part2(indexNum, &origParam);
    }

    if (relt != VOS_OK) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息原语 */
    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &origParam, ID_TAF_CCM_CALL_ORIG_REQ, sizeof(origParam), modemId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_APDS_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetClprPara(VOS_UINT8 indexNum)
{
    VOS_UINT32           result;
    TAF_Ctrl             ctrl;
    TAF_CALL_QryClprPara qryClprPara;
    ModemIdUint16        modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    qryClprPara.callId          = (MN_CALL_ID_T)g_atParaList[0].paraValue;
    qryClprPara.qryClprModeType = TAF_CALL_QRY_CLPR_MODE_GUL;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送跨核消息ID_TAF_CCM_QRY_CLPR_REQ到C核 */
    result = TAF_CCM_CallCommonReq(&ctrl, &qryClprPara, ID_TAF_CCM_QRY_CLPR_REQ, sizeof(qryClprPara), modemId);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetClprPara: TAF_CCM_CallCommonReq fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLPR_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetCLteRoamAllowPara(VOS_UINT8 indexNum)
{
    NAS_MMC_NvimLteInternationalRoamCfg nvimLteRoamAllowedFlg;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    nvimLteRoamAllowedFlg.lteRoamAllowedFlg = (VOS_UINT8)g_atParaList[0].paraValue;
    nvimLteRoamAllowedFlg.reserve[0]        = 0x00;

    /*
     * 写NV:NV_ITEM_LTE_INTERNATION_ROAM_CONFIG,
     * 该NV的结构为 NAS_MMC_NvimLteInternationalRoamCfg, 只写第1个字节
     */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_LTE_INTERNATION_ROAM_CONFIG, (VOS_UINT8 *)&(nvimLteRoamAllowedFlg),
                           sizeof(VOS_UINT16)) != NV_OK) {
        AT_ERR_LOG("AT_SetCLteRoamAllowPara:Write NV fail");
        return AT_ERROR;
    } else {
        return AT_OK;
    }
}
#endif


VOS_UINT32 At_SetWlthresholdcfgPara(VOS_UINT8 indexNum)
{
#if (FEATURE_UE_MODE_W == FEATURE_ON)
    VOS_UINT32                  result;
#endif
    AT_MTA_ReselOffsetCfgSetNtf reselOffsetCfgNtf;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&reselOffsetCfgNtf, sizeof(reselOffsetCfgNtf), 0x00, sizeof(reselOffsetCfgNtf));

    reselOffsetCfgNtf.offsetFlg = (VOS_UINT8)g_atParaList[0].paraValue;

#if (FEATURE_UE_MODE_W == FEATURE_ON)
    /* 发送消息AT_MTA_RESEL_OFFSET_CFG_SET_REQ_STRU */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_RESEL_OFFSET_CFG_SET_NTF, (VOS_UINT8 *)&reselOffsetCfgNtf,
                                    sizeof(reselOffsetCfgNtf), I0_UEPS_PID_MTA);
#endif

#if (FEATURE_LTE == FEATURE_ON)
    /* L使用参数 */
    At_SetLWThresholdCfgPara(indexNum);
#endif

#if (FEATURE_UE_MODE_W == FEATURE_ON)
    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetWlthresholdcfgPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
#endif
    return AT_OK;
}


VOS_UINT32 At_SetSwverPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;

    AT_PR_LOGI("Rcv Msg");

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        AT_WARN_LOG("At_SetSwverPara: ucCmdOptType error.");

        return AT_ERROR;
    }

    /* 发消息到C核获取充电状态和电池电量 */
    ret = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                 DRV_AGENT_SWVER_SET_REQ, VOS_NULL_PTR, 0, I0_WUEPS_PID_DRV_AGENT);
    if (ret != TAF_SUCCESS) {
        AT_WARN_LOG("At_SetSwverPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    AT_PR_LOGI("Snd Msg");

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SWVER_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetCbgPara(VOS_UINT8 indexNum)
{
    VOS_UINT32       result;
    APP_VC_MsgUint16 msgName;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取下发VC的消息头名称 */
    if (g_atParaList[0].paraValue == 0) {
        msgName = APP_VC_MSG_SET_FOREGROUND_REQ;
    } else {
        msgName = APP_VC_MSG_SET_BACKGROUND_REQ;
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, msgName,
                                    VOS_NULL_PTR, 0, I0_WUEPS_PID_VC);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetCbgPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CBG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SndMtaBodySarPara(VOS_UINT8 indexNum, AT_MTA_BodySarStateUint16 bodySarState,
                                MTA_BodySarPara *bodySarPara)
{
    errno_t              memResult;
    VOS_UINT32           result;
    AT_MTA_BodySarSetReq bodySarSetReq;

    (VOS_VOID)memset_s(&bodySarSetReq, sizeof(bodySarSetReq), 0x00, sizeof(bodySarSetReq));

    /* 填充消息结构体 */
    bodySarSetReq.state = bodySarState;
    memResult = memcpy_s(&bodySarSetReq.bodySarPara, sizeof(bodySarSetReq.bodySarPara), bodySarPara,
                         sizeof(MTA_BodySarPara));
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(bodySarSetReq.bodySarPara), sizeof(MTA_BodySarPara));

    /* 发送消息AT_MTA_BodySarSetReq */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_BODY_SAR_SET_REQ, (VOS_UINT8 *)&bodySarSetReq,
                                    sizeof(AT_MTA_BodySarSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SndMtaBodySarPara: AT_FillAndSndAppReqMsg fail.");
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetBodySarOnPara(VOS_UINT8 indexNum)
{
    VOS_UINT32      result;
    MTA_BodySarPara bodySarPara;

    (VOS_VOID)memset_s(&bodySarPara, sizeof(bodySarPara), 0x00, sizeof(bodySarPara));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 判断BODYSAR当前状态 */
    if (g_atBodySarState == g_atParaList[0].paraValue) {
        return AT_OK;
    }

    /* 读取BODYSAR NV项 */
    result = TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_BODY_SAR_PARA, &bodySarPara, sizeof(MTA_BodySarPara));

    if (result != NV_OK) {
        AT_ERR_LOG("AT_SetBodySarOnPara: Read NV fail");
        return AT_ERROR;
    }

    /* 发送消息给MTA */
    result = AT_SndMtaBodySarPara(indexNum, (AT_MTA_BodySarStateUint16)g_atParaList[0].paraValue, &bodySarPara);
    if (result != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_BODYSARON_SET;
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckBodySarWcdmaPara(AT_BodysarwcdmaSetPara *bodySarWcdmaPara)
{
    AT_NvWgRfMainBand wGBand;
    VOS_UINT8         loop;
    VOS_UINT32        len;
    errno_t           memResult;

    (VOS_VOID)memset_s(&wGBand, sizeof(wGBand), 0x00, sizeof(wGBand));

    /* 参数个数检查 */
    if ((g_atParaIndex < AT_BODYSARWCDMA_MIN_PARA_NUM) || (g_atParaIndex > AT_BODYSARWCDMA_MAX_PARA_NUM)) {
        AT_WARN_LOG1("AT_CheckBodySarWcdmaPara: Para Num Incorrect!", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当参数个数为1时，补充默认值 */
    if (g_atParaIndex == AT_BODYSARWCDMA_MIN_PARA_NUM) {
        len = VOS_StrLen(AT_RF_BAND_ANY_STR);
        if (len > 0) {
            memResult = memcpy_s(g_atParaList[AT_BODYSARWCDMA_BAND].para, sizeof(g_atParaList[AT_BODYSARWCDMA_BAND].para),
                                 AT_RF_BAND_ANY_STR, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(g_atParaList[AT_BODYSARWCDMA_BAND].para), len);
        }
        g_atParaList[AT_BODYSARWCDMA_BAND].para[len] = '\0';
        g_atParaList[AT_BODYSARWCDMA_BAND].paraLen   = (VOS_UINT16)len;
        g_atParaIndex                                = 2; /* 表示BODYSARWCDMA指令有2个参数 */
    }

    /* 参数个数必须为偶数 */
    if ((g_atParaIndex % 2) != 0) {
        AT_WARN_LOG1("AT_CheckBodySarWcdmaPara: Para Num is not Even!", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取WCDMA Band能力值 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WG_RF_MAIN_BAND, &wGBand, sizeof(wGBand)) != NV_OK) {
        AT_ERR_LOG("AT_CheckBodySarWcdmaPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 循环检查Band频段是否支持，并填充参数结构体 */
    bodySarWcdmaPara->paraNum = 0;
    for (loop = 0; loop < (g_atParaIndex / 2); loop++) { /* 将BODYSARWCDMA指令参数分为<power><band>为对应一组 */
        /* 将用户输入的频段参数由16进制字符串转换为数字 */
        if (At_String2Hex(g_atParaList[loop * 2 + 1].para, g_atParaList[loop * 2 + 1].paraLen,
                          &g_atParaList[loop * 2 + 1].paraValue) != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果用户输入的是任意Band频段，则替换为当前支持的Band频段值 */
        if (g_atParaList[loop * 2 + 1].paraValue == AT_RF_BAND_ANY) {
            g_atParaList[loop * 2 + 1].paraValue = wGBand.unWcdmaBand.band;
        }

        /* 检查用户输入的频段当前是否支持，如果不支持返回参数错误 */
        if ((g_atParaList[loop * 2 + 1].paraValue & (~wGBand.unWcdmaBand.band)) != 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        bodySarWcdmaPara->asPower[bodySarWcdmaPara->paraNum] = (VOS_INT16)g_atParaList[loop * 2].paraValue;
        bodySarWcdmaPara->band[bodySarWcdmaPara->paraNum]    = g_atParaList[loop * 2 + 1].paraValue;
        bodySarWcdmaPara->paraNum++;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_FillBodySarWcdmaPara(AT_BodysarwcdmaSetPara *bodySarWcdmaPara, MTA_BodySarPara *bodySarPara)
{
    VOS_UINT8           loop1;
    MTA_WcdmaBandUint16 loop2;
    VOS_UINT8           loop3;

    bodySarWcdmaPara->paraNum = (VOS_UINT8)TAF_MIN(bodySarWcdmaPara->paraNum, AT_BODYSARWCDMA_MAX_PARA_GROUP_NUM);

    bodySarPara->wBandNum = (VOS_UINT16)TAF_MIN(bodySarPara->wBandNum, MTA_BODY_SAR_WBAND_MAX_NUM);

    /* 遍历命令所有的参数 */
    for (loop1 = 0; loop1 < bodySarWcdmaPara->paraNum; loop1++) {
        /* 按照WCDMA Band来填充参数 */
        for (loop2 = MTA_WCDMA_I_2100; loop2 < MTA_WCDMA_BAND_BUTT; loop2++) {
            if ((bodySarWcdmaPara->band[loop1] & (0x00000001UL << (loop2 - 1))) == 0) {
                continue;
            }

            for (loop3 = 0; loop3 < bodySarPara->wBandNum; loop3++) {
                if (loop2 == bodySarPara->wBandPara[loop3].band) {
                    break;
                }
            }

            if (loop3 == bodySarPara->wBandNum) {
                /* 若超出W Band最大支持个数，则回复失败 */
                if (bodySarPara->wBandNum >= MTA_BODY_SAR_WBAND_MAX_NUM) {
                    AT_ERR_LOG("AT_FillBodySarWcdmaPara: Too Many W Band!");
                    return VOS_ERR;
                }

                bodySarPara->wBandNum++;
            }
            if (loop3 < MTA_BODY_SAR_WBAND_MAX_NUM) {
                bodySarPara->wBandPara[loop3].band  = loop2;
                bodySarPara->wBandPara[loop3].power = bodySarWcdmaPara->asPower[loop1];
            }
        }
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetBodySarWcdmaPara(VOS_UINT8 indexNum)
{
    MTA_BodySarPara        bodySarPara;
    AT_BodysarwcdmaSetPara bodySarWcdmaPara;
    VOS_UINT32             result;

    (VOS_VOID)memset_s(&bodySarPara, sizeof(bodySarPara), 0x00, sizeof(bodySarPara));
    (VOS_VOID)memset_s(&bodySarWcdmaPara, sizeof(bodySarWcdmaPara), 0x00, sizeof(bodySarWcdmaPara));

    /* 检查参数有效性 */
    result = AT_CheckBodySarWcdmaPara(&bodySarWcdmaPara);
    if (result != AT_SUCCESS) {
        return result;
    }

    /* 从NV项中读取Body SAR功率门限值 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_BODY_SAR_PARA, &bodySarPara, sizeof(bodySarPara)) != NV_OK) {
        AT_ERR_LOG("AT_SetBodysarWcdmaPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 将WCDMA的频段参数填充到Body SAR参数结构体中 */
    if (AT_FillBodySarWcdmaPara(&bodySarWcdmaPara, &bodySarPara) != VOS_OK) {
        return AT_ERROR;
    }

    /* 将Body SAR功率门限值保存到NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_BODY_SAR_PARA, (VOS_UINT8 *)&(bodySarPara), sizeof(bodySarPara)) !=
        NV_OK) {
        AT_ERR_LOG("AT_SetBodysarWcdmaPara: Write NV fail!");
        return AT_ERROR;
    }

    /* 如果当前开启了Body SAR功能，则通知物理层新的Body SAR参数 */
    if (g_atBodySarState == AT_MTA_BODY_SAR_ON) {
        if (AT_SndMtaBodySarPara(indexNum, g_atBodySarState, &bodySarPara) != VOS_OK) {
            AT_WARN_LOG("AT_SetBodySarWcdmaPara: AT_SndMtaBodySarPara fail!");
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_GetGsmBandCapa(VOS_UINT32 *gBand)
{
    AT_NvWgRfMainBand wGBand;

    (VOS_VOID)memset_s(&wGBand, sizeof(wGBand), 0x00, sizeof(wGBand));
    *gBand = 0;

    /* 从NV项中读取单板支持的频段 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_WG_RF_MAIN_BAND, &wGBand, sizeof(wGBand)) != NV_OK) {
        AT_ERR_LOG("AT_GetGsmBandCapa: Read NV fail!");
        return VOS_ERR;
    }

    if (wGBand.unGsmBand.bitBand.bandGsm850 == VOS_TRUE) {
        *gBand |= AT_BODY_SAR_GBAND_GPRS_850_MASK;
        *gBand |= AT_BODY_SAR_GBAND_EDGE_850_MASK;
    }

    if ((wGBand.unGsmBand.bitBand.bandGsmP900 == VOS_TRUE) || (wGBand.unGsmBand.bitBand.bandGsmR900 == VOS_TRUE) ||
        (wGBand.unGsmBand.bitBand.bandGsmE900 == VOS_TRUE)) {
        *gBand |= AT_BODY_SAR_GBAND_GPRS_900_MASK;
        *gBand |= AT_BODY_SAR_GBAND_EDGE_900_MASK;
    }

    if (wGBand.unGsmBand.bitBand.bandGsm1800 == VOS_TRUE) {
        *gBand |= AT_BODY_SAR_GBAND_GPRS_1800_MASK;
        *gBand |= AT_BODY_SAR_GBAND_EDGE_1800_MASK;
    }

    if (wGBand.unGsmBand.bitBand.bandGsm1900 == VOS_TRUE) {
        *gBand |= AT_BODY_SAR_GBAND_GPRS_1900_MASK;
        *gBand |= AT_BODY_SAR_GBAND_EDGE_1900_MASK;
    }

    return VOS_OK;
}


VOS_UINT32 AT_CheckBodySarGsmPara(AT_BodysargsmSetPara *bodySarGsmPara)
{
    VOS_UINT32 gBand;
    VOS_UINT8  loop;
    VOS_UINT32 len;
    errno_t    memResult;

    gBand = 0;

    /* 参数个数检查 */
    if ((g_atParaIndex < AT_BODYSARGSM_MIN_PARA_NUM) || (g_atParaIndex > AT_BODYSARGSM_MAX_PARA_NUM)) {
        AT_WARN_LOG1("AT_CheckBodySarGsmPara: Para Num Incorrect!", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 当参数个数为1时，补充默认值 */
    if (g_atParaIndex == AT_BODYSARGSM_MIN_PARA_NUM) {
        len = VOS_StrLen(AT_RF_BAND_ANY_STR);
        if (len > 0) {
            memResult = memcpy_s(g_atParaList[AT_BODYSARGSM_BAND].para, sizeof(g_atParaList[AT_BODYSARGSM_BAND].para),
                             AT_RF_BAND_ANY_STR, len);
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(g_atParaList[AT_BODYSARGSM_BAND].para), len);
        }
        g_atParaList[AT_BODYSARGSM_BAND].para[len] = '\0';
        g_atParaList[AT_BODYSARGSM_BAND].paraLen   = (VOS_UINT16)len;
        g_atParaIndex                              = 2; /* 表示BODYSARGSM指令有2个参数 */
    }

    /* 参数个数必须为偶数 */
    if ((g_atParaIndex % 2) != 0) {
        AT_WARN_LOG1("AT_CheckBodySarGsmPara: Para Num is not Even!", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取GSM Band能力值 */
    if (AT_GetGsmBandCapa(&gBand) != VOS_OK) {
        return AT_ERROR;
    }

    /* 循环检查Band频段是否支持，并填充参数结构体 */
    bodySarGsmPara->paraNum = 0;
    for (loop = 0; loop < (g_atParaIndex / 2); loop++) { /* 将BODYSARGSM指令参数分为<power><band>为对应一组 */
        /* 将用户输入的频段参数由16进制字符串转换为数字 */
        if (At_String2Hex(g_atParaList[loop * 2 + 1].para, g_atParaList[loop * 2 + 1].paraLen,
                          &g_atParaList[loop * 2 + 1].paraValue) != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 如果用户输入的是任意Band频段，则替换为当前支持的Band频段值 */
        if (g_atParaList[loop * 2 + 1].paraValue == AT_RF_BAND_ANY) {
            g_atParaList[loop * 2 + 1].paraValue = gBand;
        }

        /* 检查用户输入的频段当前是否支持，如果不支持返回参数错误 */
        if ((g_atParaList[loop * 2 + 1].paraValue & (~gBand)) != 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        bodySarGsmPara->asPower[bodySarGsmPara->paraNum] = (VOS_INT16)g_atParaList[loop * 2].paraValue;
        bodySarGsmPara->band[bodySarGsmPara->paraNum]    = g_atParaList[loop * 2 + 1].paraValue;
        bodySarGsmPara->paraNum++;
    }

    return AT_SUCCESS;
}


VOS_VOID AT_FillBodySarGsmPara(AT_BodysargsmSetPara *bodySarGsmPara, MTA_BodySarPara *bodySarPara)
{
    VOS_UINT8 loop;

    /* 遍历命令所有的参数 */
    bodySarGsmPara->paraNum = AT_MIN(bodySarGsmPara->paraNum, AT_NVIM_BODYSARGSM_MAX_PARA_GROUP_NUM);
    for (loop = 0; loop < bodySarGsmPara->paraNum; loop++) {
        if ((AT_BODY_SAR_GBAND_GPRS_850_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_GPRS_850_MASK;
            bodySarPara->gBandPara[AT_GSM_850].gprsPower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_850_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_EDGE_850_MASK;
            bodySarPara->gBandPara[AT_GSM_850].edgePower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_900_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_GPRS_900_MASK;
            bodySarPara->gBandPara[AT_GSM_900].gprsPower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_900_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_EDGE_900_MASK;
            bodySarPara->gBandPara[AT_GSM_900].edgePower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_1800_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_GPRS_1800_MASK;
            bodySarPara->gBandPara[AT_GSM_1800].gprsPower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_1800_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_EDGE_1800_MASK;
            bodySarPara->gBandPara[AT_GSM_1800].edgePower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_GPRS_1900_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_GPRS_1900_MASK;
            bodySarPara->gBandPara[AT_GSM_1900].gprsPower = bodySarGsmPara->asPower[loop];
        }

        if ((AT_BODY_SAR_GBAND_EDGE_1900_MASK & bodySarGsmPara->band[loop]) != 0) {
            bodySarPara->gBandMask |= AT_BODY_SAR_GBAND_EDGE_1900_MASK;
            bodySarPara->gBandPara[AT_GSM_1900].edgePower = bodySarGsmPara->asPower[loop];
        }
    }

    return;
}


VOS_UINT32 AT_SetBodySarGsmPara(VOS_UINT8 indexNum)
{
    MTA_BodySarPara      bodySarPara;
    AT_BodysargsmSetPara bodySarGsmPara;
    VOS_UINT32           result;

    (VOS_VOID)memset_s(&bodySarPara, sizeof(bodySarPara), 0x00, sizeof(bodySarPara));
    (VOS_VOID)memset_s(&bodySarGsmPara, sizeof(bodySarGsmPara), 0x00, sizeof(bodySarGsmPara));

    /* 检查参数有效性 */
    result = AT_CheckBodySarGsmPara(&bodySarGsmPara);
    if (result != AT_SUCCESS) {
        return result;
    }

    /* 从NV项中读取Body SAR功率门限值 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_BODY_SAR_PARA, &bodySarPara, sizeof(bodySarPara)) != NV_OK) {
        AT_ERR_LOG("AT_SetBodySarGsmPara: Read NV fail!");
        return AT_ERROR;
    }

    /* 将GSM的频段参数填充到Body SAR参数结构体中 */
    AT_FillBodySarGsmPara(&bodySarGsmPara, &bodySarPara);

    /* 将Body SAR功率门限值保存到NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_BODY_SAR_PARA, (VOS_UINT8 *)&(bodySarPara), sizeof(bodySarPara)) !=
        NV_OK) {
        AT_ERR_LOG("AT_SetBodySarGsmPara: Write NV fail!");
        return AT_ERROR;
    }

    /* 如果当前开启了Body SAR功能，则通知物理层新的Body SAR参数 */
    if (g_atBodySarState == AT_MTA_BODY_SAR_ON) {
        if (AT_SndMtaBodySarPara(indexNum, g_atBodySarState, &bodySarPara) != VOS_OK) {
            AT_WARN_LOG("AT_SetBodySarGsmPara: AT_SndMtaBodySarPara fail!");
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_SetCopnPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 ret;
    VOS_UINT16 fromIndex = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }
    ret = TAF_MMA_QryCopnInfoReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, fromIndex, 0);
    if (ret != VOS_TRUE) {
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COPN_QRY;

    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 AT_SetHistoryFreqPara(VOS_UINT8 indexNum)
{
    AT_MTA_ClearHistoryFreqReq atCmd;
    VOS_UINT32                 result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        AT_WARN_LOG("AT_SetHistoryFreqPara: WARNING:Input Len invalid!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.mode = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^CHISFREQ设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_CLEAR_HISTORY_FREQ_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_ClearHistoryFreqReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLEAR_HISTORY_FREQ;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CommBoosterParaCheck(VOS_VOID)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return VOS_ERR;
    }

    if (g_atParaIndex != AT_COMMBOOSTER_PARA_NUM) {
        return VOS_ERR;
    }

    if ((g_atParaList[AT_COMMBOOSTER_MODULEID].paraLen == 0) || (g_atParaList[AT_COMMBOOSTER_LEN].paraLen == 0) ||
        (g_atParaList[AT_COMMBOOSTER_PARAM].paraLen  == 0)) {
        return VOS_ERR;
    }

    /* g_atParaList[1]记录字节数，g_atParaList[2]是字符个数，一个字节占2个字符，这里做一下校验 */
    if ((g_atParaList[AT_COMMBOOSTER_LEN].paraValue != g_atParaList[AT_COMMBOOSTER_PARAM].paraLen / 2) ||
        (g_atParaList[AT_COMMBOOSTER_PARAM].paraLen % 2 != 0)) {
        return VOS_ERR;
    }

    /* 字符的个数大于500都是错误参数 */
    if (g_atParaList[AT_COMMBOOSTER_PARAM].paraLen > AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH) {
        return VOS_ERR;
    }

    return VOS_OK;
}


VOS_UINT32 AT_SetCommBoosterPara(VOS_UINT8 indexNum)
{
    AT_MTA_CommBoosterSetReq   commBoosterSet;
    AT_MTA_CommBoosterQueryReq commBoosterQuery;
    VOS_UINT32 result;

    if (AT_CommBoosterParaCheck() != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 1) {
        (VOS_VOID)memset_s(&commBoosterSet, sizeof(commBoosterSet), 0x00, sizeof(commBoosterSet));
        commBoosterSet.pidIndex = (VOS_UINT16)g_atParaList[AT_COMMBOOSTER_MODULEID].paraValue;
        commBoosterSet.len      = g_atParaList[AT_COMMBOOSTER_LEN].paraValue;
        (VOS_VOID)memset_s(commBoosterSet.date, AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH, 0x00, sizeof(commBoosterSet.date));

        if (At_AsciiString2HexSimple(commBoosterSet.date, g_atParaList[AT_COMMBOOSTER_PARAM].para,
                                     g_atParaList[AT_COMMBOOSTER_PARAM].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_COMM_BOOSTER_SET_REQ,
                                        (VOS_UINT8 *)&commBoosterSet, sizeof(AT_MTA_CommBoosterSetReq),
                                        I0_UEPS_PID_MTA);
    } else {
        (VOS_VOID)memset_s(&commBoosterQuery, sizeof(commBoosterQuery), 0x00, sizeof(commBoosterQuery));
        commBoosterQuery.pidIndex = (VOS_UINT16)g_atParaList[AT_COMMBOOSTER_MODULEID].paraValue;
        commBoosterQuery.len      = g_atParaList[AT_COMMBOOSTER_LEN].paraValue;
        (VOS_VOID)memset_s(commBoosterQuery.date, AT_CMD_COMM_BOOSTER_BS_MAX_LENGTH, 0x00,
                 sizeof(commBoosterQuery.date));

        if (At_AsciiString2HexSimple(commBoosterQuery.date, g_atParaList[AT_COMMBOOSTER_PARAM].para,
                                     g_atParaList[AT_COMMBOOSTER_PARAM].paraLen) == AT_FAILURE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_COMM_BOOSTER_QRY_REQ,
                                        (VOS_UINT8 *)&commBoosterQuery, sizeof(AT_MTA_CommBoosterQueryReq),
                                        I0_UEPS_PID_MTA);
    }

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    if (g_atParaList[0].paraValue == 1) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COMM_BOOSTER_SET;
    } else {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_COMM_BOOSTER_QRY;
    }

    return AT_WAIT_ASYNC_RETURN;
}



VOS_UINT32 AT_WriteNvAndSaveNvParaProc(VOS_UINT8 indexNum) {
    AT_ModemNvloadCtx                *nvloadCarrierCtx = VOS_NULL_PTR;
    TAF_NVIM_UsimDependentResultInfo  activeNvloadInfo;
    VOS_UINT32                        nvWriteResult;
    errno_t                           memResult;
    VOS_UINT16                        length;
    ModemIdUint16                     modemId = MODEM_ID_0;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        AT_ERR_LOG("AT_WriteNvAndSaveNvParaProc: Get modem id fail.");
        return AT_ERROR;
    }

    nvloadCarrierCtx = AT_GetModemNvloadCtxAddrFromModemId(modemId);

    (VOS_VOID)memset_s(&activeNvloadInfo, sizeof(activeNvloadInfo), 0, sizeof(activeNvloadInfo));

    length = g_atParaList[AT_NV_CARRIER_NAME].paraLen;
    if (length > AT_SET_NV_CARRIER_NAME_LEN) {
        AT_WARN_LOG("AT_WriteNvAndSaveNvParaProc: CARRIERNAME Length Error");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if(length != 0) {
        memResult = memcpy_s(activeNvloadInfo.operName, sizeof(activeNvloadInfo.operName),
            g_atParaList[AT_NV_CARRIER_NAME].para, length);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(activeNvloadInfo.operName), length);
    }

    if(g_atParaIndex > AT_NV_CARRIER_PARA_NUM) {
        if(g_atParaList[AT_NV_CARRIER_EFFECTIVEWAY].paraLen != 0) {
            activeNvloadInfo.effectiveWay = (VOS_UINT8)g_atParaList[AT_NV_CARRIER_EFFECTIVEWAY].paraValue;
        }
    }

    if((VOS_StrNiCmp((VOS_CHAR *)nvloadCarrierCtx->carrierName, (VOS_CHAR *)activeNvloadInfo.operName,
            AT_SET_NV_CARRIER_NAME_LEN) != 0) ||
       (nvloadCarrierCtx->specialEffectiveFlg != activeNvloadInfo.effectiveWay)) {
        /* 写NV项 */
        nvWriteResult = TAF_ACORE_NV_WRITE(modemId, NV_ITEM_USIM_DEPENDENT_RESULT_INFO, (VOS_UINT8 *)&activeNvloadInfo,
            sizeof(TAF_NVIM_UsimDependentResultInfo));
        if (nvWriteResult != NV_OK) {
            AT_ERR_LOG("AT_WriteNvAndSaveNvParaProc: NV_ITEM_USIM_DEPENDENT_RESULT_INFO NV Write Error.");
            return AT_ERROR;
        } else {
            AT_NORM_LOG("AT_WriteNvAndSaveNvParaProc: NV_ITEM_USIM_DEPENDENT_RESULT_INFO NV Write OK");

            /* 保存到全局变量中 */
            memResult = memcpy_s(nvloadCarrierCtx->carrierName, sizeof(nvloadCarrierCtx->carrierName),
                activeNvloadInfo.operName, sizeof(activeNvloadInfo.operName));
            TAF_MEM_CHK_RTN_VAL(memResult, sizeof(nvloadCarrierCtx->carrierName), sizeof(activeNvloadInfo.operName));
            nvloadCarrierCtx->specialEffectiveFlg = activeNvloadInfo.effectiveWay;
        }
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetNvLoadPara(VOS_UINT8 indexNum)
{
    AT_MTA_NvloadSetReq atCmd;
    VOS_UINT32          result;

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.noFlushFlg = VOS_FALSE;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为1-4个，否则返回AT_CME_INCORRECT_PARAMETERS */
    if (g_atParaIndex < AT_NV_CARRIER_PARA_MIN_NUM || g_atParaIndex > AT_NV_CARRIER_PARA_MAX_NUM) {
        AT_WARN_LOG("AT_SetNvLoadPara: At Para Num Error.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数长度检查 */
    if (g_atParaList[AT_NV_CARRIER_ENABLE].paraLen == 0) {
        AT_WARN_LOG("AT_SetNvLoadPara: ENABLE Length Error");
        return AT_CME_INCORRECT_PARAMETERS;
    }
    atCmd.reqType = (VOS_UINT8)g_atParaList[AT_NV_CARRIER_ENABLE].paraValue;

    /* 参数个数大于1时，写NV，并将参数1，2保存到全局变量 */
    if (g_atParaIndex > AT_NV_CARRIER_PARA_MIN_NUM) {
       result = AT_WriteNvAndSaveNvParaProc(indexNum);
        if (result != AT_SUCCESS){
            return result;
        }
    }

    if (g_atParaIndex == AT_NV_CARRIER_PARA_MAX_NUM) {
        if (g_atParaList[AT_NV_CARRIER_NOFLUSH].paraLen != 0) {
            atCmd.noFlushFlg = (VOS_UINT8)g_atParaList[AT_NV_CARRIER_NOFLUSH].paraValue;
        }
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_NVLOAD_SET_REQ, (VOS_UINT8 *)&atCmd,
        sizeof(AT_MTA_NvloadSetReq), I0_UEPS_PID_MTA);

    if (result != AT_SUCCESS) {
        AT_WARN_LOG("AT_SetNvLoadPara: AT_FillAndSndAppReqMsg Failed!");
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NVLOAD_SET;
    return AT_WAIT_ASYNC_RETURN;
}



VOS_UINT32 AT_SetNCellMonitorPara(VOS_UINT8 indexNum)
{
    AT_MTA_NcellMonitorSetReq atCmd;
    VOS_UINT32                result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.switchFlag = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^NCELLMONITOR设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_NCELL_MONITOR_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_NcellMonitorSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NCELL_MONITOR_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 At_SetSimInsertPara(VOS_UINT8 indexNum)
{
    TAF_SIM_InsertStateUint32 simInsertState;
    VOS_UINT32                result;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    simInsertState = (TAF_SIM_InsertStateUint32)g_atParaList[0].paraValue;

    result = TAF_MMA_SimInsertReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  simInsertState);
    if (result == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SIMINSERT_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
#endif


VOS_UINT32 At_SetModemLoopPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;
    VOS_UINT8  modemLoop;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    modemLoop = (VOS_UINT8)g_atParaList[0].paraValue;

    result = APP_VC_SetModemLoop(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, modemLoop);
    if (result == TAF_SUCCESS) {
        return AT_OK; /* 此命令不需要等待C核回复，直接返回OK */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 At_SetReleaseRrc(VOS_UINT8 indexNum)
{
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;

    /* 读取NV项中当前产品形态 */
    systemAppConfig = AT_GetSystemAppConfigAddr();

    /* 非ANDROID系统不支持 */
    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_CMD_NOT_SUPPORT;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 下发请求 */
    if (At_SndReleaseRrcReq(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_RELEASE_RRC_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetRefclkfreqPara(VOS_UINT8 indexNum)
{
    VOS_UINT32              result;
    AT_MTA_RefclkfreqSetReq refClockReq;

    /* 通道检查 */
    if (AT_IsApPort(indexNum) == VOS_FALSE) {
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_ERROR;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&refClockReq, sizeof(refClockReq), 0x00, sizeof(refClockReq));

    refClockReq.rptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送跨核消息到C核, 设置GPS参考时钟状态是否主动上报 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_REFCLKFREQ_SET_REQ, (VOS_UINT8 *)&refClockReq, sizeof(refClockReq),
                                    I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetRefclkfreqPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_REFCLKFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 At_SetDieSNPara(VOS_UINT8 indexNum)
{
    VOS_UINT8  dieSN[AT_DIE_SN_LEN];
    VOS_INT32  i;
    VOS_UINT16 length;

    AT_PR_LOGI("Rcv Msg");

    (VOS_VOID)memset_s(dieSN, sizeof(dieSN), 0x00, sizeof(dieSN));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        AT_WARN_LOG("At_SetDieSNPara: ucCmdOptType error!");

        return AT_ERROR;
    }

    /* 获取DIE SN */
    if (AT_GetEfuseDieid(dieSN, AT_DIE_SN_LEN) != VOS_OK) {
        AT_WARN_LOG("At_SetDieSNPara: Get Die Sn Failed!");

        return AT_ERROR;
    }

    /* 最高位,高4 BIT置0 */
    dieSN[AT_DIE_SN_LEN - 1] = (dieSN[AT_DIE_SN_LEN - 1] & 0x0F);

    /* 格式化输出查询结果 */
    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s: 0x", g_parseContext[indexNum].cmdElement->cmdName);

    for (i = (AT_DIE_SN_LEN - 1); i >= 0; i--) {
        length += (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress + length, "%02x", dieSN[i]);
    }

    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 At_SetHandleDect(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;
    VOS_UINT8  handleType;
    VOS_UINT8 *systemAppConfig = VOS_NULL_PTR;

    /* 读取NV项中当前产品形态 */
    systemAppConfig = AT_GetSystemAppConfigAddr();

    /* 该命令用来配置phone和pad形态cp侧手持位置，非ANDROID系统不支持 */
    if (*systemAppConfig != SYSTEM_APP_ANDROID) {
        return AT_CMD_NOT_SUPPORT;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_ERROR;
    }

    /* handletype 取值错误 */
    if (g_atParaList[0].paraValue > AT_MTA_HANDLEDECT_MAX_TYPE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    handleType = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 发送消息 ID_AT_MTA_HANDLEDECT_SET_REQ 给MTA处理，该消息带参数(VOS_UINT8)g_atParaList[0].ulParaValue */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), ID_AT_MTA_HANDLEDECT_SET_REQ,
                                 &handleType, sizeof(handleType), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_HANDLEDECT_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

#if (FEATURE_IMS == FEATURE_ON)

TAF_UINT32 AT_SetCiregPara(TAF_UINT8 indexNum)
{
    AT_IMSA_CiregSetReq cireg;
    VOS_UINT32          result;

    (VOS_VOID)memset_s(&cireg, sizeof(cireg), 0x00, sizeof(AT_IMSA_CiregSetReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        cireg.cireg = g_atParaList[0].paraValue;

    } else {
        /* 如果参数为空，默认设置为不主动上报 */
        cireg.cireg = AT_IMSA_IMS_REG_STATE_DISABLE_REPORT;
    }

    /* 给IMSA发送+CIREG设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_IMSA_CIREG_SET_REQ,
                                    (VOS_UINT8 *)&cireg.cireg, sizeof(AT_IMSA_ImsRegStateReportUint32), PS_PID_IMSA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CIREG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCirepPara(TAF_UINT8 indexNum)
{
    AT_IMSA_CirepSetReq cirep;
    VOS_UINT32          result;

    (VOS_VOID)memset_s(&cirep, sizeof(cirep), 0x00, sizeof(AT_IMSA_CirepSetReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不为空 */
    if (g_atParaList[0].paraLen != 0) {
        cirep.report = g_atParaList[0].paraValue;

    } else {
        /* 如果参数为空，默认设置为不主动上报 */
        cirep.report = AT_IMSA_CIREP_REPORT_DISENABLE;
    }

    /* 给IMSA发送+CIREG设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_IMSA_CIREP_SET_REQ,
                                    (VOS_UINT8 *)&cirep.report, sizeof(AT_IMSA_CirepReportUint32), PS_PID_IMSA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CIREP_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetVolteimpuPara(TAF_UINT8 indexNum)
{
    AT_IMSA_VolteimpuQryReq impu;
    VOS_UINT32              result;

    (VOS_VOID)memset_s(&impu, sizeof(impu), 0x00, sizeof(AT_IMSA_VolteimpuQryReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 给IMSA发送^VOLTEIMPU设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_IMSA_VOLTEIMPU_QRY_REQ, impu.content,
                                    sizeof(impu.content), PS_PID_IMSA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IMPU_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_UINT32 AT_SetCacmimsPara(TAF_UINT8 indexNum)
{
    VOS_UINT32             i;
    VOS_UINT32             callNum;
    MN_CALL_OrigParam      origParam;
    TAF_CALL_EconfDialInfo econfDialInfo;
    TAF_Ctrl               ctrl;
    AT_ModemSsCtx         *ssCtx = VOS_NULL_PTR;
    VOS_UINT32             result;
    VOS_UINT32             indexValue;
    ModemIdUint16          modemId;

    /* 初始化 */
    (VOS_VOID)memset_s(&origParam, sizeof(origParam), 0x00, sizeof(MN_CALL_OrigParam));
    (VOS_VOID)memset_s(&econfDialInfo, sizeof(econfDialInfo), 0x00, sizeof(econfDialInfo));

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不对 */
    /* 参数的个数应该是total_callnum+2 */
    if ((g_atParaList[AT_CACMIMS_TOTAL_CALLNUM].paraValue + 2) != g_atParaIndex) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 普通多方通话邀请 */
    if (g_atParaList[AT_CACMIMS_IS_ECON].paraValue == 0) {
        /* 普通多方通话只能邀请一个用户 */
        if (g_atParaList[AT_CACMIMS_TOTAL_CALLNUM].paraValue != 1) {
            AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* 设置<dial_string> */
        if (AT_FillCalledNumPara(g_atParaList[AT_CACMIMS_CALL_ADDRESS].para,
                                 g_atParaList[AT_CACMIMS_CALL_ADDRESS].paraLen, &origParam.dialNumber) != VOS_OK) {
            AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
            return AT_CME_INCORRECT_PARAMETERS;
        }

        origParam.callType          = MN_CALL_TYPE_VOICE;
        origParam.callMode          = ssCtx->cModType;
        origParam.dataCfg           = ssCtx->cbstDataCfg;
        origParam.imsInvitePtptFlag = VOS_TRUE;

        origParam.voiceDomain = TAF_CALL_VOICE_DOMAIN_AUTO;

        /* AT向CCM发送呼叫消息 */
        if (TAF_CCM_CallCommonReq(&ctrl, &origParam, ID_TAF_CCM_CALL_ORIG_REQ, sizeof(origParam), modemId) == VOS_OK) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CACMIMS_SET;
            return AT_WAIT_ASYNC_RETURN;
        } else {
            AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
            return AT_ERROR;
        }
    }
    /* 增强型多方通话邀请 */
    else {
        callNum = g_atParaList[AT_CACMIMS_TOTAL_CALLNUM].paraValue;

        /* 默认情况是使用CCA设置的默认值 */
        econfDialInfo.callMode = ssCtx->cModType;
        econfDialInfo.dataCfg  = ssCtx->cbstDataCfg;
        econfDialInfo.clirCfg  = ssCtx->clirType;
        econfDialInfo.cugCfg   = ssCtx->ccugCfg;

        for (i = 0; i < callNum; i++) {
            indexValue = 2 + i; /* 2表示CACMIMS指令参数total_callnum 和 isEcon占下标索引0和1，call_address下标从2开始 */

            if (g_atParaList[indexValue].paraLen == 0) {
                AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);

                return AT_CME_INCORRECT_PARAMETERS;
            }

            if (AT_FillCalledNumPara(g_atParaList[indexValue].para, g_atParaList[indexValue].paraLen,
                                     &econfDialInfo.econfCalllist.dialNumber[i]) != VOS_OK) {
                AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
                return AT_CME_INCORRECT_PARAMETERS;
            }
        }

        econfDialInfo.econfCalllist.callNum = callNum;
        econfDialInfo.callType              = MN_CALL_TYPE_VOICE;
        econfDialInfo.voiceDomain           = TAF_CALL_VOICE_DOMAIN_IMS;
        econfDialInfo.imsInvitePtptFlag     = VOS_TRUE;

        /* AT向CCM发送增强多方通话消息 */
        result = TAF_CCM_CallCommonReq(&ctrl, &econfDialInfo, ID_TAF_CCM_ECONF_DIAL_REQ, sizeof(econfDialInfo),
                                       modemId);

        if (result == VOS_OK) {
            g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CACMIMS_SET;
            return AT_WAIT_ASYNC_RETURN;
        } else {
            AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_UNKNOWN, VOS_NULL_PTR);
            return AT_ERROR;
        }
    }
}


VOS_VOID At_MapInputValueToCcwaiMode(VOS_UINT32 value, TAF_CALL_CcwaiModeUint8 *mode)
{
    switch (value) {
        /* ccwaimode disable */
        case 0:
            *mode = TAF_CALL_CCWAI_MODE_DISABLE;
            break;
        /* ccwaimode enable */
        case 1:
            *mode = TAF_CALL_CCWAI_MODE_ENABLE;
            break;

        default:
            *mode = TAF_CALL_CCWAI_MODE_BUTT;
            break;
    }

    return;
}


VOS_VOID At_MapInputValueToCcwaiSrvClass(VOS_UINT32 value, TAF_CALL_CcwaiSrvClassUint8 *srvClass)
{
    switch (value) {
        case AT_CALL_SRV_CLASS_VOICE:
            *srvClass = TAF_CALL_CCWAI_SRV_CLASS_VOICE;
            break;

        case AT_CALL_SRV_CLASS_VIDEO:
            *srvClass = TAF_CALL_CCWAI_SRV_CLASS_VIDEO;
            break;

        case AT_CALL_SRV_CLASS_SET_NW:
            *srvClass = TAF_CALL_CCWAI_SRV_CLASS_SET_NW;
            break;

        default:
            *srvClass = TAF_CALL_CCWAI_SRV_CLASS_BUTT;
            break;
    }

    return;
}

TAF_UINT32 AT_SetCcwaiPara(TAF_UINT8 indexNum)
{
    VOS_UINT32           result;
    TAF_Ctrl             ctrl;
    TAF_CALL_CcwaiSetReq ccwaiSet;
    ModemIdUint16        modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&ccwaiSet, sizeof(ccwaiSet), 0x00, sizeof(ccwaiSet));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    /* 参数过多 */
    if (g_atParaIndex > AT_CCWAI_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if ((g_atParaList[AT_CCWAI_MODE].paraLen == 0) || (g_atParaList[AT_CCWAI_SERVICE_CLASS].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填充消息结构体 */
    At_MapInputValueToCcwaiMode(g_atParaList[AT_CCWAI_MODE].paraValue, &ccwaiSet.mode);
    At_MapInputValueToCcwaiSrvClass(g_atParaList[AT_CCWAI_SERVICE_CLASS].paraValue, &ccwaiSet.srvClass);

    if ((ccwaiSet.mode == TAF_CALL_CCWAI_MODE_BUTT) || (ccwaiSet.srvClass == TAF_CALL_CCWAI_SRV_CLASS_BUTT)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 给CCM发送^CCWAI设置请求 */
    result = TAF_CCM_CallCommonReq(&ctrl, &ccwaiSet, ID_TAF_CCM_CCWAI_SET_REQ, sizeof(ccwaiSet), modemId);

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCWAI_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetUiccAuthPara(VOS_UINT8 indexNum)
{
    SI_PIH_UiccAuth authData;
    errno_t         memResult;

    if ((g_atParaIndex != AT_UICCAUTH_PARA_NUM) || (g_atParaList[AT_UICCAUTH_RAND].paraLen == 0) ||
        (g_atParaList[AT_UICCAUTH_AUTH].paraLen == 0)) {
        AT_ERR_LOG("AT_SetUiccAuthPara: para check fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_UICCAUTH_RAND].para,
                              &g_atParaList[AT_UICCAUTH_RAND].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("AT_SetUiccAuthPara: At_AsciiNum2HexString para1 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_UICCAUTH_AUTH].para,
                              &g_atParaList[AT_UICCAUTH_AUTH].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("AT_SetUiccAuthPara: At_AsciiNum2HexString para2 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_UICCAUTH_RAND].paraLen > SI_AUTH_DATA_MAX) ||
        (g_atParaList[AT_UICCAUTH_AUTH].paraLen > SI_AUTH_DATA_MAX)) {
        AT_ERR_LOG("AT_SetUiccAuthPara: String Len fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_UICCAUTH_AUTH_TYPE].paraValue == SI_PIH_ATUICCAUTH_USIMAKA) {
        authData.authType = SI_PIH_UICCAUTH_AKA;
        authData.appType  = SI_PIH_UICCAPP_USIM;
    } else if (g_atParaList[AT_UICCAUTH_AUTH_TYPE].paraValue == SI_PIH_ATUICCAUTH_ISIMAKA) {
        authData.authType = SI_PIH_UICCAUTH_AKA;
        authData.appType  = SI_PIH_UICCAPP_ISIM;
    } else if (g_atParaList[AT_UICCAUTH_AUTH_TYPE].paraValue == SI_PIH_ATUICCAUTH_USIMGBA) {
        authData.authType = SI_PIH_UICCAUTH_GBA;
        authData.appType  = SI_PIH_UICCAPP_USIM;
    } else if (g_atParaList[AT_UICCAUTH_AUTH_TYPE].paraValue == SI_PIH_ATUICCAUTH_ISIMGBA) {
        authData.authType = SI_PIH_UICCAUTH_GBA;
        authData.appType  = SI_PIH_UICCAPP_ISIM;
    } else {
        AT_ERR_LOG("AT_SetUiccAuthPara: Para 1 value fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    authData.authData.aka.randLen = g_atParaList[AT_UICCAUTH_RAND].paraLen;

    authData.authData.aka.authLen = g_atParaList[AT_UICCAUTH_AUTH].paraLen;

    /* GBA和AKA鉴权数据结构是一样的 */
    memResult = memcpy_s(authData.authData.aka.rand, sizeof(authData.authData.aka.rand),
                         g_atParaList[AT_UICCAUTH_RAND].para, g_atParaList[AT_UICCAUTH_RAND].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authData.authData.aka.rand), g_atParaList[AT_UICCAUTH_RAND].paraLen);

    memResult = memcpy_s(authData.authData.aka.auth, sizeof(authData.authData.aka.auth),
                         g_atParaList[AT_UICCAUTH_AUTH].para, g_atParaList[AT_UICCAUTH_AUTH].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authData.authData.aka.auth), g_atParaList[AT_UICCAUTH_AUTH].paraLen);

    if (SI_PIH_UiccAuthReq(g_atClientTab[indexNum].clientId, 0, &authData) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UICCAUTH_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        AT_ERR_LOG("AT_SetUiccAuthPara: SI_PIH_UiccAuthReq fail.");

        return AT_ERROR;
    }
}


VOS_VOID AT_RSMParaFillCommandAndPath(SI_PIH_AccessFile *command)
{
    errno_t memResult;

    if ((g_atParaList[AT_CURSM_DATA].paraLen > 0) &&
        (g_atParaList[AT_CURSM_DATA].paraLen <= sizeof(command->command))) {
        memResult = memcpy_s(command->command, sizeof(command->command), g_atParaList[AT_CURSM_DATA].para,
                             g_atParaList[AT_CURSM_DATA].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command->command), g_atParaList[AT_CURSM_DATA].paraLen);
    }
    if ((g_atParaList[AT_CURSM_PATHID].paraLen > 0) &&
        (g_atParaList[AT_CURSM_PATHID].paraLen <= sizeof(command->path))) {
        memResult = memcpy_s(command->path, sizeof(command->path), g_atParaList[AT_CURSM_PATHID].para,
                             g_atParaList[AT_CURSM_PATHID].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(command->path), g_atParaList[AT_CURSM_PATHID].paraLen);
    }

    return;
}

VOS_UINT32 AT_SetURSMPara(VOS_UINT8 indexNum)
{
    SI_PIH_AccessFile command;
    VOS_UINT16        fileID;

    /* 参数过多 */
    if ((g_atParaIndex > AT_CURSM_MAX_PARA_NUM) || (g_atParaIndex < AT_CURSM_MIN_PARA_NUM)) {
        AT_ERR_LOG("AT_SetURSMPara: too many para");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CURSM_COMMAND].paraValue == SI_PIH_ACCESS_WRITE) &&
        (g_atParaList[AT_CURSM_DATA].paraLen == 0)) {
        AT_ERR_LOG("AT_SetURSMPara: Write para wrong");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CURSM_COMMAND].paraValue == SI_PIH_ACCESS_READ) &&
        (g_atParaList[AT_CURSM_DATA].paraLen != 0)) {
        AT_ERR_LOG("AT_SetURSMPara: Read para wrong");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取文件ID前两位 */
    fileID = (g_atParaList[AT_CURSM_FILEID].paraValue >> 8) & (0x00FF);

    /* 输入的文件ID必须是EF文件，前两位不可以是3F/5F/7F */
    if ((fileID == MFLAB) || (fileID == DFUNDERMFLAB) || (fileID == DFUNDERDFLAB)) {
        AT_ERR_LOG("AT_SetURSMPara: File Id error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_CURSM_DATA].paraLen != 0) {
        if (At_AsciiNum2HexString(g_atParaList[AT_CURSM_DATA].para,
                                  &g_atParaList[AT_CURSM_DATA].paraLen) == AT_FAILURE) {
            AT_ERR_LOG("AT_SetURSMPara: At_AsciiNum2HexString para4 fail.");

            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if (g_atParaList[AT_CURSM_PATHID].paraLen != 0) {
        if (At_AsciiNum2HexString(g_atParaList[AT_CURSM_PATHID].para,
                                  &g_atParaList[AT_CURSM_PATHID].paraLen) == AT_FAILURE) {
            AT_ERR_LOG("AT_SetURSMPara: At_AsciiNum2HexString para5 fail.");

            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    if ((g_atParaList[AT_CURSM_DATA].paraLen > USIMM_T0_APDU_MAX_LEN) ||
        (g_atParaList[AT_CURSM_PATHID].paraLen > USIMM_MAX_PATH_LEN) ||
        (g_atParaList[AT_CURSM_APP_TYPE].paraValue >= SI_PIH_UICCAPP_BUTT)) {
        AT_ERR_LOG("AT_SetURSMPara: AT para 4 or 5 is fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    command.efId      = (VOS_UINT16)g_atParaList[AT_CURSM_FILEID].paraValue;
    command.appType   = g_atParaList[AT_CURSM_APP_TYPE].paraValue;
    command.cmdType   = (VOS_UINT8)g_atParaList[AT_CURSM_COMMAND].paraValue;
    command.recordNum = (VOS_UINT8)g_atParaList[AT_CURSM_RECORD_NUMBER].paraValue;
    command.dataLen   = g_atParaList[AT_CURSM_DATA].paraLen;
    command.pathLen   = g_atParaList[AT_CURSM_PATHID].paraLen;

    AT_RSMParaFillCommandAndPath(&command);

    /* 执行命令操作 */
    if (SI_PIH_AccessUICCFileReq(g_atClientTab[indexNum].clientId, 0, &command) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CURSM_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        AT_ERR_LOG("AT_SetURSMPara: SI_PIH_AccessUICCFileReq error.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetKsNafAuthPara(VOS_UINT8 indexNum)
{
    SI_PIH_UiccAuth authData;
    errno_t         memResult;

    if ((g_atParaIndex != AT_KSNAFAUTH_PARA_NUM) || (g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen == 0) ||
        (g_atParaList[AT_KSNAFAUTH_IMPI].paraLen == 0)) {
        AT_ERR_LOG("AT_SetKsNafAuthPara: check para fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_KSNAFAUTH_NAF_ID].para,
                              &g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("AT_SetKsNafAuthPara: At_AsciiNum2HexString para1 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_AsciiNum2HexString(g_atParaList[AT_KSNAFAUTH_IMPI].para,
                              &g_atParaList[AT_KSNAFAUTH_IMPI].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("AT_SetKsNafAuthPara: At_AsciiNum2HexString para2 fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen > SI_AUTH_DATA_MAX) ||
        (g_atParaList[AT_KSNAFAUTH_IMPI].paraLen > SI_AUTH_DATA_MAX)) {
        AT_ERR_LOG("AT_SetKsNafAuthPara: Str Len check fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_KSNAFAUTH_AUTH_TYPE].paraValue == SI_PIH_ATKSNAFAUTH_USIM) {
        authData.authType = SI_PIH_UICCAUTH_NAF;
        authData.appType  = SI_PIH_UICCAPP_USIM;
    } else if (g_atParaList[AT_KSNAFAUTH_AUTH_TYPE].paraValue == SI_PIH_ATKSNAFAUTH_ISIM) {
        authData.authType = SI_PIH_UICCAUTH_NAF;
        authData.appType  = SI_PIH_UICCAPP_ISIM;
    } else {
        AT_ERR_LOG("AT_SetKsNafAuthPara: Auth type fail.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    authData.authData.ksNAF.nafIdLen = g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen;

    authData.authData.ksNAF.impiLen = g_atParaList[AT_KSNAFAUTH_IMPI].paraLen;

    memResult = memcpy_s(authData.authData.ksNAF.nafId, sizeof(authData.authData.ksNAF.nafId),
                         g_atParaList[AT_KSNAFAUTH_NAF_ID].para, g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authData.authData.ksNAF.nafId), g_atParaList[AT_KSNAFAUTH_NAF_ID].paraLen);

    memResult = memcpy_s(authData.authData.ksNAF.impi, sizeof(authData.authData.ksNAF.impi),
                         g_atParaList[AT_KSNAFAUTH_IMPI].para, g_atParaList[AT_KSNAFAUTH_IMPI].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(authData.authData.ksNAF.impi), g_atParaList[AT_KSNAFAUTH_IMPI].paraLen);

    if (SI_PIH_UiccAuthReq(g_atClientTab[indexNum].clientId, 0, &authData) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_KSNAFAUTH_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        AT_ERR_LOG("AT_SetKsNafAuthPara: SI_PIH_UiccAuthReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetRoamImsServicePara(VOS_UINT8 indexNum)
{
    TAF_MMA_RoamImsSupportUint32 roamImsSupport;

    roamImsSupport = TAF_MMA_ROAM_IMS_BUTT;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaIndex != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 0) {
        roamImsSupport = TAF_MMA_ROAM_IMS_UNSUPPORT;
    } else {
        roamImsSupport = TAF_MMA_ROAM_IMS_SUPPORT;
    }

    if (TAF_MMA_SetRoamImsSupportReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, roamImsSupport) == VOS_TRUE) {
        /* 设置AT模块实体的状态为等待异步返回 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ROAM_IMS_SET;

        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetRoamImsServicePara: TAF_MMA_SetRoamImsSupportReq fail.");

        return AT_ERROR;
    }
}

#endif


VOS_UINT32 AT_SetEOPlmnParaCheck(VOS_VOID)
{
    /* 参数有效性检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不为TAF_AT_EOPLMN_PARA_NUM，返回AT_CME_INCORRECT_PARAMETERS */
    if (g_atParaIndex != TAF_AT_EOPLMN_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第1个参数检查,version长度不能大于TAF_MAX_USER_CFG_OPLMN_VERSION_LEN */
    if (g_atParaList[AT_EOPLMN_VERSION].paraLen >= TAF_MAX_USER_CFG_OPLMN_VERSION_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第2个参数检查，组Index值不能大于5 */
    if (g_atParaList[AT_EOPLMN_INDEX].paraValue > TAF_MAX_USER_CFG_OPLMN_GROUP_INDEX) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数检查，pduLen值不能大于500 */
    if (g_atParaList[AT_EOPLMN_PDULEN].paraValue > TAF_AT_PLMN_WITH_RAT_LEN * TAF_MAX_GROUP_CFG_OPLMN_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第3个参数检查，pduLen值必须为TAF_AT_PLMN_WITH_RAT_LEN的整数倍 */
    if ((g_atParaList[AT_EOPLMN_PDULEN].paraValue % TAF_AT_PLMN_WITH_RAT_LEN) != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 最大只允许设置256个，因此最后的第6组(index=5)最大允许用户设置6个OPLMN */
    if ((g_atParaList[AT_EOPLMN_PDULEN].paraValue > 6 * TAF_AT_PLMN_WITH_RAT_LEN) &&
        (g_atParaList[AT_EOPLMN_INDEX].paraValue == TAF_MAX_USER_CFG_OPLMN_GROUP_INDEX)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第4个参数检查，PDU的实际长度必须与指定的pdulen相同 */
    if (g_atParaList[AT_EOPLMN_PDU].paraLen != g_atParaList[AT_EOPLMN_PDULEN].paraValue) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第4个参数检查，PDU数据必须可以完成16进制字符串转换 */
    if (At_AsciiNum2HexString(g_atParaList[AT_EOPLMN_PDU].para,
                              &g_atParaList[AT_EOPLMN_PDU].paraLen) != AT_SUCCESS) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetUserCfgOPlmnPara(VOS_UINT8 indexNum)
{
    TAF_MMA_SetEoplmnList eOPlmnSetPara;
    VOS_UINT32            rst;
    errno_t               memResult;

    (VOS_VOID)memset_s(&eOPlmnSetPara, sizeof(eOPlmnSetPara), 0x00, sizeof(TAF_MMA_SetEoplmnList));

    /* 参数个数和合法性检查,不合法直接返回失败 */
    rst = AT_SetEOPlmnParaCheck();
    if (rst != AT_SUCCESS) {
        return rst;
    }

    /* 将设置的AT参数封装成TAF_MMA_SetEoplmnList的形式 */
    memResult = memcpy_s(eOPlmnSetPara.version, sizeof(eOPlmnSetPara.version), g_atParaList[0].para,
                         TAF_MAX_USER_CFG_OPLMN_VERSION_LEN);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(eOPlmnSetPara.version), TAF_MAX_USER_CFG_OPLMN_VERSION_LEN);

    if (g_atParaList[AT_EOPLMN_PDU].paraLen > TAF_MAX_GROUP_CFG_OPLMN_DATA_LEN) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[AT_EOPLMN_PDU].paraLen > 0) {
        memResult = memcpy_s(eOPlmnSetPara.oPlmnWithRat, sizeof(eOPlmnSetPara.oPlmnWithRat),
                             g_atParaList[AT_EOPLMN_PDU].para, g_atParaList[AT_EOPLMN_PDU].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(eOPlmnSetPara.oPlmnWithRat), g_atParaList[AT_EOPLMN_PDU].paraLen);
    }

    eOPlmnSetPara.indexNum   = (VOS_UINT8)g_atParaList[1].paraValue;
    eOPlmnSetPara.oPlmnCount = (VOS_UINT8)(g_atParaList[AT_EOPLMN_PDULEN].paraValue / TAF_AT_PLMN_WITH_RAT_LEN);

    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    rst = TAF_MMA_SetEOPlmnReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &eOPlmnSetPara);
    if (rst == VOS_TRUE) {
        /* 指示当前用户的命令操作类型为设置命令 */
        g_parseContext[indexNum].clientStatus = AT_FW_CLIENT_STATUS_PEND;
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_EOPLMN_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetEcidPara(VOS_UINT8 indexNum)
{
    VOS_UINT32        result;
    AT_MTA_EcidSetReq ecidSetReq;

    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&ecidSetReq, sizeof(ecidSetReq), 0x00, sizeof(ecidSetReq));

    ecidSetReq.version = g_atParaList[0].paraValue;

    /* 发送跨核消息到C核, 设置GPS参考时钟状态是否主动上报 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_ECID_SET_REQ, (VOS_UINT8 *)&ecidSetReq, sizeof(ecidSetReq),
                                    I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetEcidPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECID_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_AT_HSUART == FEATURE_ON)

VOS_VOID AT_UpdateUartCfgNV(VOS_VOID)
{
    AT_UartCtx    *uartCtx = VOS_NULL_PTR;
    TAF_NV_UartCfg uartNvCfg;

    /* 初始化 */
    (VOS_VOID)memset_s(&uartNvCfg, sizeof(uartNvCfg), 0x00, sizeof(TAF_NV_UartCfg));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_UART_CFG, &uartNvCfg, sizeof(TAF_NV_UartCfg)) != NV_OK) {
        AT_ERR_LOG("AT_UpdateUartCfgNV: Read NV fail!");
        return;
    }

    /* 获取UART参数 */
    uartCtx                = AT_GetUartCtxAddr();
    uartNvCfg.baudRate     = uartCtx->phyConfig.baudRate;
    uartNvCfg.frame.format = uartCtx->phyConfig.frame.format;
    uartNvCfg.frame.parity = uartCtx->phyConfig.frame.parity;

    /* 更新UART参数NV */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_UART_CFG, (VOS_UINT8 *)&uartNvCfg, sizeof(TAF_NV_UartCfg)) != NV_OK) {
        AT_ERR_LOG("AT_UpdateUartCfgNV: Write NV fail!");
    }

    return;
}


VOS_UINT32 AT_SetIprPara(VOS_UINT8 indexNum)
{
    AT_UartPhyCfg        *phyCfg = VOS_NULL_PTR;
    AT_UartBaudrateUint32 baudRate;

    phyCfg = AT_GetUartPhyCfgInfo();

    /* 只支持UART端口下发 */
    if ((AT_CheckHsUartUser(indexNum) != VOS_TRUE) &&
        (AT_CheckUartUser(indexNum) != VOS_TRUE)) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空, 使用等效值115200 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        baudRate = AT_UART_DEFAULT_BAUDRATE;
    } else {
        if (g_atParaList[0].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        baudRate = g_atParaList[0].paraValue;
    }

    /* 波特率有效性检查 */
    if (AT_CheckHsUartUser(indexNum) == VOS_TRUE) {
        if (AT_HSUART_IsBaudRateValid(baudRate) != VOS_TRUE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    } else {
        if (AT_UART_IsBaudRateValid(baudRate) != VOS_TRUE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 更新波特率参数 */
    phyCfg->baudRate = baudRate;

    /* 刷新UART配置NV */
    AT_UpdateUartCfgNV();

    /* 先上报OK */
    At_FormatResultData(indexNum, AT_OK);

#if (FEATURE_UART_BAUDRATE_AUTO_ADAPTION == FEATURE_ON)
    if (AT_UART_BAUDRATE_0 == baudRate) {
        return AT_SUCCESS;
    }
#endif
    /* 配置波特率参数 */
    AT_HSUART_ConfigBaudRate(indexNum, baudRate);

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetIcfPara(VOS_UINT8 indexNum)
{
    AT_UartPhyCfg     *phyCfg = VOS_NULL_PTR;
    AT_UartFormatUint8 format;
    AT_UartParityUint8 parity;

    phyCfg = AT_GetUartPhyCfgInfo();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(indexNum) != VOS_TRUE) {
        return AT_OK;
    }

    /* 参数检查 */
    if (g_atParaIndex > AT_ICF_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数有效性检查 */
    /* 参数为空，使用等效值(3,3),即:8个数据位1个停止位无校验位 */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        format = AT_UART_DEFAULT_FORMAT;
        parity = AT_UART_DEFAULT_PARITY;
    } else {
        /* AT_CMD_OPT_SET_PARA_CMD */
        /* AT+ICF= */
        if (g_atParaIndex == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* AT+ICF=, */
        if (g_atParaList[AT_ICF_FORMAT].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        format = (VOS_UINT8)g_atParaList[AT_ICF_FORMAT].paraValue;

        if (g_atParaIndex > AT_ICF_PARITY) {
            if (g_atParaList[AT_ICF_PARITY].paraLen != 0) {
                /* AT+ICF=<format>,<parity> */
                parity = (VOS_UINT8)g_atParaList[AT_ICF_PARITY].paraValue;
            } else {
                /* AT+ICF=<format>, */
                return AT_CME_INCORRECT_PARAMETERS;
            }
        } else {
            /* AT+ICF=<format> */
            parity = AT_UART_DEFAULT_PARITY;
        }
    }

    /* 检查帧格式参数有效性 */
    if (AT_HSUART_ValidateCharFrameParam(format, parity) == VOS_FALSE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新帧格式参数 */
    phyCfg->frame.format = format;
    phyCfg->frame.parity = parity;

    /* 刷新UART配置NV */
    AT_UpdateUartCfgNV();

    /* 先上报OK */
    At_FormatResultData(indexNum, AT_OK);

    /* 配置帧格式参数 */
    AT_HSUART_ConfigCharFrame(indexNum, format, parity);

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetIfcPara(VOS_UINT8 indexNum)
{
    AT_UartFlowCtrl       *uartFlowCtrl = VOS_NULL_PTR;
    AT_UartFcDceByDteUint8 fcDceByDte;
    AT_UartFcDteByDceUint8 fcDteByDce;
    VOS_UINT32             rtsFlag;
    VOS_UINT32             ctsFlag;

    uartFlowCtrl = AT_GetUartFlowCtrlInfo();

    /* 只支持UART端口下发 */
    if (AT_CheckHsUartUser(indexNum) != VOS_TRUE) {
        return AT_OK;
    }

    /* 命令参数个数检查 */
    if (g_atParaIndex > AT_IFC_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /*
     * AT+IFC等效于AT+IFC=0,0
     * 注: 该处理为产品线要求, IUT-T-V.250中规定AT+IFC等效于AT+IFC=2,2
     */
    if (g_atParseCmd.cmdOptType == AT_CMD_OPT_SET_CMD_NO_PARA) {
        fcDceByDte = AT_UART_DEFAULT_FC_DCE_BY_DTE;
        fcDteByDce = AT_UART_DEFAULT_FC_DTE_BY_DCE;
    } else {
        /* AT+IFC= */
        if (g_atParaIndex == 0) {
            /* AT+IFC= */
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* AT+IFC=, */
        if (g_atParaList[AT_IFC_DCE_BY_DTE].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        if (g_atParaIndex > AT_IFC_DTE_BY_DCE) {
            if (g_atParaList[AT_IFC_DTE_BY_DCE].paraLen != 0) {
                /* AT+IFC=<DCE_by_DTE>,<DTE_by_DCE> */
                fcDteByDce = (VOS_UINT8)g_atParaList[AT_IFC_DTE_BY_DCE].paraValue;
            } else {
                /* AT+IFC=<DCE_by_DTE>, */
                return AT_CME_INCORRECT_PARAMETERS;
            }
        } else {
            /* AT+IFC=<DCE_by_DTE> */
            fcDteByDce = AT_UART_DEFAULT_FC_DTE_BY_DCE;
        }

        fcDceByDte = (VOS_UINT8)g_atParaList[AT_IFC_DCE_BY_DTE].paraValue;
    }

    /* 检查流控参数有效性 */
    if (AT_HSUART_ValidateFlowCtrlParam(fcDceByDte, fcDteByDce) == VOS_FALSE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 更新流控参数 */
    uartFlowCtrl->dceByDte = fcDceByDte;
    uartFlowCtrl->dteByDce = fcDteByDce;

    /* 转换硬件流控参数 */
    rtsFlag = (fcDceByDte == AT_UART_FC_DCE_BY_DTE_RTS) ? VOS_TRUE : VOS_FALSE;

    ctsFlag = (fcDteByDce == AT_UART_FC_DTE_BY_DCE_CTS) ? VOS_TRUE : VOS_FALSE;

    /* 配置硬件流控参数 */
    AT_HSUART_ConfigFlowCtrl(indexNum, rtsFlag, ctsFlag);

    return AT_OK;
}


VOS_UINT32 AT_SetOPara(VOS_UINT8 indexNum)
{
    DMS_PortIdUint16            portId;
    DMS_PortModeUint8           mode;

    portId   = g_atClientTab[indexNum].portNo;
    mode     = DMS_PORT_GetMode(portId);

    /* 如果当前通道模式为ONLINE-COMMAND模式, 直接恢复当前数据模式 */
    if (mode == DMS_PORT_MODE_ONLINE_CMD) {
        /* 将通道模式设置为DATA模式，其中data的子模式不做修改，直接继承 */
        DMS_PORT_SetMode(portId, DMS_PORT_MODE_ONLINE_DATA);

        /* 此处dataState先置为STOP，
         * 待connect上报后，数据状态才切换为start;
         * 切换为start的函数参见AT_DisplayResultData
         */
        DMS_PORT_SetDataState(portId, DMS_PORT_DATA_STATE_STOP);

        return AT_CONNECT;
    } else {
        return AT_NO_CARRIER;
    }
}


VOS_UINT32 AT_SetSwitchUart(VOS_UINT8 indexNum)
{
    VOS_UINT32 ulmode;

    if (indexNum != AT_CLIENT_ID_HSUART) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 1\n");
        return AT_ERROR;
    }

    /* 判断CK是否校验通过 */
    if (g_spWordCtx.shellPwdCheckFlag != VOS_TRUE) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 2\n");
        AT_WARN_LOG("AT_SetSwitchUart:WARNING: datalock check faild!");
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParaList[0].paraLen == 0) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 3\n");
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 4\n");
        return AT_ERROR;
    }

    /* 切换到 A shell */
    if (g_atParaList[0].paraValue == AT_UART_MODE_ASHELL) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 5\n");
        ulmode = DMS_UART_A_SHELL;
    } else if (g_atParaList[0].paraValue == AT_UART_MODE_CSHELL) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 6\n");
        ulmode = DMS_UART_C_SHELL;
    } else {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 7\n");
        AT_WARN_LOG("AT_SetSwitchUart: unknown value!");
        return AT_ERROR;
    }

    if (DMS_PORT_SetACShell(DMS_PORT_HSUART, ulmode) != VOS_OK) {
        PS_PRINTF_WARNING("<AT_SetSwitchUart> 8\n");
        AT_WARN_LOG("AT_SetSwitchUart:DRV_UDI_IOCTL faild!");
        return AT_ERROR;
    }

    AT_INFO_LOG("AT_SetSwitchUart: success and leave!!");
    PS_PRINTF_INFO("<AT_SetSwitchUart> success and leave!!\n");

    return AT_OK;
}
#endif



VOS_UINT32 AT_SetRATCombinePara(VOS_UINT8 indexNum)
{
    return AT_CME_OPERATION_NOT_ALLOWED;
}

#if (FEATURE_IMS == FEATURE_ON)

VOS_UINT32 AT_SetCallModifyInitPara(VOS_UINT8 indexNum)
{
    TAF_Ctrl               ctrl;
    TAF_CCM_CallModifyPara callMdfPara;
    VOS_UINT32             result;
    ModemIdUint16          modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_Ctrl));
    (VOS_VOID)memset_s(&callMdfPara, sizeof(callMdfPara), 0x00, sizeof(callMdfPara));

    /* 参数检查 */
    if (g_atParaIndex != AT_CALLMODIFYINIT_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CALLMODIFYINIT_IDX].paraLen == 0) ||
        (g_atParaList[AT_CALLMODIFYINIT_CURR_CALL_TYPE].paraLen == 0) ||
        (g_atParaList[AT_CALLMODIFYINIT_DEST_CALL_TYPE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    callMdfPara.callId         = (MN_CALL_ID_T)g_atParaList[AT_CALLMODIFYINIT_IDX].paraValue;
    callMdfPara.currCallType   = (MN_CALL_TypeUint8 )g_atParaList[AT_CALLMODIFYINIT_CURR_CALL_TYPE].paraValue;
    callMdfPara.expectCallType = (MN_CALL_TypeUint8 )g_atParaList[AT_CALLMODIFYINIT_DEST_CALL_TYPE].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    result = TAF_CCM_CallCommonReq(&ctrl, &callMdfPara, ID_TAF_CCM_CALL_MODIFY_REQ, sizeof(callMdfPara), modemId);

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CALL_MODIFY_INIT_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCallModifyAnsPara(VOS_UINT8 indexNum)
{
    TAF_Ctrl                           ctrl;
    TAF_CCM_CallAnswerRemoteModifyPara ansRemoteMdfPara;
    VOS_UINT32                         result;
    ModemIdUint16                      modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&ansRemoteMdfPara, sizeof(ansRemoteMdfPara), 0x00, sizeof(ansRemoteMdfPara));

    /* 参数检查 */
    if (g_atParaIndex != AT_CALLMODIFYANS_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_CALLMODIFYANS_IDX].paraLen == 0) ||
        (g_atParaList[AT_CALLMODIFYANS_CURR_CALL_TYPE].paraLen == 0) ||
        (g_atParaList[AT_CALLMODIFYANS_DEST_CALL_TYPE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    ansRemoteMdfPara.callId         = (MN_CALL_ID_T)g_atParaList[AT_CALLMODIFYANS_IDX].paraValue;
    ansRemoteMdfPara.currCallType   = (MN_CALL_TypeUint8 )g_atParaList[AT_CALLMODIFYANS_CURR_CALL_TYPE].paraValue;
    ansRemoteMdfPara.expectCallType = (MN_CALL_TypeUint8 )g_atParaList[AT_CALLMODIFYANS_DEST_CALL_TYPE].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送呼叫消息 */
    result = TAF_CCM_CallCommonReq(&ctrl, &ansRemoteMdfPara, ID_TAF_CCM_CALL_ANSWER_REMOTE_MODIFY_REQ,
                                   sizeof(ansRemoteMdfPara), modemId);

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CALL_MODIFY_ANS_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_FillEconfDialPara(VOS_UINT8 indexNum, TAF_CALL_EconfDialInfo *dialParam)
{
    AT_ModemSsCtx *ssCtx = VOS_NULL_PTR;
    VOS_UINT32     callNum;
    VOS_UINT32     i;
    VOS_UINT32     indexValue;

    ssCtx = AT_GetModemSsCtxAddrFromClientId(indexNum);

    /* 默认情况是使用CCA设置的默认值 */
    dialParam->callMode = ssCtx->cModType;
    dialParam->dataCfg  = ssCtx->cbstDataCfg;
    dialParam->clirCfg  = ssCtx->clirType;
    dialParam->cugCfg   = ssCtx->ccugCfg;

    /* 第二个参数为会议中心号码，目前不关注 */
    if ((g_atParaList[AT_ECONFDIAL_DIAL_COUNT].paraLen == 0) || (g_atParaList[AT_ECONFDIAL_DIAL_I].paraLen == 0) ||
        (g_atParaList[AT_ECONFDIAL_CALL_TYPE].paraLen == 0) || (g_atParaList[AT_ECONFDIAL_CALLDOMAIN].paraLen == 0) ||
        (g_atParaList[AT_ECONFDIAL_ISECONF].paraLen   == 0)) {
        return VOS_ERR;
    } else {
        /* 从第7个参数开始为与会者号码，第一个参数指明与会者人数 */
        callNum = g_atParaList[AT_ECONFDIAL_DIAL_COUNT].paraValue;

        for (i = 0; i < callNum; i++) {
            indexValue = AT_ECONFDIAL_FIRST_SIX_PARA_NUM + i;

            if (g_atParaList[indexValue].paraLen == 0) {
                return VOS_ERR;
            }

            if (AT_FillCalledNumPara(g_atParaList[indexValue].para, g_atParaList[indexValue].paraLen,
                                     &dialParam->econfCalllist.dialNumber[i]) != VOS_OK) {
                return VOS_ERR;
            }
        }

        dialParam->econfCalllist.callNum = callNum;
    }

    /* 设置<I>参数 */
    if (g_atParaList[AT_ECONFDIAL_DIAL_I].paraValue == 0) {
        dialParam->clirCfg = AT_CLIR_INVOKE;
    } else if (g_atParaList[AT_ECONFDIAL_DIAL_I].paraValue == 1) {
        dialParam->clirCfg = AT_CLIR_SUPPRESS;
    } else {
        return VOS_ERR;
    }

    dialParam->callType          = (MN_CALL_TypeUint8 )g_atParaList[AT_ECONFDIAL_CALL_TYPE].paraValue;
    dialParam->voiceDomain       = (TAF_CALL_VoiceDomainUint8 )g_atParaList[AT_ECONFDIAL_CALLDOMAIN].paraValue;
    dialParam->imsInvitePtptFlag = VOS_FALSE;

    return VOS_OK;
}


VOS_UINT32 AT_SetEconfDialPara(VOS_UINT8 indexNum)
{
    TAF_CALL_EconfDialInfo econfDialInfo;
    TAF_Ctrl               ctrl;
    VOS_UINT32             result;
    ModemIdUint16          modemId;

    (VOS_VOID)memset_s(&econfDialInfo, sizeof(econfDialInfo), 0x00, sizeof(econfDialInfo));

    /* 参数检查 */
    if ((g_atParaIndex < AT_CMD_ECONF_DIAL_MIN_PARA_NUM) || (g_atParaIndex > AT_CMD_ECONF_DIAL_MAX_PARA_NUM)) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不对 */
    /* 参数的个数应该是total_callnum+6 */
    if ((g_atParaList[AT_ECONFDIAL_DIAL_COUNT].paraValue + 6) != g_atParaIndex) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查并填写输入的参数 */
    result = AT_FillEconfDialPara(indexNum, &econfDialInfo);
    if (result != VOS_OK) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* AT向CCM发送增强多方通话消息 */
    result = TAF_CCM_CallCommonReq(&ctrl, &(econfDialInfo), ID_TAF_CCM_ECONF_DIAL_REQ, sizeof(econfDialInfo), modemId);

    if (result == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECONF_DIAL_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetImsSwitchPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                     rst;
    TAF_MMA_ImsSwitchInfo          imsSwitchInfo;
    TAF_NV_ImsSwitchRatRelationCfg imsSwitchRatRelationCfg;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex > AT_IMSSWITCH_PARA_MAX_NUM) {
        return AT_TOO_MANY_PARA;
    }

    /* 参数为空 */
    if (g_atParaList[AT_IMSSWITCH_LTE_ENABLE].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&imsSwitchInfo, sizeof(imsSwitchInfo), 0, sizeof(TAF_MMA_ImsSwitchInfo));
    (VOS_VOID)memset_s(&imsSwitchRatRelationCfg, sizeof(imsSwitchRatRelationCfg), 0, sizeof(TAF_NV_ImsSwitchRatRelationCfg));

    imsSwitchInfo.bitOpImsSwitch = VOS_TRUE;

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_IMS_SWITCH_RAT_RELATION_CFG, &imsSwitchRatRelationCfg,
                          sizeof(imsSwitchRatRelationCfg)) != NV_OK) {
        AT_WARN_LOG("AT_SetImsSwitchPara: Read NV fail!");
        (VOS_VOID)memset_s(&imsSwitchRatRelationCfg, sizeof(imsSwitchRatRelationCfg), 0, sizeof(imsSwitchRatRelationCfg));
    }

    imsSwitchInfo.imsSwitchRat.lteEnable = (g_atParaList[AT_IMSSWITCH_LTE_ENABLE].paraValue ==
                                            TAF_MMA_IMS_SWITCH_SET_ON) ?
                                            TAF_MMA_IMS_SWITCH_SET_ON :
                                            TAF_MMA_IMS_SWITCH_SET_OFF;

    if (g_atParaIndex > AT_IMSSWITCH_UTRAN_ENABLE) {
        imsSwitchInfo.imsSwitchRat.utranEnable = ((g_atParaList[AT_IMSSWITCH_UTRAN_ENABLE].paraLen > 0) &&
                                                  (g_atParaList[AT_IMSSWITCH_UTRAN_ENABLE].paraValue) ==
                                                  TAF_MMA_IMS_SWITCH_SET_ON) ?
                                                  TAF_MMA_IMS_SWITCH_SET_ON :
                                                  TAF_MMA_IMS_SWITCH_SET_OFF;
    } else {
        if (imsSwitchRatRelationCfg.utranRelationLteFlg == VOS_TRUE) {
            imsSwitchInfo.imsSwitchRat.utranEnable = imsSwitchInfo.imsSwitchRat.lteEnable;
        }
    }

    if (g_atParaIndex > AT_IMSSWITCH_GSM_ENABLE) {
        imsSwitchInfo.imsSwitchRat.gsmEnable = ((g_atParaList[AT_IMSSWITCH_GSM_ENABLE].paraLen > 0) &&
                                                (g_atParaList[AT_IMSSWITCH_GSM_ENABLE].paraValue) ==
                                                TAF_MMA_IMS_SWITCH_SET_ON) ? TAF_MMA_IMS_SWITCH_SET_ON :
                                                TAF_MMA_IMS_SWITCH_SET_OFF;
    } else {
        if (imsSwitchRatRelationCfg.gsmRelationLteFlg == VOS_TRUE) {
            imsSwitchInfo.imsSwitchRat.gsmEnable = imsSwitchInfo.imsSwitchRat.lteEnable;
        }
    }

    rst = TAF_MMA_SetImsSwitchReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  &imsSwitchInfo);
    if (rst != VOS_TRUE) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IMS_SWITCH_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_InputValueTransToVoiceDomain(VOS_UINT32 value, TAF_MMA_VoiceDomainUint32 *voiceDomain)
{
    VOS_UINT32 rst;

    rst = VOS_TRUE;

    switch (value) {
        case AT_VOICE_DOMAIN_TYPE_CS_ONLY:
            *voiceDomain = TAF_MMA_VOICE_DOMAIN_CS_ONLY;
            break;

        case AT_VOICE_DOMAIN_TYPE_CS_PREFERRED:
            *voiceDomain = TAF_MMA_VOICE_DOMAIN_CS_PREFERRED;
            break;

        case AT_VOICE_DOMAIN_TYPE_IMS_PS_PREFERRED:
            *voiceDomain = TAF_MMA_VOICE_DOMAIN_IMS_PS_PREFERRED;
            break;

        case AT_VOICE_DOMAIN_TYPE_IMS_PS_ONLY:
            *voiceDomain = TAF_MMA_VOICE_DOMAIN_IMS_PS_ONLY;
            break;

        default:
            *voiceDomain = TAF_MMA_VOICE_DOMAIN_BUTT;
            rst          = VOS_FALSE;
            break;
    }

    return rst;
}


VOS_UINT32 AT_SetCevdpPara(VOS_UINT8 indexNum)
{
    TAF_MMA_VoiceDomainUint32 voiceDomain;
    VOS_UINT32                rst;

    rst         = VOS_FALSE;
    voiceDomain = TAF_MMA_VOICE_DOMAIN_BUTT;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空，协议没有明确规定默认值，此处默认设置为CS ONLY */
    if (g_atParaList[0].paraLen == 0) {
        voiceDomain = TAF_MMA_VOICE_DOMAIN_CS_ONLY;
    } else {
        if (AT_InputValueTransToVoiceDomain(g_atParaList[0].paraValue, &voiceDomain) != VOS_TRUE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    rst = TAF_MMA_SetVoiceDomainReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, voiceDomain);
    if (rst != VOS_TRUE) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VOICE_DOMAIN_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetImsctrlmsgPara(VOS_UINT8 indexNum)
{
    AT_IMS_CtrlMsg *atImsaMsgPara = VOS_NULL_PTR;
    VOS_UINT8      *msg           = VOS_NULL_PTR;
    VOS_UINT32      atImsaMsgParaLen;
    VOS_UINT32      msgSubStrCount;
    VOS_UINT32      i;
    VOS_UINT32      indexValue;
    errno_t         memResult;
    VOS_UINT16      msgStrLen;
    VOS_UINT16      length;
    VOS_UINT32      result;

    /* 参数检查 */
    if (g_atParaIndex < AT_IMSCTRLMSG_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_IMSCTRLMSG_MSG_ID].paraLen == 0) || (g_atParaList[AT_IMSCTRLMSG_MSG_LEN].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    msgSubStrCount = (VOS_UINT32)g_atParaIndex - AT_DOUBLE_QUO_MARKS_LENGTH;
    msgStrLen      = 0;

    for (i = 0; i < msgSubStrCount; i++) {
        indexValue = i + AT_IMSCTRLMSG_MSG_LEN_INDEX;

        if (g_atParaList[indexValue].paraLen == 0) {
            return AT_CME_INCORRECT_PARAMETERS;
        }

        msgStrLen += g_atParaList[indexValue].paraLen;
    }
    /*lint -save -e516 */
    msg = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, msgStrLen + 1);
    /*lint -restore */
    if (msg == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetImsctrlmsgPara: Memory malloc failed!");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(msg, msgStrLen + 1, 0x00, msgStrLen + 1);

    length = 0;
    for (i = 0; i < msgSubStrCount; i++) {
        indexValue = i + AT_IMSCTRLMSG_MSG_LEN_INDEX;

        length += (VOS_UINT16)AT_FormatReportString(msgStrLen + 1, (VOS_CHAR *)msg, (VOS_CHAR *)msg + length, "%s",
            g_atParaList[indexValue].para);
    }

    /* 将字符串参数转换为码流 */
    result = At_AsciiNum2HexString(msg, &length);

    if ((result != AT_SUCCESS) || (g_atParaList[AT_IMSCTRLMSG_MSG_LEN].paraValue != length)) {
        PS_MEM_FREE(WUEPS_PID_AT, msg);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 申请内存空间，大小为Mapcon给IMSA发送的消息的长度 */
    atImsaMsgParaLen = sizeof(VOS_UINT32) + g_atParaList[AT_IMSCTRLMSG_MSG_LEN].paraValue;
    atImsaMsgPara    = (AT_IMS_CtrlMsg *)PS_MEM_ALLOC(WUEPS_PID_AT, atImsaMsgParaLen);

    if (atImsaMsgPara == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetImsctrlmsgPara: Memory malloc failed!");
        PS_MEM_FREE(WUEPS_PID_AT, msg);

        return AT_ERROR;
    }

    (VOS_VOID)memset_s(atImsaMsgPara, atImsaMsgParaLen, 0x00, atImsaMsgParaLen);

    /* 填充AT_IMSA_ImsCtrlMsg */
    atImsaMsgPara->msgLen = g_atParaList[AT_IMSCTRLMSG_MSG_LEN].paraValue;
    if (atImsaMsgPara->msgLen > 0) {
        memResult = memcpy_s(atImsaMsgPara->msgContext, atImsaMsgPara->msgLen, msg, atImsaMsgPara->msgLen);
        TAF_MEM_CHK_RTN_VAL(memResult, atImsaMsgPara->msgLen, atImsaMsgPara->msgLen);
    }

    /* 转发MAPCON给IMSA的消息 */
    if (g_atParaList[AT_IMSCTRLMSG_MSG_ID].paraValue == 0) {
        result = AT_SndImsaImsCtrlMsg(g_atClientTab[indexNum].clientId, 0, atImsaMsgPara);
    } else {
        result = AT_PS_ProcMapconMsg(g_atClientTab[indexNum].clientId, (AT_MAPCON_CTRL_MSG_STRU *)atImsaMsgPara);
    }

    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, msg);
    PS_MEM_FREE(WUEPS_PID_AT, atImsaMsgPara);
    /*lint -restore */
    if (result != VOS_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}


LOCAL VOS_UINT32 AT_CheckFusionCallRawPara(VOS_VOID)
{
    /* 参数检查 */
    if (g_atParaIndex < AT_FUSIONCALL_RAW_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_FUSIONCALL_RAW_MSG_ID_INDEX].paraLen == 0) ||
        (g_atParaList[AT_FUSIONCALL_RAW_MSG_LEN_INDEX].paraLen == 0) ||
        (g_atParaList[AT_FUSIONCALL_RAW_MSG_DATA_INDEX].paraLen == 0)){
        return AT_CME_INCORRECT_PARAMETERS;
    }
    return AT_SUCCESS;
}


VOS_UINT32 AT_SetFusionCallRawPara(VOS_UINT8 indexNum)
{
    VOS_UINT8                *tmpData = VOS_NULL_PTR;
    VOS_UINT32                result;
    VOS_UINT16                msgStrLen = 0;
    VOS_UINT16                length = 0;

    /* 参数检查 */
    result = AT_CheckFusionCallRawPara();
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetFusionCallRawPara:check para error.");

        return result;
    }

    msgStrLen = g_atParaList[AT_FUSIONCALL_RAW_MSG_DATA_INDEX].paraLen;

    tmpData = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, msgStrLen + 1);

    if (tmpData == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetFusionCallRawPara: Memory malloc failed!");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(tmpData, msgStrLen + 1, 0x00, msgStrLen + 1);
    length += (VOS_UINT16)AT_FormatReportString(msgStrLen + 1, (VOS_CHAR *)tmpData, (VOS_CHAR *)tmpData, "%s",
                                                g_atParaList[AT_FUSIONCALL_RAW_MSG_DATA_INDEX].para);

    /* 将字符串参数转换为码流 */
    result = At_AsciiNum2HexString(tmpData, &length);

    if ((result != AT_SUCCESS) || (g_atParaList[AT_FUSIONCALL_RAW_MSG_LEN_INDEX].paraValue != length)) {
        PS_MEM_FREE(WUEPS_PID_AT, tmpData);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 转发FUSIONCALL给IMSA的消息 */
    result = AT_SndImsaCallRawDataMsg(g_atClientTab[indexNum].clientId, 0,
                                      (VOS_UINT8)g_atParaList[AT_FUSIONCALL_RAW_MSG_ID_INDEX].paraValue,
                                      g_atParaList[AT_FUSIONCALL_RAW_MSG_LEN_INDEX].paraValue,
                                      tmpData);

    PS_MEM_FREE(WUEPS_PID_AT, tmpData);
    if (result != VOS_OK) {
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetImsDomainCfgPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                     rst;
    TAF_MMA_ImsDomainCfgTypeUint32 imsDomainCfg;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    imsDomainCfg = (TAF_MMA_ImsDomainCfgTypeUint32)g_atParaList[0].paraValue;

    /* 执行命令操作 */
    rst = TAF_MMA_SetImsDomainCfgReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, imsDomainCfg);

    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_IMSDOMAINCFG_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCallEncryptPara(VOS_UINT8 indexNum)
{
    VOS_UINT32                result;
    AT_IMSA_CallEncryptSetReq callEncrypt;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    callEncrypt.encrypt = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给IMSA发送^CALLENCRYPT设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_IMSA_CALL_ENCRYPT_SET_REQ,
                                    &callEncrypt.encrypt, sizeof(VOS_UINT8), PS_PID_IMSA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CALLENCRYPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#endif

#if (FEATURE_HUAWEI_VP == FEATURE_ON)

VOS_UINT32 AT_SetVoicePreferPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 voicePreferAct;
    VOS_UINT32 rslt;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 第一个参数为空 */
    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    voicePreferAct = g_atParaList[0].paraValue;

    rslt = AT_SndSetVoicePrefer(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId, voicePreferAct);
    if (rslt == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_VOICEPREFER_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCrmPara(VOS_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
#if (FEATURE_PPP == FEATURE_ON)

    if (g_atParaList[0].paraValue == TAF_PS_CDATA_DIAL_MODE_RELAY) {
        PPP_SetRawDataByPassMode(VOS_TRUE);
    } else {
        PPP_SetRawDataByPassMode(VOS_FALSE);
    }
#endif

    if (TAF_PS_SetCdataDialModeInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId),
                                    g_atParaList[0].paraValue) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CRM_SET;
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCcmgsPara(VOS_UINT8 indexNum, VOS_UINT32 lengthValue, VOS_UINT8 *command, VOS_UINT16 commandLength)
{
    TAF_XSMS_Message smsPdu;
    errno_t          memResult;
    VOS_UINT16       commandHexLen;
    TAF_UINT8        smSFormat;

    smSFormat = AT_GetModemSmsCtxAddrFromClientId(indexNum)->cmgfMsgFormat;

    if (smSFormat != AT_CMGF_MSG_FORMAT_PDU) {
        AT_WARN_LOG("AT_SetCcmgsPara: current format is not PDU!");
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&smsPdu, sizeof(smsPdu), 0x00, sizeof(smsPdu));

    /* 参数检查 */
    if ((lengthValue > (AT_DOUBLE_LENGTH * sizeof(TAF_XSMS_Message))) || (lengthValue != commandLength) ||
        ((lengthValue % AT_DOUBLE_LENGTH) != VOS_NULL)) {
        AT_WARN_LOG("AT_SetCcmgsPara: incorrect parameters!");
        AT_WARN_LOG1("AT_SetCcmgsPara: ulLengthValue:", lengthValue);
        AT_WARN_LOG1("AT_SetCcmgsPara: usCommandLength:", commandLength);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PDU>是ASCII码，做输入参数到HEX的转换 */
    commandHexLen = commandLength;
    if (At_AsciiNum2HexString(command, &commandHexLen) == AT_FAILURE) {
        AT_WARN_LOG("AT_SetCcmgsPara: ascii2hex fail!");
        AT_WARN_LOG1("AT_SetCcmgsPara: usCommandLength:", commandLength);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将PDU的码流拷贝到数据结构 */
    if (commandHexLen > 0) {
        memResult = memcpy_s(&smsPdu, sizeof(smsPdu), command, commandHexLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(smsPdu), commandHexLen);
    }

    /* 执行命令操作 */
    if (TAF_XSMS_SendSmsReq(g_atClientTab[indexNum].clientId, 0, TAF_XSMS_SEND_OPTION_SINGLE, (VOS_UINT8 *)&smsPdu) ==
        AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCMGS_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCcmgsPara: CNAS_XSMS_SendSmsReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCcmgwPara(VOS_UINT8 indexNum, VOS_UINT32 lengthValue, VOS_UINT32 statValue, VOS_UINT8 *command,
                           VOS_UINT16 commandLength)
{
    TAF_XSMS_Message smsPdu;
    errno_t          memResult;
    VOS_UINT16       commandHexLen;
    TAF_UINT8        smSFormat;

    smSFormat = AT_GetModemSmsCtxAddrFromClientId(indexNum)->cmgfMsgFormat;

    if (smSFormat != AT_CMGF_MSG_FORMAT_PDU) {
        return AT_CMS_OPERATION_NOT_ALLOWED;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&smsPdu, sizeof(smsPdu), 0x00, sizeof(smsPdu));

    /* 参数检查 */
    if ((lengthValue > (AT_DOUBLE_LENGTH * sizeof(TAF_XSMS_Message))) || (lengthValue != commandLength) ||
        ((lengthValue % AT_DOUBLE_LENGTH) != VOS_NULL)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数2合法性检查 */
    if (statValue > TAF_XSMS_STATUS_STO_SEND) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <PDU>是ASCII码，做输入参数到HEX的转换 */
    commandHexLen = commandLength;
    if (At_AsciiNum2HexString(command, &commandHexLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将PDU的码流拷贝到数据结构 */
    if (commandHexLen > 0) {
        memResult = memcpy_s(&smsPdu, sizeof(smsPdu), command, commandHexLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(smsPdu), commandHexLen);
    }

    /* 执行命令操作 */
    if (TAF_XSMS_WriteSmsReq(g_atClientTab[indexNum].clientId, 0, (VOS_UINT8)statValue, (VOS_UINT8 *)&smsPdu) ==
        AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCMGW_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCcmgwPara: CNAS_XSMS_WriteSmsReq fail.");

        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCcmgdPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 smsIndex;

    /* 参数不合法，返回错误 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    smsIndex = (VOS_UINT8)g_atParaList[0].paraValue;


    /* 执行命令操作 */
    if (TAF_XSMS_DeleteSmsReq(g_atClientTab[indexNum].clientId, 0, smsIndex) == AT_SUCCESS) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CCMGD_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_CheckCFreqLockEnablePara(VOS_VOID)
{
    VOS_UINT8 loop;

    for (loop = 1; loop < AT_CFREQLOCK_PARA_NUM_MAX; loop++) {
        if (g_atParaList[loop].paraLen == 0) {
            return VOS_FALSE;
        }
    }

    return VOS_TRUE;
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetCFreqLockPara(VOS_UINT8 indexNum)
{
    TAF_MMA_CfreqLockSetPara cFreqLockPara;
    VOS_UINT32               rst;

    /* 参数有效性检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果第一个参数是开启锁频,但参数个数不为9，或第一个参数是解除锁频，但参数个数不为1，都不合法 */
    if (((g_atParaList[0].paraValue == 1) && (g_atParaIndex != AT_CFREQLOCK_PARA_NUM_MAX)) ||
        ((g_atParaList[0].paraValue == 0) && (g_atParaIndex != AT_CFREQLOCK_PARA_NUM_MIN))) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果第一个参数是锁频，则1X/EVDO的锁频参数需同时设置，并需判断<cdma_pn>和<evdo_pn>的有效范围 */
    if (g_atParaList[0].paraValue == 1) {
        if (AT_CheckCFreqLockEnablePara() == VOS_FALSE) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 发送消息赋值 */
    (VOS_VOID)memset_s(&cFreqLockPara, sizeof(cFreqLockPara), 0x00, sizeof(TAF_MMA_CfreqLockSetPara));

    if ((VOS_UINT8)g_atParaList[0].paraValue == 1) {
        cFreqLockPara.freqLockMode  = TAF_MMA_CFREQ_LOCK_MODE_ON;
        cFreqLockPara.sid           = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_SID].paraValue;
        cFreqLockPara.nid           = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_NID].paraValue;
        cFreqLockPara.cdmaBandClass = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_CDMA_BAND_CLASS].paraValue;
        cFreqLockPara.cdmaFreq      = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_CDMA_FREQ].paraValue;
        cFreqLockPara.cdmaPn        = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_CDMA_PN].paraValue;
        cFreqLockPara.evdoBandClass = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_EVDO_BAND_CLASS].paraValue;
        cFreqLockPara.evdoFreq      = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_EVDO_FREQ].paraValue;
        cFreqLockPara.evdoPn        = (VOS_UINT16)g_atParaList[AT_CFREQLOCK_EVDO_PN].paraValue;
    } else {
        cFreqLockPara.freqLockMode = TAF_MMA_CFREQ_LOCK_MODE_OFF;
    }

    /* 发送TAF_MMA_CFREQ_LOCK_SET_REQ消息 */
    rst = TAF_MMA_ProcCFreqLockSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                      &cFreqLockPara);
    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CFREQLOCK_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif

VOS_UINT32 AT_SetCdmaCsqPara(VOS_UINT8 indexNum)
{
    TAF_MMA_CdmacsqPara cdmaCsqPara;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaIndex != AT_CDMACSQ_MIN_PARA_NUM) || (g_atParaList[AT_CDMACSQ_MODE].paraLen == 0) ||
        (g_atParaList[AT_CDMACSQ_TIME_INTERVAL].paraLen == 0) ||
        (g_atParaList[AT_CDMACSQ_RSSI_RPT_THRE].paraLen == 0) ||
        (g_atParaList[AT_CDMACSQ_ECIO_RPT_THRE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&cdmaCsqPara, sizeof(cdmaCsqPara), 0x00, sizeof(TAF_MMA_CdmacsqPara));
    cdmaCsqPara.mode         = (TAF_UINT8)g_atParaList[AT_CDMACSQ_MODE].paraValue;
    cdmaCsqPara.timeInterval = (TAF_UINT8)g_atParaList[AT_CDMACSQ_TIME_INTERVAL].paraValue;
    cdmaCsqPara.rssiRptThreshold = (TAF_UINT8)g_atParaList[AT_CDMACSQ_RSSI_RPT_THRE].paraValue;
    cdmaCsqPara.ecIoRptThreshold = (TAF_UINT8)g_atParaList[AT_CDMACSQ_ECIO_RPT_THRE].paraValue;

    if (TAF_MMA_ProcCdmaCsqSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &cdmaCsqPara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CDMACSQ_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}
#endif


VOS_UINT32 AT_SetTTYModePara(VOS_UINT8 indexNum)
{
    VOS_UINT32           result;
    APP_VC_SetTtymodeReq setTTYMode;

    (VOS_VOID)memset_s(&setTTYMode, sizeof(setTTYMode), 0x00, sizeof(APP_VC_SetTtymodeReq));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaIndex != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    setTTYMode.ttyMode = (TAF_VC_TtymodeUint8)g_atParaList[0].paraValue;

    /* 获取下发VC的消息头名称 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    APP_VC_MSG_SET_TTYMODE_REQ, (VOS_UINT8 *)&setTTYMode, sizeof(APP_VC_SetTtymodeReq),
                                    I0_WUEPS_PID_VC);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetTTYModePara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_TTYMODE_SET;

    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 At_SetCustomDial(VOS_UINT8 indexNum)
{
    TAF_CALL_CustomDialPara customDialPara;
    TAF_Ctrl                ctrl;
    ModemIdUint16           modemId;

    (VOS_VOID)memset_s(&customDialPara, sizeof(customDialPara), 0x00, sizeof(TAF_CALL_CustomDialPara));
    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_Ctrl));

    /* 将输入第一个参数转成呼叫号码 */
    if (AT_FillCalledNumPara(g_atParaList[0].para, g_atParaList[0].paraLen, &customDialPara.dialNumber) != VOS_OK) {
        AT_UpdateCallErrInfo(indexNum, TAF_CS_CAUSE_INVALID_PARAMETER, VOS_NULL_PTR);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将输入第二个参数转成SO */
    customDialPara.so       = g_atParaList[1].paraValue;
    customDialPara.callType = MN_CALL_TYPE_VOICE;

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    if (TAF_CCM_CallCommonReq(&ctrl, &customDialPara, ID_TAF_CCM_CUSTOM_DIAL_REQ, sizeof(customDialPara), modemId) ==
        VOS_OK) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CUSTOMDIAL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_IsPlatformSupportHrpdMode(PLATAFORM_RatCapability *platform)
{
    VOS_UINT16 i;

    for (i = 0; i < AT_MIN(platform->ratNum, PLATFORM_MAX_RAT_NUM); i++) {
        if (platform->ratList[i] == PLATFORM_RAT_HRPD) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_IsPlatformSupport1XMode(PLATAFORM_RatCapability *platform)
{
    VOS_UINT16 i;

    for (i = 0; i < AT_MIN(platform->ratNum, PLATFORM_MAX_RAT_NUM); i++) {
        if (platform->ratList[i] == PLATFORM_RAT_1X) {
            return VOS_TRUE;
        }
    }

    return VOS_FALSE;
}


VOS_UINT32 AT_AddSpecRatIntoPlatform(PLATFORM_RatTypeUint16 ratType, PLATAFORM_RatCapability *platform)
{
    if (platform->ratNum >= PLATFORM_MAX_RAT_NUM) {
        return VOS_FALSE;
    }

    platform->ratList[platform->ratNum] = ratType;
    platform->ratNum++;

    return VOS_TRUE;
}


VOS_UINT32 AT_RemoveSpecRatFromPlatform(PLATFORM_RatTypeUint16 ratType, PLATAFORM_RatCapability *platform)
{
    VOS_UINT16 i;
    VOS_UINT16 ratNum;

    ratNum = 0;

    for (i = 0; i < AT_MIN(platform->ratNum, PLATFORM_MAX_RAT_NUM); i++) {
        if (ratType != platform->ratList[i]) {
            platform->ratList[ratNum] = platform->ratList[i];
            ratNum++;
        }
    }

    platform->ratNum = ratNum;

    return VOS_TRUE;
}


VOS_UINT32 AT_IsPlatformValidRemovingXCap(PLATAFORM_RatCapability *modemPlatform)
{
    VOS_UINT32 modemSupport1XFlg;
    VOS_UINT32 modemSupportHrpdFlg;

    modemSupport1XFlg   = AT_IsPlatformSupport1XMode(modemPlatform);
    modemSupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modemPlatform);

    /* 判断满足切换的条件:modem切换后，如果它的平台能力个数为0的话，则不切换 */
    if (((modemSupport1XFlg && modemSupportHrpdFlg)) && (modemPlatform->ratNum == 2)) { /* 接入技术的个数为2 */
        return VOS_FALSE;
    }

    if (((modemSupport1XFlg || modemSupportHrpdFlg)) && (modemPlatform->ratNum == 1)) { /* 接入技术的个数为1 */
        return VOS_FALSE;
    }

    return VOS_TRUE;
}




VOS_UINT32 AT_CheckSwitchCdmaModePara(PLATAFORM_RatCapability *modem0PlatRat, PLATAFORM_RatCapability *modem1PlatRat,
                                      PLATAFORM_RatCapability *modem2PlatRat, VOS_UINT32 modemId)
{
    VOS_UINT32 modem0Support1XFlg;
    VOS_UINT32 modem0SupportHrpdFlg;
    VOS_UINT32 modem1Support1XFlg;
    VOS_UINT32 modem1SupportHrpdFlg;
    VOS_UINT32 modem2Support1XFlg;
    VOS_UINT32 modem2SupportHrpdFlg;
    VOS_UINT32 modem0SupportCMode;
    VOS_UINT32 modem1SupportCMode;
    VOS_UINT32 modem2SupportCMode;

    modem0Support1XFlg   = AT_IsPlatformSupport1XMode(modem0PlatRat);
    modem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modem0PlatRat);
    modem1Support1XFlg   = AT_IsPlatformSupport1XMode(modem1PlatRat);
    modem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modem1PlatRat);
    modem2Support1XFlg   = AT_IsPlatformSupport1XMode(modem2PlatRat);
    modem2SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modem2PlatRat);

    modem0SupportCMode = (modem0Support1XFlg || modem0SupportHrpdFlg);
    modem1SupportCMode = (modem1Support1XFlg || modem1SupportHrpdFlg);
    modem2SupportCMode = (modem2Support1XFlg || modem2SupportHrpdFlg);

    /* 如果modem0和modem1同时满足支持，则认为设置失败 */
    if ((modem0SupportCMode == VOS_TRUE) && (modem1SupportCMode == VOS_TRUE)) {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem0 and Modem1 Support CMode");
        return AT_ERROR;
    }

    /* 如果modem0和modem2同时满足支持，则认为设置失败 */
    if ((modem0SupportCMode == VOS_TRUE) && (modem2SupportCMode == VOS_TRUE)) {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem0 and Modem2 Support CMode");

        return AT_ERROR;
    }

    /* 如果modem1和modem2同时满足支持，则认为设置失败 */
    if ((modem1SupportCMode == VOS_TRUE) && (modem2SupportCMode == VOS_TRUE)) {
        AT_ERR_LOG("AT_CheckSwitchCdmaModePara: Modem2 and Modem1 Support CMode");
        return AT_ERROR;
    }

    /* 如果需要将CDMA modem切换的目标modem0，而modem0已经支持，则直接返回OK */
    if ((modemId == MODEM_ID_0) && (modem0SupportCMode)) {
        return AT_OK;
    }

    /* 如果需要将CDMA modem切换的目标modem1，而modem1已经支持，则直接返回OK */
    if ((modemId == MODEM_ID_1) && (modem1SupportCMode)) {
        return AT_OK;
    }

    /* 如果需要将CDMA modem切换的目标modem2，而modem2已经支持，则直接返回OK */
    if ((modemId == MODEM_ID_2) && (modem2SupportCMode)) {
        return AT_OK;
    }

    return AT_SUCCESS;
}

VOS_UINT32 AT_SwitchCdmaMode(VOS_UINT8 indexNum, VOS_UINT32 modemId, PLATAFORM_RatCapability *modem0Platform,
                             PLATAFORM_RatCapability *modem1Platform, PLATAFORM_RatCapability *modem2Platform)
{
    ModemIdUint16            sourceModemId;
    ModemIdUint16            destinationModemId;
    PLATAFORM_RatCapability *sourceModemPlatform      = VOS_NULL_PTR;
    PLATAFORM_RatCapability *destinationModemPlatform = VOS_NULL_PTR;
    VOS_UINT32               modem0Support1XFlg;
    VOS_UINT32               modem0SupportHrpdFlg;
    VOS_UINT32               modem1Support1XFlg;
    VOS_UINT32               modem1SupportHrpdFlg;
    VOS_UINT32               modem0SupportCMode;
    VOS_UINT32               modem1SupportCMode;
    VOS_UINT32               sourceSupport1XFlg;
    VOS_UINT32               sourceSupportHrpdFlg;

    modem0Support1XFlg   = AT_IsPlatformSupport1XMode(modem0Platform);
    modem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modem0Platform);
    modem1Support1XFlg   = AT_IsPlatformSupport1XMode(modem1Platform);
    modem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(modem1Platform);

    modem0SupportCMode = (modem0Support1XFlg || modem0SupportHrpdFlg);
    modem1SupportCMode = (modem1Support1XFlg || modem1SupportHrpdFlg);

    if (modemId == 0) {
        destinationModemId       = MODEM_ID_0;
        destinationModemPlatform = modem0Platform;
    } else if (modemId == 1) {
        destinationModemId       = MODEM_ID_1;
        destinationModemPlatform = modem1Platform;
    } else {
        destinationModemId       = MODEM_ID_2;
        destinationModemPlatform = modem2Platform;
    }

    if (modem0SupportCMode == VOS_TRUE) {
        sourceModemId       = MODEM_ID_0;
        sourceModemPlatform = modem0Platform;
    } else if (modem1SupportCMode == VOS_TRUE) {
        sourceModemId       = MODEM_ID_1;
        sourceModemPlatform = modem1Platform;
    } else {
        sourceModemId       = MODEM_ID_2;
        sourceModemPlatform = modem2Platform;
    }

    sourceSupport1XFlg   = AT_IsPlatformSupport1XMode(sourceModemPlatform);
    sourceSupportHrpdFlg = AT_IsPlatformSupportHrpdMode(sourceModemPlatform);

    if (AT_IsPlatformValidRemovingXCap(sourceModemPlatform) == VOS_FALSE) {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_IsPlatformValidRemovingXCap return  FALSE !");
        return VOS_FALSE;
    }

    if (sourceSupport1XFlg == VOS_TRUE) {
        (VOS_VOID)AT_RemoveSpecRatFromPlatform(PLATFORM_RAT_1X, sourceModemPlatform);
    }

    if (sourceSupportHrpdFlg == VOS_TRUE) {
        (VOS_VOID)AT_RemoveSpecRatFromPlatform(PLATFORM_RAT_HRPD, sourceModemPlatform);
    }

    (VOS_VOID)AT_AddSpecRatIntoPlatform(PLATFORM_RAT_1X, destinationModemPlatform);
    (VOS_VOID)AT_AddSpecRatIntoPlatform(PLATFORM_RAT_HRPD, destinationModemPlatform);

    if (AT_SetCdmaModemCapPara(sourceModemPlatform, destinationModemPlatform, sourceModemId, destinationModemId,
                               indexNum) == AT_ERROR) {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_SetCdmaModemCapPara return Error!");

        return VOS_FALSE;
    } else {
        AT_ERR_LOG("AT_SwitchCdmaMode: AT_SetCdmaModemCapPara return Ok!");
    }

    return VOS_TRUE;
}


VOS_UINT32 At_SetCdmaModemSwitch(VOS_UINT8 indexNum)
{
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (MULTI_MODEM_NUMBER >= 2)
    PLATAFORM_RatCapability  modem0PlatRat;
    PLATAFORM_RatCapability  modem1PlatRat;
    PLATAFORM_RatCapability  modem2PlatRat;
    VOS_UINT32               modemId;
    AT_MTA_ModemCapUpdateReq atMtaModemCapUpdate;
    ModemIdUint16            modemIdTemp;
    VOS_UINT8 isCdmaModemSwitchNotResetFlg;
    VOS_UINT32 checkParaRlt;
    VOS_UINT32 result;

    modemIdTemp = MODEM_ID_BUTT;
    (VOS_VOID)memset_s(&atMtaModemCapUpdate, sizeof(AT_MTA_ModemCapUpdateReq), 0x00, sizeof(AT_MTA_ModemCapUpdateReq));

    (VOS_VOID)memset_s(&modem0PlatRat, sizeof(modem0PlatRat), 0x00, sizeof(modem0PlatRat));
    (VOS_VOID)memset_s(&modem1PlatRat, sizeof(modem1PlatRat), 0x00, sizeof(modem1PlatRat));
    (VOS_VOID)memset_s(&modem2PlatRat, sizeof(modem2PlatRat), 0x00, sizeof(modem2PlatRat));

    modemId = g_atParaList[0].paraValue;

    /* 改命令仅支持在Modem0上发起 */
    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemIdTemp) != VOS_OK) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Get modem id fail!");

        return AT_ERROR;
    }

    isCdmaModemSwitchNotResetFlg = AT_GetModemCdmaModemSwitchCtxAddrFromModemId(modemIdTemp)->enableFlg;

    if ((modemIdTemp != MODEM_ID_0) && (isCdmaModemSwitchNotResetFlg == VOS_TRUE)) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: This Command Only Support On Modem0!");

        return AT_ERROR;
    }

    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PLATFORM_RAT_CAP, &modem0PlatRat, sizeof(PLATAFORM_RatCapability))) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem0!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_0, modem0PlatRat);
    /* 先打印便于分析，后边界保护 */
    modem0PlatRat.ratNum = AT_MIN(modem0PlatRat.ratNum, PLATFORM_MAX_RAT_NUM);

    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_1, NV_ITEM_PLATFORM_RAT_CAP, &modem1PlatRat, sizeof(PLATAFORM_RatCapability))) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem1!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_1, modem1PlatRat);
    /* 先打印便于分析，后边界保护 */
    modem1PlatRat.ratNum = AT_MIN(modem1PlatRat.ratNum, PLATFORM_MAX_RAT_NUM);

#if (MULTI_MODEM_NUMBER == 3)
    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_2, NV_ITEM_PLATFORM_RAT_CAP, &modem2PlatRat, sizeof(PLATAFORM_RatCapability))) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: Read Nv Fail, NvId PlatForm_Rat_Cap,Modem2!");
        return AT_ERROR;
    }

    AT_NORM_LOG("Read PlatForm from Work success: ");
    AT_ReadPlatFormPrint(MODEM_ID_2, modem2PlatRat);
    /* 先打印便于分析，后边界保护 */
    modem2PlatRat.ratNum = AT_MIN(modem2PlatRat.ratNum, PLATFORM_MAX_RAT_NUM);

#endif

#if (MULTI_MODEM_NUMBER == 2)
    /* 双modem时，设置为2的时候返回错误 */
    if (modemId == 2) {
        AT_ERR_LOG1("At_SetCdmaModemSwitch: ulModemId id Error! ulModemId: ", modemId);

        return AT_ERROR;
    }
#endif

    /*
     * CDMA支持切换需满足以下条件:
     * 1、CDMA能力只能在一个MODEM;
     * 2、目标modem上不存在CDMA，如果已经存在CDMA则直接返回OK
     * 3、进行C模切换后的modem平台支持接入技术个数不为0
     */
    checkParaRlt = AT_CheckSwitchCdmaModePara(&modem0PlatRat, &modem1PlatRat, &modem2PlatRat, modemId);
    if (checkParaRlt == AT_ERROR) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: AT_CheckSwitchCdmaModePara return Error!");

        return AT_ERROR;
    } else if (checkParaRlt == AT_OK) {
        return AT_OK;
    } else {
        /* pclint */
    }

    result = AT_SwitchCdmaMode(indexNum, modemId, &modem0PlatRat, &modem1PlatRat, &modem2PlatRat);
    if (result == VOS_FALSE) {
        AT_ERR_LOG("At_SetCdmaModemSwitch: AT_SwitchCdmaMode return Error!");
        return AT_ERROR;
    } else {
        AT_ERR_LOG1("At_SetCdmaModemSwitch: AT_SwitchCdmaMode return Result : ", result);
        return AT_WAIT_ASYNC_RETURN;
    }

#else
    return AT_OK;
#endif
#else
    return AT_OK;
#endif
}

#if (MULTI_MODEM_NUMBER >= 2)

LOCAL VOS_UINT32 At_QryCdmaModemSwitchCdmaCapCheck(VOS_UINT32 modem0SupportCMode, VOS_UINT32 modem1SupportCMode,
#if (MULTI_MODEM_NUMBER == 3)
                                                   VOS_UINT32 ulModem2SupportCMode,
#endif
                                                   VOS_UINT32 *pulAllModemNotSupportCMode)
{
    VOS_UINT32 checkRlt;

    checkRlt = AT_SUCCESS;

    /* 如果modem0和modem1同时满足支持，则认为设置失败 */
    if ((modem0SupportCMode == VOS_TRUE) && (modem1SupportCMode == VOS_TRUE)) {
        checkRlt = AT_ERROR;
    }

#if (MULTI_MODEM_NUMBER == 3)
    /* 如果modem0和modem2同时满足支持，则认为设置失败 */
    if ((modem0SupportCMode == VOS_TRUE) && (ulModem2SupportCMode == VOS_TRUE)) {
        checkRlt = AT_ERROR;
    }

    /* 如果modem1和modem2同时满足支持，则认为设置失败 */
    if ((modem1SupportCMode == VOS_TRUE) && (ulModem2SupportCMode == VOS_TRUE)) {
        checkRlt = AT_ERROR;
    }
#endif

    if ((modem0SupportCMode == VOS_FALSE) && (modem1SupportCMode == VOS_FALSE)
#if (MULTI_MODEM_NUMBER == 3)
        && (ulModem2SupportCMode == VOS_FALSE))
#else
    )
#endif
    {
        checkRlt                    = AT_ERROR;
        *pulAllModemNotSupportCMode = VOS_TRUE;
    }

    return checkRlt;
}
#endif

VOS_UINT32 At_QryCdmaModemSwitch(VOS_UINT8 indexNum)
{
#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
    PLATAFORM_RatCapability modem0PlatRat;
    VOS_UINT32              modem0Support1XFlg;
    VOS_UINT32              modem0SupportHrpdFlg;
    VOS_UINT32              modem0SupportCMode;
    VOS_UINT16              length;
#if (MULTI_MODEM_NUMBER >= 2)
    PLATAFORM_RatCapability modem1PlatRat;
    VOS_UINT32              modem1Support1XFlg;
    VOS_UINT32              modem1SupportHrpdFlg;
    VOS_UINT32              modem1SupportCMode;
    VOS_UINT32              checkRlt;
    VOS_UINT32              allModemNotSupportCMode;
#if (MULTI_MODEM_NUMBER == 3)
    PLATAFORM_RatCapability modem2PlatRat;
    VOS_UINT32              modem2Support1XFlg;
    VOS_UINT32              modem2SupportHrpdFlg;
    VOS_UINT32              modem2SupportCMode;
#endif

    (VOS_VOID)memset_s(&modem0PlatRat, sizeof(modem0PlatRat), 0x00, sizeof(modem0PlatRat));
    (VOS_VOID)memset_s(&modem1PlatRat, sizeof(modem1PlatRat), 0x00, sizeof(modem1PlatRat));
    checkRlt                = AT_SUCCESS;
    allModemNotSupportCMode = VOS_FALSE;

#if (MULTI_MODEM_NUMBER == 3)
    (VOS_VOID)memset_s(&modem2PlatRat, sizeof(modem2PlatRat), 0x00, sizeof(modem2PlatRat));
#endif
    /*  查询读取nv，修改为从使用区读取，不从工作区读取 */
    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PLATFORM_RAT_CAP, &modem0PlatRat, sizeof(PLATAFORM_RatCapability))) {
        return AT_ERROR;
    } else {
        AT_NORM_LOG("Read PlatForm from success: ");
        AT_ReadPlatFormPrint(MODEM_ID_0, modem0PlatRat);
    }

    if (NV_OK !=
        TAF_ACORE_NV_READ(MODEM_ID_1, NV_ITEM_PLATFORM_RAT_CAP, &modem1PlatRat, sizeof(PLATAFORM_RatCapability))) {
        return AT_ERROR;
    } else {
        AT_NORM_LOG("Read PlatForm from success: ");
        AT_ReadPlatFormPrint(MODEM_ID_1, modem1PlatRat);
    }

#if (MULTI_MODEM_NUMBER == 3)
    if (TAF_ACORE_NV_READ(MODEM_ID_2, NV_ITEM_PLATFORM_RAT_CAP, &modem2PlatRat, sizeof(PLATAFORM_RatCapability)) !=
        NV_OK) {
        return AT_ERROR;
    }
#endif

    modem0Support1XFlg   = AT_IsPlatformSupport1XMode(&modem0PlatRat);
    modem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&modem0PlatRat);
    modem1Support1XFlg   = AT_IsPlatformSupport1XMode(&modem1PlatRat);
    modem1SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&modem1PlatRat);
#if (MULTI_MODEM_NUMBER == 3)
    modem2Support1XFlg   = AT_IsPlatformSupport1XMode(&modem2PlatRat);
    modem2SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&modem2PlatRat);
#endif
    modem0SupportCMode = (modem0Support1XFlg || modem0SupportHrpdFlg);
    modem1SupportCMode = (modem1Support1XFlg || modem1SupportHrpdFlg);
#if (MULTI_MODEM_NUMBER == 3)
    modem2SupportCMode = (modem2Support1XFlg || modem2SupportHrpdFlg);
#endif

    checkRlt = At_QryCdmaModemSwitchCdmaCapCheck(modem0SupportCMode, modem1SupportCMode,
#if (MULTI_MODEM_NUMBER == 3)
                                                 modem2SupportCMode,
#endif
                                                 &allModemNotSupportCMode);

    if (checkRlt == AT_ERROR) {
        if (allModemNotSupportCMode == VOS_TRUE) {
            length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
                (VOS_CHAR *)g_atSndCodeAddress, "%s: -1", g_parseContext[indexNum].cmdElement->cmdName);

            g_atSendDataBuff.bufLen = length;

            return AT_OK;
        }

        return AT_ERROR;
    }

    /* 1X,DO在Modem0 */
    if (modem0SupportCMode == VOS_TRUE) {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: 0", g_parseContext[indexNum].cmdElement->cmdName);

        g_atSendDataBuff.bufLen = length;

        return AT_OK;
    }

    /* 1X,DO在Modem1 */
    if (modem1SupportCMode == VOS_TRUE) {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: 1", g_parseContext[indexNum].cmdElement->cmdName);

        g_atSendDataBuff.bufLen = length;

        return AT_OK;
    }

#if (MULTI_MODEM_NUMBER == 3)
    /* 1X,DO在Modem2 */
    if (modem2SupportCMode == VOS_TRUE) {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: 2", g_parseContext[indexNum].cmdElement->cmdName);

        g_atSendDataBuff.bufLen = length;

        return AT_OK;
    }
#endif
#elif (MULTI_MODEM_NUMBER == 1)
    (VOS_VOID)memset_s(&modem0PlatRat, sizeof(modem0PlatRat), 0x00, sizeof(modem0PlatRat));

    if (TAF_ACORE_NV_READ(MODEM_ID_0, NV_ITEM_PLATFORM_RAT_CAP, &modem0PlatRat, sizeof(PLATAFORM_RatCapability))
        != NV_OK) {
        return AT_ERROR;
    } else {
        AT_NORM_LOG("Read PlatForm from success: ");
        AT_ReadPlatFormPrint(MODEM_ID_0, modem0PlatRat);
    }

    modem0Support1XFlg   = AT_IsPlatformSupport1XMode(&modem0PlatRat);
    modem0SupportHrpdFlg = AT_IsPlatformSupportHrpdMode(&modem0PlatRat);
    modem0SupportCMode = (modem0Support1XFlg || modem0SupportHrpdFlg);

    /* 1X,DO在Modem0 */
    if (modem0SupportCMode == VOS_TRUE) {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: 0", g_parseContext[indexNum].cmdElement->cmdName);

        g_atSendDataBuff.bufLen = length;

        return AT_OK;
    } else {
        length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
            (VOS_CHAR *)g_atSndCodeAddress, "%s: -1", g_parseContext[indexNum].cmdElement->cmdName);

        g_atSendDataBuff.bufLen = length;

        return AT_OK;
    }
#endif
#endif

    return AT_OK;
}


VOS_UINT32 AT_SetCtaPara(VOS_UINT8 indexNum)
{
    VOS_UINT8 timeLen;

    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    timeLen = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 执行命令操作 */
    if (TAF_PS_SetCtaInfo(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0, timeLen) !=
        VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CTA_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif


VOS_UINT32 At_SetFemCtrl(VOS_UINT8 indexNum)
{
    VOS_UINT32           rst;
    AT_MTA_SetFemctrlReq femctrlReq;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 参数过多 */
    if (g_atParaIndex > AT_FEMCTRL_MAX_PARA_NUM) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[AT_FEMCTRL_CTRL_TYPE].paraLen == 0) || (g_atParaList[AT_FEMCTRL_PARA1].paraLen == 0) ||
        (g_atParaList[AT_FEMCTRL_PARA2].paraLen == 0) || (g_atParaList[AT_FEMCTRL_PARA3].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    femctrlReq.ctrlType = g_atParaList[AT_FEMCTRL_CTRL_TYPE].paraValue;
    femctrlReq.para1    = g_atParaList[AT_FEMCTRL_PARA1].paraValue;
    femctrlReq.para2    = g_atParaList[AT_FEMCTRL_PARA2].paraValue;
    femctrlReq.para3    = g_atParaList[AT_FEMCTRL_PARA3].paraValue;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, At_GetOpId(), ID_AT_MTA_SET_FEMCTRL_REQ,
                                 (VOS_UINT8 *)&femctrlReq, sizeof(femctrlReq), I0_UEPS_PID_MTA);

    if (rst == AT_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_FEMCTRL_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

VOS_UINT32 At_SetRatRfSwitch(VOS_UINT8 indexNum)
{
    NAS_NvTriModeEnable       triModeEnableStru;
    NAS_NvTriModeFemProfileId triModeFemProfileIdStru;

    (VOS_VOID)memset_s(&triModeEnableStru, sizeof(triModeEnableStru), 0x00, sizeof(triModeEnableStru));
    (VOS_VOID)memset_s(&triModeFemProfileIdStru, sizeof(triModeFemProfileIdStru), 0x00, sizeof(triModeFemProfileIdStru));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaIndex != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 查询是否支持全网通功能 */
    if (TAF_ACORE_NV_READ(MODEM_ID_0, en_NV_Item_TRI_MODE_ENABLE, &triModeEnableStru, sizeof(triModeEnableStru)) !=
        NV_OK) {
        AT_WARN_LOG("At_SetRatRfSwitch:read en_NV_Item_TRI_MODE_ENABLE failed");
        return AT_ERROR;
    }

    /* 不支持，返回 */
    if (triModeEnableStru.enable == 0) {
        AT_WARN_LOG("At_SetRatRfSwitch:uhwEnable is not enabled");
        return AT_CME_OPERATION_NOT_ALLOWED;
    }

    triModeFemProfileIdStru.profileId = g_atParaList[0].paraValue;

    /* 配置Profile Id */
    if (TAF_ACORE_NV_WRITE(MODEM_ID_0, en_NV_Item_TRI_MODE_FEM_PROFILE_ID, (VOS_UINT8 *)&triModeFemProfileIdStru,
                           sizeof(triModeFemProfileIdStru)) != NV_OK) {
        AT_WARN_LOG("At_SetRatRfSwitch: MODEM_ID_0 write en_NV_Item_TRI_MODE_FEM_PROFILE_ID failed");
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_SetQuitCallBack(VOS_UINT8 indexNum)
{
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_CMD_NO_PARA) {
        return AT_ERROR;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetQuitCallBack(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_QCCB_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_Set1xChanPara(VOS_UINT8 indexNum)
{
    TAF_MMA_CfreqLockSetPara cFreqLockPara;
    VOS_UINT32               rst;

    /* 参数有效性检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数合法性判断 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息赋值 */
    (VOS_VOID)memset_s(&cFreqLockPara, sizeof(cFreqLockPara), 0x00, sizeof(TAF_MMA_CfreqLockSetPara));

    /* 复用锁频接口，除channel外，其他填0或者通配符 */
    cFreqLockPara.freqLockMode  = TAF_MMA_CFREQ_LOCK_MODE_ON;
    cFreqLockPara.sid           = 0x0000;
    cFreqLockPara.nid           = 0xFFFF;
    cFreqLockPara.cdmaBandClass = 0x0000;
    cFreqLockPara.cdmaFreq      = (VOS_UINT16)g_atParaList[0].paraValue;
    cFreqLockPara.cdmaPn        = 0xFFFF;
    cFreqLockPara.evdoBandClass = 0x0000;
    cFreqLockPara.evdoFreq      = 0x0000;
    cFreqLockPara.evdoPn        = 0xFFFF;

    /* 发送TAF_MMA_CFREQ_LOCK_SET_REQ消息 */
    rst = TAF_MMA_Proc1xChanSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                   &cFreqLockPara);
    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_1XCHAN_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}
#endif


VOS_UINT32 AT_SetCSidEnable(VOS_UINT8 indexNum)
{

    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType      = AT_MTA_SET_CSID_RPT_TYPE;
    atCmd.u.csidRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^CSID设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

/* 移出CDMA编译开关 */


VOS_UINT32 AT_ConvertCSidListMcc(VOS_UINT8 *para, VOS_UINT16 len, VOS_UINT32 *mcc)
{
    VOS_UINT32 rslt;

    rslt = 0;

    /* 如果Mcc为空，返回失败 */
    if (len != AT_MCC_LENGTH) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rslt |= (VOS_UINT32)(*para - '0');
    rslt |= ((VOS_UINT32)(*(para + AT_CSIDLIST_PARA_OFFSET_1) - '0') << 8);
    rslt |= ((VOS_UINT32)(*(para + AT_CSIDLIST_PARA_OFFSET_2) - '0') << 16);

    *mcc = rslt;

    return AT_SUCCESS;
}
#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetCSidList(VOS_UINT8 indexNum)
{
    TAF_MMA_OperLockTrustSid trustSidList;
    VOS_UINT8                listNum;
    VOS_UINT32               rslt;
    VOS_UINT32               i;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_ERROR;
    }

    /* 入参检查 */
    if (g_atParaList[AT_CSIDLIST_TRUST_LIST_NUM].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为3N + 1,其中 1 表示 SID Trust名单数量 这个参数，3N为包含起始SID 终止SID 和国家码的三个一组N组数据的个数 */
    if ((g_atParaIndex - 1) % 3 != 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 AT命令最大参数个数为16个 即5组Trust名单 */
    if (g_atParaIndex > AT_MAX_PARA_NUMBER) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&trustSidList, sizeof(trustSidList), 0x00, sizeof(trustSidList));

    if (g_atParaList[AT_CSIDLIST_TRUST_LIST_NUM].paraValue != 0) {
        trustSidList.enable = VOS_TRUE;
    } else {
        trustSidList.enable = VOS_FALSE;
    }

    /* 计算Trust名单个数，1 表示 SID Trust名单数量 这个参数，一组Trust名单包含起始SID 终止SID 和国家码，所以除以3 */
    trustSidList.trustSysNum = ((VOS_UINT16)g_atParaIndex - 1) / 3;
    i                        = 0;
    /* 1表示第一组Trust名单中的起始SID所在位置索引 */
    /* 一组Trust名单包含起始SID终止SID和国家码3个数据， listNum += 3就跳转到下一组Trust名单进行判断 */
    for (listNum = 1; listNum < g_atParaIndex; listNum += 3) {
        /* startSid value must less then endSid value */
        /* listNum + 1表示每一组Trust名单中终止SID所在位置索引 */
        if (g_atParaList[listNum].paraValue > g_atParaList[listNum + 1].paraValue) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        trustSidList.sysInfo[i].startSid = (VOS_UINT16)g_atParaList[listNum].paraValue;
        trustSidList.sysInfo[i].endSid   = (VOS_UINT16)g_atParaList[listNum + 1].paraValue;

        /* 转换 mcc */
        /* listNum + 2表示每一组Trust名单中国家码所在位置索引 */
        rslt = AT_ConvertCSidListMcc(g_atParaList[listNum + 2].para, g_atParaList[listNum + 2].paraLen,
                                     &trustSidList.sysInfo[i].mcc);

        i++;

        if (i >= TAF_MMA_MAX_TRUST_LOCK_SID_NUM) {
            break;
        }

        if (rslt != AT_SUCCESS) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetCSidList(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &trustSidList) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CSIDLIST_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    } else {
        return AT_ERROR;
    }
}
#endif
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT == FEATURE_ON)

VOS_UINT32 AT_SetEncryptCall(VOS_UINT8 indexNum)
{
    errno_t                  memResult;
    VOS_UINT8                callNum[AT_CMD_ECCALL_MAX_NUM_LENGTH + 1];
    VOS_UINT32               startIndex;
    TAF_Ctrl                 ctrl;
    TAF_CCM_EncryptVoicePara encrypVoicePara;
    ModemIdUint16            modemId;
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)
    TAF_CHAR  acNewDocName[AT_TEST_ECC_FILE_NAME_MAX_LEN];
    VOS_INT32 length;
    int       fd;

    (VOS_VOID)memset_s(acNewDocName, sizeof(acNewDocName), 0x00, sizeof(acNewDocName));

    length = 0;
#endif

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&encrypVoicePara, sizeof(encrypVoicePara), 0x00, sizeof(encrypVoicePara));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (g_atParaIndex != 2) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaList[1].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(callNum, sizeof(callNum), 0x00, sizeof(callNum));
    /* 如果呼叫号码大于11位，则仅取最后的11位 */
    startIndex = 0;
    if (g_atParaList[1].paraLen > AT_CMD_ECCALL_MAX_NUM_LENGTH) {
        startIndex = (VOS_UINT32)g_atParaList[1].paraLen - AT_CMD_ECCALL_MAX_NUM_LENGTH;
    }
    memResult = memcpy_s(callNum, (VOS_UINT32)sizeof(callNum), &g_atParaList[1].para[startIndex],
                         AT_CMD_ECCALL_MAX_NUM_LENGTH);
    TAF_MEM_CHK_RTN_VAL(memResult, (VOS_UINT32)sizeof(callNum), AT_CMD_ECCALL_MAX_NUM_LENGTH);

    /* 检查并转换电话号码 */
    if (AT_AsciiNumberToBcd((VOS_CHAR *)callNum, encrypVoicePara.dialNumber.bcdNum,
                            &encrypVoicePara.dialNumber.numLen) != MN_ERR_NO_ERROR) {
        return AT_ERROR;
    }

    /* 执行命令操作 */

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    encrypVoicePara.eccVoiceType = g_atParaList[0].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SEND_FLASH_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &encrypVoicePara, ID_TAF_CCM_ENCRYPT_VOICE_REQ, sizeof(encrypVoicePara),
                              modemId) == VOS_OK) {
#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)

        /* 密话测试模式写文件path下标 */
        g_currEncVoiceDataWriteFileNum++;

        /* 最大写密话数据文件数为5,超过的话循环写文件1，同时需要删掉文件中的内容 */
        if (g_currEncVoiceDataWriteFileNum > ENCRYPT_VOICE_DATA_FILE_MAX_NUM) {
            g_currEncVoiceDataWriteFileNum = 1;
        }
        g_atCurrEncVoiceDataCount = 0;

        g_atCurrEncVoiceTestFileNum++;

        (VOS_VOID)memset_s(g_atCurrDocName, sizeof(g_atCurrDocName), 0x00, sizeof(g_atCurrDocName));

        length = snprintf_s(acNewDocName, (VOS_SIZE_T)sizeof(acNewDocName), (VOS_SIZE_T)(sizeof(acNewDocName) - 1),
                            MODEM_LOG_ROOT "/ECC_TEST/Encrypted_call_execute_time%d.txt", g_atCurrEncVoiceTestFileNum);
        if (length <= 0) {
            AT_WARN_LOG("AT_SetEncryptCall(): snprintf_s len <= 0");

            return AT_ERROR;
        }

        /* 清除待写入文件中的内容 */
        fd = at_file_open(g_currEncVoiceDataWriteFilePath[g_currEncVoiceDataWriteFileNum], "w");
        if (fd < 0) {
            AT_WARN_LOG("AT_SetEncryptCall: Clear file data failed!!!\n");
        } else {
            at_file_close(fd);
        }

        fd = at_file_open(acNewDocName, "w");
        if (fd < 0) {
            AT_WARN_LOG("AT_SetEncryptCall: Truncate file failed!!!\n");
        } else {
            at_file_close(fd);
        }
#endif
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECCALL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }
    return AT_ERROR;
}


VOS_UINT32 AT_SetEncryptCallRemoteCtrl(VOS_UINT8 indexNum)
{
    TAF_Ctrl                     ctrl;
    TAF_CCM_RemoteCtrlAnswerInfo remoteCtrlAnswerInfo;
    ModemIdUint16                modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&remoteCtrlAnswerInfo, sizeof(remoteCtrlAnswerInfo), 0x00, sizeof(remoteCtrlAnswerInfo));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (g_atParaIndex != 2) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaList[1].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    remoteCtrlAnswerInfo.remoteCtrlEvtType = g_atParaList[0].paraValue;
    remoteCtrlAnswerInfo.result            = g_atParaList[1].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &remoteCtrlAnswerInfo, ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ,
                              sizeof(remoteCtrlAnswerInfo), modemId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECCTRL_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }
    return AT_ERROR;
}


VOS_UINT32 AT_SetEncryptCallCap(VOS_UINT8 indexNum)
{
    TAF_Ctrl                 ctrl;
    TAF_CCM_EccSrvCapCfgPara encryptCallCapPara;
    ModemIdUint16            modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&encryptCallCapPara, sizeof(encryptCallCapPara), 0x00, sizeof(encryptCallCapPara));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (g_atParaIndex != 2) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaList[1].paraLen != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 用户不允许enalbe密话业务能力，只允许disable密话能力 */
    if (g_atParaList[0].paraValue == TAF_CALL_ECC_SRV_CAP_ENABLE) {
        return AT_CME_OPERATION_NOT_ALLOWED;
    }

    /* 执行命令操作 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    encryptCallCapPara.eccSrvCap    = g_atParaList[0].paraValue;
    encryptCallCapPara.eccSrvStatus = g_atParaList[1].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 给CCM发送ID_TAF_CCM_REMOTE_CTRL_ANSWER_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &encryptCallCapPara, ID_TAF_CCM_ECC_SRV_CAP_CFG_REQ, sizeof(encryptCallCapPara),
                              modemId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECCAP_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

#if (FEATURE_CHINA_TELECOM_VOICE_ENCRYPT_TEST_MODE == FEATURE_ON)

VOS_UINT32 AT_SetEncryptCallKmc(VOS_UINT8 indexNum)
{
    TAF_Ctrl             ctrl;
    MN_CALL_AppEcKmcData kmcData;
    ModemIdUint16        modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&kmcData, sizeof(kmcData), 0x00, sizeof(kmcData));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为2 */
    if (g_atParaIndex != AT_ECKMC_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if ((g_atParaList[AT_ECKMC_KEY].paraLen > AT_CMD_ECKMC_MAX_KMC_LENGTH) ||
        (g_atParaList[AT_ECKMC_KEY].paraLen == 0) ||
        (g_atParaList[AT_ECKMC_VER].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    kmcData.eccKmcVer = (VOS_UINT8)g_atParaList[AT_ECKMC_VER].paraValue;

    /* 要取KMC公钥长度的一半，如果长度为偶数，直接除2，否则除2后加1 */
    if (g_atParaList[AT_ECKMC_KEY].paraLen % 2 == 0) {
        kmcData.eccKmcLength = g_atParaList[AT_ECKMC_KEY].paraLen / 2;
    } else {
        kmcData.eccKmcLength = g_atParaList[AT_ECKMC_KEY].paraLen / 2 + 1;
    }

    /*lint -e516 */
    /*  把kmc data转换为hex保存 */
    if (At_AsciiString2HexSimple(kmcData.eccKmcData, g_atParaList[AT_ECKMC_KEY].para,
                                 g_atParaList[AT_ECKMC_KEY].paraLen) == AT_FAILURE) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SET_EC_KMC_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &kmcData, ID_TAF_CCM_SET_EC_KMC_REQ, sizeof(kmcData), modemId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECKMC_SET;

        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

VOS_UINT32 AT_SetEccTestMode(VOS_UINT8 indexNum)
{
    TAF_Ctrl                     ctrl;
    TAF_CALL_SetEcTestModeUint32 eccTestModeStatus;
    ModemIdUint16                modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数为1 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 入参长度检查 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    g_atCurrEncVoiceTestFileNum = 0;

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    eccTestModeStatus = g_atParaList[0].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_SET_EC_TEST_MODE_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &eccTestModeStatus, ID_TAF_CCM_SET_EC_TEST_MODE_REQ, sizeof(eccTestModeStatus),
                              modemId) == VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_ECCTEST_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}

#endif
#endif

VOS_UINT32 AT_SetClocinfoEnable(VOS_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType          = AT_MTA_SET_CLOCINFO_RPT_TYPE;
    atCmd.u.clocinfoRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^CLOCINFO设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}

VOS_UINT32 AT_SetPrivacyModePreferred(VOS_UINT8 indexNum)
{
    TAF_Ctrl                    ctrl;
    TAF_CALL_PrivacyModeSetPara privacyMode;
    ModemIdUint16               modemId;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(ctrl));
    (VOS_VOID)memset_s(&privacyMode, sizeof(privacyMode), 0x00, sizeof(privacyMode));

    /* 检查命令类型是否匹配 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查入参长度检查 */
    if (g_atParaList[0].paraLen != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数值范围 */
    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */

    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = g_atClientTab[indexNum].opId;

    privacyMode.privacyMode = (TAF_CALL_PrivacyModeUint8)g_atParaList[0].paraValue;

    if (AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId) != VOS_OK) {
        return AT_ERROR;
    }

    /* 发送ID_TAF_CCM_PRIVACY_MODE_SET_REQ消息 */
    if (TAF_CCM_CallCommonReq(&ctrl, &privacyMode, ID_TAF_CCM_PRIVACY_MODE_SET_REQ, sizeof(privacyMode), modemId) ==
        VOS_OK) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CPMP_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCtOosCount(VOS_UINT8 indexNum)
{
    /* 检查命令类型是否匹配 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (g_atParaIndex != AT_CTOOSCOUNT_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetCtOosCount(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0,
                              g_atParaList[AT_CTOOSCOUNT_CL_COUNT].paraValue,
                              g_atParaList[AT_CTOOSCOUNT_GUL_COUNT].paraValue) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CTOOSCOUNT_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetCtRoamInfo(VOS_UINT8 indexNum)
{
    /* 检查命令类型是否匹配 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查参数个数是否匹配 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 执行命令操作 */
    if (TAF_MMA_SetCtRoamInfo(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0,
                              (VOS_UINT8)g_atParaList[0].paraValue) == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CTROAMINFO_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 AT_SetNoCardMode(VOS_UINT8 indexNum)
{
    AT_MTA_NoCardModeSetReq noCardModeCfg = {0};
    VOS_UINT32              rslt;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&noCardModeCfg, sizeof(noCardModeCfg), 0x00, sizeof(noCardModeCfg));

    noCardModeCfg.enableFlag = g_atParaList[0].paraValue;

    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_NO_CARD_MODE_SET_REQ,
                                  (VOS_UINT8 *)&noCardModeCfg, sizeof(noCardModeCfg), I0_UEPS_PID_MTA);

    if (rslt == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_NOCARDMODE_SET;

        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetNoCardMode: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }
}

#endif


VOS_UINT32 AT_CheckMccFreqPara(VOS_VOID)
{
    VOS_UINT32 loop;
    VOS_UINT32 length;

    /* 参数个数不正确,4~7个参数 */
    if ((g_atParaIndex > AT_MCCFREQ_MAX_PARA_NUM) || (g_atParaIndex < AT_MCCFREQ_MIN_PARA_NUM)) {
        AT_ERR_LOG("AT_CheckMccFreqPara:number of parameter error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数长度不对 */
    if ((g_atParaList[AT_MCCFREQ_SEQ].paraLen == 0) || (g_atParaList[AT_MCCFREQ_VER].paraLen != MCC_INFO_VERSION_LEN) ||
        (g_atParaList[AT_MCCFREQ_OPERATION].paraLen == 0) || (g_atParaList[AT_MCCFREQ_LENGTH].paraLen == 0)) {
        AT_ERR_LOG("AT_CheckMccFreqPara:para len error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是删除所有的运营商预制频点和频段信息，不需要携带BS1、BS2、BS3，且length必须为0 */
    if ((g_atParaList[AT_MCCFREQ_OPERATION].paraValue == AT_CSS_SET_MCC_TYPE_DELETE_ALL_MCC) &&
        ((g_atParaIndex > AT_MCCFREQ_MIN_PARA_NUM) || (g_atParaList[AT_MCCFREQ_LENGTH].paraValue != 0))) {
        AT_ERR_LOG("AT_CheckMccFreqPara:too mang para when delete all mcc.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    length = 0;

    /* 获取携带BS1、BS2、BS3码流总长度,BS1是第五个参数，即g_atParaList[4]保存着BS1相关信息 */
    for (loop = 4; loop < g_atParaIndex; loop++) {
        /*
         * 如果输入的BS1、或者BS2、或者BS3存在空洞或者长度大于500，直接返回错误
         * 例如AT^MCCFREQ=255,"00.00.001",0,100,,BS2(其中BS1存在空洞,长度为0)
         * AT^MCCFREQ=255,"00.00.001",0,100,BS1,    (其中BS2存在空洞,长度为0)
         */
        if ((g_atParaList[loop].paraLen == 0) || (g_atParaList[loop].paraLen > AT_CMD_MCCFREQ_BS_MAX_LENGTH)) {
            AT_ERR_LOG("AT_CheckMccFreqPara: string BS format is error");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        length += g_atParaList[loop].paraLen;
    }

    /* 如果BS1、BS2、BS3码流总长度与AT命令中携带的LENGTH长度不相同，直接返回错误 */
    if (length != g_atParaList[AT_MCCFREQ_LENGTH].paraValue) {
        AT_ERR_LOG("AT_CheckMccFreqPara: total length is error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetMccFreqPara(VOS_UINT8 indexNum)
{
    AT_CSS_MccInfoSetReq *msg = VOS_NULL_PTR;
    VOS_UINT32            bufLen;
    ModemIdUint16 modemId;
    VOS_UINT32    ret;
    VOS_UINT32    result;
    errno_t       memResult;

    modemId = MODEM_ID_0;

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("AT_SetMccFreqPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_ERR_LOG("AT_SetMccFreqPara:Cmd Opt Type is wrong.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    result = AT_CheckMccFreqPara();
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetMccFreqPara:check mcc freq para error.");

        return result;
    }

    /* 预制频点信息长度 */
    bufLen = sizeof(AT_CSS_MccInfoSetReq);

    if (g_atParaList[AT_MCCFREQ_LENGTH].paraValue > AT_CSS_MCCINFO_SET_REQ_BUFF_LEN) {
        bufLen += g_atParaList[AT_MCCFREQ_LENGTH].paraValue - AT_CSS_MCCINFO_SET_REQ_BUFF_LEN;
    }

    /* 申请消息包AT_CSS_MccInfoSetReq */
    msg = (AT_CSS_MccInfoSetReq *)AT_ALLOC_MSG_WITH_HDR(bufLen);

    /* 内存申请失败，返回 */
    if (msg == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetMccFreqPara:memory alloc fail.");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s((VOS_INT8 *)msg + VOS_MSG_HEAD_LENGTH, bufLen - VOS_MSG_HEAD_LENGTH, 0x00,
                       bufLen - VOS_MSG_HEAD_LENGTH);
    /* 填写消息头 */
    AT_CFG_MSG_HDR(msg, PS_PID_CSS, ID_AT_CSS_MCC_INFO_SET_REQ);

    /* 填写消息内容 */
    msg->modemId = modemId;
    msg->clientId       = g_atClientTab[indexNum].clientId;
    msg->seq            = (VOS_UINT8)g_atParaList[0].paraValue;
    msg->operateType    = (VOS_UINT8)g_atParaList[AT_MCCFREQ_OPERATION].paraValue;
    msg->mccInfoBuffLen = g_atParaList[AT_MCCFREQ_LENGTH].paraValue;

    if (g_atParaList[1].paraLen > 0) {
        memResult = memcpy_s(msg->versionId, sizeof(msg->versionId), g_atParaList[1].para, g_atParaList[1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(msg->versionId), g_atParaList[1].paraLen);
    }

    if (msg->mccInfoBuffLen > 0) {
        /* BS1 */
        if (g_atParaList[AT_MCCFREQ_BS1].paraLen > 0) {
            memResult = memcpy_s(msg->mccInfoBuff, msg->mccInfoBuffLen, g_atParaList[AT_MCCFREQ_BS1].para,
                                 g_atParaList[AT_MCCFREQ_BS1].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, msg->mccInfoBuffLen, g_atParaList[AT_MCCFREQ_BS1].paraLen);
        }

        /* BS1 未携带完所有的频点频段信息，BS2 携带了部分信息 */
        if (msg->mccInfoBuffLen > g_atParaList[AT_MCCFREQ_BS1].paraLen) {
            if (g_atParaList[AT_MCCFREQ_BS2].paraLen > 0) {
                memResult = memcpy_s(msg->mccInfoBuff + g_atParaList[AT_MCCFREQ_BS1].paraLen,
                                     msg->mccInfoBuffLen - g_atParaList[AT_MCCFREQ_BS1].paraLen,
                                     g_atParaList[AT_MCCFREQ_BS2].para, g_atParaList[AT_MCCFREQ_BS2].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, msg->mccInfoBuffLen - g_atParaList[AT_MCCFREQ_BS1].paraLen,
                                    g_atParaList[AT_MCCFREQ_BS2].paraLen);
            }

            /* BS1 & BS2 未携带完所有的频点频段信息，BS3 携带了部分信息 */
            if (msg->mccInfoBuffLen > ((VOS_UINT32)g_atParaList[AT_MCCFREQ_BS1].paraLen +
                g_atParaList[AT_MCCFREQ_BS2].paraLen)) {
                if (g_atParaList[AT_MCCFREQ_BS3].paraLen > 0) {
                    memResult = memcpy_s(msg->mccInfoBuff + g_atParaList[AT_MCCFREQ_BS1].paraLen +
                                         g_atParaList[AT_MCCFREQ_BS2].paraLen, msg->mccInfoBuffLen -
                                         g_atParaList[AT_MCCFREQ_BS1].paraLen - g_atParaList[AT_MCCFREQ_BS2].paraLen,
                                         g_atParaList[AT_MCCFREQ_BS3].para, g_atParaList[AT_MCCFREQ_BS3].paraLen);
                    TAF_MEM_CHK_RTN_VAL(memResult,
                                        msg->mccInfoBuffLen - g_atParaList[AT_MCCFREQ_BS1].paraLen -
                                        g_atParaList[AT_MCCFREQ_BS2].paraLen, g_atParaList[AT_MCCFREQ_BS3].paraLen);
                }
            }
        }
    }
    /* 发送消息，返回命令处理挂起状态 */

    AT_SEND_MSG(msg);

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_MCCFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}


LOCAL VOS_UINT32 AT_CheckCloudDataPara(VOS_VOID)
{
    VOS_UINT32 loop;
    VOS_UINT32 length;

    /* 参数个数不正确,2~4个参数 */
    if ((g_atParaIndex > AT_CLOUDDATA_MAX_PARA_NUM) || (g_atParaIndex < AT_CLOUDDATA_MIN_PARA_NUM)) {
        AT_ERR_LOG("AT_CheckCloudDataPara:number of parameter error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数长度不对 */
    if (g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraLen == 0) {
        AT_ERR_LOG("AT_CheckCloudDataPara:para len error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

   /* 输入参数length值0，直接返回错误 */
    if (g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraValue == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    length = 0;

    /* 获取携带BS1、BS2、BS3码流总长度,BS1是第二个参数，即g_atParaList[1]保存着BS1相关信息 */
    for (loop = 1; loop < g_atParaIndex; loop++) {
        /*
         * 如果输入的BS1、或者BS2、或者BS3存在空洞或者长度大于500，直接返回错误
         * 例如AT^CLOUDDATA=100,,BS2(其中BS1存在空洞,长度为0)
         * AT^CLOUDDATA=100,BS1,    (其中BS2存在空洞,长度为0)
         */
        if ((g_atParaList[loop].paraLen == 0) || (g_atParaList[loop].paraLen > AT_CMD_CLOUDDATA_BS_MAX_LENGTH)) {
            AT_ERR_LOG("AT_CheckCloudDataPara: string BS format is error");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        length += g_atParaList[loop].paraLen;
    }

    /* 如果BS1、BS2、BS3码流总长度与AT命令中携带的LENGTH长度不相同，直接返回错误 */
    if (length != g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraValue) {
        AT_ERR_LOG("AT_CheckCloudDataPara: total length is error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_VOID AT_FillCloudDataPara(VOS_UINT32 dataLen, VOS_UINT8 *data)
{
    errno_t       memResult;

    /* BS1 */
    if (g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen > 0) {
        memResult = memcpy_s(data, dataLen, g_atParaList[AT_CLOUDDATA_PARA_BS1].para,
            g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, dataLen, g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen);
    }

    /* BS1 未携带完所有的频点频段信息，BS2 携带了部分信息 */
    if (dataLen > g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen) {
        if (g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen > 0) {
            memResult = memcpy_s(data + g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen,
                dataLen - g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen,
                g_atParaList[AT_CLOUDDATA_PARA_BS2].para, g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, dataLen - g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen,
                g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen);
        }
    }

    /* BS1 & BS2 未携带完所有的频点频段信息，BS3 携带了部分信息 */
    if (dataLen > ((VOS_UINT32)g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen +
        g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen)) {
        if (g_atParaList[AT_CLOUDDATA_PARA_BS3].paraLen > 0) {
            memResult = memcpy_s(data + g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen +
                g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen, dataLen - g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen -
                g_atParaList[AT_CLOUDDATA_PARA_BS2].paraLen, g_atParaList[AT_CLOUDDATA_PARA_BS3].para,
                g_atParaList[AT_CLOUDDATA_PARA_BS3].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, dataLen - g_atParaList[AT_CLOUDDATA_PARA_BS1].paraLen -
                g_atParaList[ AT_CLOUDDATA_PARA_BS2].paraLen, g_atParaList[AT_CLOUDDATA_PARA_BS3].paraLen);
        }
    }
}


VOS_UINT32 AT_SetCloudDataPara(VOS_UINT8 indexNum)
{
    AT_CSS_CloudDataSetReq *msg = VOS_NULL_PTR;
    VOS_UINT32              bufLen;
    VOS_UINT32              ret;
    VOS_UINT32              result;
    ModemIdUint16           modemId;

    modemId = MODEM_ID_0;

    ret = AT_GetModemIdFromClient(indexNum, &modemId);

    if (ret != VOS_OK) {
        AT_ERR_LOG("AT_SetCloudDataPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_ERR_LOG("AT_SetCloudDataPara:Cmd Opt Type is wrong.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    result = AT_CheckCloudDataPara();
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetCloudDataPara:check cloud data para error.");

        return result;
    }

    /* 预制频点信息长度 */
    bufLen = sizeof(AT_CSS_CloudDataSetReq);

    if (g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraValue > AT_CSS_CLOUDDATA_SET_REQ_BUFF_LEN) {
        bufLen += g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraValue - AT_CSS_CLOUDDATA_SET_REQ_BUFF_LEN;
    }

    /* 申请消息包AT_CSS_CloudDataSetReq */
    msg = (AT_CSS_CloudDataSetReq *)AT_ALLOC_MSG_WITH_HDR(bufLen);

    /* 内存申请失败，返回 */
    if (msg == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetCloudDataPara:memory alloc fail.");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s((VOS_UINT8 *)msg + VOS_MSG_HEAD_LENGTH, bufLen - VOS_MSG_HEAD_LENGTH, 0x00, bufLen -
        VOS_MSG_HEAD_LENGTH);

    /* 填写消息头 */
    AT_CFG_MSG_HDR(msg, PS_PID_CSS, ID_AT_CSS_CLOUD_DATA_SET_REQ);

    /* 填写消息内容 */
    msg->modemId  = modemId;
    msg->clientId = g_atClientTab[indexNum].clientId;
    msg->dataLen  = g_atParaList[AT_CLOUDDATA_PARA_LENGTH].paraValue;

    /* 填写码流参数BS1、BS2、BS3内容 */
    AT_FillCloudDataPara(msg->dataLen, msg->data);
    /* 发送消息，返回命令处理挂起状态 */

    AT_SEND_MSG(msg);

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CLOUDDATA_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckBlockCellListBsPara(VOS_VOID)
{
    VOS_UINT32 loop;
    VOS_UINT32 length;

    length = 0;

    /* 获取携带BS1、BS2、BS3码流总长度,BS1是第六个参数，即g_atParaList[5]保存着BS1相关信息 */
    for (loop = 5; loop < g_atParaIndex; loop++) {
        /*
         * 如果输入的BS1、或者BS2、或者BS3存在空洞或者长度大于500，直接返回错误
         * 例如AT^CLOUDBLOCKLIST=255,"00.00.001",0,0,504,,BS2 (其中BS1存在空洞,长度为0),
         * AT^CLOUDBLOCKLIST=255,"00.00.001",0,0,504,BS1,     (其中BS2存在空洞,长度为0)
         */
        if ((g_atParaList[loop].paraLen == 0) || (g_atParaList[loop].paraLen > AT_CMD_BLOCK_CELL_BS_MAX_LENGTH)) {
            AT_ERR_LOG("AT_CheckBlockCellListBsPara: input BS format is error");

            return AT_CME_INCORRECT_PARAMETERS;
        }

        length += g_atParaList[loop].paraLen;
    }

    /* 如果BS1、BS2、BS3码流总长度与AT命令中携带的LENGTH长度不相同，直接返回错误 */
    if (length != g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraValue) {
        AT_ERR_LOG("AT_CheckBlockCellListBsPara: total length is error");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_CheckBlockCellListPara(VOS_VOID)
{
    /* 参数个数不正确,5~8个参数 */
    if ((g_atParaIndex > AT_BLOCKCELLLIST_MAX_PARA_NUM) || (g_atParaIndex < AT_BLOCKCELLLIST_MIN_PARA_NUM)) {
        AT_ERR_LOG("AT_CheckBlockCellListPara:number of parameter error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 输入参数长度不对 */
    if ((g_atParaList[AT_BLOCKCELLLIST_SEQ].paraLen == 0) ||
        (g_atParaList[AT_BLOCKCELLLIST_VER].paraLen != AT_CSS_BLOCK_CELL_LIST_VERSION_LEN) ||
        (g_atParaList[AT_BLOCKCELLLIST_OPERATION].paraLen == 0) ||
        (g_atParaList[AT_BLOCKCELLLIST_SYSMODE].paraLen   == 0) ||
        (g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraLen    == 0)) {
        AT_ERR_LOG("AT_CheckBlockCellListPara:para len error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 如果是删除所有的云通信Block小区信息，不需要携带BS1、BS2、BS3，且length必须为0 */
    if ((g_atParaList[AT_BLOCKCELLLIST_OPERATION].paraValue == AT_CSS_BLOCK_CELL_LIST_DELETE_ALL) &&
        ((g_atParaIndex > AT_BLOCKCELLLIST_MIN_PARA_NUM) || (g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraValue != 0))) {
        AT_ERR_LOG("AT_CheckBlockCellListPara:too mang para when delete all cloud block list.");

        return AT_CME_INCORRECT_PARAMETERS;
    }


    /* 输入的BS格式不正确，包括存在空洞、BS总长度不等于length长度 */
    if (AT_CheckBlockCellListBsPara() != AT_SUCCESS) {
        AT_ERR_LOG("AT_CheckBlockCellListPara:input BS para is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetBlockCellListPara(VOS_UINT8 indexNum)
{
    AT_CSS_BlockCellListSetReq *msg = VOS_NULL_PTR;
    VOS_UINT32                  bufLen;
    VOS_UINT32                  result;
    errno_t                     memResult;

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_ERR_LOG("AT_SetBlockCellListPara:Cmd Opt Type is wrong.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数检查 */
    result = AT_CheckBlockCellListPara();
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetBlockCellListPara:check block cell list para error.");

        return result;
    }

    bufLen = sizeof(AT_CSS_BlockCellListSetReq);

    if (g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraValue > AT_CSS_BLOCK_CELL_LIST_SET_REQ_BUFF_LEN) {
        bufLen += g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraValue - AT_CSS_BLOCK_CELL_LIST_SET_REQ_BUFF_LEN;
    }

    /* 申请消息包AT_CSS_CLOUD_BLOCK_LIST_SET_REQ_STRU */
    msg = (AT_CSS_BlockCellListSetReq *)AT_ALLOC_MSG_WITH_HDR(bufLen);

    /* 内存申请失败，返回 */
    if (msg == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetBlockCellListPara:memory alloc fail.");

        return AT_ERROR;
    }

    (VOS_VOID)memset_s((VOS_INT8 *)msg + VOS_MSG_HEAD_LENGTH, bufLen - VOS_MSG_HEAD_LENGTH, 0x00,
        bufLen - VOS_MSG_HEAD_LENGTH);

    /* 填写消息头 */
    AT_CFG_MSG_HDR(msg, PS_PID_CSS, ID_AT_CSS_BLOCK_CELL_LIST_SET_REQ);

    /* 填写消息内容 */
    msg->clientId = g_atClientTab[indexNum].clientId;
    msg->seq      = (VOS_UINT8)g_atParaList[0].paraValue;

    if (g_atParaList[1].paraLen > 0) {
        memResult = memcpy_s(msg->versionId, sizeof(msg->versionId), g_atParaList[1].para, g_atParaList[1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(msg->versionId), g_atParaList[1].paraLen);
    }

    msg->operateType          = (VOS_UINT8)g_atParaList[AT_BLOCKCELLLIST_OPERATION].paraValue;
    msg->ratType              = (VOS_UINT8)g_atParaList[AT_BLOCKCELLLIST_SYSMODE].paraValue;
    msg->blockCellListBuffLen = g_atParaList[AT_BLOCKCELLLIST_LENGTH].paraValue;

    if (msg->blockCellListBuffLen > 0) {
        /* BS1 */
        if (g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen > 0) {
            memResult = memcpy_s(msg->blockCellListBuff, msg->blockCellListBuffLen,
                                 g_atParaList[AT_BLOCKCELLLIST_BS1].para, g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, msg->blockCellListBuffLen, g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen);
        }

        /* BS1未携带完所有的云通信Block小区信息，BS2携带了部分信息 */
        if (msg->blockCellListBuffLen > g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen) {
            if (g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen > 0) {
                memResult = memcpy_s(msg->blockCellListBuff + g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen,
                                     msg->blockCellListBuffLen - g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen,
                                     g_atParaList[AT_BLOCKCELLLIST_BS2].para,
                                     g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, msg->blockCellListBuffLen - g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen,
                                    g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen);
            }

            /* BS1 & BS2未携带完所有的云通信Block小区信息，BS3携带了部分信息 */
            if (msg->blockCellListBuffLen >
                ((VOS_UINT32)g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen +
                 g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen)) {
                if (g_atParaList[AT_BLOCKCELLLIST_BS3].paraLen > 0) {
                    memResult = memcpy_s(msg->blockCellListBuff + g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen +
                                         g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen,
                                         msg->blockCellListBuffLen - g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen -
                                         g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen,
                                         g_atParaList[AT_BLOCKCELLLIST_BS3].para,
                                         g_atParaList[AT_BLOCKCELLLIST_BS3].paraLen);
                    TAF_MEM_CHK_RTN_VAL(memResult,
                                        msg->blockCellListBuffLen - g_atParaList[AT_BLOCKCELLLIST_BS1].paraLen -
                                        g_atParaList[AT_BLOCKCELLLIST_BS2].paraLen,
                                        g_atParaList[AT_BLOCKCELLLIST_BS3].paraLen);
                }
            }
        }
    }

    /* 发送消息，返回命令处理挂起状态 */
    AT_SEND_MSG(msg);

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_BLOCKCELLLIST_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 TAF_MMA_BuildBorderInfo(VOS_UINT32 bsTotalLen, TAF_MMA_BorderInfo *borderInfo)
{
    errno_t    memResult;
    VOS_UINT32 offset;

    /* 流水号 */
    borderInfo->seq = (VOS_UINT8)g_atParaList[1].paraValue;

    /* 版本号 */
    if (g_atParaList[AT_BORDERINFO_VER].paraLen > 0) {
        memResult = memcpy_s(borderInfo->versionId, TAF_MMA_VERSION_INFO_LEN, g_atParaList[AT_BORDERINFO_VER].para,
                             g_atParaList[AT_BORDERINFO_VER].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_VERSION_INFO_LEN, g_atParaList[AT_BORDERINFO_VER].paraLen);
    }

    /* EHPLMN信息 */
    borderInfo->ehPlmnNum = (VOS_UINT8)g_atParaList[AT_BORDERINFO_EHPLMNNUM].paraValue;
    if (AT_ParseEhplmnStringList(g_atParaList[AT_BORDERINFO_EHPLMNLIST].paraLen,
                                 g_atParaList[AT_BORDERINFO_EHPLMNLIST].para, &(borderInfo->ehPlmnNum),
                                 borderInfo->ehPlmnList) == AT_ERROR) {
        AT_ERR_LOG("TAF_MMA_BuildBorderInfo: parse EHPLMN list failed!");
        return VOS_FALSE;
    }

    /* 边境信息 */
    borderInfo->borderInfoLen = bsTotalLen;

    offset = 0;

    /* BS1 */
    if ((borderInfo->borderInfoLen > 0) && (g_atParaList[AT_BORDERINFO_BS1].paraLen > 0)) {
        memResult = memcpy_s(borderInfo->borderInfoBuff, borderInfo->borderInfoLen,
                             g_atParaList[AT_BORDERINFO_BS1].para, g_atParaList[AT_BORDERINFO_BS1].paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, borderInfo->borderInfoLen, g_atParaList[AT_BORDERINFO_BS1].paraLen);
    }

    offset += g_atParaList[AT_BORDERINFO_BS1].paraLen;

    /* BS1 未携带完所有的边境信息，BS2 携带了部分信息 */
    if (bsTotalLen > offset) {

        if (g_atParaList[AT_BORDERINFO_BS2].paraLen > 0) {
            memResult = memcpy_s(borderInfo->borderInfoBuff + offset, g_atParaList[AT_BORDERINFO_BS2].paraLen,
                                 g_atParaList[AT_BORDERINFO_BS2].para, g_atParaList[AT_BORDERINFO_BS2].paraLen);
            TAF_MEM_CHK_RTN_VAL(memResult, g_atParaList[AT_BORDERINFO_BS2].paraLen,
                                g_atParaList[AT_BORDERINFO_BS2].paraLen);
        }

        offset += g_atParaList[AT_BORDERINFO_BS2].paraLen;

        /* BS1 & BS2 未携带完所有的边境信息，BS3 携带了部分信息 */
        if (bsTotalLen > offset) {

            if (g_atParaList[AT_BORDERINFO_BS3].paraLen > 0) {
                memResult = memcpy_s(borderInfo->borderInfoBuff + offset, g_atParaList[AT_BORDERINFO_BS3].paraLen,
                                     g_atParaList[AT_BORDERINFO_BS3].para, g_atParaList[AT_BORDERINFO_BS3].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, g_atParaList[AT_BORDERINFO_BS3].paraLen,
                                    g_atParaList[AT_BORDERINFO_BS3].paraLen);
            }

        }
    }

    return VOS_TRUE;
}


VOS_UINT32 AT_SetBorderInfoPara(VOS_UINT8 indexNum)
{
    TAF_MMA_BorderInfo                   *borderInfo = VOS_NULL_PTR;
    VOS_UINT32                            bsTotalLen;
    VOS_UINT32                            rslt;
    ModemIdUint16                         modemId;
    VOS_UINT8                             i;
    TAF_MMA_SetBorderInfoOperateTypeUint8 operateType;
    VOS_UINT8                             bsCount;

    modemId    = MODEM_ID_0;
    bsTotalLen = 0;

    rslt = AT_GetModemIdFromClient(indexNum, &modemId);

    if (rslt != VOS_OK) {
        AT_ERR_LOG("AT_SetBorderInfoPara: Get modem id fail.");
        return AT_ERROR;
    }

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 操作类型 0:增加 1:删除所有 */
    operateType = (TAF_MMA_SetBorderInfoOperateTypeUint8)g_atParaList[AT_BORDERINFO_OPERTION_TYPE].paraValue;

    /* 参数个数或者VER长度不正确 */
    if (operateType == TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ADD) {
        if ((g_atParaIndex > AT_BORDERINFO_MAX_PARA_NUM) || (g_atParaIndex < AT_BORDERINFO_MIN_PARA_NUM) ||
            (g_atParaList[AT_BORDERINFO_VER].paraLen != MCC_INFO_VERSION_LEN)) {
            AT_ERR_LOG("AT_SetBorderInfoPara:number of parameter error.");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /* ucBsCount的有效性AT框架已经有合法性检查，此处不再检查 */
        bsCount = (VOS_UINT8)g_atParaList[AT_BORDERINFO_COUNT].paraValue;

        for (i = 0; i < bsCount; i++) {
            bsTotalLen += (VOS_UINT32)g_atParaList[AT_BORDERINFO_BS1 + i].paraLen;
        }

    } else {
        bsTotalLen = TAF_MMA_BODER_INFO_BUFF_LEN;
    }

    /* 申请TAF_MMA_BorderInfo结构体 */
    /*lint -save -e516 */
    borderInfo = (TAF_MMA_BorderInfo *)PS_MEM_ALLOC(WUEPS_PID_AT,
        sizeof(TAF_MMA_BorderInfo) + bsTotalLen - TAF_MMA_BODER_INFO_BUFF_LEN);
    /*lint -restore */
    if (borderInfo == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetBorderInfoPara: Memory malloc failed!");
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(borderInfo, sizeof(TAF_MMA_BorderInfo) + bsTotalLen - TAF_MMA_BODER_INFO_BUFF_LEN, 0x00,
        sizeof(TAF_MMA_BorderInfo) + bsTotalLen - TAF_MMA_BODER_INFO_BUFF_LEN);

    /* 填写边境信息结构体:删除时不需要这些信息 */
    if (operateType == TAF_MMA_SET_BORDER_INFO_OPERATE_TYPE_ADD) {
        if (TAF_MMA_BuildBorderInfo(bsTotalLen, borderInfo) == VOS_FALSE) {
            /*lint -save -e516 */
            PS_MEM_FREE(WUEPS_PID_AT, borderInfo);
            /*lint -restore */
            return AT_ERROR;
        }
    }

    rslt = TAF_MMA_SetBorderInfoReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, operateType, borderInfo);

    if (rslt != VOS_TRUE) {
        AT_ERR_LOG("AT_SetBorderInfoPara: snd msg failed!");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, borderInfo);
        /*lint -restore */
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_BORDERINFO_SET;
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, borderInfo);
    /*lint -restore */
    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_ParseDplmnLengthIllegal(VOS_UINT16 subStrLen)
{
    /* Dplmn长度不合法 */
    if ((subStrLen != AT_DPLMN_LEN_FIVE) && (subStrLen != AT_DPLMN_LEN_SIX)) {
        AT_ERR_LOG("AT_ParseDplmnLengthIllegal: dplmn len error");
        return AT_ERROR;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParseDplmnStringList(VOS_UINT8 indexNum, VOS_UINT8 *dplmnString, TAF_MMA_DplmnInfoSet *dplmnInfoSet)
{
    VOS_UINT8  *subStr     = VOS_NULL_PTR;
    VOS_CHAR   *nextSubStr = VOS_NULL_PTR;
    VOS_UINT8   dilms[]    = ",";
    VOS_UINT16  subStrLen;
    VOS_UINT16  indexValue;
    VOS_UINT32  dplmnNum;
    VOS_UINT32  simRat;
    errno_t     memResult;
    TAF_PLMN_Id plmnId;

    subStr     = (VOS_UINT8 *)strtok_s((VOS_CHAR *)dplmnString, (const VOS_CHAR *)dilms, &nextSubStr);
    dplmnNum   = 0;
    indexValue = 0;
    simRat     = 0;

    /* 解析预置Dplmn & SimRat组合的个数 */
    if (subStr != VOS_NULL_PTR) {
        subStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR *)subStr);
        if (AT_String2Hex((TAF_UINT8 *)subStr, subStrLen, &dplmnNum) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mnc error");
            return AT_ERROR;
        }
        subStr = (VOS_UINT8 *)strtok_s(VOS_NULL_PTR, (const VOS_CHAR *)dilms, &nextSubStr);
    }

    dplmnInfoSet->dplmnNum = (VOS_UINT16)dplmnNum;

    if (subStr == VOS_NULL_PTR) {
        dplmnInfoSet->dplmnNum = 0;
    }

    while (subStr != VOS_NULL_PTR) {
        subStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR *)subStr);

        /* Dplmn长度不合法 */
        if (AT_ParseDplmnLengthIllegal(subStrLen) == AT_ERROR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn len error");
            return AT_ERROR;
        }

        /* Dplmn Mcc */
        if (AT_String2Hex(subStr, AT_MCC_LENGTH, &plmnId.mcc) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mcc error");
            return AT_ERROR;
        }

        /* Dplmn Mnc */
        if (AT_String2Hex(&subStr[AT_SUB_STR_INDEX_3], subStrLen - AT_MCC_LENGTH, &plmnId.mnc) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn mnc error");
            return AT_ERROR;
        }

        plmnId.mcc &= 0x0FFF;

        if (subStrLen == AT_DPLMN_LEN_FIVE) {
            plmnId.mnc |= 0x0F00;
        }

        plmnId.mnc &= 0x0FFF;

        /* 解析出来的Dplmn是无效的Plmn */
        if (AT_PH_IsPlmnValid(&plmnId) == VOS_FALSE) {
            AT_ERR_LOG("AT_ParseDplmnStringList: dplmn is invalid");
            return AT_ERROR;
        }

        /* Dplmn Sim Rat */
        subStr = (VOS_UINT8 *)strtok_s(VOS_NULL_PTR, (const VOS_CHAR *)dilms, &nextSubStr);

        if (subStr == VOS_NULL_PTR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: no sim rat");
            return AT_ERROR;
        }

        subStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR *)subStr);

        if (AT_String2Hex(subStr, subStrLen, &simRat) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseDplmnStringList: parse sim rat error");
            return AT_ERROR;
        }

        /* AP预置的Dplmn的Simrat为无效值 */
        if ((simRat == AT_AP_PRESET_DPLMN_INVALID_RAT) || (simRat > AT_AP_PRESET_DPLMN_ALL_RAT)) {
            AT_ERR_LOG("AT_ParseDplmnStringList: sim rat invalid");
            return AT_ERROR;
        }

        memResult = memcpy_s(&(dplmnInfoSet->dplmnList[indexValue].plmnId),
                             sizeof(dplmnInfoSet->dplmnList[indexValue].plmnId), &plmnId, sizeof(TAF_PLMN_Id));
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(dplmnInfoSet->dplmnList[indexValue].plmnId), sizeof(TAF_PLMN_Id));
        dplmnInfoSet->dplmnList[indexValue].simRat = (VOS_UINT16)simRat;
        indexValue++;

        if (dplmnInfoSet->dplmnNum <= indexValue) {
            break;
        }

        subStr = (VOS_UINT8 *)strtok_s(VOS_NULL_PTR, (const VOS_CHAR *)dilms, &nextSubStr);
    }

    if (dplmnInfoSet->dplmnNum > indexValue) {
        dplmnInfoSet->dplmnNum = indexValue;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParseEhplmnStringList(VOS_UINT32 paraLen, VOS_UINT8 *para, VOS_UINT8 *ehPlmnNum, TAF_PLMN_Id *ehplmnList)
{
    TAF_PLMN_Id plmnId;
    VOS_UINT16  indexNum;
    VOS_UINT16  subStrLen;
    VOS_UINT8 ehplmnStr[TAF_MMA_MAX_EHPLMN_STR + 1] = {0};
    VOS_UINT8 *subStr     = VOS_NULL_PTR;
    VOS_CHAR  *nextSubStr = VOS_NULL_PTR;
    VOS_UINT8  dilms[]    = ",";
    VOS_UINT32 len;
    errno_t    memResult;

    len = paraLen;

    if (len > TAF_MMA_MAX_EHPLMN_STR) {
        len = TAF_MMA_MAX_EHPLMN_STR;
    }

    if (len > 0) {
        memResult = memcpy_s(ehplmnStr, sizeof(ehplmnStr), para, len);
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(ehplmnStr), len);
    }

    subStr   = (VOS_UINT8 *)strtok_s((VOS_CHAR *)ehplmnStr, (const VOS_CHAR *)dilms, &nextSubStr);
    indexNum = 0;

    while (subStr != VOS_NULL_PTR) {
        subStrLen = (VOS_UINT16)AT_STRLEN((VOS_CHAR *)subStr);

        if ((subStrLen != AT_EHPLMN_LEN_FIVE) && (subStrLen != AT_EHPLMN_LEN_SIX)) {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn len error");
            return AT_ERROR;
        }

        /* Ehplmn Mcc */
        if (AT_String2Hex(subStr, AT_MCC_LENGTH, &plmnId.mcc) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn mcc error");
            return AT_ERROR;
        }

        /* Ehplmn Mnc */
        if (AT_String2Hex(&subStr[AT_SUB_STR_INDEX_3], subStrLen - AT_MCC_LENGTH, &plmnId.mnc) == VOS_ERR) {
            AT_ERR_LOG("AT_ParseEhplmnStringList: ehplmn mnc error");
            return AT_ERROR;
        }

        plmnId.mcc &= 0x0FFF;

        if (subStrLen == AT_EHPLMN_LEN_FIVE) {
            plmnId.mnc |= 0x0F00;
        }

        plmnId.mnc &= 0x0FFF;

        /* 解析出来的Ehplmn是无效的Plmn */
        if (AT_PH_IsPlmnValid(&plmnId) == VOS_FALSE) {
            AT_ERR_LOG("AT_ParseEhplmnStringList: plmn is invalid");
            return AT_ERROR;
        }

        memResult = memcpy_s(&(ehplmnList[indexNum]), sizeof(TAF_PLMN_Id), &plmnId, sizeof(TAF_PLMN_Id));
        indexNum++;
        TAF_MEM_CHK_RTN_VAL(memResult, sizeof(TAF_PLMN_Id), sizeof(TAF_PLMN_Id));

        if (*ehPlmnNum <= indexNum) {
            break;
        }

        subStr = (VOS_UINT8 *)strtok_s(VOS_NULL_PTR, (const VOS_CHAR *)dilms, &nextSubStr);
    }

    if (*ehPlmnNum > indexNum) {
        *ehPlmnNum = (VOS_UINT8)indexNum;
    }

    return AT_SUCCESS;
}

VOS_UINT32 AT_DplmnFillDplmnString(VOS_UINT8 numDplmnSubStr, VOS_UINT8 *dplmnString, TAF_MMA_DplmnInfoSet *dplmnInfo)
{
    errno_t memResult;

    switch (numDplmnSubStr) {
        case AT_UCNUMDPLMNSUB_NUM1:
            if ((g_atParaList[AT_DPLMNLIST_BS1].paraLen > 0) &&
                (g_atParaList[AT_DPLMNLIST_BS1].paraLen <= TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString, TAF_MMA_MAX_STR_LEN, (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS1].para,
                                     g_atParaList[AT_DPLMNLIST_BS1].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_STR_LEN, g_atParaList[AT_DPLMNLIST_BS1].paraLen);
            }
            break;

        case AT_UCNUMDPLMNSUB_NUM2:
            if ((g_atParaList[AT_DPLMNLIST_BS1].paraLen > 0) &&
                (g_atParaList[AT_DPLMNLIST_BS1].paraLen <= TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString, TAF_MMA_MAX_STR_LEN, (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS1].para,
                                     g_atParaList[AT_DPLMNLIST_BS1].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_STR_LEN, g_atParaList[AT_DPLMNLIST_BS1].paraLen);
            }
            if ((g_atParaList[AT_DPLMNLIST_BS2].paraLen > 0) &&
                ((g_atParaList[AT_DPLMNLIST_BS2].paraLen + g_atParaList[AT_DPLMNLIST_BS1].paraLen ) <=
                  TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString + g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                     TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                     (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS2].para,
                                     g_atParaList[AT_DPLMNLIST_BS2].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                    g_atParaList[AT_DPLMNLIST_BS2].paraLen);
            }
            break;

        case AT_UCNUMDPLMNSUB_NUM3:
            if ((g_atParaList[AT_DPLMNLIST_BS1].paraLen > 0) &&
                (g_atParaList[AT_DPLMNLIST_BS1].paraLen <= TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString, TAF_MMA_MAX_STR_LEN,
                                     (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS1].para,
                                     g_atParaList[AT_DPLMNLIST_BS1].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_STR_LEN, g_atParaList[AT_DPLMNLIST_BS1].paraLen);
            }
            if ((g_atParaList[AT_DPLMNLIST_BS2].paraLen > 0) &&
                ((g_atParaList[AT_DPLMNLIST_BS2].paraLen + g_atParaList[AT_DPLMNLIST_BS1].paraLen) <=
                 TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString + g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                     TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                     (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS2].para,
                                     g_atParaList[AT_DPLMNLIST_BS2].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen,
                                    g_atParaList[AT_DPLMNLIST_BS2].paraLen);
            }
            if ((g_atParaList[AT_DPLMNLIST_BS3].paraLen > 0) &&
                ((g_atParaList[AT_DPLMNLIST_BS1].paraLen + g_atParaList[AT_DPLMNLIST_BS2].paraLen +
                 g_atParaList[AT_DPLMNLIST_BS3].paraLen) <= TAF_MMA_MAX_STR_LEN)) {
                memResult = memcpy_s(dplmnString + g_atParaList[AT_DPLMNLIST_BS1].paraLen +
                                        g_atParaList[AT_DPLMNLIST_BS2].paraLen,
                                     TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen -
                                        g_atParaList[AT_DPLMNLIST_BS2].paraLen,
                                     (VOS_UINT8 *)g_atParaList[AT_DPLMNLIST_BS3].para,
                                     g_atParaList[AT_DPLMNLIST_BS3].paraLen);
                TAF_MEM_CHK_RTN_VAL(memResult,
                                    TAF_MMA_MAX_STR_LEN - g_atParaList[AT_DPLMNLIST_BS1].paraLen -
                                    g_atParaList[AT_DPLMNLIST_BS2].paraLen,
                                    g_atParaList[AT_DPLMNLIST_BS3].paraLen);
            }
            break;

        default:
            AT_ERR_LOG("AT_SetDplmnListPara: ucNumDplmnSubStr error!");
            return AT_ERROR;
    }

    return AT_OK;
}

VOS_UINT32 AT_DplmnListParaCheck(VOS_VOID)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数不正确 */
    if (g_atParaIndex < AT_DPLMNLIST_MIN_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 版本号长度不对 */
    if (g_atParaList[AT_DPLMNLIST_VER].paraLen != TAF_MMA_VERSION_INFO_LEN) {
        AT_ERR_LOG("AT_SetDplmnListPara: incorrect version length ");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    return AT_OK;
}

VOS_UINT32 AT_SetDplmnListPara(VOS_UINT8 indexNum)
{
    errno_t               memResult;
    VOS_UINT8             seq;
    VOS_UINT32            rst;
    VOS_UINT8             versionId[TAF_MMA_VERSION_INFO_LEN];
    TAF_MMA_DplmnInfoSet *dplmnInfo   = VOS_NULL_PTR;
    VOS_UINT8            *dplmnString = VOS_NULL_PTR;
    VOS_UINT8             numDplmnSubStr;

    rst = AT_DplmnListParaCheck();
    if (rst != AT_OK) {
        return rst;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DPLMNLIST_SET;

    /* 填充流水号 */
    seq = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 填充版本号 */
    memResult = memcpy_s(versionId, sizeof(versionId), g_atParaList[AT_DPLMNLIST_VER].para,
        g_atParaList[AT_DPLMNLIST_VER].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, sizeof(versionId), g_atParaList[AT_DPLMNLIST_VER].paraLen);

    /* 申请DPLMN INFO SET结构体 */
    /*lint -save -e516 */
    dplmnInfo = (TAF_MMA_DplmnInfoSet *)PS_MEM_ALLOC(WUEPS_PID_AT, sizeof(TAF_MMA_DplmnInfoSet));
    /*lint -restore */

    if (dplmnInfo == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetDplmnListPara: Memory malloc failed!");
        return AT_ERROR;
    }

    /* 申请空间将分片的Dplmn String组合成一条完整的字符串 */
    /*lint -save -e516 */
    dplmnString = (VOS_UINT8 *)PS_MEM_ALLOC(WUEPS_PID_AT, TAF_MMA_MAX_STR_LEN * sizeof(VOS_UINT8));
    /*lint -restore */
    if (dplmnString == VOS_NULL_PTR) {
        AT_ERR_LOG("AT_SetDplmnListPara: Memory malloc failed!");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        /*lint -restore */
        return AT_ERROR;
    }

    (VOS_VOID)memset_s(dplmnInfo, sizeof(TAF_MMA_DplmnInfoSet), 0x00, sizeof(TAF_MMA_DplmnInfoSet));

    (VOS_VOID)memset_s(dplmnString, TAF_MMA_MAX_STR_LEN * sizeof(VOS_UINT8), 0x00, TAF_MMA_MAX_STR_LEN * sizeof(VOS_UINT8));
    numDplmnSubStr = (VOS_UINT8)g_atParaList[AT_DPLMNLIST_BSCOUNT].paraValue;

    if ((g_atParaList[AT_DPLMNLIST_BS1].paraLen + g_atParaList[AT_DPLMNLIST_BS2].paraLen +
        g_atParaList[AT_DPLMNLIST_BS3].paraLen) > TAF_MMA_MAX_STR_LEN) {
        AT_ERR_LOG("AT_SetDplmnListPara: para len error!");
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    rst = AT_DplmnFillDplmnString(numDplmnSubStr, dplmnString, dplmnInfo);
    if (rst != AT_OK) {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
        /*lint -restore */
        return rst;
    }

    /* Ehplmn解析 */
    dplmnInfo->ehPlmnNum = (VOS_UINT8)g_atParaList[AT_DPLMNLIST_EHPLMNNUM].paraValue;

    if (AT_ParseEhplmnStringList(g_atParaList[AT_DPLMNLIST_EHPLMN].paraLen,
                                 g_atParaList[AT_DPLMNLIST_EHPLMN].para, &(dplmnInfo->ehPlmnNum),
                                 dplmnInfo->ehPlmnInfo) == AT_ERROR) {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    /* Dplmn */
    if (AT_ParseDplmnStringList(indexNum, dplmnString, dplmnInfo) == AT_ERROR) {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
        /*lint -restore */
        return AT_ERROR;
    }

    rst = TAF_MMA_SetDplmnListReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, seq, versionId, dplmnInfo);

    if (rst != VOS_TRUE) {
        /*lint -save -e516 */
        PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
        PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
        /*lint -restore */
        return AT_ERROR;
    }
    /*lint -save -e516 */
    PS_MEM_FREE(WUEPS_PID_AT, dplmnInfo);
    PS_MEM_FREE(WUEPS_PID_AT, dplmnString);
    /*lint -restore */
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_MULTI_MODEM == FEATURE_ON)

VOS_UINT32 AT_ExchangeModemInfo(VOS_UINT8 indexNum)
{
    VOS_UINT32    rst;
    ModemIdUint16 firstModemId;
    ModemIdUint16 secondModemId;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("AT_ExchangeModemInfo: NOT AT_CMD_OPT_SET_PARA_CMD!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数长度为0，返回错误 */
    if ((g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID1].paraLen == 0) ||
        (g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID2].paraLen == 0)) {
        AT_WARN_LOG("AT_ExchangeModemInfo: para len is 0!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数不正确 */
    if (g_atParaIndex != AT_EXCHANGEMODEMINFO_PARA_NUM) {
        AT_WARN_LOG("AT_ExchangeModemInfo: para num is wrong!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 两个modemID相同，返回错误 */
    if (g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID1].paraValue ==
        g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID2].paraValue) {
        AT_WARN_LOG("AT_ExchangeModemInfo: two modem ID is the same!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    firstModemId  = (ModemIdUint16)g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID1].paraValue;
    secondModemId = (ModemIdUint16)g_atParaList[AT_EXCHANGEMODEMINFO_MODEMID2].paraValue;

    /* modemID值无效，返回错误 */
    if ((firstModemId >= MODEM_ID_BUTT) || (secondModemId >= MODEM_ID_BUTT)) {
        AT_WARN_LOG("AT_ExchangeModemInfo: modem ID is butt!");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    rst = TAF_MMA_ExchangeModemInfoReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, firstModemId, secondModemId);

    if (rst != VOS_TRUE) {
        AT_ERR_LOG("AT_ExchangeModemInfo: snd msg failed!");
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_EXCHANGE_MODEM_INFO_SET;

    return AT_WAIT_ASYNC_RETURN;
}
#endif

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetCdmaDormantTimer(VOS_UINT8 indexNum)
{
    VOS_UINT8 dormantTimer;

    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    dormantTimer = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 执行命令操作 */
    if (TAF_PS_SetCdmaDormantTimer(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                   dormantTimer) != VOS_OK) {
        return AT_ERROR;
    }

    /* 设置当前操作类型 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_DORMTIMER_SET;

    /* 返回命令处理挂起状态 */
    return AT_WAIT_ASYNC_RETURN;
}
#endif

VOS_UINT32 AT_SetUECenterPara(VOS_UINT8 indexNum)
{
    AT_MTA_SetUeCenterReq setUeCenterInfo;
    VOS_UINT32            rst;

    (VOS_VOID)memset_s(&setUeCenterInfo, sizeof(setUeCenterInfo), 0x00, sizeof(AT_MTA_SetUeCenterReq));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        setUeCenterInfo.ueCenter = 0;
    } else {
        setUeCenterInfo.ueCenter = g_atParaList[0].paraValue;
    }

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UE_CENTER_SET_REQ,
                                 (VOS_UINT8 *)&setUeCenterInfo, sizeof(AT_MTA_SetUeCenterReq), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UE_CENTER_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetQuickCardSwitchPara(VOS_UINT8 indexNum)
{
    AT_MTA_SetQuickCardSwitchReq quickCardSwitchInfo;
    TAF_MMA_IsSamePlmnFlagUint8  isSamePlmnInfo;
    VOS_UINT32                   rst;

    (VOS_VOID)memset_s(&quickCardSwitchInfo, sizeof(AT_MTA_SetQuickCardSwitchReq), 0x00, sizeof(AT_MTA_SetQuickCardSwitchReq));

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    quickCardSwitchInfo.isSameFlag = (VOS_UINT8)g_atParaList[0].paraValue;
    isSamePlmnInfo = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 通知MMA双卡切换场景信息 */
    TAF_MMA_CardQuickSwitchNotify(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, isSamePlmnInfo);

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_QUICK_CARD_SWITCH_REQ,
                                 (VOS_UINT8 *)&quickCardSwitchInfo, sizeof(AT_MTA_SetQuickCardSwitchReq), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_QUICK_CARD_SWITCH_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        return AT_ERROR;
    }
}

#if (FEATURE_UE_MODE_CDMA == FEATURE_ON)

VOS_UINT32 AT_SetHdrCsqPara(VOS_UINT8 indexNum)
{
    TAF_MMA_HdrCsqPara hdrCsqPara;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaIndex != AT_HDRCSQ_PARA_NUM) || (g_atParaList[AT_HDRCSQ_MODE].paraLen == 0) ||
        (g_atParaList[AT_HDRCSQ_TIME_INTERVAL].paraLen == 0) ||
        (g_atParaList[AT_HDRCSQ_RSSI_RPT_THRE].paraLen == 0) ||
        (g_atParaList[AT_HDRCSQ_SNR_RPT_THRE].paraLen  == 0) ||
        (g_atParaList[AT_HDRCSQ_ECIO_RPT_THRE].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&hdrCsqPara, sizeof(hdrCsqPara), 0x00, sizeof(TAF_MMA_HdrCsqPara));
    hdrCsqPara.mode          = (TAF_UINT8)g_atParaList[AT_HDRCSQ_MODE].paraValue;
    hdrCsqPara.timeInterval  = (TAF_UINT8)g_atParaList[AT_HDRCSQ_TIME_INTERVAL].paraValue;
    hdrCsqPara.rssiThreshold = (TAF_UINT8)g_atParaList[AT_HDRCSQ_RSSI_RPT_THRE].paraValue;
    hdrCsqPara.snrThreshold  = (TAF_UINT8)g_atParaList[AT_HDRCSQ_SNR_RPT_THRE].paraValue;
    hdrCsqPara.ecioThreshold = (TAF_UINT8)g_atParaList[AT_HDRCSQ_ECIO_RPT_THRE].paraValue;

    if (TAF_MMA_ProcHdrCsqSetReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, &hdrCsqPara) == VOS_TRUE) {
        /* 设置当前操作类型 */
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_HDR_CSQ_SET;
        return AT_WAIT_ASYNC_RETURN; /* 返回命令处理挂起状态 */
    }

    return AT_ERROR;
}
#endif

VOS_UINT32 At_SetSensorPara(VOS_UINT8 indexNum)
{
    VOS_UINT32          rst;
    AT_MTA_SetSensorReq sensorStat;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("At_SetSensorPara: Incorrect Cmd Type.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((g_atParaList[0].paraLen == 0) || (g_atParaIndex != 1)) {
        AT_WARN_LOG("At_SetSensorPara: Incorrect Param Length.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&sensorStat, sizeof(sensorStat), 0x00, sizeof(sensorStat));

    sensorStat.sensorStat = g_atParaList[0].paraValue;

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_SET_SENSOR_REQ,
                                 (VOS_UINT8 *)&sensorStat, sizeof(sensorStat), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SENSOR_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("At_SetSensorPara: Send msg fail!");
        return AT_ERROR;
    }
}


LOCAL VOS_VOID AT_SendCssScreenStatusInd(VOS_UINT8 status)
{
    AT_CSS_ScreenStatusInd *msg = VOS_NULL_PTR;
    VOS_UINT32              bufLen;

    bufLen = sizeof(AT_CSS_ScreenStatusInd);

    msg = (AT_CSS_ScreenStatusInd *)AT_ALLOC_MSG_WITH_HDR(bufLen);

    /* 内存申请失败，返回 */
    if (msg == VOS_NULL_PTR) {
        AT_ERR_LOG("msg alloc fail.");
        return;
    }

    (VOS_VOID)memset_s((VOS_UINT8 *)msg + VOS_MSG_HEAD_LENGTH, bufLen - VOS_MSG_HEAD_LENGTH, 0x00, bufLen -
        VOS_MSG_HEAD_LENGTH);

    /* 填写消息头 */
    AT_CFG_MSG_HDR(msg, PS_PID_CSS, ID_AT_CSS_SCREEN_STATUS_IND);
    /* 填写消息内容 */
    msg->status = status;

    /* 发送消息 */
    AT_SEND_MSG(msg);
}


VOS_UINT32 At_SetScreenPara(VOS_UINT8 indexNum)
{
    VOS_UINT32          rst;
    AT_MTA_SetScreenReq screenStat;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("At_SetScreenPara: Incorrect Cmd Type.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((g_atParaList[0].paraLen != 1) || (g_atParaIndex != 1)) {
        AT_WARN_LOG("At_SetScreenPara: Incorrect Param Length.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 初始化 */
    (VOS_VOID)memset_s(&screenStat, sizeof(screenStat), 0, sizeof(screenStat));

    screenStat.screenStat = (VOS_UINT8)g_atParaList[0].paraValue;

    AT_SendCssScreenStatusInd(screenStat.screenStat);

    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_SET_SCREEN_REQ,
                                 (VOS_UINT8 *)&screenStat, sizeof(screenStat), I0_UEPS_PID_MTA);

    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SCREEN_SET;
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("At_SetScreenPara: Send msg fail!");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetPcuiCtrlConcurrentFlagForTest(VOS_UINT8 indexNum)
{
    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if ((g_atParaIndex != 1) || (g_atParaList[0].paraLen == 0)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    AT_SetPcuiCtrlConcurrentFlag((VOS_UINT8)(g_atParaList[0].paraValue));
    return AT_OK;
}


VOS_UINT32 AT_SetFclassPara(VOS_UINT8 indexNum)
{
    AT_WARN_LOG("AT_SetFclassPara: Not support this command!");
    (VOS_VOID)indexNum;
    return AT_ERROR;
}


VOS_UINT32 AT_SetGciPara(VOS_UINT8 indexNum)
{
    AT_WARN_LOG("AT_SetGciPara: Not support this command!");
    (VOS_VOID)indexNum;
    return AT_ERROR;
}



VOS_UINT32 AT_SetBestFreqPara(VOS_UINT8 indexNum)
{
    AT_MTA_BestfreqSetReq bestFreqSetReq;
    VOS_UINT32            rslt;
    ModemIdUint16         modemId;

    /* 指令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("AT_SetBestFreqPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数或长度不正确 */
    if ((g_atParaIndex != AT_BESTFREQ_PARA_NUM) || (g_atParaList[AT_BESTFREQ_DEVICEID].paraLen == 0) ||
        (g_atParaList[AT_BESTFREQ_MODE].paraLen == 0)) {
        AT_WARN_LOG("AT_SetBestFreqPara : The number of input parameters is error.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&bestFreqSetReq, sizeof(bestFreqSetReq), 0x00, sizeof(AT_MTA_BestfreqSetReq));
    modemId = MODEM_ID_BUTT;

    /* 通过clientID获得ModemID */
    rslt = AT_GetModemIdFromClient(g_atClientTab[indexNum].clientId, &modemId);

    /* 如果ModemID获取失败或不在Modem0，返回失败 */
    if ((rslt != VOS_OK) || (modemId != MODEM_ID_0)) {
        AT_WARN_LOG("AT_SetBestFreqPara: AT_GetModemIdFromClient failed or not modem0!");
        return AT_ERROR;
    }

    /* 填写消息 */
    bestFreqSetReq.deviceId = (VOS_UINT8)g_atParaList[AT_BESTFREQ_DEVICEID].paraValue;
    bestFreqSetReq.mode     = (VOS_UINT8)g_atParaList[AT_BESTFREQ_MODE].paraValue;

    /* 发送跨核消息到C核, 设置侦听测试模式 */
    rslt = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                  ID_AT_MTA_BESTFREQ_SET_REQ, (VOS_UINT8 *)&bestFreqSetReq,
                                  (VOS_SIZE_T)sizeof(bestFreqSetReq), I0_UEPS_PID_MTA);

    if (rslt != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetBestFreqPara: AT_FillAndSndAppReqMsg fail.");
        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_BESTFREQ_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_CheckPseucellInfoParaLen(VOS_VOID)
{
    /* 如果notify type长度为0，返回错误 */
    if (g_atParaList[AT_PSEUCELL_NOTIFY_TYPE].paraLen == 0) {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Pseucell Notify Type Len is error.");

        return AT_ERROR;
    }

    /* 如果sys mode长度为0，返回错误 */
    if (g_atParaList[AT_PSEUCELL_RAT].paraLen == 0) {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : sys mode Len is error.");

        return AT_ERROR;
    }

    /* PLMN参数长度不等于5也不等于6，返回错误 */
    if ((g_atParaList[AT_PSEUCELL_PLMN].paraLen != AT_MTA_PSEUCELL_PLMN_LEN_FIVE) &&
        (g_atParaList[AT_PSEUCELL_PLMN].paraLen != AT_MTA_PSEUCELL_PLMN_LEN_SIX)) {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Plmn Len is error.");

        return AT_ERROR;
    }

    /*  LAC参数长度不等于4，返回错误 */
    if (g_atParaList[AT_PSEUCELL_LAC].paraLen != AT_MTA_PSEUCELL_LAC_LEN) {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : Lac Len is error.");

        return AT_ERROR;
    }

    /*  CellId参数长度大于8，或者长度为0，返回错误 */
    if (g_atParaList[AT_PSEUCELL_CELLID].paraLen != AT_MTA_PSEUCELL_CELLID_LEN) {
        AT_WARN_LOG("AT_CheckPseucellInfoParaLen : CellId Len is error.");

        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_ParsePseucellInfoMccMnc(VOS_UINT8 *para, VOS_UINT16 paraLen, VOS_UINT32 *mcc, VOS_UINT32 *mnc)
{
    errno_t    memResult;
    VOS_UINT32 tempMcc;
    VOS_UINT32 tempMnc;
    VOS_UINT32 mncLen;
    VOS_UINT8  plmnStr[AT_MTA_PSEUCELL_PLMN_LEN_SIX];

    tempMcc = 0;
    tempMnc = 0;

    mncLen = (VOS_UINT32)paraLen - AT_MTA_PLMN_MCC_LEN;

    (VOS_VOID)memset_s(plmnStr, sizeof(plmnStr), 0, sizeof(plmnStr));

    if ((paraLen > 0) && (paraLen <= AT_MTA_PSEUCELL_PLMN_LEN_SIX)) {
        memResult = memcpy_s(plmnStr, AT_MTA_PSEUCELL_PLMN_LEN_SIX, para, paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_MTA_PSEUCELL_PLMN_LEN_SIX, paraLen);
    }

    if (AT_String2Hex(plmnStr, AT_MTA_PLMN_MCC_LEN, &tempMcc) == VOS_ERR) {
        AT_WARN_LOG("AT_ParsePseucellInfoMccMnc : Mcc is error.");

        return AT_ERROR;
    }

    if (AT_String2Hex(plmnStr + AT_MTA_PLMN_MCC_LEN, (VOS_UINT16)mncLen, &tempMnc) == VOS_ERR) {
        AT_WARN_LOG("AT_ParsePseucellInfoMccMnc : Mnc is error.");

        return AT_ERROR;
    }

    /* 将MCC转化为NAS类型 */
    AT_ConvertMccToNasType(tempMcc, mcc);

    /* 将MNC转化为NAS类型 */
    if (mncLen == AT_MTA_PLMN_MNC_LEN_TWO) {
        tempMnc |= 0x00000F00;
    } else {
        tempMnc &= 0x00000FFF;
    }

    AT_ConvertMncToNasType(tempMnc, mncLen, mnc);

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParsePseucellInfoLac(VOS_UINT8 *para, VOS_UINT16 paraLen, VOS_UINT32 *lac)
{
    VOS_UINT8 lacStr[AT_MTA_PSEUCELL_LAC_LEN];
    errno_t   memResult;

    (VOS_VOID)memset_s(lacStr, sizeof(lacStr), 0, sizeof(lacStr));

    if ((paraLen > 0) && (paraLen <= AT_MTA_PSEUCELL_LAC_LEN)) {
        memResult = memcpy_s(lacStr, AT_MTA_PSEUCELL_LAC_LEN, para, paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_MTA_PSEUCELL_LAC_LEN, paraLen);
    }

    if (AT_String2Hex(lacStr, paraLen, lac) == VOS_ERR) {
        AT_WARN_LOG("AT_ParsePseucellInfoLac : Lac is error.");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_ParsePseucellInfoCellId(VOS_UINT8 *para, VOS_UINT16 paraLen, VOS_UINT32 *cellId)
{
    VOS_UINT8 cellIdStr[AT_MTA_PSEUCELL_CELLID_LEN];
    errno_t   memResult;

    (VOS_VOID)memset_s(cellIdStr, sizeof(cellIdStr), 0, sizeof(cellIdStr));

    if ((paraLen > 0) && (paraLen <= AT_MTA_PSEUCELL_CELLID_LEN)) {
        memResult = memcpy_s(cellIdStr, AT_MTA_PSEUCELL_CELLID_LEN, para, paraLen);
        TAF_MEM_CHK_RTN_VAL(memResult, AT_MTA_PSEUCELL_CELLID_LEN, paraLen);
    }

    paraLen = (VOS_UINT16)AT_MIN(paraLen, AT_MTA_PSEUCELL_CELLID_LEN);

    if (AT_String2Hex(cellIdStr, paraLen, cellId) == VOS_ERR) {
        AT_WARN_LOG("AT_ParsePseucellInfoCellId : CellId is error.");

        return AT_ERROR;
    }

    return AT_SUCCESS;
}


VOS_UINT32 AT_SetPseucellInfoPara(VOS_UINT8 indexNum)
{
    AT_MTA_PseucellInfoSetReq pseucellInfoSetReq;
    VOS_UINT32                result;

    result = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者过少 */
    if (g_atParaIndex != AT_PSEUCELL_PARA_NUM) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Para Num is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 检查输入参数长度是否正确 */
    if (AT_CheckPseucellInfoParaLen() == AT_ERROR) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : para len is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 不是GSM模式，回应参数错误 */
    if (g_atParaList[AT_PSEUCELL_RAT].paraValue != AT_MTA_SYS_MODE_GSM) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : Not GSM.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&pseucellInfoSetReq, sizeof(pseucellInfoSetReq), 0x00, sizeof(pseucellInfoSetReq));

    /* 解析MCC和MNC */
    if (AT_ParsePseucellInfoMccMnc(g_atParaList[AT_PSEUCELL_PLMN].para,
                                   g_atParaList[AT_PSEUCELL_PLMN].paraLen,
                                   &pseucellInfoSetReq.mcc,
                                   &pseucellInfoSetReq.mnc) == AT_ERROR) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse mcc mnc error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析LAC */
    if (AT_ParsePseucellInfoLac(g_atParaList[AT_PSEUCELL_LAC].para,
                                g_atParaList[AT_PSEUCELL_LAC].paraLen, &pseucellInfoSetReq.lac) == AT_ERROR) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse lac error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 解析CellId */
    if (AT_ParsePseucellInfoCellId(g_atParaList[AT_PSEUCELL_CELLID].para, g_atParaList[AT_PSEUCELL_CELLID].paraLen,
                                   &pseucellInfoSetReq.cellId) == AT_ERROR) {
        AT_WARN_LOG("AT_SetPseucellInfoPara : parse cellid error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    pseucellInfoSetReq.pseucellNotifyType = (VOS_UINT8)g_atParaList[AT_PSEUCELL_NOTIFY_TYPE].paraValue;
    pseucellInfoSetReq.sysmode            = g_atParaList[AT_PSEUCELL_RAT].paraValue;

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_PSEUCELL_INFO_SET_REQ, (VOS_UINT8 *)&pseucellInfoSetReq,
                                    (VOS_SIZE_T)sizeof(pseucellInfoSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetPseucellInfoPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PSEUCELL_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetChrAlarmRlatCnfInfoPara(VOS_UINT8 indexNum)
{
    AT_MTA_ChrAlarmRlatCfgSetReq chrAlarmRlatCfgSetReq;
    VOS_UINT32                   result;

    result = 0;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Current Option is not AT_CMD_OPT_SET_PARA_CMD.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多或者过少 */
    if ((g_atParaIndex != AT_CHRALARMRLATCFG_MIN_PARA_NUM) && (g_atParaIndex != AT_CHRALARMRLATCFG_MAX_PARA_NUM)) {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para Num is error.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数1长度为0 */
    if (g_atParaList[AT_CHRALARMRLATCFG_ALARMID].paraLen == 0) {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para 1 length is 0.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数2长度为0 */
    if ((g_atParaIndex == AT_CHRALARMRLATCFG_MAX_PARA_NUM) &&
        (g_atParaList[AT_CHRALARMRLATCFG_ALARMID_DETAIL].paraLen == 0)) {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara : Para 2 length is 0.");

        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&chrAlarmRlatCfgSetReq, sizeof(chrAlarmRlatCfgSetReq), 0x00, sizeof(chrAlarmRlatCfgSetReq));

    chrAlarmRlatCfgSetReq.alarmId = g_atParaList[AT_CHRALARMRLATCFG_ALARMID].paraValue;

    if (g_atParaIndex == AT_CHRALARMRLATCFG_MIN_PARA_NUM) {
        chrAlarmRlatCfgSetReq.alarmOp = AT_MTA_CHR_ALARM_RLAT_OP_READ;
    } else {
        chrAlarmRlatCfgSetReq.alarmOp     = AT_MTA_CHR_ALARM_RLAT_OP_WRITE;
        chrAlarmRlatCfgSetReq.alarmDetail = g_atParaList[AT_CHRALARMRLATCFG_ALARMID_DETAIL].paraValue;
    }

    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, g_atClientTab[indexNum].opId,
                                    ID_AT_MTA_CHRALARMRLAT_CFG_SET_REQ, (VOS_UINT8 *)&chrAlarmRlatCfgSetReq,
                                    (VOS_SIZE_T)sizeof(chrAlarmRlatCfgSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        AT_WARN_LOG("AT_SetChrAlarmRlatCnfInfoPara: AT_FillAndSndAppReqMsg fail.");

        return AT_ERROR;
    }

    /* 设置AT模块实体的状态为等待异步返回 */
    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CHRALARMRLATCFG_SET;

    return AT_WAIT_ASYNC_RETURN;
}


VOS_UINT32 AT_SetMtReattachPara(VOS_UINT8 indexNum)
{
    AT_MTA_UnsolicitedRptSetReq atCmd;
    VOS_UINT32                  result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if ((g_atParaList[0].paraLen == 0) || (g_atParaList[0].paraValue > 1)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0x00, sizeof(atCmd));
    atCmd.reqType            = AT_MTA_SET_MTREATTACH_RPT_TYPE;
    atCmd.u.mtReattachRptFlg = (VOS_UINT8)g_atParaList[0].paraValue;

    /* 给MTA发送^MTREATTACH设置请求 */
    result = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_UNSOLICITED_RPT_SET_REQ,
                                    (VOS_UINT8 *)&atCmd, sizeof(AT_MTA_UnsolicitedRptSetReq), I0_UEPS_PID_MTA);

    if (result != TAF_SUCCESS) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_UNSOLICITED_RPT_SET;

    return AT_WAIT_ASYNC_RETURN;
}


TAF_WRITE_AcoreNv* AT_FillACoreNvWriteStru(VOS_UINT32 modemId, VOS_UINT32 nvItemId, VOS_UINT8 *data,
                                           VOS_UINT32 nvLength)
{
    g_writeAcoreNv.modemId     = modemId;
    g_writeAcoreNv.nvItemId    = nvItemId;
    g_writeAcoreNv.nvLength    = nvLength;
    g_writeAcoreNv.isNeedCheck = VOS_TRUE;
    g_writeAcoreNv.offset      = 0;
    g_writeAcoreNv.data        = data;

    return &g_writeAcoreNv;
}


TAF_WRITE_AcoreNv* AT_FillACoreNvWriteNoCheckStru(VOS_UINT32 modemId, VOS_UINT32 nvItemId, VOS_UINT8 *data,
                                                  VOS_UINT32 nvLength)
{
    g_writeAcoreNv.modemId     = modemId;
    g_writeAcoreNv.nvItemId    = nvItemId;
    g_writeAcoreNv.nvLength    = nvLength;
    g_writeAcoreNv.isNeedCheck = VOS_FALSE;
    g_writeAcoreNv.offset      = 0;
    g_writeAcoreNv.data        = data;

    return &g_writeAcoreNv;
}


TAF_WRITE_AcoreNv* AT_FillACoreNvWritePartStru(VOS_UINT32 modemId, VOS_UINT32 nvItemId, VOS_UINT32 offset,
                                               VOS_UINT8 *data, VOS_UINT32 nvLength)
{
    g_writeAcoreNv.modemId     = modemId;
    g_writeAcoreNv.nvItemId    = nvItemId;
    g_writeAcoreNv.nvLength    = nvLength;
    g_writeAcoreNv.isNeedCheck = VOS_TRUE;
    g_writeAcoreNv.offset      = offset;
    g_writeAcoreNv.data        = data;

    return &g_writeAcoreNv;
}


TAF_WRITE_AcoreNv* AT_FillACoreNvWritePartNoCheckStru(VOS_UINT32 modemId, VOS_UINT32 nvItemId, VOS_UINT32 offset,
                                                      VOS_UINT8 *data, VOS_UINT32 nvLength)
{
    g_writeAcoreNv.modemId     = modemId;
    g_writeAcoreNv.nvItemId    = nvItemId;
    g_writeAcoreNv.nvLength    = nvLength;
    g_writeAcoreNv.isNeedCheck = VOS_FALSE;
    g_writeAcoreNv.offset      = offset;
    g_writeAcoreNv.data        = data;

    return &g_writeAcoreNv;
}


VOS_UINT32 AT_SetCemodePara(VOS_UINT8 indexNum)
{
    VOS_UINT32 rst;
    rst = 0;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex > 1) {
        return AT_TOO_MANY_PARA;
    }

    if (g_atParaList[0].paraLen == 0) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 与MMA进行交互不成功返回失败，交互成功返回命令处理挂起状态 */
    rst = TAF_MMA_SetCemodeReq(WUEPS_PID_AT, g_atClientTab[indexNum].clientId, 0, g_atParaList[0].paraValue);
    if (rst == VOS_TRUE) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_CEMODE_SET;
        /* 返回命令处理挂起状态 */
        return AT_WAIT_ASYNC_RETURN;
    } else {
        AT_WARN_LOG("AT_SetCemodePara: TAF_MMA_SetCemodeReq fail.");
        return AT_ERROR;
    }
}


VOS_UINT32 AT_SetCvhuPara(VOS_UINT8 indexNum)
{
    ModemIdUint16  modemId;
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数错误 */
    if (g_atParaIndex > 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 将设置参数保存到CC上下文中 */
    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        AT_LOG1("AT_SetCvhuPara AT_GetModemIdFromClient fail", indexNum);
        return AT_ERROR;
    }

    ccCtx = AT_GetModemCcCtxAddrFromModemId(modemId);

    /* 如果参数为空，默认按照CVHU_MODE_0处理 */
    if (g_atParaIndex == 0) {
        ccCtx->cvhuMode = CVHU_MODE_0;
    } else {
        ccCtx->cvhuMode = (AT_CvhuModeUint8)(g_atParaList[0].paraValue);
    }

    return AT_OK;
}

VOS_UINT32 AT_QryCvhuPara(VOS_UINT8 indexNum)
{
    ModemIdUint16  modemId;
    AT_ModemCcCtx *ccCtx = VOS_NULL_PTR;
    VOS_UINT16     length;

    /* 命令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_READ_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 获取ModemID */
    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        AT_LOG1("AT_QryCvhuPara AT_GetModemIdFromClient fail", indexNum);
        return AT_ERROR;
    }

    /* 获取CC上下文 */
    ccCtx = AT_GetModemCcCtxAddrFromModemId(modemId);

    length = (VOS_UINT16)AT_FormatReportString(AT_CMD_MAX_LEN, (VOS_CHAR *)g_atSndCodeAddress,
        (VOS_CHAR *)g_atSndCodeAddress, "%s: %d", g_parseContext[indexNum].cmdElement->cmdName, ccCtx->cvhuMode);
    g_atSendDataBuff.bufLen = length;

    return AT_OK;
}


VOS_UINT32 AT_SetParaRspSimsqPara(VOS_UINT8 indexNum)
{
    VOS_UINT32 result;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数只能为一个 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (At_GetSimsqEnable() != g_atParaList[0].paraValue) {
        At_SetSimsqEnable((VOS_UINT8)g_atParaList[0].paraValue);

        result = TAF_ACORE_NV_WRITE(MODEM_ID_0, NV_ITEM_CUSTOM_USIMM_CFG,
                                    (VOS_UINT8 *)&AT_GetCommCtxAddr()->customUsimmCfg, sizeof(NAS_NVIM_CustomUsimmCfg));

        if (result != NV_OK) {
            AT_WARN_LOG("AT_SetParaRspSimsqPara: write nv failed!");
            return AT_ERROR;
        }
    }

    return AT_OK;
}


VOS_UINT32 AT_QryParaRspSimsqPara(VOS_UINT8 indexNum)
{
    ModemIdUint16 modemId;

    /* 将设置参数保存到CC上下文中 */
    if (AT_GetModemIdFromClient(indexNum, &modemId) != VOS_OK) {
        AT_LOG1("AT_ProcSimsqInd AT_GetModemIdFromClient fail", indexNum);
        return AT_ERROR;
    }

    AT_ProcReportSimSqInfo(indexNum, At_GetSimsqStatus(modemId));

    return AT_OK;
}


LOCAL VOS_UINT32 AT_GetPlmnSrchRsrpPara(TAF_MMA_RatTypeUint8 rat, TAF_PLMN_UserSel *extUserPlmnSrch)
{
#if (FEATURE_LTE == FEATURE_ON)
    VOS_UINT32 rsrpTmp;

    if (g_atParaIndex <= AT_PLMNSRCH_RSRP) {
        return VOS_OK;
    }

    rsrpTmp = g_atParaList[AT_PLMNSRCH_RSRP].paraValue;
    switch (rat) {
        case TAF_MMA_RAT_LTE:
            if ((rsrpTmp < AT_PLMNSRCH_LTE_RSRP_THRESHOLD_MIN) ||
                (rsrpTmp > AT_PLMNSRCH_LTE_RSRP_THRESHOLD_MAX)) {
                AT_NORM_LOG1("AT_GetPlmnSrchRsrpPara: LTE rsrpthreshold incorrect!", rsrpTmp);
                return VOS_ERR;
            }
            extUserPlmnSrch->rsrpThresholdFlg = VOS_TRUE;
            extUserPlmnSrch->rsrp             = 0 - (VOS_INT16)rsrpTmp;
            break;
#if (FEATURE_UE_MODE_NR == FEATURE_ON)
        case TAF_MMA_RAT_NR:
            if ((rsrpTmp < AT_PLMNSRCH_NR_RSRP_THRESHOLD_MIN) ||
                (rsrpTmp > AT_PLMNSRCH_NR_RSRP_THRESHOLD_MAX)) {
                AT_NORM_LOG1("AT_GetPlmnSrchRsrpPara: NR rsrpthreshold incorrect!", rsrpTmp);
                return VOS_ERR;
            }
            extUserPlmnSrch->rsrpThresholdFlg = VOS_TRUE;
            extUserPlmnSrch->rsrp             = 0 - (VOS_INT16)rsrpTmp;
            break;
#endif
        default:
            AT_NORM_LOG1("AT_GetPlmnSrchRsrpPara: rat not support rsrpthreshold!", rat);
            break;
    }
#endif

    return VOS_OK;
}


VOS_UINT32 AT_SetPlmnSrchPara(VOS_UINT8 indexNum)
{
    TAF_MMA_RatTypeUint8  phRat;
    TAF_MMA_Ctrl           ctrl;
    TAF_PLMN_UserSel      extUserPlmnSrch;
    errno_t                     memResult;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&extUserPlmnSrch, sizeof(extUserPlmnSrch), 0x00, sizeof(TAF_PLMN_UserSel));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_NORM_LOG("AT_SetPlmnSrchPara:  not AT_CMD_OPT_SET_PARA_CMD");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if ((g_atParaIndex != AT_PLMNSRCH_PARA_NUM) && (g_atParaIndex != AT_PLMNSRCH_MAX_PARA_NUM)) {
        AT_NORM_LOG1("AT_SetPlmnSrchPara: Param Number not correct:", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口相关信息 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    /* 设置RAT */
    At_SetCopsActPara(&phRat, g_atParaList[AT_PLMNSRCH_RAT].paraLen, g_atParaList[AT_PLMNSRCH_RAT].paraValue);

    extUserPlmnSrch.formatType       = AT_COPS_NUMERIC_TYPE;
    extUserPlmnSrch.bgSrchFlag       = (VOS_UINT8)g_atParaList[AT_PLMNSRCH_SRCH_MODE_FLAG].paraValue;
    extUserPlmnSrch.operNameLen      = g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen;
    extUserPlmnSrch.accessMode       = phRat;
    extUserPlmnSrch.srchType         = (VOS_UINT8)g_atParaList[AT_PLMNSRCH_SRCHTYPE].paraValue;
    extUserPlmnSrch.rsrpThresholdFlg = VOS_FALSE;

    if ((g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen != AT_PLMN_LEN_FIVE) &&
        (g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen != AT_PLMN_LEN_SIX)) {
        AT_NORM_LOG1("AT_SetPlmnSrchPara: PLMN Length Not correct:", g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    memResult = memcpy_s(extUserPlmnSrch.operName, TAF_MMA_PLMN_ID_LEN,
                         (VOS_CHAR *)g_atParaList[AT_PLMNSRCH_PLMN_LEN].para,
                         g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen);
    TAF_MEM_CHK_RTN_VAL(memResult, TAF_MMA_PLMN_ID_LEN, g_atParaList[AT_PLMNSRCH_PLMN_LEN].paraLen);

    if (AT_GetPlmnSrchRsrpPara(phRat, &extUserPlmnSrch) != VOS_OK) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_MMA_PlmnSearchReq(&ctrl, TAF_MMA_SEARCH_TYPE_MANUAL, &extUserPlmnSrch) == VOS_TRUE) {
        AT_NORM_LOG("AT_SetPlmnSrchPara:  AT_CMD_PLMNSRCH_SET: ASYNC");
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PLMNSRCH_SET;

        return AT_WAIT_ASYNC_RETURN;
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetDetectPlmnRsrp(TAF_UINT8 indexNum)
{
    TAF_MMA_RatTypeUint8 phRat;
    TAF_MMA_Ctrl         ctrl;
    TAF_DETECT_Plmn      plmnDetect;

    (VOS_VOID)memset_s(&ctrl, sizeof(ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&plmnDetect, sizeof(plmnDetect), 0x00, sizeof(TAF_DETECT_Plmn));

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_NORM_LOG("At_SetDtectPlmnRsrp:  not AT_CMD_OPT_SET_PARA_CMD");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数过多 */
    if (g_atParaIndex != AT_DETECTPLMN_PARA_NUM) {
        AT_NORM_LOG1("At_SetDtectPlmnRsrp: Param Number not correct:", g_atParaIndex);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 填写端口相关信息 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    /* 设置RAT */
    At_SetCopsActPara(&phRat, g_atParaList[AT_DETECTPLMN_RAT].paraLen, g_atParaList[AT_DETECTPLMN_RAT].paraValue);

    plmnDetect.accessMode = phRat;

    if (phRat != TAF_MMA_RAT_LTE) {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: Only support LTE");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if ((g_atParaList[AT_DETECTPLMN_PLMN].paraLen != AT_PLMN_LEN_FIVE) &&
        (g_atParaList[AT_DETECTPLMN_PLMN].paraLen != AT_PLMN_LEN_SIX)) {
        AT_NORM_LOG1("At_SetDtectPlmnRsrp: PLMN Length Not correct:", g_atParaList[AT_DETECTPLMN_PLMN].paraLen);
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* mcc mnc 解析 */
    /* Mcc */
    if (AT_DigitString2Hex((TAF_UINT8 *)(g_atParaList[AT_DETECTPLMN_PLMN].para),
                           AT_MCC_LENGTH, &(plmnDetect.plmnId.mcc)) == VOS_FALSE) {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: PLMN Illegal");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* Mnc */
    if (AT_DigitString2Hex((TAF_UINT8 *)&(g_atParaList[AT_DETECTPLMN_PLMN].para[3]),
                           g_atParaList[AT_DETECTPLMN_PLMN].paraLen - AT_MNC_LENGTH,
                           &(plmnDetect.plmnId.mnc)) == VOS_FALSE) {
        AT_NORM_LOG("At_SetDtectPlmnRsrp: PLMN Illegal");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    plmnDetect.plmnId.mcc |= 0xFFFFF000;
    /* mnc一个数字只占半个字节，也就是4bit */
    plmnDetect.plmnId.mnc |= (0xFFFFFFFF << ((g_atParaList[AT_DETECTPLMN_PLMN].paraLen - AT_MNC_LENGTH) * 4));

    if (TAF_MMA_PlmnDetectReq(&ctrl, &plmnDetect) == VOS_TRUE) {
        AT_NORM_LOG("At_SetDtectPlmnRsrp:  AT_CMD_PLMNSRCH_SET: ASYNC");

        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_PLMNSRCH_SET;

        return AT_OK;
    } else {
        return AT_ERROR;
    }
}

#if (defined(FEATURE_PHONE_ENG_AT_CMD) && (FEATURE_PHONE_ENG_AT_CMD == FEATURE_ON))

VOS_UINT32 AT_SetLteSarStubPara(VOS_UINT8 indexNum)
{
    AT_MTA_LteSarStubSetReq atCmd;
    VOS_UINT32              rst;

    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }
    /* 参数个数检查 */
    if (g_atParaIndex != AT_LTESARSTUB_PARA_NUM) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&atCmd, sizeof(atCmd), 0, sizeof(atCmd));
    atCmd.switchFlag = (VOS_UINT8)g_atParaList[0].paraValue;
    /* 下发参数更新请求消息给C核处理 */
    rst = AT_FillAndSndAppReqMsg(g_atClientTab[indexNum].clientId, 0, ID_AT_MTA_SET_LTESARSTUB_REQ, (VOS_UINT8 *)&atCmd,
                                 sizeof(AT_MTA_LteSarStubSetReq), I0_UEPS_PID_MTA);
    if (rst == TAF_SUCCESS) {
        g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_LTESARSTUB_SET;
        return AT_WAIT_ASYNC_RETURN;
    }
    return AT_ERROR;
}
#endif


#if (FEATURE_IOT_HSUART_CMUX == FEATURE_ON)

cmux_info_type* AT_GetCmuxInfo(VOS_VOID)
{
    return &g_cmux_info;
}


VOS_UINT32 AT_CheckCmuxSpeedAndBaudrate(cmux_info_type *atCmuxPara)
{
    TAF_NV_UartCfg uartNVCfg = {0};
    VOS_UINT32     ret = 0;
    VOS_UINT32     result;

    /* 读取NV项中波特率，并检验 */
    result = TAF_ACORE_NV_READ(MODEM_ID_0,
                 NV_ITEM_UART_CFG,
                  &uartNVCfg,
                  sizeof(TAF_NV_UartCfg));
    if (result == VOS_OK) {
        ret = cmux_baud_to_num(uartNVCfg.baudRate);
    } else {
        /*NV读取失败，使用默认值进行比较*/
        AT_NORM_LOG("At_SetCmuxPara: read baud NV failed!");
        return AT_ERROR;
    }

    /*  <port_speed> 1 - 9600 bit/s;2 - 19200 bit/s;3 - 38400 bit/s;4 - 57600 bit/s;5 - 115200 bit/s;6 - 230400 bits/s;7 - 460800 bits/s;8 - 921600 bits/s */
    if (g_atParaList[2].paraLen != 0) {
        if ((g_atParaList[2].paraValue < CMUX_PHY_PORT_SPEED_1) || (g_atParaList[2].paraValue > CMUX_PHY_PORT_SPEED_6)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid Port speed!");
            return AT_CME_INCORRECT_PARAMETERS;
        }

        /*CMUX设置波特率参数与NV中波特率不相等*/
        if(ret != g_atParaList[2].paraValue) {
            AT_NORM_LOG("At_SetCmuxPara:port speed not equal to NV!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->port_speed = ((TAF_UINT16)g_atParaList[2].paraValue);
    } else {
        /*判断NV波特率是否在CMUX所支持的范围内*/
        if (ret != CMUX_PHY_PORT_SPEED_INVALID) {
            atCmuxPara->port_speed = ret;
        } else {
            AT_NORM_LOG("NV value is not supported by CMUX!");
            return AT_ERROR;
        }
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_CheckCmuxParaN2T2N3(cmux_info_type *atCmuxPara)
{
    /* <N2>: 0-10; where 3 is default */
    if (g_atParaList[5].paraLen != 0) {
        if (g_atParaList[5].paraValue > CMUX_MAX_FRAME_N2) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid N2!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->max_cmd_num_tx_times_N2 = (TAF_UINT8)g_atParaList[5].paraValue;
    }

    /* <T2>: 10-250; where 90 is default (900 ms); T2 must be longer than T1. */
    if (g_atParaList[6].paraLen != 0) {
        if ((g_atParaList[6].paraValue < 10 ) || (g_atParaList[6].paraValue > 250)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid T2!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->response_timer_T2 = T1_T2_FACTOR * g_atParaList[6].paraValue;

        if (atCmuxPara->response_timer_T2 <= atCmuxPara->response_timer_T1) {
            AT_NORM_LOG("At_SetCmuxPara: T2 must be longer than T1!");
            return AT_ERROR;
        }
    }

    /* <T3>: 1-255; where 10 is default  */
    if (g_atParaList[7].paraLen != 0) {
        if ((g_atParaList[7].paraValue < 1 ) || (g_atParaList[7].paraValue > 255)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid T3!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->response_timer_T3 = g_atParaList[7].paraValue;
    }

    return AT_SUCCESS;
}


VOS_UINT32 At_CheckCmuxParaN1T1(cmux_info_type *atCmuxPara)
{
    VOS_UINT32 result;

    /* <N1>: 31- 1540 ;31 is default for Basic option and 64 is default for Advanced option   */
    if (g_atParaList[3].paraLen != 0) {
        if ((g_atParaList[3].paraValue < CMUX_MIN_FRAME_N1 ) || (g_atParaList[3].paraValue > CMUX_MAX_FRAME_N1)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid N1!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->max_frame_size_N1 = (TAF_UINT16)g_atParaList[3].paraValue;
    } else if (atCmuxPara->operating_mode == CMUX_MODE_ADVANCED) {
        atCmuxPara->max_frame_size_N1 = CMUX_ADVANCED_MODE_DEFAULT_FRAME_N1;
    }

    /* <T1>: 10-255; where 10 is default (100 ms)  */
    if (g_atParaList[4].paraLen != 0) {
        if ((g_atParaList[4].paraValue < 10 ) || (g_atParaList[4].paraValue > 250)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid T1!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->response_timer_T1 = T1_T2_FACTOR * g_atParaList[4].paraValue;
    }

    result = At_CheckCmuxParaN2T2N3(atCmuxPara);

    return result;
}


VOS_UINT32 At_CheckCmuxPara(cmux_info_type *atCmuxPara)
{
    VOS_UINT32 result;

    /* 参数检查 */
    if ((g_atParaIndex < CMUX_NUM_MIN) || (g_atParaIndex > CMUX_NUM_MAX)) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* <operation>: 0 Basic option ; 1 Advanced option */
    if ((g_atParaList[0].paraLen == 0) || ((g_atParaList[0].paraValue != CMUX_MODE_BASIC) &&
        (g_atParaList[0].paraValue != CMUX_MODE_ADVANCED))) {

        return AT_CME_INCORRECT_PARAMETERS;
    } else {
        atCmuxPara->operating_mode = (TAF_UINT8)g_atParaList[0].paraValue;
    }

    /* <subset>: 0 UIH frames used only ;1 UI frames used only;2 I frames used only,UIH supported only */
    if (g_atParaList[1].paraLen != 0) {
        if (g_atParaList[1].paraValue != CMUX_SUBSET_UIH) {
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara->subset = (TAF_UINT8)g_atParaList[1].paraValue;
    }

    result = AT_CheckCmuxSpeedAndBaudrate(atCmuxPara);
    if (result != AT_SUCCESS) {
        return result;
    }

    result = At_CheckCmuxParaN1T1(atCmuxPara);

    return result;
}

/*************************************************************
  函数名称  : At_SetCmuxPara
  功能描述  : 开启CMUX功能，进入串口多路复用模式
              配置通道参数
  输入参数  : 无
  被调函数  : NA
  输出参数  : 无
  返 回 值      : 0-执行成功
                  非0-执行失败，请参考错误log
*************************************************************/
VOS_UINT32 At_SetCmuxPara(VOS_UINT8 indexNum)
{
    cmux_info_type          atCmuxPara;
    VOS_UINT32              result;
    DMS_PortIdUint16        portId;
    cmux_info_type         *cmux_info = VOS_NULL_PTR;

    portId = AT_GetDmsPortIdByClientId((AT_ClientIdUint16)indexNum);

    /* 检查通道，只支持UART端口下发 */
    if (AT_CMUX_CheckUartUser(indexNum) != VOS_TRUE) {
        return AT_ERROR;
    }

    if (g_cmuxOpen == VOS_TRUE) {
        /*CMUX功能已经开启，再下发命令不生效*/
        AT_NORM_LOG("At_SetCmuxPara: CMUX is already OPEN!");
        return AT_ERROR;
    }

    /* 参数初始化 */
    atCmuxPara.operating_mode          = CMUX_MODE_BASIC;
    atCmuxPara.subset                  = CMUX_SUBSET_UIH;
    atCmuxPara.port_speed              = CMUX_PHY_PORT_SPEED_5;
    atCmuxPara.max_frame_size_N1       = CMUX_BASIC_MODE_DEFAULT_FRAME_N1;
    atCmuxPara.response_timer_T1       = CMUX_DEFAULT_CMD_TIMER_T1;
    atCmuxPara.max_cmd_num_tx_times_N2 = CMUX_DEFAULT_MAX_TX_N2;
    atCmuxPara.response_timer_T2       = CMUX_DEFAULT_DLCI0_TIMER_T2;
    atCmuxPara.response_timer_T3       = CMUX_DEFAULT_TIMER_T3;
    atCmuxPara.window_size_k           = CMUX_DEFAULT_WINDOW_SIZE_K;

    result = At_CheckCmuxPara(&atCmuxPara);
    if (result != AT_SUCCESS) {
        return result;
    }

    /* <k>: 1-7; where 2 is default */
    if (g_atParaList[8].paraLen != 0) {
        if ((g_atParaList[8].paraValue < CMUX_WINDOW_SIZE_1 ) || (g_atParaList[8].paraValue > CMUX_WINDOW_SIZE_7)) {
            AT_NORM_LOG("At_SetCmuxPara: Invalid window size k!");
            return AT_CME_INCORRECT_PARAMETERS;
        }
        atCmuxPara.window_size_k = (TAF_UINT8)g_atParaList[8].paraValue;
    }
    cmux_info = AT_GetCmuxInfo();
    /* Assign the default values */
    cmux_info->operating_mode          = atCmuxPara.operating_mode;
    cmux_info->subset                  = atCmuxPara.subset;
    cmux_info->port_speed              = atCmuxPara.port_speed;
    cmux_info->max_frame_size_N1       = atCmuxPara.max_frame_size_N1;
    cmux_info->response_timer_T1       = atCmuxPara.response_timer_T1;
    cmux_info->max_cmd_num_tx_times_N2 = atCmuxPara.max_cmd_num_tx_times_N2;
    cmux_info->response_timer_T2       = atCmuxPara.response_timer_T2;
    cmux_info->response_timer_T3       = atCmuxPara.response_timer_T3;
    cmux_info->window_size_k           = atCmuxPara.window_size_k;

    /* 初始化CMUX功能接口 */
    if (DMS_PORT_SwitchUart2Cmux(cmux_info, portId) == VOS_ERR) {
        return AT_ERROR;
    }

    g_cmuxOpen = VOS_TRUE;

    return AT_OK;
}
#endif


VOS_UINT32 AT_CheckOosSrchStgyPara(VOS_VOID)
{
    /*
     * 参数校验,以下情况返回校验失败:
     * 1、非 set 命令；
     * 2、参数个数不是1或2
     * 3、参数1值不是 0或1
     * 4、参数1值为0时，参数个数不为1
     */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        AT_NORM_LOG("AT_CheckOosSrchStgyPara:  not AT_CMD_OPT_SET_PARA_CMD");
        return AT_ERROR;
    }

    if ((g_atParaIndex != 1) && (g_atParaIndex != 2)) {
        AT_NORM_LOG1("AT_CheckOosSrchStgyPara: Param Number not 1 or 2:", g_atParaIndex);
        return AT_ERROR;
    }

    if ((g_atParaList[0].paraValue != 0) && (g_atParaList[0].paraValue != 1)) {
        AT_NORM_LOG1("AT_CheckOosSrchStgyPara: Para1 value not correct:", g_atParaList[0].paraValue);
        return AT_ERROR;
    }

    if ((g_atParaList[0].paraValue == 0) && (g_atParaIndex != 1)) {
        AT_NORM_LOG1("AT_CheckOosSrchStgyPara: Para1 is 0, but para num not correct:", g_atParaIndex);
        return AT_ERROR;
    }

    return AT_OK;
}


VOS_UINT32 AT_DecodeOosSrchStgySceneInfo(TAF_MMA_SetOosSrchStrategyPara *srchStrategy, VOS_UINT32 paraIndex)
{
    VOS_UINT32 indexNum = paraIndex;
    VOS_UINT32 i;

    for (i = 0; i < srchStrategy->strategyNum; i++) {
        /* 获取场景id */
        switch (g_atParaList[1].para[indexNum]) {
            case TAF_MMA_STRATEGY_SCENE_RELATIVE_STILL:
            case TAF_MMA_STRATEGY_SCENE_DATA_MODEM:
            case TAF_MMA_STRATEGY_SCENE_NO_DATA_MODEM:
                srchStrategy->strategyInfo[i].stragetyScene = g_atParaList[1].para[indexNum];
                break;
            default:
                AT_NORM_LOG("AT_DecodeOosSrchStgySceneInfo: Scene not support");
                return AT_ERROR;
        }

        /* 获取各场景OOS的参数设置 */
        indexNum++;

        /* 一阶段参数值 */
        srchStrategy->strategyInfo[i].strategyCfg[0].totalTimerLen =
            (g_atParaList[1].para[indexNum] << AT_BITS_OF_ONE_BYTE) + g_atParaList[1].para[indexNum + 1];
        indexNum += AT_OOS_SRCH_STGY_TIMER_LEN_PARA_LEN;
        srchStrategy->strategyInfo[i].strategyCfg[0].sleepTimerLen =
            (g_atParaList[1].para[indexNum] << AT_BITS_OF_ONE_BYTE) + g_atParaList[1].para[indexNum + 1];
        indexNum += AT_OOS_SRCH_STGY_TIMER_LEN_PARA_LEN;
        srchStrategy->strategyInfo[i].strategyCfg[0].historyNum = g_atParaList[1].para[indexNum++];
        srchStrategy->strategyInfo[i].strategyCfg[0].prefBandNum = g_atParaList[1].para[indexNum++];
        srchStrategy->strategyInfo[i].strategyCfg[0].fullBandNum = g_atParaList[1].para[indexNum++];

        /* 二阶段参数值 */
        srchStrategy->strategyInfo[i].strategyCfg[1].totalTimerLen =
            (g_atParaList[1].para[indexNum] << AT_BITS_OF_ONE_BYTE) + g_atParaList[1].para[indexNum + 1];
        indexNum += AT_OOS_SRCH_STGY_TIMER_LEN_PARA_LEN;
        srchStrategy->strategyInfo[i].strategyCfg[1].sleepTimerLen =
            (g_atParaList[1].para[indexNum] << AT_BITS_OF_ONE_BYTE) + g_atParaList[1].para[indexNum + 1];
        indexNum += AT_OOS_SRCH_STGY_TIMER_LEN_PARA_LEN;
        srchStrategy->strategyInfo[i].strategyCfg[1].historyNum = g_atParaList[1].para[indexNum++];
        srchStrategy->strategyInfo[i].strategyCfg[1].prefBandNum = g_atParaList[1].para[indexNum++];
        srchStrategy->strategyInfo[i].strategyCfg[1].fullBandNum = g_atParaList[1].para[indexNum++];
    }

    return AT_OK;
}


VOS_UINT32 AT_DecodeOosSrchStgyPara(TAF_MMA_SetOosSrchStrategyPara *srchStrategy)
{
    VOS_UINT32 paraIndex = 0;
    VOS_UINT32 paraLength;

    if (g_atParaList[0].paraValue == 0) {
        /* 清除所有搜网策略 */
        srchStrategy->strategyMode = TAF_MMA_STRATEGY_MODE_CLEAR;
        return AT_OK;
    } else if (g_atParaList[0].paraValue == 1) {
        /* 设置搜网策略 */
        srchStrategy->strategyMode = TAF_MMA_STRATEGY_MODE_SET;
    }

    /* 将字符串转换为16进制数组 */
    if (At_AsciiNum2HexString(g_atParaList[1].para, &g_atParaList[1].paraLen) == AT_FAILURE) {
        AT_ERR_LOG("AT_SetOosSrchStgyPara: At_AsciiNum2HexString fail.");
        return AT_ERROR;
    }

    /*
     * 参数错误，返回失败
     * 1.每条记录数长度为15字节，num占1个字节，策略参数长度不为 (15 * Num+1),
     * 2.记录数不在 1-10 范围内；
     * 3.场景不识别；
     * 4.存在多条相同场景记录；
     */
    srchStrategy->strategyNum = g_atParaList[1].para[paraIndex++];
    if ((srchStrategy->strategyNum > TAF_MMA_SET_OOS_SCENE_MAX_NUM) || (srchStrategy->strategyNum < 1)) {
        AT_ERR_LOG1("AT_SetOosSrchStgyPara: RecordNum out of range, ", srchStrategy->strategyNum);
        return AT_ERROR;
    }
    paraLength = AT_OOS_RECORD_LEN * srchStrategy->strategyNum + 1;
    if (paraLength != g_atParaList[1].paraLen) {
        AT_ERR_LOG1("AT_SetOosSrchStgyPara: paraLength is not correct, ", g_atParaList[1].paraLen);
        return AT_ERROR;
    }

    /* data */
    return AT_DecodeOosSrchStgySceneInfo(srchStrategy, paraIndex);
}


VOS_UINT32 AT_SetOosSrchStgyPara(VOS_UINT8 indexNum)
{
    TAF_MMA_SetOosSrchStrategyPara      srchStrategy;
    TAF_MMA_Ctrl                        ctrl;

    /* 参数检查 */
    if (AT_CheckOosSrchStgyPara() == AT_ERROR) {
        AT_ERR_LOG("AT_SetOosSrchStgyPara: check para fail.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    (VOS_VOID)memset_s(&ctrl, sizeof(TAF_MMA_Ctrl), 0x00, sizeof(TAF_MMA_Ctrl));
    (VOS_VOID)memset_s(&srchStrategy, sizeof(srchStrategy), 0x00, sizeof(TAF_MMA_SetOosSrchStrategyPara));

    /* 填写端口相关信息 */
    ctrl.moduleId = WUEPS_PID_AT;
    ctrl.clientId = g_atClientTab[indexNum].clientId;
    ctrl.opId     = 0;

    /* 解析码流 */
    if (AT_DecodeOosSrchStgyPara(&srchStrategy) == AT_ERROR) {
        AT_ERR_LOG("AT_SetOosSrchStgyPara: decode fail.");
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发送消息 */
    if (TAF_MMA_SndOosSrchStrategySetInd(&ctrl, &srchStrategy) == VOS_TRUE) {
        AT_NORM_LOG("AT_SetOosSrchStgyPara:  AT_CMD_OOSSRCHSTGY: ASYNC");
        return AT_OK;
    }

    return AT_ERROR;
}


VOS_UINT32 At_SetHifiReset(VOS_UINT8 indexNum)
{
    APP_VC_MsgUint16          msgName;
    APP_VC_HifiResetTypeUint8 hifiResetType = APP_VC_HIFI_RESET_FROM_AP;

    /* 参数检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 参数个数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaList[0].paraValue == 0) {
        msgName = APP_VC_MSG_HIFI_RESET_BEGIN_NTF;
    } else {
        msgName = APP_VC_MSG_HIFI_RESET_END_NTF;
    }

    APP_VC_SendHifiResetNtf(I0_WUEPS_PID_VC, hifiResetType, msgName);

#if (MULTI_MODEM_NUMBER == 2)
    APP_VC_SendHifiResetNtf(I1_WUEPS_PID_VC, hifiResetType, msgName);
#endif

#if (MULTI_MODEM_NUMBER == 3)
    APP_VC_SendHifiResetNtf(I1_WUEPS_PID_VC, hifiResetType, msgName);
    APP_VC_SendHifiResetNtf(I2_WUEPS_PID_VC, hifiResetType, msgName);
#endif

    return AT_OK;
}


VOS_UINT32 AT_SetSinglePdnSwitch(VOS_UINT8 indexNum)
{
    /* 指令类型检查 */
    if (g_atParseCmd.cmdOptType != AT_CMD_OPT_SET_PARA_CMD) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    if (TAF_PS_SetSinglePdnSwitch(WUEPS_PID_AT, AT_PS_BuildExClientId(g_atClientTab[indexNum].clientId), 0,
                                  (VOS_UINT8)g_atParaList[0].paraValue) != VOS_OK) {
        return AT_ERROR;
    }

    g_atClientTab[indexNum].cmdCurrentOpt = AT_CMD_SINGLEPDNSWITCH_SET;
    return AT_WAIT_ASYNC_RETURN;
}

#if (FEATURE_MBB_CUST == FEATURE_ON)
#if (FEATURE_PHONE_USIM == FEATURE_OFF)
/*
 * 功能描述: 设置有卡模式与无卡模式
 * 修改历史:
 *  1.日    期: 2020年5月21日
 *    修改内容: 新生成函数
 */
VOS_UINT32 AT_SetNoCard(VOS_UINT8 index)
{
    VOS_UINT32 result;
    MN_CLIENT_OperationId clientOperationId;

    /* 参数检查 */
    if (g_atParaIndex != 1) {
        return AT_CME_INCORRECT_PARAMETERS;
    }

    /* 发消息通知MMA模块修改NOCARD状态 */
    clientOperationId.clientId = g_atClientTab[index].clientId;
    clientOperationId.opId = 0;
    clientOperationId.reserve = 0;
    result = MN_FillAndSndAppReqMsg(&clientOperationId, TAF_MSG_MMA_NOCARD_SET_REQ, &(g_atParaList[0].paraValue),
        sizeof(g_atParaList[0].paraValue), I0_WUEPS_PID_MMA);
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetNoCard:Set MMA Notify fail!");
        return AT_ERROR;
    }

    /* 发消息通知USIMM模块修改NOCARD状态 */
    result = SI_PIH_SendNoCardReq(g_atClientTab[index].clientId, g_atClientTab[index].opId, g_atParaList[0].paraValue);
    if (result != AT_SUCCESS) {
        AT_ERR_LOG("AT_SetNoCard:Set USIMM Notify fail!");
        return AT_ERROR;
    }

    g_atClientTab[index].cmdCurrentOpt = AT_CMD_NOCARD_SET;

    return AT_WAIT_ASYNC_RETURN;
}
#endif
#endif

