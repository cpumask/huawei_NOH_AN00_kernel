/*
 * Copyright (C) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 * Description: Implementation of 1) get/set sdp encryption metadata;
 *                                2) update sdp metadata.
 * Author: LAI Xinyi
 * Create: 2020-02-12
 */
#include "sdp_metadata.h"

#include <linux/fs.h>
#include <linux/f2fs_fs.h>
#include <linux/random.h>
#include "xattr.h"
#include "sdp.h"

#include <linux/hisi/hisi_fbe_ctrl.h>

/*
 * In FBE3, regular files' nonce is generated by 2 segments: 48 bytes for
 * ci_key, 16 bytes for metadata; directory files' nonce is generated as usual.
 */
void generate_nonce(u8 *nonce, struct inode *inode, size_t len)
{
	if (S_ISREG(inode->i_mode) && inode->i_sb->s_cop->is_inline_encrypted &&
	    inode->i_sb->s_cop->is_inline_encrypted(inode)) {
		get_random_bytes(nonce, CI_KEY_LEN_NEW);
		get_random_bytes(nonce + CI_KEY_LEN_NEW, METADATA_BYTE_IN_KDF);
	} else {
		get_random_bytes(nonce, len);
	}
}

int f2fs_get_metadata_context(struct inode *inode, void *ctx, size_t len,
			      void *fs_data)
{
	return f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
			     F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
			     fs_data);
}

int f2fs_get_sdp_metadata_context(struct inode *inode, void *ctx, size_t len,
				  void *fs_data)
{
	int ret = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data);
	if (ret != len)
		pr_err("%s:f2fs_getxattr error %d ino = %llu\r\n", __func__,
		       ret, inode->i_ino);

	return ret;
}

int f2fs_set_sdp_metadata_context(struct inode *inode, const void *ctx,
				  size_t len, void *fs_data)
{
	int ret = f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data, XATTR_CREATE);
	if (ret == -EEXIST)
		ret = f2fs_update_sdp_metadata_context(inode, ctx, len,
						       fs_data);

	return ret;
}

int f2fs_update_sdp_metadata_context(struct inode *inode, const void *ctx,
				     size_t len, void *fs_data)
{
	int ret = f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION_METADATA,
				F2FS_XATTR_NAME_ENCRYPTION_CONTEXT, ctx, len,
				fs_data, XATTR_REPLACE);
	if (ret)
		pr_err("%s: XATTR_REPLACE fail %d ino = %llu\r\n", __func__,
		       ret, inode->i_ino);

	return ret;
}

int fscrypt_open_metadata_config(struct inode *inode,
				 struct fscrypt_info *ci_info)
{
	int res;

	if (!ci_info || !ci_info->ci_key) {
		pr_err("[FBE3]%s: no ci_info for inline-encrypted file!\n",
		       __func__);
		return -ENODATA;
	}

	res = inode->i_sb->s_cop->get_metadata_context(
		inode, ci_info->metadata, METADATA_BYTE_IN_KDF, NULL);
	/*
	* if getting metadata failed, this is a new file after hota
	* update. Therefore, we reuse the last 16 Bytes of ci_key as
	* metadata. if not, this is an old file, we keep the old method
	*/
	if (res == -ENODATA) {
		memcpy(ci_info->metadata, ci_info->ci_key + CI_KEY_LEN_NEW,
		       METADATA_BYTE_IN_KDF);
		ci_info->ci_key_len = CI_KEY_LEN_NEW;
	} else if (res < 0) {
		pr_err("%s: inode %lu get metadata failed, res %d\n", __func__,
		       inode->i_ino, res);
		return res;
	} else if (res != METADATA_BYTE_IN_KDF) {
		pr_err("%s: inode %lu metadata invalid length: %d\n", __func__,
		       inode->i_ino, res);
		return -EINVAL;
	}

	ci_info->ci_key_index |= (CD << FILE_ENCRY_TYPE_BEGIN_BIT);

	return 0;
}

int fscrypt_open_sece_metadata_config(struct inode *inode,
				      struct fscrypt_info *ci_info,
				      void *fs_data)
{
	struct f2fs_sdp_fscrypt_context sdp_ctx;
	struct f2fs_sb_info *sb = F2FS_I_SB(inode);
	u8 fpubkey[FPUBKEY_LEN];
	int err = 0;
	int keyindex = -1;
	int res;

	if (!sb || !sb->s_sdp_cop) {
		pr_err("[FBE3]%s: no super block or sdp ops for inode %lu\n",
		       __func__, inode->i_ino);
		return -ENODATA;
	}
	res = sb->s_sdp_cop->get_sdp_context(inode, &sdp_ctx, sizeof(sdp_ctx),
					     fs_data);
	if (res != sizeof(sdp_ctx)) {
		pr_err("%s: get sdp ctx failed, ino = %lu\n", __func__,
		       inode->i_ino);
		return -EINVAL;
	}

	if (sdp_ctx.sdpclass == FSCRYPT_SDP_SECE_CLASS) {
		err = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (err != FPUBKEY_LEN) {
			pr_err("%s: inode(%lu) get sece fpubkey failed, err %d\n",
			       __func__, inode->i_ino, err);
			return -EINVAL;
		}

		keyindex = ci_info->ci_key_index & FILE_ENCRY_TYPE_MASK;
		err = hisi_get_metadata_sece(SEC_FILE_ENCRY_CMD_ID_GEN_METADATA,
					     keyindex, fpubkey, FPUBKEY_LEN,
					     ci_info->metadata,
					     METADATA_BYTE_IN_KDF);
		if (err) {
			pr_err("[FBE3]%s: screen locked, inode(%lu) get sece metadata failed, err:%d\n",
			       __func__, inode->i_ino, err);
			return -EKEYREVOKED;
		}
		ci_info->ci_key_index &= 0xff;
		ci_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	}
	return err;
}

int f2fs_get_sdp_ece_metadata(struct inode *inode, struct f2fs_sb_info *sb,
			      struct fscrypt_info *crypt_info, void *fs_data,
			      int flag)
{
	int res;

	if (F2FS_INODE_IS_ENABLED_SDP_ECE_ENCRYPTION(flag)) {
		res = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, crypt_info->metadata, METADATA_BYTE_IN_KDF,
			NULL);
		if (unlikely(res != METADATA_BYTE_IN_KDF)) {
			pr_err("%s: inode(%lu) get ece metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return -EINVAL;
		}
		res = 0;
	} else {
		res = hisi_get_metadata(crypt_info->metadata,
					METADATA_BYTE_IN_KDF);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: ece generating metadata failed, res:%d\n",
			       __func__, res);
			return -EKEYREJECTED;
		}

		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, crypt_info->metadata, METADATA_BYTE_IN_KDF,
			fs_data);
		if (unlikely(res)) {
			pr_err("[FBE3]f2fs_sdp %s: inode %lu set metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return res;
		}
	}
	crypt_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
	crypt_info->ci_key_index |= (ECE << FILE_ENCRY_TYPE_BEGIN_BIT);

	return res;
}

int f2fs_get_sdp_sece_metadata(struct inode *inode, struct f2fs_sb_info *sb,
			       struct fscrypt_info *crypt_info, void *fs_data,
			       u32 flag)
{
	u8 fpubkey[FPUBKEY_LEN];
	int res;
	int keyindex = -1;

	if (!F2FS_INODE_IS_ENABLED_SDP_SECE_ENCRYPTION(flag)) {
		res = hisi_get_metadata_sece(SEC_FILE_ENCRY_CMD_ID_NEW_SECE,
					     crypt_info->ci_key_index, fpubkey,
					     FPUBKEY_LEN, crypt_info->metadata,
					     METADATA_BYTE_IN_KDF);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: sece generating metadata failed, res:%d\n",
			       __func__, res);
			return -EKEYREJECTED;
		}
		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (unlikely(res)) {
			pr_err("[FBE3]%s: inode(%lu) set metadata failed, res %d\n",
			       __func__, inode->i_ino, res);
			return res;
		}
	} else {
		res = sb->s_sdp_cop->get_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		if (res != FPUBKEY_LEN) {
			pr_err("%s: inode(%lu) get sece fpubkey failed, res %d\n",
			       __func__, inode->i_ino, res);
			return -EINVAL;
		}

		keyindex = crypt_info->ci_key_index & FILE_ENCRY_TYPE_MASK;
		res = hisi_get_metadata_sece(SEC_FILE_ENCRY_CMD_ID_GEN_METADATA,
					     keyindex, fpubkey, FPUBKEY_LEN,
					     crypt_info->metadata,
					     METADATA_BYTE_IN_KDF);
		if (res) {
			pr_err("[FBE3]%s: screen locked, inode(%lu) get sece metadata failed, res:%d\n",
			       __func__, inode->i_ino, res);
			return -EKEYREVOKED;
		}
	}
	crypt_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
	crypt_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);

	return res;
}

int f2fs_update_metadata_sdp_crypto(struct inode *inode, void *fs_data,
				    struct f2fs_sdp_fscrypt_context *sdp_ctx)
{
	int res = 0;
	struct fscrypt_info *ci_info = inode->i_crypt_info;
	struct f2fs_sb_info *sb = F2FS_I_SB(inode);
	u8 fpubkey[FPUBKEY_LEN];
	struct dentry *dentry = NULL;

	if (sdp_ctx->sdpclass == FSCRYPT_SDP_ECE_CLASS) {
		res = hisi_get_metadata(ci_info->metadata,
					METADATA_BYTE_IN_KDF);
		if (res) {
			pr_err("[FBE3]%s: ece generating metadata failed, res:%d\n",
			       __func__, res);
			res = -EKEYREJECTED;
			return res;
		}
		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, ci_info->metadata, METADATA_BYTE_IN_KDF,
			fs_data);

		ci_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
		ci_info->ci_key_index |= (ECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	} else if (sdp_ctx->sdpclass == FSCRYPT_SDP_SECE_CLASS) {
		res = hisi_get_metadata_sece(SEC_FILE_ENCRY_CMD_ID_NEW_SECE,
					     ci_info->ci_key_index, fpubkey,
					     FPUBKEY_LEN, ci_info->metadata,
					     METADATA_BYTE_IN_KDF);
		if (res) {
			pr_err("[FBE3]%s: sece generating metadata failed, res:%d\n",
			       __func__, res);
			res = -EKEYREJECTED;
			return res;
		}

		res = sb->s_sdp_cop->set_sdp_metadata_context(
			inode, fpubkey, FPUBKEY_LEN, fs_data);
		ci_info->ci_key_index &= FILE_ENCRY_TYPE_MASK;
		ci_info->ci_key_index |= (SECE << FILE_ENCRY_TYPE_BEGIN_BIT);
	}

	if (res) {
		pr_err("[FBE3]f2fs_sdp %s: inode %lu set metadata failed, res %d\n",
		       __func__, inode->i_ino, res);
		dentry = d_find_any_alias(inode);
		if (dentry)
			pr_err("[FBE3]%s: dir: %s\n", __func__,
			       dentry->d_name.name);
	}

	return res;
}

